/* Generated code for Python module 'OpenSSL.SSL'
 * created by Nuitka version 0.6.1.1
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_OpenSSL$SSL" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_OpenSSL$SSL;
PyDictObject *moduledict_OpenSSL$SSL;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain_SSL_CTX_set_next_proto_select_cb;
static PyObject *const_tuple_str_plain_errorcode_tuple;
extern PyObject *const_str_plain_get;
static PyObject *const_str_plain_SSL_CIPHER_get_bits;
static PyObject *const_str_digest_3284a0d54b2aa35ff31d3f6e48d74aec;
static PyObject *const_str_plain_SSL_VERIFY_CLIENT_ONCE;
static PyObject *const_str_digest_360fff1f759f48242850b1a03fa368f8;
static PyObject *const_str_plain_SSL_CTX_use_PrivateKey;
extern PyObject *const_str_plain_SSLv23_METHOD;
static PyObject *const_str_digest_2db82bf07fbb595fa9b0bb5b41c7d7cb;
static PyObject *const_str_plain_filetype;
static PyObject *const_str_plain_BIO_write;
extern PyObject *const_str_plain_errorcode;
static PyObject *const_str_digest_60759f97a8e448eec2208bd0c353d705;
static PyObject *const_list_3507872b18f9d5cd646e67697ec96e56_list;
static PyObject *const_str_plain__NpnAdvertiseHelper;
extern PyObject *const_str_plain_function;
static PyObject *const_str_plain_ca_list;
static PyObject *const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple;
static PyObject *const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039;
static PyObject *const_str_plain_pyname;
extern PyObject *const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
extern PyObject *const_str_plain_use_privatekey_file;
static PyObject *const_str_plain_OP_COOKIE_EXCHANGE;
extern PyObject *const_str_plain_UNSPECIFIED;
static PyObject *const_str_plain_ca_names;
extern PyObject *const_str_plain_cdata;
static PyObject *const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE;
static PyObject *const_str_plain_OP_SINGLE_ECDH_USE;
static PyObject *const_str_digest_6e6304d3afc4a993b41c01e5af499f6b;
static PyObject *const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple;
static PyObject *const_str_plain_SSL_set_tlsext_host_name;
extern PyObject *const_str_plain_pkey;
static PyObject *const_tuple_str_plain_self_str_plain_depth_tuple;
static PyObject *const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
static PyObject *const_str_plain_depth;
static PyObject *const_str_plain_SSL_OP_NO_QUERY_MTU;
static PyObject *const_str_digest_ca4a6d4d96b227b5bd17bc5998515ec3;
static PyObject *const_str_plain_X509_STORE_CTX_get_ex_data;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
extern PyObject *const_str_plain_SSL_set_alpn_protos;
static PyObject *const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple;
extern PyObject *const_str_plain_i;
static PyObject *const_str_digest_1491fa532da0499070a77d607dd12a0d;
static PyObject *const_str_plain_SSL_get_servername;
static PyObject *const_str_plain_error_number;
extern PyObject *const_str_plain_OP_NO_SSLv2;
extern PyObject *const_str_plain_Cryptography_HAS_ALPN;
static PyObject *const_str_plain_SSL_ST_CONNECT;
static PyObject *const_str_plain_want_read;
static PyObject *const_str_plain_add_client_ca;
extern PyObject *const_str_plain_environ;
static PyObject *const_str_digest_536ef6d81295f4591dd87bc79e8440e7;
static PyObject *const_str_plain_OP_NO_QUERY_MTU;
extern PyObject *const_str_plain_e;
static PyObject *const_str_plain__from_ssl;
static PyObject *const_str_plain_set_ocsp_server_callback;
static PyObject *const_str_plain_SSL_CTX_get_timeout;
static PyObject *const_str_plain_get_next_proto_negotiated;
static PyObject *const_str_plain_SSLeay_version;
extern PyObject *const_str_plain_write;
extern PyObject *const_str_plain_WantWriteError;
extern PyObject *const_str_plain_X509Name;
extern PyObject *const_str_plain_DH_free;
static PyObject *const_str_plain__OCSPClientCallbackHelper;
static PyObject *const_str_plain_OP_PKCS1_CHECK_1;
extern PyObject *const_int_neg_1;
static PyObject *const_str_plain_VERIFY_CLIENT_ONCE;
static PyObject *const_str_plain_getwinerror;
static PyObject *const_str_plain__reverse_mapping;
static PyObject *const_tuple_1bf74246b679aacbbc5982cad038a099_tuple;
extern PyObject *const_str_plain_addr;
static PyObject *const_str_plain_set_client_ca_list;
static PyObject *const_str_plain_connect_ex;
extern PyObject *const_str_plain_proto;
static PyObject *const_str_plain_set_info_callback;
extern PyObject *const_int_pos_5;
static PyObject *const_str_digest_8e472bc9049677fa90a9da1a818ea22f;
static PyObject *const_tuple_str_plain_self_str_plain_mode_tuple;
static PyObject *const_str_digest_b02795b9590127f96a3b627129a2fbd2;
static PyObject *const_str_digest_c0087bb531594ec7f6b437fc33f5a397;
static PyObject *const_str_plain_outstr;
extern PyObject *const_str_plain_flag;
extern PyObject *const_str_plain_ok;
extern PyObject *const_str_plain_recv;
extern PyObject *const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple;
extern PyObject *const_str_plain_ciphers;
extern PyObject *const_str_plain_os;
extern PyObject *const_str_plain__text_to_bytes_and_warn;
static PyObject *const_str_plain__npn_advertise_helper;
extern PyObject *const_str_plain_Context;
extern PyObject *const_str_plain_Cryptography_HAS_SSL_ST;
static PyObject *const_str_plain_OP_NO_TLSv1_1;
static PyObject *const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple;
static PyObject *const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7;
static PyObject *const_str_plain_SSL_CTX_set_mode;
extern PyObject *const_str_plain_out;
extern PyObject *const_str_plain_dh;
static PyObject *const_str_plain_SSL_get_cipher_list;
static PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple;
extern PyObject *const_str_plain_send;
static PyObject *const_str_plain_SSL_get1_session;
extern PyObject *const_str_plain__from_raw_x509_ptr;
static PyObject *const_str_plain_SSL_CTX_set_verify;
static PyObject *const_str_digest_cbc74855fdd069af46a5197a85921eab;
static PyObject *const_tuple_8f082d20432d2aa73d41a80627094b27_tuple;
static PyObject *const_str_plain__into_ssl;
static PyObject *const_str_plain_BIO_new_file;
static PyObject *const_str_plain__NpnSelectHelper;
extern PyObject *const_str_plain_verify;
extern PyObject *const_str_plain_certfile;
static PyObject *const_str_digest_73851dbd1821d646fbb8ad48e937548f;
extern PyObject *const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
static PyObject *const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9;
extern PyObject *const_tuple_str_plain_self_str_plain_state_tuple;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_plain_SSLEAY_DIR;
static PyObject *const_str_digest_099382aff2f4e6520a621b385fae4992;
static PyObject *const_str_plain_use_privatekey;
static PyObject *const_str_plain_OP_PKCS1_CHECK_2;
extern PyObject *const_str_plain_ascii;
static PyObject *const_str_plain_nbytes;
extern PyObject *const_str_plain_items;
static PyObject *const_str_digest_0bdfe95b50c341a06f9727afb1a762dc;
static PyObject *const_str_plain_SSL_SESS_CACHE_OFF;
extern PyObject *const_str_plain_new;
static PyObject *const_str_plain_SSL_CB_HANDSHAKE_DONE;
static PyObject *const_str_plain_SESS_CACHE_OFF;
static PyObject *const_str_digest_240fed82a102b949d0d53c00df42e330;
static PyObject *const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE;
static PyObject *const_str_digest_3957b1b23f06761ef1844caf450dffd3;
extern PyObject *const_str_plain_SSLv3_method;
static PyObject *const_str_plain__VerifyHelper;
static PyObject *const_str_plain_SSL_CIPHER_get_version;
extern PyObject *const_str_plain_store;
static PyObject *const_str_plain_bio_shutdown;
static PyObject *const_str_digest_f45f13437cfffca595693525af90acd6;
extern PyObject *const_str_plain_more_args;
static PyObject *const_str_plain_TLSEXT_NAMETYPE_host_name;
extern PyObject *const_str_angle_genexpr;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_SSL_CB_EXIT;
static PyObject *const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
static PyObject *const_dict_c3a065e676a930b8196978eb12fcba71;
extern PyObject *const_str_plain__raise_current_error;
static PyObject *const_str_digest_060a092ce142509580b5fc6c56b149a1;
extern PyObject *const_str_plain_state;
extern PyObject *const_str_plain_where;
static PyObject *const_str_plain__wrap_callback;
static PyObject *const_str_plain_get_app_data;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR;
static PyObject *const_str_digest_7ac3fb96e522dea60117802c4a4274df;
static PyObject *const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1_2;
extern PyObject *const_str_plain_None;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1_1;
static PyObject *const_str_plain_Cryptography_HAS_NEXTPROTONEG;
static PyObject *const_str_plain_bio_read;
static PyObject *const_str_plain__requires_decorator;
extern PyObject *const_str_plain_res;
static PyObject *const_str_plain_name_stack;
static PyObject *const_str_digest_3d1ad7b2c9fa025afe944eacf471d909;
static PyObject *const_tuple_40c019df00fadc68e051d5153056e038_tuple;
extern PyObject *const_str_plain_SSL_ST_BEFORE;
extern PyObject *const_str_plain_read;
static PyObject *const_str_digest_77c1b668370aaac8571fd41e2e807543;
static PyObject *const_str_plain__asFileDescriptor;
static PyObject *const_str_plain_SESS_CACHE_NO_AUTO_CLEAR;
static PyObject *const_str_plain_add_extra_chain_cert;
static PyObject *const_str_digest_04211c3d50cdc4f69d9c36018d92c12f;
static PyObject *const_str_digest_09af89b9aab79bc5666da647371af25d;
extern PyObject *const_str_plain_Session;
static PyObject *const_str_digest_a824ae6766bf79c53a58510064186c32;
static PyObject *const_str_plain_instr;
static PyObject *const_str_digest_1494ae1301cb98a828389add570df55f;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_str_plain_TLS_CHACHA20_POLY1305_SHA256;
static PyObject *const_str_plain_SSL_CTX_use_certificate;
static PyObject *const_str_plain_SESS_CACHE_BOTH;
extern PyObject *const_str_plain_SSL_CTX_set_alpn_select_cb;
extern PyObject *const_tuple_str_plain_ascii_tuple;
static PyObject *const_str_digest_ee77c76941f8fd58acff5cfda589cc1d;
static PyObject *const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple;
static PyObject *const_str_digest_f5da7ec1228a5c8d32fa9b786affa014;
static PyObject *const_str_digest_0b1af5d020260df564f1f58f9f88daaa;
static PyObject *const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490;
static PyObject *const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb;
static PyObject *const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple;
static PyObject *const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
extern PyObject *const_str_plain__pkey;
extern PyObject *const_str_plain_x509;
extern PyObject *const_str_plain_label;
static PyObject *const_str_plain_TLS_AES_256_GCM_SHA384;
static PyObject *const_str_plain_OP_EPHEMERAL_RSA;
extern PyObject *const_str_plain_False;
static PyObject *const_str_plain_set_timeout;
extern PyObject *const_str_plain_set_passwd_cb;
static PyObject *const_str_plain_X509_get_default_cert_file;
static PyObject *const_str_plain_protos;
extern PyObject *const_tuple_str_plain_self_str_plain_version_tuple;
static PyObject *const_str_plain_Cryptography_HAS_TLSEXT_HOSTNAME;
extern PyObject *const_str_plain_size;
static PyObject *const_str_plain_SSL_set_bio;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_tuple;
extern PyObject *const_str_digest_c804b213c384a15865e18bf31cfff70e;
static PyObject *const_str_digest_b7964fdc1d8df81dacc8b4450db712e3;
extern PyObject *const_str_plain_sys;
static PyObject *const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple;
static PyObject *const_str_digest_ef6e6485863cf611499d4e66d7c8cb32;
static PyObject *const_str_digest_3c214455d63d6846892932f043ae8dab;
static PyObject *const_tuple_str_plain_self_str_plain_options_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple;
static PyObject *const_str_digest_ad463a4d3fa3baff68f13aea2d205572;
static PyObject *const_str_plain_get_servername;
static PyObject *const_str_plain_BIO_should_retry;
static PyObject *const_str_plain_set_context;
static PyObject *const_str_digest_053565796c68d049169d0efbeceaaf7d;
extern PyObject *const_str_plain_Connection;
static PyObject *const_str_plain_push_result;
extern PyObject *const_str_digest_fa91b370bf4aa8601b20ad022c04c7f5;
static PyObject *const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f;
extern PyObject *const_str_plain_mode;
static PyObject *const_str_digest_b6f7e6068b1690fa00ff377454fad5cf;
static PyObject *const_str_digest_5f09856be161f8b617a90e11db2ed735;
extern PyObject *const_str_plain_wrapper;
static PyObject *const_str_plain_SSL_CB_ACCEPT_EXIT;
static PyObject *const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG;
static PyObject *const_str_plain_SSL_peek;
extern PyObject *const_str_plain__native;
extern PyObject *const_str_plain_get_certificate;
static PyObject *const_str_plain__ALPNSelectHelper;
extern PyObject *const_str_plain__ffi;
static PyObject *const_str_plain_bio_write;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_status_cb;
static PyObject *const_str_plain_BIO_should_io_special;
static PyObject *const_str_plain_TLSv1_method;
static PyObject *const_str_plain_export_keying_material;
static PyObject *const_str_plain_in_;
static PyObject *const_str_plain_SSL_get_tlsext_status_ocsp_resp;
static PyObject *const_str_plain_get_session_cache_mode;
static PyObject *const_str_digest_eb75de26d3d89a0b83fc536ac20042b0;
static PyObject *const_str_plain_get_verify_depth;
static PyObject *const_str_plain_tmpconn;
extern PyObject *const_str_plain_indexbytes;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error;
static PyObject *const_str_plain_SSL_CTX_set_client_CA_list;
static PyObject *const_str_plain__requires_alpn;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple;
static PyObject *const_str_plain_sk_X509_NAME_value;
static PyObject *const_str_plain_OP_MICROSOFT_SESS_ID_BUG;
static PyObject *const_str_digest_e5bdbccc007b5187d287f36f3c9f8130;
extern PyObject *const_tuple_str_plain_self_str_plain_curve_tuple;
static PyObject *const_str_plain_SSL_CTX_use_certificate_file;
static PyObject *const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple;
static PyObject *const_str_plain_SSL_MODE_RELEASE_BUFFERS;
static PyObject *const_str_digest_b2b544e0252baa92681eeaf8ffa03130;
static PyObject *const_str_plain_ocsp_data_length;
extern PyObject *const_str_plain_args;
static PyObject *const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple;
extern PyObject *const_str_plain_X509_NAME_free;
static PyObject *const_str_plain_OP_NETSCAPE_CHALLENGE_BUG;
static PyObject *const_str_digest_62f84685dfb1efe6a65f54b5d84154ad;
extern PyObject *const_str_plain_sk_X509_num;
static PyObject *const_str_plain__ocsp_data;
extern PyObject *const_str_plain_data;
static PyObject *const_tuple_str_plain_count_str_plain_chain_tuple;
static PyObject *const_str_digest_d84d6f514b61e2d13913a11459387aca;
extern PyObject *const_str_plain_OPENSSL_malloc;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_TLS_AES_128_GCM_SHA256;
extern PyObject *const_str_plain___all__;
static PyObject *const_str_plain_protostr;
static PyObject *const_str_plain_SSL_CTX_get_verify_mode;
static PyObject *const_dict_8204a0d80b2c8b5483fe77928e561739;
extern PyObject *const_str_plain__problems;
extern PyObject *const_str_plain_index;
static PyObject *const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple;
static PyObject *const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb;
static PyObject *const_tuple_78e460fdd8266d432328f4bff5207c29_tuple;
static PyObject *const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3;
static PyObject *const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple;
extern PyObject *const_str_plain_kwargs;
static PyObject *const_str_plain_rc;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_61df355efe52f096d5251268bee9ada3;
static PyObject *const_str_plain_SSL_CB_CONNECT_LOOP;
static PyObject *const_str_digest_f85e475b3736c6da8cbd8e92af63eba4;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL_STORE;
static PyObject *const_str_plain_SSL_ERROR_WANT_X509_LOOKUP;
extern PyObject *const_str_plain_path_string;
static PyObject *const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple;
extern PyObject *const_str_plain_makefile;
extern PyObject *const_str_digest_df9e5608be804d3b3249be3c13b24db8;
extern PyObject *const_str_plain_method;
extern PyObject *const_str_plain___debug__;
static PyObject *const_str_digest_fe0750f479b57ce782e84a9b40cf000b;
static PyObject *const_str_plain_SSL_OP_SINGLE_ECDH_USE;
static PyObject *const_str_plain_certificate_authority;
static PyObject *const_str_plain_use_result;
static PyObject *const_str_plain__requires_npn;
extern PyObject *const_str_plain_gc;
static PyObject *const_str_plain_OPENSSL_VERSION_NUMBER;
static PyObject *const_str_plain_SSL_ERROR_WANT_WRITE;
static PyObject *const_str_plain_X509_up_ref;
extern PyObject *const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
static PyObject *const_str_digest_bafb2b633667a6bc76266cfd60bf7f9d;
extern PyObject *const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
static PyObject *const_str_plain_profiles;
static PyObject *const_str_digest_fd8757ca246c476601094123086e9a80;
static PyObject *const_str_plain__methods;
static PyObject *const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP;
extern PyObject *const_str_plain_lib;
static PyObject *const_str_plain_accept;
static PyObject *const_str_plain__path_string;
static PyObject *const_str_plain_fd;
static PyObject *const_str_plain_SSL_renegotiate;
extern PyObject *const_str_plain__UNSPECIFIED;
static PyObject *const_str_plain_SSL_set_fd;
extern PyObject *const_str_plain_X509_STORE_CTX_get_current_cert;
static PyObject *const_list_6fa8c3d8587ec1659fa28b2f58883e42_list;
static PyObject *const_tuple_7e6126bff16a8a76a713850dcb042242_tuple;
static PyObject *const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE;
static PyObject *const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple;
static PyObject *const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;
static PyObject *const_list_b44af29ad37821285e6b89a520342cf5_list;
extern PyObject *const_str_plain_text_to_bytes_and_warn;
extern PyObject *const_str_plain_str;
extern PyObject *const_str_plain_socket;
static PyObject *const_str_digest_d242bea258df0e7212519aa660c5f53d;
static PyObject *const_str_plain_X509_get_default_cert_dir_env;
static PyObject *const_str_digest_aa8d23211c54bc521e23e53a6e431cd2;
extern PyObject *const_str_plain__make_assert;
extern PyObject *const_str_plain_arg;
static PyObject *const_str_plain_get_cipher_bits;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_status_arg;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_tuple_a67b1154f8342873401b8122b6389ba8_tuple;
static PyObject *const_str_plain_SSL_get_session;
static PyObject *const_str_plain_SSL_ERROR_SYSCALL;
extern PyObject *const_str_plain_SSL_CTX_set_ecdh_auto;
static PyObject *const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING;
extern PyObject *const_str_plain_errno;
extern PyObject *const_str_plain_userdata;
static PyObject *const_str_plain_ocsp_ptr;
extern PyObject *const_str_plain_X509_NAME_dup;
static PyObject *const_tuple_87f1641fb31961ccfc03a99691482662_tuple;
static PyObject *const_str_plain_SSL_ERROR_WANT_READ;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_plain_OP_CIPHER_SERVER_PREFERENCE;
static PyObject *const_str_plain_SSL_ST_ACCEPT;
static PyObject *const_str_plain_X509_get_default_cert_dir;
static PyObject *const_str_plain_SSL_CTX_add_extra_chain_cert;
static PyObject *const_str_digest_776556dd9343f57c1cd72ff937153f0f;
extern PyObject *const_int_pos_2147483647;
extern PyObject *const_str_digest_e33a7f733650e687efe98e5491512b82;
static PyObject *const_str_plain_SSL_want_read;
static PyObject *const_tuple_26498c7c65e3c1d61715bb934548919d_tuple;
static PyObject *const_str_plain_inlen;
extern PyObject *const_tuple_str_plain_self_str_plain_buf_tuple;
extern PyObject *const_str_plain___new__;
static PyObject *const_tuple_str_plain_self_str_plain_profiles_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple;
static PyObject *const_str_digest_d5ded94dafea47ce6f2b4fa579755177;
static PyObject *const_str_plain_set_alpn_protos;
extern PyObject *const_str_plain_path;
static PyObject *const_str_plain__CallbackExceptionHelper;
extern PyObject *const_str_plain_PEM_read_bio_DHparams;
extern PyObject *const_str_plain_VERIFY_PEER;
extern PyObject *const_str_plain_weakref;
static PyObject *const_str_plain_empty;
extern PyObject *const_str_plain__PassphraseHelper;
static PyObject *const_str_plain_sk_X509_NAME_push;
extern PyObject *const_str_plain_name;
static PyObject *const_str_plain_X509_V_OK;
static PyObject *const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026;
static PyObject *const_str_plain_SSLEAY_BUILT_ON;
static PyObject *const_str_plain_total_renegotiations;
extern PyObject *const_str_plain_SSL_get0_alpn_selected;
static PyObject *const_str_plain_TLSv1_1_method;
extern PyObject *const_str_plain_SSL_CTX_set_alpn_protos;
static PyObject *const_str_plain_from_iterable;
extern PyObject *const_str_plain_VERIFY_NONE;
extern PyObject *const_str_plain_set_tlsext_host_name;
static PyObject *const_str_plain_error_depth;
static PyObject *const_str_digest_47543c17fa95d5ac5c9bf71145417a30;
static PyObject *const_str_digest_ebaec5436a48442094f25464a6eec24c;
static PyObject *const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6;
static PyObject *const_str_digest_d89a36d0b4664ac4178af2071f30652f;
static PyObject *const_str_plain_SSL_CB_CONNECT_EXIT;
static PyObject *const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c;
static PyObject *const_str_digest_3462bf983701fbd7caf2f521f5975fff;
extern PyObject *const_str_plain_SSL_library_init;
static PyObject *const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
static PyObject *const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG;
static PyObject *const_str_plain_get_finished;
static PyObject *const_str_digest_794f687944b90121fa261238090835e1;
extern PyObject *const_str_plain_flags;
static PyObject *const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple;
extern PyObject *const_str_chr_0;
extern PyObject *const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
static PyObject *const_str_digest_fded22d63d84a836b130c747fc61664e;
extern PyObject *const_str_plain_sendall;
static PyObject *const_str_plain_get_cipher_name;
static PyObject *const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER;
static PyObject *const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13;
static PyObject *const_str_plain__fallback_default_verify_paths;
static PyObject *const_str_plain_OP_ALL;
static PyObject *const_str_plain_SSL_total_renegotiations;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG;
static PyObject *const_str_plain_SSL_CTX_load_verify_locations;
static PyObject *const_str_plain__requires_sni;
static PyObject *const_tuple_str_plain_type_tuple;
extern PyObject *const_str_plain_Error;
static PyObject *const_str_plain_SSL_set_SSL_CTX;
static PyObject *const_str_plain_OP_NO_TLSv1;
static PyObject *const_str_plain_SSL_ERROR_ZERO_RETURN;
extern PyObject *const_str_plain_get_shutdown;
static PyObject *const_str_plain_SSLv23_method;
static PyObject *const_str_digest_616719c4a0cde3344203a07484a7fb54;
static PyObject *const_tuple_str_plain_WeakValueDictionary_tuple;
static PyObject *const_str_digest_1f723e76cd26cf3162ae94f693472dd5;
static PyObject *const_str_plain_SSL_CTX_get_cert_store;
static PyObject *const_str_plain_new_handle;
extern PyObject *const_str_plain_BIO_free;
static PyObject *const_str_plain_SSLv2_method;
static PyObject *const_str_plain_OP_SINGLE_DH_USE;
static PyObject *const_str_digest_94c36790285a25f5d9268c8333413cf2;
static PyObject *const_str_plain_SSL_CB_ALERT;
static PyObject *const_str_plain_use_certificate_file;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_str_plain_SSL_OP_SINGLE_DH_USE;
static PyObject *const_str_plain_SSL_write;
static PyObject *const_str_plain_meth;
extern PyObject *const_str_plain_ffi;
static PyObject *const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
extern PyObject *const_str_plain_outlen;
static PyObject *const_str_plain_cert_stack;
static PyObject *const_str_plain_get_alpn_proto_negotiated;
extern PyObject *const_tuple_str_plain_self_str_plain_cert_tuple;
static PyObject *const_str_plain_ca_name;
static PyObject *const_tuple_str_plain_self_str_plain_callback_tuple;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_use_srtp;
extern PyObject *const_str_plain_truncate;
extern PyObject *const_str_plain_SysCallError;
static PyObject *const_str_plain_set_session;
static PyObject *const_tuple_70adcf8f254ece362639433ee96fdafb_tuple;
static PyObject *const_str_plain_SESS_CACHE_SERVER;
extern PyObject *const_str_plain_set_connect_state;
extern PyObject *const_str_plain_pop;
static PyObject *const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple;
static PyObject *const_str_plain__no_zero_allocator;
static PyObject *const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS;
extern PyObject *const_str_plain_fileno;
static PyObject *const_str_plain_SSL_CIPHER_get_name;
extern PyObject *const_str_plain_raise_if_problem;
static PyObject *const_str_digest_6e6e0d8d93df9702d9c8795dc2391090;
static PyObject *const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple;
static PyObject *const_str_plain__alpn_select_helper;
static PyObject *const_str_plain_ocsp_len;
static PyObject *const_str_plain_SSL_set_connect_state;
static PyObject *const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12;
static PyObject *const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5;
extern PyObject *const_str_plain__buffer;
static PyObject *const_str_plain__CERTIFICATE_PATH_LOCATIONS;
static PyObject *const_str_plain__app_data;
static PyObject *const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple;
extern PyObject *const_str_plain_partial;
static PyObject *const_str_plain_MSG_PEEK;
static PyObject *const_str_plain_get_cipher_version;
static PyObject *const_str_plain_SSL_ERROR_NONE;
static PyObject *const_tuple_str_plain_self_str_plain_rc_tuple;
extern PyObject *const_str_plain_set_result;
static PyObject *const_str_plain__npn_select_callback_args;
extern PyObject *const_str_plain__exception_from_error_queue;
static PyObject *const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple;
extern PyObject *const_str_plain_encoded_len;
static PyObject *const_str_digest_e04d236da419e1b15c5c13532be67a91;
extern PyObject *const_str_plain_type;
static PyObject *const_str_digest_85e95361903fe71cece52bb01216866e;
static PyObject *const_str_plain_SSL_SESS_CACHE_BOTH;
extern PyObject *const_str_plain_decode;
extern PyObject *const_str_plain_X509_free;
static PyObject *const_str_plain_sk_X509_NAME_free;
static PyObject *const_str_plain_get_protocol_version_name;
static PyObject *const_str_plain_identifier;
extern PyObject *const_str_plain___getattr__;
static PyObject *const_str_plain_alert;
static PyObject *const_str_plain_SSL_CB_HANDSHAKE_START;
static PyObject *const_str_plain_SSLEAY_PLATFORM;
static PyObject *const_str_plain__get_finished_message;
static PyObject *const_str_plain_SSL_version;
static PyObject *const_str_plain_SSL_set_mode;
static PyObject *const_str_plain_tobytes;
static PyObject *const_str_plain_SSL_CB_WRITE;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;
static PyObject *const_str_plain__check_env_vars_set;
extern PyObject *const_str_plain_object;
static PyObject *const_str_plain_SSL_CTX_get_verify_depth;
extern PyObject *const_str_plain_set_cipher_list;
static PyObject *const_str_plain_SSL_OP_EPHEMERAL_RSA;
static PyObject *const_str_plain_SSL_SESS_CACHE_CLIENT;
extern PyObject *const_str_plain_curve;
extern PyObject *const_str_plain_set_default_verify_paths;
static PyObject *const_str_digest_1c06dc4166e08805f38a8dca82ce4339;
static PyObject *const_tuple_str_plain_wraps_str_plain_partial_tuple;
extern PyObject *const_str_plain_self;
static PyObject *const_str_digest_ceaeeee7f342339744c9535ada3c62e3;
static PyObject *const_str_plain_SSL_set_tlsext_status_type;
static PyObject *const_str_plain__verify_helper;
extern PyObject *const_str_plain_shutdown;
static PyObject *const_str_digest_38eb25c1dd31f1c93831bc586a51d94a;
static PyObject *const_str_plain__socket;
static PyObject *const_str_digest_afa60644cf27716474a6bbd780185867;
static PyObject *const_str_plain_pysession;
static PyObject *const_str_digest_7cc8f764b42656b144d56bfbd9df2b48;
static PyObject *const_str_plain__make_requires;
static PyObject *const_str_digest_39dd8800b3995a2e161e8739b1bebc01;
static PyObject *const_str_plain__npn_select_helper;
extern PyObject *const_str_plain_cafile;
static PyObject *const_str_plain_BIO_should_read;
static PyObject *const_str_plain_cipher_list;
extern PyObject *const_str_plain_binary_type;
static PyObject *const_str_plain_set_verify_depth;
static PyObject *const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d;
static PyObject *const_str_digest_0f682ae315fc37e97d14dcc920e8b91d;
static PyObject *const_str_plain_chain;
static PyObject *const_str_digest_b65860d01f08f87c7391d19b5cfd9850;
static PyObject *const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf;
static PyObject *const_str_plain_use_certificate;
extern PyObject *const_str_plain_store_ctx;
static PyObject *const_str_plain_SSL_CTX_get_session_cache_mode;
extern PyObject *const_tuple_str_plain_deprecated_tuple;
static PyObject *const_str_plain_dir_path;
static PyObject *const_str_digest_f5111f918158679228186076f422f85e;
extern PyObject *const_str_plain_set_verify;
static PyObject *const_str_digest_720dcf8e2be0afcf53b482e84751fd16;
extern PyObject *const_str_plain_deprecated;
extern PyObject *const_str_plain_min;
extern PyObject *const_str_plain_memoryview;
extern PyObject *const_str_plain_DeprecationWarning;
static PyObject *const_str_plain_SSL_CTX_new;
static PyObject *const_str_plain__raise_ssl_error;
static PyObject *const_str_plain_SSL_get_peer_finished;
static PyObject *const_str_plain_SSL_MODE_AUTO_RETRY;
static PyObject *const_str_digest_f64bec1377ff9f22e4ed4c823f6a5647;
static PyObject *const_str_plain_SSL_get_peer_certificate;
static PyObject *const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG;
extern PyObject *const_str_plain_capath;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_load_client_ca;
extern PyObject *const_str_plain_buf;
static PyObject *const_str_plain_SSL_get_server_random;
static PyObject *const_str_plain_dhfile;
extern PyObject *const_str_plain_return_code;
extern PyObject *const_str_plain_error;
static PyObject *const_str_plain_SSL_CB_ACCEPT_LOOP;
extern PyObject *const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
static PyObject *const_tuple_b5f59418c193d572a22cf854b821fa76_tuple;
static PyObject *const_str_plain_ContextType;
extern PyObject *const_str_plain_NULL;
extern PyObject *const_str_plain_OP_NO_COMPRESSION;
static PyObject *const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
static PyObject *const_str_plain_client_random;
static PyObject *const_str_plain_renegotiate_pending;
static PyObject *const_str_plain_SSL_SENT_SHUTDOWN;
static PyObject *const_str_plain__tlsext_servername_callback;
static PyObject *const_str_plain_protolist;
extern PyObject *const_int_pos_6;
extern PyObject *const_int_pos_4;
static PyObject *const_str_plain_BIO_should_write;
extern PyObject *const_int_pos_2;
extern PyObject *const_int_pos_3;
extern PyObject *const_str_plain_RECEIVED_SHUTDOWN;
extern PyObject *const_int_pos_1;
static PyObject *const_str_digest_a971aca8bab65513da2005120ca529f5;
static PyObject *const_str_digest_9c76bfc2ff06864d351211fc5c45c351;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE;
static PyObject *const_str_plain_SSL_state_string_long;
static PyObject *const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple;
extern PyObject *const_str_plain_add_result;
static PyObject *const_str_plain_SSL_get_client_CA_list;
static PyObject *const_str_plain_SSL_CTX_use_PrivateKey_file;
static PyObject *const_str_plain_SSL_VERIFY_NONE;
static PyObject *const_str_plain_load_result;
static PyObject *const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
static PyObject *const_str_plain_SSLEAY_CFLAGS;
extern PyObject *const_str_plain_set_options;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL;
extern PyObject *const_str_plain_win32;
static PyObject *const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50;
static PyObject *const_str_plain_SSL_CTX_set_tlsext_servername_callback;
static PyObject *const_str_plain_SSL_CTX_set_options;
static PyObject *const_str_digest_052250489768b32f02c8505795c1c0c7;
static PyObject *const_str_plain_OP_NO_TLSv1_2;
extern PyObject *const_str_digest_c561652c58984ec0e9541542aa405594;
extern PyObject *const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple;
static PyObject *const_str_plain__handle_bio_errors;
static PyObject *const_str_plain_get_session;
extern PyObject *const_str_plain_SSL_ST_INIT;
static PyObject *const_str_plain_WeakValueDictionary;
static PyObject *const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
static PyObject *const_str_plain_SSL_CTX_set_tmp_dh;
static PyObject *const_str_digest_0438f8885bf87c226201350e81ca4f79;
static PyObject *const_str_digest_1bd7405e218c8a579c48801956097e27;
extern PyObject *const_tuple_str_plain_self_str_plain_timeout_tuple;
static PyObject *const_str_plain_SSL_read;
extern PyObject *const_str_plain_sk_X509_value;
static PyObject *const_str_plain_SSL_free;
static PyObject *const_str_plain_explode;
extern PyObject *const_str_plain_join;
static PyObject *const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple;
extern PyObject *const_str_plain_count;
extern PyObject *const_str_digest_499043b9b2da602637f07b1aa101ddfb;
static PyObject *const_str_digest_723fb164f3e133051d00542dd747fe2d;
static PyObject *const_str_plain_SSL_get0_next_proto_negotiated;
extern PyObject *const_str_plain_functools;
static PyObject *const_str_plain_set_app_data;
static PyObject *const_str_plain__npn_advertise_callback;
static PyObject *const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple;
static PyObject *const_str_plain_SSL_SESS_CACHE_SERVER;
extern PyObject *const_str_plain_connect;
static PyObject *const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG;
static PyObject *const_tuple_cf035770f08c8746b05138973d8b64b8_tuple;
extern PyObject *const_str_plain_itertools;
static PyObject *const_str_digest_971aa32305ac0845a4048d72c4cd63c5;
static PyObject *const_tuple_str_plain_self_str_plain_addr_tuple;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_plain_SSL_want_write;
static PyObject *const_str_digest_2eac950a8b26412274fa98ea596054c5;
extern PyObject *const_str_plain_result;
extern PyObject *const_str_plain_BIO_new;
static PyObject *const_str_plain__binary_type;
static PyObject *const_str_plain_method_func;
static PyObject *const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a;
static PyObject *const_str_plain_client;
static PyObject *const_dict_4a96d2f6310f0842d222254905a83466;
static PyObject *const_str_plain_SSL_CTX_use_certificate_chain_file;
extern PyObject *const_str_plain__openssl_assert;
static PyObject *const_str_digest_c5585513b25f5127855be671a08a1332;
extern PyObject *const_str_plain_int2byte;
static PyObject *const_str_plain_SSLv2_METHOD;
static PyObject *const_str_plain_default_file;
extern PyObject *const_str_plain_buffer;
extern PyObject *const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple;
static PyObject *const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51;
static PyObject *const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple;
extern PyObject *const_str_plain_TLSv1_METHOD;
extern PyObject *const_str_plain_p;
static PyObject *const_str_plain_ocsp_data;
extern PyObject *const_str_plain_r;
static PyObject *const_str_plain_load_tmp_dh;
static PyObject *const_str_plain__alpn_select_callback_args;
static PyObject *const_str_plain__context;
static PyObject *const_tuple_str_plain_self_str_plain_context_tuple;
static PyObject *const_str_plain_valid;
static PyObject *const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1;
static PyObject *const_str_digest_746ae0014bb266cffee8b7b1473626af;
static PyObject *const_str_plain_SSL_shutdown;
extern PyObject *const_str_plain_X509Store;
static PyObject *const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple;
static PyObject *const_str_plain_SSL_get_peer_cert_chain;
static PyObject *const_str_plain__session;
static PyObject *const_str_plain_set_session_cache_mode;
static PyObject *const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad;
static PyObject *const_str_plain__OCSPServerCallbackHelper;
static PyObject *const_str_plain_SSL_new;
static PyObject *const_str_digest_655ba65e888ba33199198c92a8e95d70;
static PyObject *const_str_plain__alpn_select_callback;
extern PyObject *const_str_plain_pending;
extern PyObject *const_str_plain_platform;
static PyObject *const_str_digest_8d1f7ec402c1b452808eeb662977982b;
static PyObject *const_str_plain__passphrase_userdata;
extern PyObject *const_str_plain_FILETYPE_PEM;
extern PyObject *const_str_plain_native;
extern PyObject *const_str_plain_helper;
static PyObject *const_str_plain_SSL_OP_NO_SSLv3;
static PyObject *const_str_plain_SSL_OP_NO_SSLv2;
static PyObject *const_str_plain_SSL_SESSION_free;
extern PyObject *const_str_plain_TLSv1_2_METHOD;
static PyObject *const_str_digest_6d088f969ab84bf3d60ab75faa431e51;
static PyObject *const_str_plain_from_handle;
extern PyObject *const_int_0;
extern PyObject *const_str_plain_six;
static PyObject *const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
extern PyObject *const_str_plain_make_assert;
static PyObject *const_str_plain_SSL_renegotiate_pending;
static PyObject *const_str_plain_pystore;
static PyObject *const_str_plain_SSL_load_client_CA_file;
static PyObject *const_str_plain_SSL_pending;
static PyObject *const_str_plain_SSL_OP_NO_TLSv1;
extern PyObject *const_str_plain_callback;
extern PyObject *const_str_plain_callable;
static PyObject *const_str_digest_4387d84e76f6b2a931cf315cb767f6ce;
static PyObject *const_str_plain_check_privatekey;
static PyObject *const_str_plain_SSL_get_shutdown;
static PyObject *const_str_plain_context_buf;
static PyObject *const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple;
static PyObject *const_str_digest_b55bbb0df6959d47693f7145ead6828a;
static PyObject *const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple;
extern PyObject *const_str_plain_append;
static PyObject *const_str_plain_dir_env_var;
static PyObject *const_str_digest_3b38b9684d0a691f727a5c25b49127cb;
static PyObject *const_str_plain_request_ocsp;
static PyObject *const_str_plain__info_callback;
extern PyObject *const_str_plain_load_verify_locations;
static PyObject *const_str_plain_OP_TLS_D5_BUG;
static PyObject *const_str_plain_SSL_CTX_set_next_protos_advertised_cb;
static PyObject *const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple;
static PyObject *const_str_digest_df17ae6c88635e3960d7bf94f5e880a4;
extern PyObject *const_str_plain_copy;
static PyObject *const_str_plain_set_npn_select_callback;
static PyObject *const_str_plain_SSL_CTX_set_default_passwd_cb;
static PyObject *const_str_plain_SSL_CTX_set_info_callback;
static PyObject *const_str_plain_OP_TLS_BLOCK_PADDING_BUG;
static PyObject *const_str_plain_SSL_get_error;
static PyObject *const_str_plain_SSL_get_certificate;
static PyObject *const_str_plain_get_timeout;
static PyObject *const_str_digest_f68d1733f2e29d0ad83b903b8f287e14;
extern PyObject *const_str_plain_pycert;
extern PyObject *const_str_plain_func;
static PyObject *const_str_plain_SSL_VERIFY_PEER;
extern PyObject *const_tuple_str_plain_self_str_plain_data_tuple;
extern PyObject *const_str_plain_wraps;
static PyObject *const_tuple_e7183725d38a187a36c7befeae938036_tuple;
static PyObject *const_str_digest_685ba6a7380a18939915178358979194;
static PyObject *const_str_plain_SSL_set_shutdown;
static PyObject *const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple;
static PyObject *const_str_plain_use_context;
static PyObject *const_str_digest_68d768407778bc3b4c8ffc953440b717;
extern PyObject *const_str_plain__verify_callback;
extern PyObject *const_str_plain_version;
static PyObject *const_str_plain_outp;
static PyObject *const_str_digest_fe9d923dffe7ca07e210d76d45bba668;
static PyObject *const_str_plain__npn_select_callback;
static PyObject *const_str_digest_71f502d97e845c89ec13eb6ef271f294;
static PyObject *const_str_plain_get_cipher_list;
static PyObject *const_tuple_str_plain_platform_tuple;
static PyObject *const_str_plain_bufsiz;
static PyObject *const_str_plain_left_to_send;
static PyObject *const_str_digest_75d74458faf9dee1d9b7a20a034cfad7;
extern PyObject *const_str_plain__name;
static PyObject *const_str_plain_file_env_var;
extern PyObject *const_str_plain_keyfile;
extern PyObject *const_str_plain_length;
static PyObject *const_str_plain_set_mode;
static PyObject *const_str_digest_bd36e8cd21056831af843bc4658cec96;
extern PyObject *const_str_plain_do_handshake;
extern PyObject *const_str_plain_SSL_ST_RENEGOTIATE;
static PyObject *const_str_plain_SSL_CB_READ;
static PyObject *const_str_plain_SSL_OP_ALL;
static PyObject *const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple;
static PyObject *const_str_plain__ocsp_callback;
extern PyObject *const_str_plain_X509_dup;
static PyObject *const_str_plain_set_session_id;
static PyObject *const_str_digest_5e63447161ff7f7c21b2ac874cc6500c;
static PyObject *const_str_digest_92d0e5bbbb594d3595c30b16879df5a0;
static PyObject *const_str_digest_1f9e090d5f76db9e818dd53fef9b8465;
static PyObject *const_str_plain_set_ocsp_client_callback;
extern PyObject *const_str_plain_SSL_ST_OK;
extern PyObject *const_str_plain_ERR_peek_error;
static PyObject *const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd;
static PyObject *const_str_digest_03a9c0f25246f86801453ac49af67056;
static PyObject *const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP;
static PyObject *const_str_plain_X509_get_default_cert_file_env;
extern PyObject *const_str_plain_SSLv3_METHOD;
extern PyObject *const_str_plain__ssl;
static PyObject *const_str_digest_a9a754c6f4c1dd488de35af4ae59537f;
static PyObject *const_str_plain_WantX509LookupError;
static PyObject *const_str_plain_SSLEAY_VERSION;
static PyObject *const_str_plain_set_npn_advertise_callback;
static PyObject *const_str_plain_get_peer_finished;
static PyObject *const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple;
static PyObject *const_str_plain_want_write;
static PyObject *const_str_plain_SSL_OP_COOKIE_EXCHANGE;
static PyObject *const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple;
extern PyObject *const_str_plain_session;
static PyObject *const_str_digest_447836721d7454a13033957e012d7688;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple;
extern PyObject *const_tuple_type_Exception_tuple;
extern PyObject *const_str_plain__store;
static PyObject *const_str_digest_94e7111e03f9422114930bb75dfc492c;
static PyObject *const_str_plain_certobj;
static PyObject *const_str_digest_8d7c284f25a4b19db8bcbef7a9895745;
static PyObject *const_str_plain_SSL_get_version;
static PyObject *const_str_plain_SESS_CACHE_CLIENT;
extern PyObject *const_str_plain_connection;
static PyObject *const_str_plain_get_client_ca_list;
static PyObject *const_str_plain_get_cert_store;
static PyObject *const_tuple_str_plain_self_str_plain_result_tuple;
static PyObject *const_str_plain_SSL_get_current_cipher;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple;
static PyObject *const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx;
extern PyObject *const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple;
extern PyObject *const_str_plain_WantReadError;
extern PyObject *const_str_plain_OP_NO_SSLv3;
static PyObject *const_str_plain__set_ocsp_callback;
extern PyObject *const_str_plain_get_peer_certificate;
static PyObject *const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple;
static PyObject *const_str_plain_set_accept_state;
static PyObject *const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2;
static PyObject *const_str_plain__ocsp_helper;
static PyObject *const_str_plain_SSL_CTX_set_session_id_context;
static PyObject *const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple;
static PyObject *const_str_plain_certificate_authorities;
static PyObject *const_str_plain_file_path;
static PyObject *const_str_plain_SSL_CTX_free;
static PyObject *const_str_plain_context_len;
static PyObject *const_str_digest_215c056443df9aa1456b62fe40673d54;
static PyObject *const_tuple_fb64e812782e9f70f19909e310070a01_tuple;
static PyObject *const_str_plain_SSL_OP_TLS_D5_BUG;
static PyObject *const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG;
extern PyObject *const_str_digest_52773e1185116024389d12c91a4ccf3d;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain__to_EC_KEY;
extern PyObject *const_str_plain_cipher;
static PyObject *const_str_plain_SSL_get_finished;
static PyObject *const_str_plain_SSL_ST_MASK;
static PyObject *const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple;
static PyObject *const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple;
static PyObject *const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e;
static PyObject *const_str_plain_SSL_set_session;
extern PyObject *const_str_plain_exception_from_error_queue;
static PyObject *const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG;
static PyObject *const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple;
static PyObject *const_str_digest_428eff9fedd3b449496fa307af56b948;
extern PyObject *const_str_plain__x509;
static PyObject *const_str_plain_SSL_CTX_add_client_CA;
static PyObject *const_str_plain_sk_X509_NAME_new_null;
static PyObject *const_str_plain_SSL_OP_TLS_ROLLBACK_BUG;
extern PyObject *const_str_plain_string;
extern PyObject *const_str_plain_TLSv1_1_METHOD;
static PyObject *const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple;
static PyObject *const_str_plain_SESS_CACHE_NO_INTERNAL;
static PyObject *const_str_plain_get_protocol_version;
static PyObject *const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple;
extern PyObject *const_str_plain_ssl;
extern PyObject *const_str_plain_data_ptr;
static PyObject *const_str_plain_SSL_CB_READ_ALERT;
static PyObject *const_str_plain_set_tlsext_use_srtp;
extern PyObject *const_str_plain_no_zero_allocator;
static PyObject *const_str_plain_SSL_OP_NO_COMPRESSION;
extern PyObject *const_tuple_int_neg_1_str_digest_fa91b370bf4aa8601b20ad022c04c7f5_tuple;
static PyObject *const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple;
static PyObject *const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121;
static PyObject *const_str_plain_MODE_RELEASE_BUFFERS;
static PyObject *const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple;
static PyObject *const_str_plain__passphrase_helper;
static PyObject *const_str_plain_SSL_set_tlsext_status_ocsp_resp;
static PyObject *const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple;
extern PyObject *const_str_plain_recv_into;
static PyObject *const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0;
static PyObject *const_str_plain_SENT_SHUTDOWN;
static PyObject *const_str_plain__passphrase_callback;
static PyObject *const_str_plain_success;
extern PyObject *const_str_plain_ZeroReturnError;
static PyObject *const_str_plain_SSL_export_keying_material;
static PyObject *const_str_plain_SSL_CTX_set_default_verify_paths;
static PyObject *const_str_plain_get_state_string;
static PyObject *const_str_plain_SSL_CTX_set_cipher_list;
extern PyObject *const_str_plain_conn;
static PyObject *const_str_plain_SSL_OP_NO_TICKET;
extern PyObject *const_str_plain_cert;
static PyObject *const_str_plain_ConnectionType;
static PyObject *const_list_3574eb54ef4ecf6f2c0597b9df34708e_list;
extern PyObject *const_str_plain_get_verify_mode;
static PyObject *const_str_plain_SSL_OP_PKCS1_CHECK_1;
static PyObject *const_str_plain_SSL_OP_PKCS1_CHECK_2;
static PyObject *const_str_plain_set_shutdown;
static PyObject *const_str_plain_isfile;
static PyObject *const_str_plain_get_peer_cert_chain;
extern PyObject *const_str_plain_options;
static PyObject *const_str_plain_OP_NETSCAPE_CA_DN_BUG;
static PyObject *const_str_plain_SSL_CTX_set_tmp_ecdh;
static PyObject *const_str_plain_olen;
static PyObject *const_str_plain_SSL_CTX_set_timeout;
static PyObject *const_str_plain_method_obj;
extern PyObject *const_str_plain_obj;
static PyObject *const_str_plain__npn_advertise_callback_args;
static PyObject *const_str_digest_8cde8912e8f2207155a1addb0752791f;
static PyObject *const_str_plain__raise_passphrase_exception;
static PyObject *const_str_digest_a94ef27b6600318cb26f98532a46ec7d;
extern PyObject *const_str_plain_data_len;
static PyObject *const_str_plain_OP_TLS_ROLLBACK_BUG;
static PyObject *const_str_plain_SSL_CTX_set_verify_depth;
static PyObject *const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR;
static PyObject *const_str_plain_SSL_CB_WRITE_ALERT;
static PyObject *const_str_plain_get_context;
extern PyObject *const_str_plain_BIO_s_mem;
static PyObject *const_str_plain_TLSv1_2_method;
static PyObject *const_str_digest_6a85cdfe995e144af7c992d7adff36a9;
static PyObject *const_str_plain_set_tlsext_servername_callback;
extern PyObject *const_str_plain_bio;
static PyObject *const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple;
static PyObject *const_str_digest_b6ee2740f619fbeb4f2040d74693ca57;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
static PyObject *const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248;
static PyObject *const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple;
extern PyObject *const_str_plain_isdir;
static PyObject *const_str_digest_f6ccda911266ccc3bb4cd038d18beb52;
static PyObject *const_str_plain_SSL_CTX_check_private_key;
static PyObject *const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1;
static PyObject *const_str_digest_f7bf61568f9564a7aee5354f80d84343;
static PyObject *const_str_plain_SSL_get_client_random;
static PyObject *const_str_plain_SSL_RECEIVED_SHUTDOWN;
static PyObject *const_str_plain_input_str;
static PyObject *const_str_digest_3f54294273e4f6390044ae027b11e5ae;
static PyObject *const_str_plain_SSL_CB_LOOP;
static PyObject *const_str_digest_e0c534afee902e78ce11df02f380dfa7;
static PyObject *const_str_plain_BIO_set_mem_eof_return;
static PyObject *const_str_plain_OP_NO_TICKET;
static PyObject *const_str_plain_set_tmp_ecdh;
static PyObject *const_str_digest_91c07271f44b73503e7c77deea91aef1;
static PyObject *const_str_plain_SSL_SESSION_get_master_key;
static PyObject *const_str_plain_OP_MSIE_SSLV2_RSA_PADDING;
extern PyObject *const_str_plain__lib;
static PyObject *const_str_digest_770cbd653c9b65a44061ec243e0b5fd3;
static PyObject *const_str_digest_3319904791e7df62e14d88cc362facc1;
extern PyObject *const_str_plain_total_sent;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_a3b259134db00dfd8458bf615870c7e2;
static PyObject *const_str_plain__CERTIFICATE_FILE_LOCATIONS;
static PyObject *const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
extern PyObject *const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
static PyObject *const_str_digest_f4ac5993e0eb53c16d6349308d51d30e;
static PyObject *const_str_digest_1ba1651f4266e42e9b568d28fa131281;
extern PyObject *const_str_plain_PKey;
extern PyObject *const_str_plain_use_certificate_chain_file;
static PyObject *const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5;
static PyObject *const_str_plain_sk_X509_NAME_num;
static PyObject *const_str_plain_set_alpn_select_callback;
static PyObject *const_str_digest_149b7c0937a6a666f182d0520ebdf631;
static PyObject *const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8;
static PyObject *const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple;
static PyObject *const_str_plain_renegotiate;
extern PyObject *const_str_empty;
static PyObject *const_str_digest_9071118ef0006cb5d28d9100761be8e9;
extern PyObject *const_str_plain_context;
static PyObject *const_str_plain_master_key;
static PyObject *const_str_digest_0d994cfb9823ffc5647bea3454d1e646;
static PyObject *const_str_plain_SSL_do_handshake;
extern PyObject *const_str_plain_VERIFY_FAIL_IF_NO_PEER_CERT;
extern PyObject *const_str_plain_timeout;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error_depth;
static PyObject *const_str_plain_server_random;
static PyObject *const_str_plain_SSL_CTX_set_session_cache_mode;
static PyObject *const_str_plain_SSL_set_accept_state;
static PyObject *const_str_plain_sock_shutdown;
static PyObject *const_str_plain_BIO_read;
extern PyObject *const_str_plain_X509;
static PyObject *const_str_digest_592776beca582822ed747da68adba670;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain_X509_STORE_CTX_set_error;
static PyObject *const_str_plain_TLSEXT_STATUSTYPE_ocsp;
static PyObject *const_str_plain_default_dir;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_str_plain_SSL_CTX_set_next_proto_select_cb = UNSTREAM_STRING( &constant_bin[ 108 ], 32, 1 );
    const_tuple_str_plain_errorcode_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_errorcode_tuple, 0, const_str_plain_errorcode ); Py_INCREF( const_str_plain_errorcode );
    const_str_plain_SSL_CIPHER_get_bits = UNSTREAM_STRING( &constant_bin[ 140 ], 19, 1 );
    const_str_digest_3284a0d54b2aa35ff31d3f6e48d74aec = UNSTREAM_STRING( &constant_bin[ 159 ], 47, 0 );
    const_str_plain_SSL_VERIFY_CLIENT_ONCE = UNSTREAM_STRING( &constant_bin[ 206 ], 22, 1 );
    const_str_digest_360fff1f759f48242850b1a03fa368f8 = UNSTREAM_STRING( &constant_bin[ 228 ], 39, 0 );
    const_str_plain_SSL_CTX_use_PrivateKey = UNSTREAM_STRING( &constant_bin[ 267 ], 22, 1 );
    const_str_digest_2db82bf07fbb595fa9b0bb5b41c7d7cb = UNSTREAM_STRING( &constant_bin[ 289 ], 58, 0 );
    const_str_plain_filetype = UNSTREAM_STRING( &constant_bin[ 347 ], 8, 1 );
    const_str_plain_BIO_write = UNSTREAM_STRING( &constant_bin[ 355 ], 9, 1 );
    const_str_digest_60759f97a8e448eec2208bd0c353d705 = UNSTREAM_STRING( &constant_bin[ 364 ], 405, 0 );
    const_list_3507872b18f9d5cd646e67697ec96e56_list = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 769 ], 1799 );
    const_str_plain__NpnAdvertiseHelper = UNSTREAM_STRING( &constant_bin[ 2568 ], 19, 1 );
    const_str_plain_ca_list = UNSTREAM_STRING( &constant_bin[ 2587 ], 7, 1 );
    const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 0, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    const_str_plain_explode = UNSTREAM_STRING( &constant_bin[ 2594 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 1, const_str_plain_explode ); Py_INCREF( const_str_plain_explode );
    PyTuple_SET_ITEM( const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 2, const_str_plain_flag ); Py_INCREF( const_str_plain_flag );
    const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039 = UNSTREAM_STRING( &constant_bin[ 2601 ], 472, 0 );
    const_str_plain_pyname = UNSTREAM_STRING( &constant_bin[ 3073 ], 6, 1 );
    const_str_plain_OP_COOKIE_EXCHANGE = UNSTREAM_STRING( &constant_bin[ 1736 ], 18, 1 );
    const_str_plain_ca_names = UNSTREAM_STRING( &constant_bin[ 3079 ], 8, 1 );
    const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE = UNSTREAM_STRING( &constant_bin[ 3087 ], 32, 1 );
    const_str_plain_OP_SINGLE_ECDH_USE = UNSTREAM_STRING( &constant_bin[ 1175 ], 18, 1 );
    const_str_digest_6e6304d3afc4a993b41c01e5af499f6b = UNSTREAM_STRING( &constant_bin[ 3119 ], 154, 0 );
    const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 1, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_SSL_set_tlsext_host_name = UNSTREAM_STRING( &constant_bin[ 3273 ], 24, 1 );
    const_tuple_str_plain_self_str_plain_depth_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_depth_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_depth = UNSTREAM_STRING( &constant_bin[ 3297 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_depth_tuple, 1, const_str_plain_depth ); Py_INCREF( const_str_plain_depth );
    const_str_digest_9575fec1eee4d60c15d3f7c228d8045c = UNSTREAM_STRING( &constant_bin[ 3302 ], 22, 0 );
    const_str_plain_SSL_OP_NO_QUERY_MTU = UNSTREAM_STRING( &constant_bin[ 3324 ], 19, 1 );
    const_str_digest_ca4a6d4d96b227b5bd17bc5998515ec3 = UNSTREAM_STRING( &constant_bin[ 364 ], 5, 0 );
    const_str_plain_X509_STORE_CTX_get_ex_data = UNSTREAM_STRING( &constant_bin[ 3343 ], 26, 1 );
    const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_certobj = UNSTREAM_STRING( &constant_bin[ 3369 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 1, const_str_plain_certobj ); Py_INCREF( const_str_plain_certobj );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 2, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    PyTuple_SET_ITEM( const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 3, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_digest_1491fa532da0499070a77d607dd12a0d = UNSTREAM_STRING( &constant_bin[ 3376 ], 19, 0 );
    const_str_plain_SSL_get_servername = UNSTREAM_STRING( &constant_bin[ 3395 ], 18, 1 );
    const_str_plain_error_number = UNSTREAM_STRING( &constant_bin[ 3413 ], 12, 1 );
    const_str_plain_SSL_ST_CONNECT = UNSTREAM_STRING( &constant_bin[ 2080 ], 14, 1 );
    const_str_plain_want_read = UNSTREAM_STRING( &constant_bin[ 3425 ], 9, 1 );
    const_str_plain_add_client_ca = UNSTREAM_STRING( &constant_bin[ 3434 ], 13, 1 );
    const_str_digest_536ef6d81295f4591dd87bc79e8440e7 = UNSTREAM_STRING( &constant_bin[ 3447 ], 226, 0 );
    const_str_plain_OP_NO_QUERY_MTU = UNSTREAM_STRING( &constant_bin[ 1716 ], 15, 1 );
    const_str_plain__from_ssl = UNSTREAM_STRING( &constant_bin[ 3673 ], 9, 1 );
    const_str_plain_set_ocsp_server_callback = UNSTREAM_STRING( &constant_bin[ 3682 ], 24, 1 );
    const_str_plain_SSL_CTX_get_timeout = UNSTREAM_STRING( &constant_bin[ 3706 ], 19, 1 );
    const_str_plain_get_next_proto_negotiated = UNSTREAM_STRING( &constant_bin[ 3725 ], 25, 1 );
    const_str_plain_SSLeay_version = UNSTREAM_STRING( &constant_bin[ 2515 ], 14, 1 );
    const_str_plain__OCSPClientCallbackHelper = UNSTREAM_STRING( &constant_bin[ 3750 ], 25, 1 );
    const_str_plain_OP_PKCS1_CHECK_1 = UNSTREAM_STRING( &constant_bin[ 1587 ], 16, 1 );
    const_str_plain_VERIFY_CLIENT_ONCE = UNSTREAM_STRING( &constant_bin[ 210 ], 18, 1 );
    const_str_plain_getwinerror = UNSTREAM_STRING( &constant_bin[ 3775 ], 11, 1 );
    const_str_plain__reverse_mapping = UNSTREAM_STRING( &constant_bin[ 3786 ], 16, 1 );
    const_tuple_1bf74246b679aacbbc5982cad038a099_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_str_plain_cert_stack = UNSTREAM_STRING( &constant_bin[ 3802 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 2, const_str_plain_cert_stack ); Py_INCREF( const_str_plain_cert_stack );
    PyTuple_SET_ITEM( const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 3, const_str_plain_pycert ); Py_INCREF( const_str_plain_pycert );
    PyTuple_SET_ITEM( const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 4, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_set_client_ca_list = UNSTREAM_STRING( &constant_bin[ 3812 ], 18, 1 );
    const_str_plain_connect_ex = UNSTREAM_STRING( &constant_bin[ 389 ], 10, 1 );
    const_str_plain_set_info_callback = UNSTREAM_STRING( &constant_bin[ 3830 ], 17, 1 );
    const_str_digest_8e472bc9049677fa90a9da1a818ea22f = UNSTREAM_STRING( &constant_bin[ 3847 ], 186, 0 );
    const_tuple_str_plain_self_str_plain_mode_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_tuple, 1, const_str_plain_mode ); Py_INCREF( const_str_plain_mode );
    const_str_digest_b02795b9590127f96a3b627129a2fbd2 = UNSTREAM_STRING( &constant_bin[ 4033 ], 29, 0 );
    const_str_digest_c0087bb531594ec7f6b437fc33f5a397 = UNSTREAM_STRING( &constant_bin[ 4062 ], 900, 0 );
    const_str_plain_outstr = UNSTREAM_STRING( &constant_bin[ 4962 ], 6, 1 );
    const_str_plain__npn_advertise_helper = UNSTREAM_STRING( &constant_bin[ 4968 ], 21, 1 );
    const_str_plain_OP_NO_TLSv1_1 = UNSTREAM_STRING( &constant_bin[ 1093 ], 13, 1 );
    const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 1, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    PyTuple_SET_ITEM( const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 2, const_str_plain_capath ); Py_INCREF( const_str_plain_capath );
    const_str_plain_load_result = UNSTREAM_STRING( &constant_bin[ 4989 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 3, const_str_plain_load_result ); Py_INCREF( const_str_plain_load_result );
    const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7 = UNSTREAM_STRING( &constant_bin[ 5000 ], 148, 0 );
    const_str_plain_SSL_CTX_set_mode = UNSTREAM_STRING( &constant_bin[ 5148 ], 16, 1 );
    const_str_plain_SSL_get_cipher_list = UNSTREAM_STRING( &constant_bin[ 5164 ], 19, 1 );
    const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    const_str_plain_SSL_get1_session = UNSTREAM_STRING( &constant_bin[ 5183 ], 16, 1 );
    const_str_plain_SSL_CTX_set_verify = UNSTREAM_STRING( &constant_bin[ 4908 ], 18, 1 );
    const_str_digest_cbc74855fdd069af46a5197a85921eab = UNSTREAM_STRING( &constant_bin[ 5199 ], 328, 0 );
    const_tuple_8f082d20432d2aa73d41a80627094b27_tuple = PyTuple_New( 15 );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 1, const_str_plain_out ); Py_INCREF( const_str_plain_out );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 2, const_str_plain_outlen ); Py_INCREF( const_str_plain_outlen );
    const_str_plain_in_ = UNSTREAM_STRING( &constant_bin[ 5527 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 3, const_str_plain_in_ ); Py_INCREF( const_str_plain_in_ );
    const_str_plain_inlen = UNSTREAM_STRING( &constant_bin[ 5530 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 4, const_str_plain_inlen ); Py_INCREF( const_str_plain_inlen );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 5, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 6, const_str_plain_encoded_len ); Py_INCREF( const_str_plain_encoded_len );
    const_str_plain_protolist = UNSTREAM_STRING( &constant_bin[ 5535 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 7, const_str_plain_protolist ); Py_INCREF( const_str_plain_protolist );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 8, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    const_str_plain_instr = UNSTREAM_STRING( &constant_bin[ 5544 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 9, const_str_plain_instr ); Py_INCREF( const_str_plain_instr );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 10, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 11, const_str_plain_proto ); Py_INCREF( const_str_plain_proto );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 12, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 13, const_str_plain_outstr ); Py_INCREF( const_str_plain_outstr );
    PyTuple_SET_ITEM( const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 14, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_plain__into_ssl = UNSTREAM_STRING( &constant_bin[ 5549 ], 9, 1 );
    const_str_plain_BIO_new_file = UNSTREAM_STRING( &constant_bin[ 5558 ], 12, 1 );
    const_str_plain__NpnSelectHelper = UNSTREAM_STRING( &constant_bin[ 5570 ], 16, 1 );
    const_str_digest_73851dbd1821d646fbb8ad48e937548f = UNSTREAM_STRING( &constant_bin[ 5586 ], 135, 0 );
    const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9 = UNSTREAM_STRING( &constant_bin[ 5721 ], 24, 0 );
    const_str_plain_SSLEAY_DIR = UNSTREAM_STRING( &constant_bin[ 863 ], 10, 1 );
    const_str_digest_099382aff2f4e6520a621b385fae4992 = UNSTREAM_STRING( &constant_bin[ 5745 ], 220, 0 );
    const_str_plain_use_privatekey = UNSTREAM_STRING( &constant_bin[ 5965 ], 14, 1 );
    const_str_plain_OP_PKCS1_CHECK_2 = UNSTREAM_STRING( &constant_bin[ 1608 ], 16, 1 );
    const_str_plain_nbytes = UNSTREAM_STRING( &constant_bin[ 5979 ], 6, 1 );
    const_str_digest_0bdfe95b50c341a06f9727afb1a762dc = UNSTREAM_STRING( &constant_bin[ 5985 ], 158, 0 );
    const_str_plain_SSL_SESS_CACHE_OFF = UNSTREAM_STRING( &constant_bin[ 6143 ], 18, 1 );
    const_str_plain_SSL_CB_HANDSHAKE_DONE = UNSTREAM_STRING( &constant_bin[ 2381 ], 21, 1 );
    const_str_plain_SESS_CACHE_OFF = UNSTREAM_STRING( &constant_bin[ 1874 ], 14, 1 );
    const_str_digest_240fed82a102b949d0d53c00df42e330 = UNSTREAM_STRING( &constant_bin[ 6161 ], 103, 0 );
    const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE = UNSTREAM_STRING( &constant_bin[ 6264 ], 29, 1 );
    const_str_digest_3957b1b23f06761ef1844caf450dffd3 = UNSTREAM_STRING( &constant_bin[ 6293 ], 221, 0 );
    const_str_plain__VerifyHelper = UNSTREAM_STRING( &constant_bin[ 6514 ], 13, 1 );
    const_str_plain_SSL_CIPHER_get_version = UNSTREAM_STRING( &constant_bin[ 6527 ], 22, 1 );
    const_str_plain_bio_shutdown = UNSTREAM_STRING( &constant_bin[ 6549 ], 12, 1 );
    const_str_digest_f45f13437cfffca595693525af90acd6 = UNSTREAM_STRING( &constant_bin[ 6561 ], 156, 0 );
    const_str_plain_TLSEXT_NAMETYPE_host_name = UNSTREAM_STRING( &constant_bin[ 6717 ], 25, 1 );
    const_str_plain_SSL_CB_EXIT = UNSTREAM_STRING( &constant_bin[ 2149 ], 11, 1 );
    const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 1278 ], 35, 1 );
    const_dict_c3a065e676a930b8196978eb12fcba71 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_c3a065e676a930b8196978eb12fcba71, const_str_plain___module__, const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9 );
    const_str_digest_720dcf8e2be0afcf53b482e84751fd16 = UNSTREAM_STRING( &constant_bin[ 6742 ], 201, 0 );
    PyDict_SetItem( const_dict_c3a065e676a930b8196978eb12fcba71, const_str_plain___doc__, const_str_digest_720dcf8e2be0afcf53b482e84751fd16 );
    assert( PyDict_Size( const_dict_c3a065e676a930b8196978eb12fcba71 ) == 2 );
    const_str_digest_060a092ce142509580b5fc6c56b149a1 = UNSTREAM_STRING( &constant_bin[ 6943 ], 308, 0 );
    const_str_plain__wrap_callback = UNSTREAM_STRING( &constant_bin[ 7251 ], 14, 1 );
    const_str_plain_get_app_data = UNSTREAM_STRING( &constant_bin[ 7265 ], 12, 1 );
    const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR = UNSTREAM_STRING( &constant_bin[ 7277 ], 28, 1 );
    const_str_digest_7ac3fb96e522dea60117802c4a4274df = UNSTREAM_STRING( &constant_bin[ 7305 ], 26, 0 );
    const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 1, const_str_plain_method ); Py_INCREF( const_str_plain_method );
    const_str_plain_method_obj = UNSTREAM_STRING( &constant_bin[ 7331 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 2, const_str_plain_method_obj ); Py_INCREF( const_str_plain_method_obj );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 3, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 4, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    const_str_plain_method_func = UNSTREAM_STRING( &constant_bin[ 7341 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 5, const_str_plain_method_func ); Py_INCREF( const_str_plain_method_func );
    const_str_plain_SSL_OP_NO_TLSv1_2 = UNSTREAM_STRING( &constant_bin[ 7352 ], 17, 1 );
    const_str_plain_SSL_OP_NO_TLSv1_1 = UNSTREAM_STRING( &constant_bin[ 7369 ], 17, 1 );
    const_str_plain_Cryptography_HAS_NEXTPROTONEG = UNSTREAM_STRING( &constant_bin[ 7386 ], 29, 1 );
    const_str_plain_bio_read = UNSTREAM_STRING( &constant_bin[ 7415 ], 8, 1 );
    const_str_plain__requires_decorator = UNSTREAM_STRING( &constant_bin[ 7423 ], 19, 1 );
    const_str_plain_name_stack = UNSTREAM_STRING( &constant_bin[ 7442 ], 10, 1 );
    const_str_digest_3d1ad7b2c9fa025afe944eacf471d909 = UNSTREAM_STRING( &constant_bin[ 7452 ], 137, 0 );
    const_tuple_40c019df00fadc68e051d5153056e038_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 2, const_str_plain_pyname ); Py_INCREF( const_str_plain_pyname );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 4, const_str_plain_ca_names ); Py_INCREF( const_str_plain_ca_names );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_40c019df00fadc68e051d5153056e038_tuple, 6, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    const_str_digest_77c1b668370aaac8571fd41e2e807543 = UNSTREAM_STRING( &constant_bin[ 7589 ], 763, 0 );
    const_str_plain__asFileDescriptor = UNSTREAM_STRING( &constant_bin[ 8352 ], 17, 1 );
    const_str_plain_SESS_CACHE_NO_AUTO_CLEAR = UNSTREAM_STRING( &constant_bin[ 1957 ], 24, 1 );
    const_str_plain_add_extra_chain_cert = UNSTREAM_STRING( &constant_bin[ 8369 ], 20, 1 );
    const_str_digest_04211c3d50cdc4f69d9c36018d92c12f = UNSTREAM_STRING( &constant_bin[ 8389 ], 39, 0 );
    const_str_digest_09af89b9aab79bc5666da647371af25d = UNSTREAM_STRING( &constant_bin[ 8428 ], 272, 0 );
    const_str_digest_a824ae6766bf79c53a58510064186c32 = UNSTREAM_STRING( &constant_bin[ 8700 ], 271, 0 );
    const_str_digest_1494ae1301cb98a828389add570df55f = UNSTREAM_STRING( &constant_bin[ 8971 ], 94, 0 );
    const_str_plain_TLS_CHACHA20_POLY1305_SHA256 = UNSTREAM_STRING( &constant_bin[ 9065 ], 28, 1 );
    const_str_plain_SSL_CTX_use_certificate = UNSTREAM_STRING( &constant_bin[ 9093 ], 23, 1 );
    const_str_plain_SESS_CACHE_BOTH = UNSTREAM_STRING( &constant_bin[ 1937 ], 15, 1 );
    const_str_digest_ee77c76941f8fd58acff5cfda589cc1d = UNSTREAM_STRING( &constant_bin[ 9116 ], 22, 0 );
    const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 1, const_str_plain_cdata ); Py_INCREF( const_str_plain_cdata );
    const_str_plain_ocsp_len = UNSTREAM_STRING( &constant_bin[ 9138 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 2, const_str_plain_ocsp_len ); Py_INCREF( const_str_plain_ocsp_len );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 3, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 5, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_valid = UNSTREAM_STRING( &constant_bin[ 9146 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 6, const_str_plain_valid ); Py_INCREF( const_str_plain_valid );
    const_str_plain_ocsp_ptr = UNSTREAM_STRING( &constant_bin[ 9151 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 7, const_str_plain_ocsp_ptr ); Py_INCREF( const_str_plain_ocsp_ptr );
    const_str_plain_ocsp_data = UNSTREAM_STRING( &constant_bin[ 9159 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 8, const_str_plain_ocsp_data ); Py_INCREF( const_str_plain_ocsp_data );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 9, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 10, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_digest_f5da7ec1228a5c8d32fa9b786affa014 = UNSTREAM_STRING( &constant_bin[ 9168 ], 361, 0 );
    const_str_digest_0b1af5d020260df564f1f58f9f88daaa = UNSTREAM_STRING( &constant_bin[ 9529 ], 243, 0 );
    const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490 = UNSTREAM_STRING( &constant_bin[ 9772 ], 169, 0 );
    const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb = UNSTREAM_STRING( &constant_bin[ 9941 ], 1010, 0 );
    const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 2, const_str_plain_userdata ); Py_INCREF( const_str_plain_userdata );
    const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 1655 ], 34, 1 );
    const_str_plain_TLS_AES_256_GCM_SHA384 = UNSTREAM_STRING( &constant_bin[ 10951 ], 22, 1 );
    const_str_plain_OP_EPHEMERAL_RSA = UNSTREAM_STRING( &constant_bin[ 1198 ], 16, 1 );
    const_str_plain_set_timeout = UNSTREAM_STRING( &constant_bin[ 5052 ], 11, 1 );
    const_str_plain_X509_get_default_cert_file = UNSTREAM_STRING( &constant_bin[ 10973 ], 26, 1 );
    const_str_plain_protos = UNSTREAM_STRING( &constant_bin[ 10999 ], 6, 1 );
    const_str_plain_Cryptography_HAS_TLSEXT_HOSTNAME = UNSTREAM_STRING( &constant_bin[ 11005 ], 32, 1 );
    const_str_plain_SSL_set_bio = UNSTREAM_STRING( &constant_bin[ 11037 ], 11, 1 );
    const_tuple_str_plain_self_str_plain_cipher_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_tuple, 1, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    const_str_digest_b7964fdc1d8df81dacc8b4450db712e3 = UNSTREAM_STRING( &constant_bin[ 11048 ], 52, 0 );
    const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_ef6e6485863cf611499d4e66d7c8cb32 = UNSTREAM_STRING( &constant_bin[ 11100 ], 196, 0 );
    const_str_digest_3c214455d63d6846892932f043ae8dab = UNSTREAM_STRING( &constant_bin[ 11296 ], 362, 0 );
    const_tuple_str_plain_self_str_plain_options_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_options_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_options_tuple, 1, const_str_plain_options ); Py_INCREF( const_str_plain_options );
    const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 1, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 2, const_str_plain_connect_ex ); Py_INCREF( const_str_plain_connect_ex );
    const_str_digest_ad463a4d3fa3baff68f13aea2d205572 = UNSTREAM_STRING( &constant_bin[ 11658 ], 129, 0 );
    const_str_plain_get_servername = UNSTREAM_STRING( &constant_bin[ 3399 ], 14, 1 );
    const_str_plain_BIO_should_retry = UNSTREAM_STRING( &constant_bin[ 11787 ], 16, 1 );
    const_str_plain_set_context = UNSTREAM_STRING( &constant_bin[ 11803 ], 11, 1 );
    const_str_digest_053565796c68d049169d0efbeceaaf7d = UNSTREAM_STRING( &constant_bin[ 11814 ], 23, 0 );
    const_str_plain_push_result = UNSTREAM_STRING( &constant_bin[ 11837 ], 11, 1 );
    const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f = UNSTREAM_STRING( &constant_bin[ 11848 ], 435, 0 );
    const_str_digest_b6f7e6068b1690fa00ff377454fad5cf = UNSTREAM_STRING( &constant_bin[ 12283 ], 62, 0 );
    const_str_digest_5f09856be161f8b617a90e11db2ed735 = UNSTREAM_STRING( &constant_bin[ 12345 ], 105, 0 );
    const_str_plain_SSL_CB_ACCEPT_EXIT = UNSTREAM_STRING( &constant_bin[ 2283 ], 18, 1 );
    const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG = UNSTREAM_STRING( &constant_bin[ 12450 ], 31, 1 );
    const_str_plain_SSL_peek = UNSTREAM_STRING( &constant_bin[ 12481 ], 8, 1 );
    const_str_plain__ALPNSelectHelper = UNSTREAM_STRING( &constant_bin[ 12489 ], 17, 1 );
    const_str_plain_bio_write = UNSTREAM_STRING( &constant_bin[ 12506 ], 9, 1 );
    const_str_plain_SSL_CTX_set_tlsext_status_cb = UNSTREAM_STRING( &constant_bin[ 12515 ], 28, 1 );
    const_str_plain_BIO_should_io_special = UNSTREAM_STRING( &constant_bin[ 12543 ], 21, 1 );
    const_str_plain_TLSv1_method = UNSTREAM_STRING( &constant_bin[ 12564 ], 12, 1 );
    const_str_plain_export_keying_material = UNSTREAM_STRING( &constant_bin[ 12576 ], 22, 1 );
    const_str_plain_SSL_get_tlsext_status_ocsp_resp = UNSTREAM_STRING( &constant_bin[ 12598 ], 31, 1 );
    const_str_plain_get_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 12629 ], 22, 1 );
    const_str_digest_eb75de26d3d89a0b83fc536ac20042b0 = UNSTREAM_STRING( &constant_bin[ 12651 ], 121, 0 );
    const_str_plain_get_verify_depth = UNSTREAM_STRING( &constant_bin[ 12772 ], 16, 1 );
    const_str_plain_tmpconn = UNSTREAM_STRING( &constant_bin[ 12788 ], 7, 1 );
    const_str_plain_SSL_CTX_set_client_CA_list = UNSTREAM_STRING( &constant_bin[ 12795 ], 26, 1 );
    const_str_plain__requires_alpn = UNSTREAM_STRING( &constant_bin[ 12821 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 1, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_sk_X509_NAME_value = UNSTREAM_STRING( &constant_bin[ 12835 ], 18, 1 );
    const_str_plain_OP_MICROSOFT_SESS_ID_BUG = UNSTREAM_STRING( &constant_bin[ 1219 ], 24, 1 );
    const_str_digest_e5bdbccc007b5187d287f36f3c9f8130 = UNSTREAM_STRING( &constant_bin[ 12853 ], 360, 0 );
    const_str_plain_SSL_CTX_use_certificate_file = UNSTREAM_STRING( &constant_bin[ 13213 ], 28, 1 );
    const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 0, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    const_str_plain_fd = UNSTREAM_STRING( &constant_bin[ 13241 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 1, const_str_plain_fd ); Py_INCREF( const_str_plain_fd );
    const_str_plain_meth = UNSTREAM_STRING( &constant_bin[ 383 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 2, const_str_plain_meth ); Py_INCREF( const_str_plain_meth );
    const_str_plain_SSL_MODE_RELEASE_BUFFERS = UNSTREAM_STRING( &constant_bin[ 13243 ], 24, 1 );
    const_str_digest_b2b544e0252baa92681eeaf8ffa03130 = UNSTREAM_STRING( &constant_bin[ 13267 ], 173, 0 );
    const_str_plain_ocsp_data_length = UNSTREAM_STRING( &constant_bin[ 13440 ], 16, 1 );
    const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 1, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 2, const_str_plain_ca_list ); Py_INCREF( const_str_plain_ca_list );
    const_str_plain_OP_NETSCAPE_CHALLENGE_BUG = UNSTREAM_STRING( &constant_bin[ 1248 ], 25, 1 );
    const_str_digest_62f84685dfb1efe6a65f54b5d84154ad = UNSTREAM_STRING( &constant_bin[ 13456 ], 266, 0 );
    const_str_plain__ocsp_data = UNSTREAM_STRING( &constant_bin[ 13722 ], 10, 1 );
    const_tuple_str_plain_count_str_plain_chain_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_count_str_plain_chain_tuple, 0, const_str_plain_count ); Py_INCREF( const_str_plain_count );
    const_str_plain_chain = UNSTREAM_STRING( &constant_bin[ 7480 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_count_str_plain_chain_tuple, 1, const_str_plain_chain ); Py_INCREF( const_str_plain_chain );
    const_str_digest_d84d6f514b61e2d13913a11459387aca = UNSTREAM_STRING( &constant_bin[ 13732 ], 259, 0 );
    const_str_plain_TLS_AES_128_GCM_SHA256 = UNSTREAM_STRING( &constant_bin[ 13991 ], 22, 1 );
    const_str_plain_protostr = UNSTREAM_STRING( &constant_bin[ 14013 ], 8, 1 );
    const_str_plain_SSL_CTX_get_verify_mode = UNSTREAM_STRING( &constant_bin[ 14021 ], 23, 1 );
    const_dict_8204a0d80b2c8b5483fe77928e561739 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_8204a0d80b2c8b5483fe77928e561739, const_str_plain___module__, const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9 );
    const_str_digest_971aa32305ac0845a4048d72c4cd63c5 = UNSTREAM_STRING( &constant_bin[ 14044 ], 52, 0 );
    PyDict_SetItem( const_dict_8204a0d80b2c8b5483fe77928e561739, const_str_plain___doc__, const_str_digest_971aa32305ac0845a4048d72c4cd63c5 );
    assert( PyDict_Size( const_dict_8204a0d80b2c8b5483fe77928e561739 ) == 2 );
    const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 1, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 2, const_str_plain_socket ); Py_INCREF( const_str_plain_socket );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 3, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 4, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb = UNSTREAM_STRING( &constant_bin[ 14096 ], 404, 0 );
    const_tuple_78e460fdd8266d432328f4bff5207c29_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 1, const_str_plain_where ); Py_INCREF( const_str_plain_where );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 2, const_str_plain_return_code ); Py_INCREF( const_str_plain_return_code );
    PyTuple_SET_ITEM( const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 3, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3 = UNSTREAM_STRING( &constant_bin[ 14500 ], 49, 0 );
    const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    const_str_plain_left_to_send = UNSTREAM_STRING( &constant_bin[ 14549 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 3, const_str_plain_left_to_send ); Py_INCREF( const_str_plain_left_to_send );
    PyTuple_SET_ITEM( const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 4, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 6, const_str_plain_total_sent ); Py_INCREF( const_str_plain_total_sent );
    const_str_plain_rc = UNSTREAM_STRING( &constant_bin[ 2586 ], 2, 1 );
    const_str_digest_61df355efe52f096d5251268bee9ada3 = UNSTREAM_STRING( &constant_bin[ 14561 ], 130, 0 );
    const_str_plain_SSL_CB_CONNECT_LOOP = UNSTREAM_STRING( &constant_bin[ 2306 ], 19, 1 );
    const_str_digest_f85e475b3736c6da8cbd8e92af63eba4 = UNSTREAM_STRING( &constant_bin[ 14691 ], 258, 0 );
    const_str_plain_SESS_CACHE_NO_INTERNAL_STORE = UNSTREAM_STRING( &constant_bin[ 2020 ], 28, 1 );
    const_str_plain_SSL_ERROR_WANT_X509_LOOKUP = UNSTREAM_STRING( &constant_bin[ 14949 ], 26, 1 );
    const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_fe0750f479b57ce782e84a9b40cf000b = UNSTREAM_STRING( &constant_bin[ 14975 ], 450, 0 );
    const_str_plain_SSL_OP_SINGLE_ECDH_USE = UNSTREAM_STRING( &constant_bin[ 15425 ], 22, 1 );
    const_str_plain_certificate_authority = UNSTREAM_STRING( &constant_bin[ 9402 ], 21, 1 );
    const_str_plain_use_result = UNSTREAM_STRING( &constant_bin[ 15447 ], 10, 1 );
    const_str_plain__requires_npn = UNSTREAM_STRING( &constant_bin[ 15457 ], 13, 1 );
    const_str_plain_OPENSSL_VERSION_NUMBER = UNSTREAM_STRING( &constant_bin[ 779 ], 22, 1 );
    const_str_plain_SSL_ERROR_WANT_WRITE = UNSTREAM_STRING( &constant_bin[ 15470 ], 20, 1 );
    const_str_plain_X509_up_ref = UNSTREAM_STRING( &constant_bin[ 15490 ], 11, 1 );
    const_str_digest_bafb2b633667a6bc76266cfd60bf7f9d = UNSTREAM_STRING( &constant_bin[ 15501 ], 84, 0 );
    const_str_plain_profiles = UNSTREAM_STRING( &constant_bin[ 15585 ], 8, 1 );
    const_str_digest_fd8757ca246c476601094123086e9a80 = UNSTREAM_STRING( &constant_bin[ 15593 ], 1008, 0 );
    const_str_plain__methods = UNSTREAM_STRING( &constant_bin[ 16601 ], 8, 1 );
    const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list = PyList_New( 1 );
    const_str_digest_746ae0014bb266cffee8b7b1473626af = UNSTREAM_STRING( &constant_bin[ 16609 ], 14, 0 );
    PyList_SET_ITEM( const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list, 0, const_str_digest_746ae0014bb266cffee8b7b1473626af ); Py_INCREF( const_str_digest_746ae0014bb266cffee8b7b1473626af );
    const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP = UNSTREAM_STRING( &constant_bin[ 1986 ], 29, 1 );
    const_str_plain_accept = UNSTREAM_STRING( &constant_bin[ 10130 ], 6, 1 );
    const_str_plain__path_string = UNSTREAM_STRING( &constant_bin[ 16623 ], 12, 1 );
    const_str_plain_SSL_renegotiate = UNSTREAM_STRING( &constant_bin[ 16635 ], 15, 1 );
    const_str_plain_SSL_set_fd = UNSTREAM_STRING( &constant_bin[ 16650 ], 10, 1 );
    const_list_6fa8c3d8587ec1659fa28b2f58883e42_list = PyList_New( 3 );
    PyList_SET_ITEM( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 0, const_str_plain_TLS_AES_256_GCM_SHA384 ); Py_INCREF( const_str_plain_TLS_AES_256_GCM_SHA384 );
    PyList_SET_ITEM( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 1, const_str_plain_TLS_CHACHA20_POLY1305_SHA256 ); Py_INCREF( const_str_plain_TLS_CHACHA20_POLY1305_SHA256 );
    PyList_SET_ITEM( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list, 2, const_str_plain_TLS_AES_128_GCM_SHA256 ); Py_INCREF( const_str_plain_TLS_AES_128_GCM_SHA256 );
    const_tuple_7e6126bff16a8a76a713850dcb042242_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    const_str_plain_alert = UNSTREAM_STRING( &constant_bin[ 16660 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 1, const_str_plain_alert ); Py_INCREF( const_str_plain_alert );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 2, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    PyTuple_SET_ITEM( const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 3, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE = UNSTREAM_STRING( &constant_bin[ 16665 ], 31, 1 );
    const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 1, const_str_plain_mode ); Py_INCREF( const_str_plain_mode );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 2, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = UNSTREAM_STRING( &constant_bin[ 16696 ], 33, 1 );
    const_list_b44af29ad37821285e6b89a520342cf5_list = PyList_New( 5 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 0, const_str_digest_df9e5608be804d3b3249be3c13b24db8 ); Py_INCREF( const_str_digest_df9e5608be804d3b3249be3c13b24db8 );
    const_str_digest_052250489768b32f02c8505795c1c0c7 = UNSTREAM_STRING( &constant_bin[ 16729 ], 32, 0 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 1, const_str_digest_052250489768b32f02c8505795c1c0c7 ); Py_INCREF( const_str_digest_052250489768b32f02c8505795c1c0c7 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 2, const_str_digest_ee77c76941f8fd58acff5cfda589cc1d ); Py_INCREF( const_str_digest_ee77c76941f8fd58acff5cfda589cc1d );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 3, const_str_digest_053565796c68d049169d0efbeceaaf7d ); Py_INCREF( const_str_digest_053565796c68d049169d0efbeceaaf7d );
    const_str_digest_a3b259134db00dfd8458bf615870c7e2 = UNSTREAM_STRING( &constant_bin[ 16761 ], 49, 0 );
    PyList_SET_ITEM( const_list_b44af29ad37821285e6b89a520342cf5_list, 4, const_str_digest_a3b259134db00dfd8458bf615870c7e2 ); Py_INCREF( const_str_digest_a3b259134db00dfd8458bf615870c7e2 );
    const_str_digest_d242bea258df0e7212519aa660c5f53d = UNSTREAM_STRING( &constant_bin[ 16810 ], 24, 0 );
    const_str_plain_X509_get_default_cert_dir_env = UNSTREAM_STRING( &constant_bin[ 16834 ], 29, 1 );
    const_str_digest_aa8d23211c54bc521e23e53a6e431cd2 = UNSTREAM_STRING( &constant_bin[ 16863 ], 30, 0 );
    const_str_plain_get_cipher_bits = UNSTREAM_STRING( &constant_bin[ 16893 ], 15, 1 );
    const_str_plain_SSL_CTX_set_tlsext_status_arg = UNSTREAM_STRING( &constant_bin[ 16908 ], 29, 1 );
    const_tuple_a67b1154f8342873401b8122b6389ba8_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 2, const_str_plain_nbytes ); Py_INCREF( const_str_plain_nbytes );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 3, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 4, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_SSL_get_session = UNSTREAM_STRING( &constant_bin[ 16937 ], 15, 1 );
    const_str_plain_SSL_ERROR_SYSCALL = UNSTREAM_STRING( &constant_bin[ 16952 ], 17, 1 );
    const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING = UNSTREAM_STRING( &constant_bin[ 16969 ], 29, 1 );
    const_tuple_87f1641fb31961ccfc03a99691482662_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 0, const_str_plain_UNSPECIFIED ); Py_INCREF( const_str_plain_UNSPECIFIED );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 1, const_str_plain_exception_from_error_queue ); Py_INCREF( const_str_plain_exception_from_error_queue );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 2, const_str_plain_ffi ); Py_INCREF( const_str_plain_ffi );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 3, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 4, const_str_plain_make_assert ); Py_INCREF( const_str_plain_make_assert );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 5, const_str_plain_native ); Py_INCREF( const_str_plain_native );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 6, const_str_plain_path_string ); Py_INCREF( const_str_plain_path_string );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 7, const_str_plain_text_to_bytes_and_warn ); Py_INCREF( const_str_plain_text_to_bytes_and_warn );
    PyTuple_SET_ITEM( const_tuple_87f1641fb31961ccfc03a99691482662_tuple, 8, const_str_plain_no_zero_allocator ); Py_INCREF( const_str_plain_no_zero_allocator );
    const_str_plain_SSL_ERROR_WANT_READ = UNSTREAM_STRING( &constant_bin[ 16998 ], 19, 1 );
    const_str_plain_OP_CIPHER_SERVER_PREFERENCE = UNSTREAM_STRING( &constant_bin[ 1531 ], 27, 1 );
    const_str_plain_SSL_ST_ACCEPT = UNSTREAM_STRING( &constant_bin[ 2099 ], 13, 1 );
    const_str_plain_X509_get_default_cert_dir = UNSTREAM_STRING( &constant_bin[ 16834 ], 25, 1 );
    const_str_plain_SSL_CTX_add_extra_chain_cert = UNSTREAM_STRING( &constant_bin[ 17017 ], 28, 1 );
    const_str_digest_776556dd9343f57c1cd72ff937153f0f = UNSTREAM_STRING( &constant_bin[ 17045 ], 268, 0 );
    const_str_plain_SSL_want_read = UNSTREAM_STRING( &constant_bin[ 17313 ], 13, 1 );
    const_tuple_26498c7c65e3c1d61715bb934548919d_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 0, const_str_plain_binary_type ); Py_INCREF( const_str_plain_binary_type );
    PyTuple_SET_ITEM( const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 1, const_str_plain_integer_types ); Py_INCREF( const_str_plain_integer_types );
    PyTuple_SET_ITEM( const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 2, const_str_plain_int2byte ); Py_INCREF( const_str_plain_int2byte );
    PyTuple_SET_ITEM( const_tuple_26498c7c65e3c1d61715bb934548919d_tuple, 3, const_str_plain_indexbytes ); Py_INCREF( const_str_plain_indexbytes );
    const_tuple_str_plain_self_str_plain_profiles_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profiles_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profiles_tuple, 1, const_str_plain_profiles ); Py_INCREF( const_str_plain_profiles );
    const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_pystore = UNSTREAM_STRING( &constant_bin[ 17326 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 1, const_str_plain_pystore ); Py_INCREF( const_str_plain_pystore );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 2, const_str_plain_store ); Py_INCREF( const_str_plain_store );
    const_str_digest_d5ded94dafea47ce6f2b4fa579755177 = UNSTREAM_STRING( &constant_bin[ 17333 ], 34, 0 );
    const_str_plain_set_alpn_protos = UNSTREAM_STRING( &constant_bin[ 17367 ], 15, 1 );
    const_str_plain__CallbackExceptionHelper = UNSTREAM_STRING( &constant_bin[ 17382 ], 24, 1 );
    const_str_plain_empty = UNSTREAM_STRING( &constant_bin[ 2962 ], 5, 1 );
    const_str_plain_sk_X509_NAME_push = UNSTREAM_STRING( &constant_bin[ 17406 ], 17, 1 );
    const_str_plain_X509_V_OK = UNSTREAM_STRING( &constant_bin[ 17423 ], 9, 1 );
    const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026 = UNSTREAM_STRING( &constant_bin[ 17432 ], 195, 0 );
    const_str_plain_SSLEAY_BUILT_ON = UNSTREAM_STRING( &constant_bin[ 878 ], 15, 1 );
    const_str_plain_total_renegotiations = UNSTREAM_STRING( &constant_bin[ 17627 ], 20, 1 );
    const_str_plain_TLSv1_1_method = UNSTREAM_STRING( &constant_bin[ 17647 ], 14, 1 );
    const_str_plain_from_iterable = UNSTREAM_STRING( &constant_bin[ 17661 ], 13, 1 );
    const_str_plain_error_depth = UNSTREAM_STRING( &constant_bin[ 17674 ], 11, 1 );
    const_str_digest_47543c17fa95d5ac5c9bf71145417a30 = UNSTREAM_STRING( &constant_bin[ 17685 ], 17, 0 );
    const_str_digest_ebaec5436a48442094f25464a6eec24c = UNSTREAM_STRING( &constant_bin[ 17702 ], 277, 0 );
    const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6 = UNSTREAM_STRING( &constant_bin[ 17979 ], 302, 0 );
    const_str_digest_d89a36d0b4664ac4178af2071f30652f = UNSTREAM_STRING( &constant_bin[ 18281 ], 26, 0 );
    const_str_plain_SSL_CB_CONNECT_EXIT = UNSTREAM_STRING( &constant_bin[ 2330 ], 19, 1 );
    const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c = UNSTREAM_STRING( &constant_bin[ 18307 ], 405, 0 );
    const_str_digest_3462bf983701fbd7caf2f521f5975fff = UNSTREAM_STRING( &constant_bin[ 18712 ], 25, 0 );
    const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1 = UNSTREAM_STRING( &constant_bin[ 18737 ], 27, 0 );
    const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG = UNSTREAM_STRING( &constant_bin[ 18764 ], 28, 1 );
    const_str_plain_get_finished = UNSTREAM_STRING( &constant_bin[ 18792 ], 12, 1 );
    const_str_digest_794f687944b90121fa261238090835e1 = UNSTREAM_STRING( &constant_bin[ 18804 ], 338, 0 );
    const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple = PyTuple_New( 15 );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 1, const_str_plain_out ); Py_INCREF( const_str_plain_out );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 2, const_str_plain_outlen ); Py_INCREF( const_str_plain_outlen );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 3, const_str_plain_in_ ); Py_INCREF( const_str_plain_in_ );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 4, const_str_plain_inlen ); Py_INCREF( const_str_plain_inlen );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 5, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 6, const_str_plain_outstr ); Py_INCREF( const_str_plain_outstr );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 7, const_str_plain_protolist ); Py_INCREF( const_str_plain_protolist );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 8, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 9, const_str_plain_instr ); Py_INCREF( const_str_plain_instr );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 10, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 11, const_str_plain_proto ); Py_INCREF( const_str_plain_proto );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 12, const_str_plain_length ); Py_INCREF( const_str_plain_length );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 13, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 14, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_digest_fded22d63d84a836b130c747fc61664e = UNSTREAM_STRING( &constant_bin[ 19142 ], 80, 0 );
    const_str_plain_get_cipher_name = UNSTREAM_STRING( &constant_bin[ 19222 ], 15, 1 );
    const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER = UNSTREAM_STRING( &constant_bin[ 1353 ], 29, 1 );
    const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13 = UNSTREAM_STRING( &constant_bin[ 19237 ], 1008, 0 );
    const_str_plain__fallback_default_verify_paths = UNSTREAM_STRING( &constant_bin[ 20245 ], 30, 1 );
    const_str_plain_OP_ALL = UNSTREAM_STRING( &constant_bin[ 1776 ], 6, 1 );
    const_str_plain_SSL_total_renegotiations = UNSTREAM_STRING( &constant_bin[ 20275 ], 24, 1 );
    const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG = UNSTREAM_STRING( &constant_bin[ 20299 ], 29, 1 );
    const_str_plain_SSL_CTX_load_verify_locations = UNSTREAM_STRING( &constant_bin[ 20328 ], 29, 1 );
    const_str_plain__requires_sni = UNSTREAM_STRING( &constant_bin[ 20357 ], 13, 1 );
    const_tuple_str_plain_type_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    const_str_plain_SSL_set_SSL_CTX = UNSTREAM_STRING( &constant_bin[ 20370 ], 15, 1 );
    const_str_plain_OP_NO_TLSv1 = UNSTREAM_STRING( &constant_bin[ 1077 ], 11, 1 );
    const_str_plain_SSL_ERROR_ZERO_RETURN = UNSTREAM_STRING( &constant_bin[ 20385 ], 21, 1 );
    const_str_plain_SSLv23_method = UNSTREAM_STRING( &constant_bin[ 20406 ], 13, 1 );
    const_str_digest_616719c4a0cde3344203a07484a7fb54 = UNSTREAM_STRING( &constant_bin[ 20419 ], 18, 0 );
    const_tuple_str_plain_WeakValueDictionary_tuple = PyTuple_New( 1 );
    const_str_plain_WeakValueDictionary = UNSTREAM_STRING( &constant_bin[ 20437 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_WeakValueDictionary_tuple, 0, const_str_plain_WeakValueDictionary ); Py_INCREF( const_str_plain_WeakValueDictionary );
    const_str_digest_1f723e76cd26cf3162ae94f693472dd5 = UNSTREAM_STRING( &constant_bin[ 20456 ], 157, 0 );
    const_str_plain_SSL_CTX_get_cert_store = UNSTREAM_STRING( &constant_bin[ 20613 ], 22, 1 );
    const_str_plain_new_handle = UNSTREAM_STRING( &constant_bin[ 20635 ], 10, 1 );
    const_str_plain_SSLv2_method = UNSTREAM_STRING( &constant_bin[ 20645 ], 12, 1 );
    const_str_plain_OP_SINGLE_DH_USE = UNSTREAM_STRING( &constant_bin[ 1154 ], 16, 1 );
    const_str_digest_94c36790285a25f5d9268c8333413cf2 = UNSTREAM_STRING( &constant_bin[ 20657 ], 17, 0 );
    const_str_plain_SSL_CB_ALERT = UNSTREAM_STRING( &constant_bin[ 2198 ], 12, 1 );
    const_str_plain_use_certificate_file = UNSTREAM_STRING( &constant_bin[ 13221 ], 20, 1 );
    const_str_plain_SSL_OP_SINGLE_DH_USE = UNSTREAM_STRING( &constant_bin[ 20674 ], 20, 1 );
    const_str_plain_SSL_write = UNSTREAM_STRING( &constant_bin[ 20694 ], 9, 1 );
    const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT = UNSTREAM_STRING( &constant_bin[ 20703 ], 31, 1 );
    const_str_plain_get_alpn_proto_negotiated = UNSTREAM_STRING( &constant_bin[ 20734 ], 25, 1 );
    const_str_plain_ca_name = UNSTREAM_STRING( &constant_bin[ 3079 ], 7, 1 );
    const_tuple_str_plain_self_str_plain_callback_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_SSL_CTX_set_tlsext_use_srtp = UNSTREAM_STRING( &constant_bin[ 20759 ], 27, 1 );
    const_str_plain_set_session = UNSTREAM_STRING( &constant_bin[ 20786 ], 11, 1 );
    const_tuple_70adcf8f254ece362639433ee96fdafb_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 1, const_str_plain_certfile ); Py_INCREF( const_str_plain_certfile );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 2, const_str_plain_filetype ); Py_INCREF( const_str_plain_filetype );
    PyTuple_SET_ITEM( const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 3, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_str_plain_SESS_CACHE_SERVER = UNSTREAM_STRING( &constant_bin[ 1915 ], 17, 1 );
    const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, const_str_plain_data_len ); Py_INCREF( const_str_plain_data_len );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    const_str_plain__no_zero_allocator = UNSTREAM_STRING( &constant_bin[ 20797 ], 18, 1 );
    const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS = UNSTREAM_STRING( &constant_bin[ 1496 ], 30, 1 );
    const_str_plain_SSL_CIPHER_get_name = UNSTREAM_STRING( &constant_bin[ 20815 ], 19, 1 );
    const_str_digest_6e6e0d8d93df9702d9c8795dc2391090 = UNSTREAM_STRING( &constant_bin[ 20834 ], 205, 0 );
    const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 1, const_str_plain_function ); Py_INCREF( const_str_plain_function );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 2, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 3, const_str_plain_empty ); Py_INCREF( const_str_plain_empty );
    PyTuple_SET_ITEM( const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 4, const_str_plain_size ); Py_INCREF( const_str_plain_size );
    const_str_plain__alpn_select_helper = UNSTREAM_STRING( &constant_bin[ 21039 ], 19, 1 );
    const_str_plain_SSL_set_connect_state = UNSTREAM_STRING( &constant_bin[ 21058 ], 21, 1 );
    const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12 = UNSTREAM_STRING( &constant_bin[ 21079 ], 30, 0 );
    const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5 = UNSTREAM_STRING( &constant_bin[ 21109 ], 613, 0 );
    const_str_plain__CERTIFICATE_PATH_LOCATIONS = UNSTREAM_STRING( &constant_bin[ 21722 ], 27, 1 );
    const_str_plain__app_data = UNSTREAM_STRING( &constant_bin[ 7268 ], 9, 1 );
    const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 0, const_str_plain_FILETYPE_PEM ); Py_INCREF( const_str_plain_FILETYPE_PEM );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 1, const_str_plain__PassphraseHelper ); Py_INCREF( const_str_plain__PassphraseHelper );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 2, const_str_plain_PKey ); Py_INCREF( const_str_plain_PKey );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 3, const_str_plain_X509Name ); Py_INCREF( const_str_plain_X509Name );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 4, const_str_plain_X509 ); Py_INCREF( const_str_plain_X509 );
    PyTuple_SET_ITEM( const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple, 5, const_str_plain_X509Store ); Py_INCREF( const_str_plain_X509Store );
    const_str_plain_MSG_PEEK = UNSTREAM_STRING( &constant_bin[ 17865 ], 8, 1 );
    const_str_plain_get_cipher_version = UNSTREAM_STRING( &constant_bin[ 21749 ], 18, 1 );
    const_str_plain_SSL_ERROR_NONE = UNSTREAM_STRING( &constant_bin[ 21767 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_rc_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rc_tuple, 1, const_str_plain_rc ); Py_INCREF( const_str_plain_rc );
    const_str_plain__npn_select_callback_args = UNSTREAM_STRING( &constant_bin[ 21781 ], 25, 1 );
    const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 0, const_str_plain_size ); Py_INCREF( const_str_plain_size );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 1, const_str_plain_verify ); Py_INCREF( const_str_plain_verify );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 2, const_str_plain_userdata ); Py_INCREF( const_str_plain_userdata );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 3, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_digest_e04d236da419e1b15c5c13532be67a91 = UNSTREAM_STRING( &constant_bin[ 21806 ], 496, 0 );
    const_str_digest_85e95361903fe71cece52bb01216866e = UNSTREAM_STRING( &constant_bin[ 22302 ], 597, 0 );
    const_str_plain_SSL_SESS_CACHE_BOTH = UNSTREAM_STRING( &constant_bin[ 22899 ], 19, 1 );
    const_str_plain_sk_X509_NAME_free = UNSTREAM_STRING( &constant_bin[ 22918 ], 17, 1 );
    const_str_plain_get_protocol_version_name = UNSTREAM_STRING( &constant_bin[ 22935 ], 25, 1 );
    const_str_plain_identifier = UNSTREAM_STRING( &constant_bin[ 22960 ], 10, 1 );
    const_str_plain_SSL_CB_HANDSHAKE_START = UNSTREAM_STRING( &constant_bin[ 2354 ], 22, 1 );
    const_str_plain_SSLEAY_PLATFORM = UNSTREAM_STRING( &constant_bin[ 843 ], 15, 1 );
    const_str_plain__get_finished_message = UNSTREAM_STRING( &constant_bin[ 22970 ], 21, 1 );
    const_str_plain_SSL_version = UNSTREAM_STRING( &constant_bin[ 22991 ], 11, 1 );
    const_str_plain_SSL_set_mode = UNSTREAM_STRING( &constant_bin[ 23002 ], 12, 1 );
    const_str_plain_tobytes = UNSTREAM_STRING( &constant_bin[ 23014 ], 7, 1 );
    const_str_plain_SSL_CB_WRITE = UNSTREAM_STRING( &constant_bin[ 2181 ], 12, 1 );
    const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 23021 ], 38, 1 );
    const_str_plain__check_env_vars_set = UNSTREAM_STRING( &constant_bin[ 23059 ], 19, 1 );
    const_str_plain_SSL_CTX_get_verify_depth = UNSTREAM_STRING( &constant_bin[ 23078 ], 24, 1 );
    const_str_plain_SSL_OP_EPHEMERAL_RSA = UNSTREAM_STRING( &constant_bin[ 23102 ], 20, 1 );
    const_str_plain_SSL_SESS_CACHE_CLIENT = UNSTREAM_STRING( &constant_bin[ 23122 ], 21, 1 );
    const_str_digest_1c06dc4166e08805f38a8dca82ce4339 = UNSTREAM_STRING( &constant_bin[ 23143 ], 147, 0 );
    const_tuple_str_plain_wraps_str_plain_partial_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_wraps_str_plain_partial_tuple, 0, const_str_plain_wraps ); Py_INCREF( const_str_plain_wraps );
    PyTuple_SET_ITEM( const_tuple_str_plain_wraps_str_plain_partial_tuple, 1, const_str_plain_partial ); Py_INCREF( const_str_plain_partial );
    const_str_digest_ceaeeee7f342339744c9535ada3c62e3 = UNSTREAM_STRING( &constant_bin[ 23290 ], 223, 0 );
    const_str_plain_SSL_set_tlsext_status_type = UNSTREAM_STRING( &constant_bin[ 23513 ], 26, 1 );
    const_str_plain__verify_helper = UNSTREAM_STRING( &constant_bin[ 23539 ], 14, 1 );
    const_str_digest_38eb25c1dd31f1c93831bc586a51d94a = UNSTREAM_STRING( &constant_bin[ 23553 ], 386, 0 );
    const_str_plain__socket = UNSTREAM_STRING( &constant_bin[ 23939 ], 7, 1 );
    const_str_digest_afa60644cf27716474a6bbd780185867 = UNSTREAM_STRING( &constant_bin[ 23946 ], 49, 0 );
    const_str_plain_pysession = UNSTREAM_STRING( &constant_bin[ 23995 ], 9, 1 );
    const_str_digest_7cc8f764b42656b144d56bfbd9df2b48 = UNSTREAM_STRING( &constant_bin[ 24004 ], 909, 0 );
    const_str_plain__make_requires = UNSTREAM_STRING( &constant_bin[ 24913 ], 14, 1 );
    const_str_digest_39dd8800b3995a2e161e8739b1bebc01 = UNSTREAM_STRING( &constant_bin[ 24927 ], 337, 0 );
    const_str_plain__npn_select_helper = UNSTREAM_STRING( &constant_bin[ 25264 ], 18, 1 );
    const_str_plain_BIO_should_read = UNSTREAM_STRING( &constant_bin[ 25282 ], 15, 1 );
    const_str_plain_cipher_list = UNSTREAM_STRING( &constant_bin[ 5172 ], 11, 1 );
    const_str_plain_set_verify_depth = UNSTREAM_STRING( &constant_bin[ 25297 ], 16, 1 );
    const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d = UNSTREAM_STRING( &constant_bin[ 25313 ], 143, 0 );
    const_str_digest_0f682ae315fc37e97d14dcc920e8b91d = UNSTREAM_STRING( &constant_bin[ 25456 ], 112, 0 );
    const_str_digest_b65860d01f08f87c7391d19b5cfd9850 = UNSTREAM_STRING( &constant_bin[ 25568 ], 398, 0 );
    const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf = UNSTREAM_STRING( &constant_bin[ 25966 ], 318, 0 );
    const_str_plain_use_certificate = UNSTREAM_STRING( &constant_bin[ 9101 ], 15, 1 );
    const_str_plain_SSL_CTX_get_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 26284 ], 30, 1 );
    const_str_plain_dir_path = UNSTREAM_STRING( &constant_bin[ 26314 ], 8, 1 );
    const_str_digest_f5111f918158679228186076f422f85e = UNSTREAM_STRING( &constant_bin[ 26322 ], 46, 0 );
    const_str_plain_SSL_CTX_new = UNSTREAM_STRING( &constant_bin[ 26368 ], 11, 1 );
    const_str_plain__raise_ssl_error = UNSTREAM_STRING( &constant_bin[ 26379 ], 16, 1 );
    const_str_plain_SSL_get_peer_finished = UNSTREAM_STRING( &constant_bin[ 23723 ], 21, 1 );
    const_str_plain_SSL_MODE_AUTO_RETRY = UNSTREAM_STRING( &constant_bin[ 26395 ], 19, 1 );
    const_str_digest_f64bec1377ff9f22e4ed4c823f6a5647 = UNSTREAM_STRING( &constant_bin[ 26414 ], 47, 0 );
    const_str_plain_SSL_get_peer_certificate = UNSTREAM_STRING( &constant_bin[ 26461 ], 24, 1 );
    const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG = UNSTREAM_STRING( &constant_bin[ 26485 ], 28, 1 );
    const_str_plain_load_client_ca = UNSTREAM_STRING( &constant_bin[ 26513 ], 14, 1 );
    const_str_plain_SSL_get_server_random = UNSTREAM_STRING( &constant_bin[ 26527 ], 21, 1 );
    const_str_plain_dhfile = UNSTREAM_STRING( &constant_bin[ 3917 ], 6, 1 );
    const_str_plain_SSL_CB_ACCEPT_LOOP = UNSTREAM_STRING( &constant_bin[ 2260 ], 18, 1 );
    const_tuple_b5f59418c193d572a22cf854b821fa76_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 1, const_str_plain_identifier ); Py_INCREF( const_str_plain_identifier );
    PyTuple_SET_ITEM( const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_ContextType = UNSTREAM_STRING( &constant_bin[ 11048 ], 11, 1 );
    const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6 = UNSTREAM_STRING( &constant_bin[ 26548 ], 273, 0 );
    const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = UNSTREAM_STRING( &constant_bin[ 26821 ], 39, 1 );
    const_str_plain_client_random = UNSTREAM_STRING( &constant_bin[ 26860 ], 13, 1 );
    const_str_plain_renegotiate_pending = UNSTREAM_STRING( &constant_bin[ 26873 ], 19, 1 );
    const_str_plain_SSL_SENT_SHUTDOWN = UNSTREAM_STRING( &constant_bin[ 26892 ], 17, 1 );
    const_str_plain__tlsext_servername_callback = UNSTREAM_STRING( &constant_bin[ 26909 ], 27, 1 );
    const_str_plain_BIO_should_write = UNSTREAM_STRING( &constant_bin[ 26936 ], 16, 1 );
    const_str_digest_a971aca8bab65513da2005120ca529f5 = UNSTREAM_STRING( &constant_bin[ 26952 ], 360, 0 );
    const_str_digest_9c76bfc2ff06864d351211fc5c45c351 = UNSTREAM_STRING( &constant_bin[ 27312 ], 418, 0 );
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE = UNSTREAM_STRING( &constant_bin[ 27730 ], 32, 1 );
    const_str_plain_SSL_state_string_long = UNSTREAM_STRING( &constant_bin[ 27762 ], 21, 1 );
    const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_default_dir = UNSTREAM_STRING( &constant_bin[ 27783 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 1, const_str_plain_default_dir ); Py_INCREF( const_str_plain_default_dir );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_dir_env_var = UNSTREAM_STRING( &constant_bin[ 27794 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 3, const_str_plain_dir_env_var ); Py_INCREF( const_str_plain_dir_env_var );
    const_str_plain_file_env_var = UNSTREAM_STRING( &constant_bin[ 27805 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 4, const_str_plain_file_env_var ); Py_INCREF( const_str_plain_file_env_var );
    const_str_plain_default_file = UNSTREAM_STRING( &constant_bin[ 27817 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 5, const_str_plain_default_file ); Py_INCREF( const_str_plain_default_file );
    const_str_plain_SSL_get_client_CA_list = UNSTREAM_STRING( &constant_bin[ 27829 ], 22, 1 );
    const_str_plain_SSL_CTX_use_PrivateKey_file = UNSTREAM_STRING( &constant_bin[ 27851 ], 27, 1 );
    const_str_plain_SSL_VERIFY_NONE = UNSTREAM_STRING( &constant_bin[ 27878 ], 15, 1 );
    const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = UNSTREAM_STRING( &constant_bin[ 27893 ], 34, 1 );
    const_str_plain_SSLEAY_CFLAGS = UNSTREAM_STRING( &constant_bin[ 825 ], 13, 1 );
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL = UNSTREAM_STRING( &constant_bin[ 27730 ], 26, 1 );
    const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50 = UNSTREAM_STRING( &constant_bin[ 27927 ], 343, 0 );
    const_str_plain_SSL_CTX_set_tlsext_servername_callback = UNSTREAM_STRING( &constant_bin[ 28270 ], 38, 1 );
    const_str_plain_SSL_CTX_set_options = UNSTREAM_STRING( &constant_bin[ 28308 ], 19, 1 );
    const_str_plain_OP_NO_TLSv1_2 = UNSTREAM_STRING( &constant_bin[ 1111 ], 13, 1 );
    const_str_plain__handle_bio_errors = UNSTREAM_STRING( &constant_bin[ 28327 ], 18, 1 );
    const_str_plain_get_session = UNSTREAM_STRING( &constant_bin[ 12629 ], 11, 1 );
    const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6 = UNSTREAM_STRING( &constant_bin[ 28345 ], 28, 0 );
    const_str_plain_SSL_CTX_set_tmp_dh = UNSTREAM_STRING( &constant_bin[ 28373 ], 18, 1 );
    const_str_digest_0438f8885bf87c226201350e81ca4f79 = UNSTREAM_STRING( &constant_bin[ 28391 ], 129, 0 );
    const_str_digest_1bd7405e218c8a579c48801956097e27 = UNSTREAM_STRING( &constant_bin[ 28520 ], 94, 0 );
    const_str_plain_SSL_read = UNSTREAM_STRING( &constant_bin[ 28614 ], 8, 1 );
    const_str_plain_SSL_free = UNSTREAM_STRING( &constant_bin[ 28622 ], 8, 1 );
    const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 1, const_str_plain_certfile ); Py_INCREF( const_str_plain_certfile );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_723fb164f3e133051d00542dd747fe2d = UNSTREAM_STRING( &constant_bin[ 28630 ], 140, 0 );
    const_str_plain_SSL_get0_next_proto_negotiated = UNSTREAM_STRING( &constant_bin[ 28770 ], 30, 1 );
    const_str_plain_set_app_data = UNSTREAM_STRING( &constant_bin[ 28800 ], 12, 1 );
    const_str_plain__npn_advertise_callback = UNSTREAM_STRING( &constant_bin[ 28812 ], 23, 1 );
    const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_file_path = UNSTREAM_STRING( &constant_bin[ 28835 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 1, const_str_plain_file_path ); Py_INCREF( const_str_plain_file_path );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 2, const_str_plain_dir_path ); Py_INCREF( const_str_plain_dir_path );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 3, const_str_plain_capath ); Py_INCREF( const_str_plain_capath );
    PyTuple_SET_ITEM( const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 4, const_str_plain_cafile ); Py_INCREF( const_str_plain_cafile );
    const_str_plain_SSL_SESS_CACHE_SERVER = UNSTREAM_STRING( &constant_bin[ 28844 ], 21, 1 );
    const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG = UNSTREAM_STRING( &constant_bin[ 28865 ], 25, 1 );
    const_tuple_cf035770f08c8746b05138973d8b64b8_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 1, const_str_plain_protos ); Py_INCREF( const_str_plain_protos );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, const_str_plain_protostr ); Py_INCREF( const_str_plain_protostr );
    const_str_plain_input_str = UNSTREAM_STRING( &constant_bin[ 28890 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 3, const_str_plain_input_str ); Py_INCREF( const_str_plain_input_str );
    const_tuple_str_plain_self_str_plain_addr_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_addr_tuple, 1, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    const_str_plain_SSL_want_write = UNSTREAM_STRING( &constant_bin[ 28899 ], 14, 1 );
    const_str_digest_2eac950a8b26412274fa98ea596054c5 = UNSTREAM_STRING( &constant_bin[ 28913 ], 425, 0 );
    const_str_plain__binary_type = UNSTREAM_STRING( &constant_bin[ 29338 ], 12, 1 );
    const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a = UNSTREAM_STRING( &constant_bin[ 29350 ], 104, 0 );
    const_str_plain_client = UNSTREAM_STRING( &constant_bin[ 2655 ], 6, 1 );
    const_dict_4a96d2f6310f0842d222254905a83466 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_4a96d2f6310f0842d222254905a83466, const_str_plain_more_args, Py_True );
    PyDict_SetItem( const_dict_4a96d2f6310f0842d222254905a83466, const_str_plain_truncate, Py_True );
    assert( PyDict_Size( const_dict_4a96d2f6310f0842d222254905a83466 ) == 2 );
    const_str_plain_SSL_CTX_use_certificate_chain_file = UNSTREAM_STRING( &constant_bin[ 29454 ], 34, 1 );
    const_str_digest_c5585513b25f5127855be671a08a1332 = UNSTREAM_STRING( &constant_bin[ 29488 ], 217, 0 );
    const_str_plain_SSLv2_METHOD = UNSTREAM_STRING( &constant_bin[ 938 ], 12, 1 );
    const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51 = UNSTREAM_STRING( &constant_bin[ 29705 ], 213, 0 );
    const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 1, const_str_plain_client ); Py_INCREF( const_str_plain_client );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 2, const_str_plain_addr ); Py_INCREF( const_str_plain_addr );
    PyTuple_SET_ITEM( const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 3, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_plain_load_tmp_dh = UNSTREAM_STRING( &constant_bin[ 29918 ], 11, 1 );
    const_str_plain__alpn_select_callback_args = UNSTREAM_STRING( &constant_bin[ 29929 ], 26, 1 );
    const_str_plain__context = UNSTREAM_STRING( &constant_bin[ 11806 ], 8, 1 );
    const_tuple_str_plain_self_str_plain_context_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_context_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_context_tuple, 1, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1 = UNSTREAM_STRING( &constant_bin[ 29955 ], 729, 0 );
    const_str_plain_SSL_shutdown = UNSTREAM_STRING( &constant_bin[ 30684 ], 12, 1 );
    const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 1, const_str_plain_keyfile ); Py_INCREF( const_str_plain_keyfile );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 2, const_str_plain_filetype ); Py_INCREF( const_str_plain_filetype );
    PyTuple_SET_ITEM( const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 3, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_str_plain_SSL_get_peer_cert_chain = UNSTREAM_STRING( &constant_bin[ 30696 ], 23, 1 );
    const_str_plain__session = UNSTREAM_STRING( &constant_bin[ 5191 ], 8, 1 );
    const_str_plain_set_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 30719 ], 22, 1 );
    const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad = UNSTREAM_STRING( &constant_bin[ 30741 ], 129, 0 );
    const_str_plain__OCSPServerCallbackHelper = UNSTREAM_STRING( &constant_bin[ 30870 ], 25, 1 );
    const_str_plain_SSL_new = UNSTREAM_STRING( &constant_bin[ 30895 ], 7, 1 );
    const_str_digest_655ba65e888ba33199198c92a8e95d70 = UNSTREAM_STRING( &constant_bin[ 30902 ], 151, 0 );
    const_str_plain__alpn_select_callback = UNSTREAM_STRING( &constant_bin[ 29929 ], 21, 1 );
    const_str_digest_8d1f7ec402c1b452808eeb662977982b = UNSTREAM_STRING( &constant_bin[ 31053 ], 224, 0 );
    const_str_plain__passphrase_userdata = UNSTREAM_STRING( &constant_bin[ 31277 ], 20, 1 );
    const_str_plain_SSL_OP_NO_SSLv3 = UNSTREAM_STRING( &constant_bin[ 31297 ], 15, 1 );
    const_str_plain_SSL_OP_NO_SSLv2 = UNSTREAM_STRING( &constant_bin[ 31312 ], 15, 1 );
    const_str_plain_SSL_SESSION_free = UNSTREAM_STRING( &constant_bin[ 31327 ], 16, 1 );
    const_str_digest_6d088f969ab84bf3d60ab75faa431e51 = UNSTREAM_STRING( &constant_bin[ 31343 ], 132, 0 );
    const_str_plain_from_handle = UNSTREAM_STRING( &constant_bin[ 31475 ], 11, 1 );
    const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = UNSTREAM_STRING( &constant_bin[ 31486 ], 34, 1 );
    const_str_plain_SSL_renegotiate_pending = UNSTREAM_STRING( &constant_bin[ 31520 ], 23, 1 );
    const_str_plain_SSL_load_client_CA_file = UNSTREAM_STRING( &constant_bin[ 31543 ], 23, 1 );
    const_str_plain_SSL_pending = UNSTREAM_STRING( &constant_bin[ 31566 ], 11, 1 );
    const_str_plain_SSL_OP_NO_TLSv1 = UNSTREAM_STRING( &constant_bin[ 7352 ], 15, 1 );
    const_str_digest_4387d84e76f6b2a931cf315cb767f6ce = UNSTREAM_STRING( &constant_bin[ 31577 ], 51, 0 );
    const_str_plain_check_privatekey = UNSTREAM_STRING( &constant_bin[ 31628 ], 16, 1 );
    const_str_plain_SSL_get_shutdown = UNSTREAM_STRING( &constant_bin[ 31644 ], 16, 1 );
    const_str_plain_context_buf = UNSTREAM_STRING( &constant_bin[ 31660 ], 11, 1 );
    const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_b55bbb0df6959d47693f7145ead6828a = UNSTREAM_STRING( &constant_bin[ 31671 ], 250, 0 );
    const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_bufsiz = UNSTREAM_STRING( &constant_bin[ 17759 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 1, const_str_plain_bufsiz ); Py_INCREF( const_str_plain_bufsiz );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 2, const_str_plain_flags ); Py_INCREF( const_str_plain_flags );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 3, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 4, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_3b38b9684d0a691f727a5c25b49127cb = UNSTREAM_STRING( &constant_bin[ 31921 ], 36, 0 );
    const_str_plain_request_ocsp = UNSTREAM_STRING( &constant_bin[ 31957 ], 12, 1 );
    const_str_plain__info_callback = UNSTREAM_STRING( &constant_bin[ 3833 ], 14, 1 );
    const_str_plain_OP_TLS_D5_BUG = UNSTREAM_STRING( &constant_bin[ 1449 ], 13, 1 );
    const_str_plain_SSL_CTX_set_next_protos_advertised_cb = UNSTREAM_STRING( &constant_bin[ 31969 ], 37, 1 );
    const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 1, const_str_plain_dhfile ); Py_INCREF( const_str_plain_dhfile );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 3, const_str_plain_dh ); Py_INCREF( const_str_plain_dh );
    const_str_digest_df17ae6c88635e3960d7bf94f5e880a4 = UNSTREAM_STRING( &constant_bin[ 32006 ], 342, 0 );
    const_str_plain_set_npn_select_callback = UNSTREAM_STRING( &constant_bin[ 32348 ], 23, 1 );
    const_str_plain_SSL_CTX_set_default_passwd_cb = UNSTREAM_STRING( &constant_bin[ 32371 ], 29, 1 );
    const_str_plain_SSL_CTX_set_info_callback = UNSTREAM_STRING( &constant_bin[ 32400 ], 25, 1 );
    const_str_plain_OP_TLS_BLOCK_PADDING_BUG = UNSTREAM_STRING( &constant_bin[ 1467 ], 24, 1 );
    const_str_plain_SSL_get_error = UNSTREAM_STRING( &constant_bin[ 32425 ], 13, 1 );
    const_str_plain_SSL_get_certificate = UNSTREAM_STRING( &constant_bin[ 32438 ], 19, 1 );
    const_str_plain_get_timeout = UNSTREAM_STRING( &constant_bin[ 3714 ], 11, 1 );
    const_str_digest_f68d1733f2e29d0ad83b903b8f287e14 = UNSTREAM_STRING( &constant_bin[ 32457 ], 441, 0 );
    const_str_plain_SSL_VERIFY_PEER = UNSTREAM_STRING( &constant_bin[ 32898 ], 15, 1 );
    const_tuple_e7183725d38a187a36c7befeae938036_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 1, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 3, const_str_plain_errno ); Py_INCREF( const_str_plain_errno );
    PyTuple_SET_ITEM( const_tuple_e7183725d38a187a36c7befeae938036_tuple, 4, const_str_plain_error ); Py_INCREF( const_str_plain_error );
    const_str_digest_685ba6a7380a18939915178358979194 = UNSTREAM_STRING( &constant_bin[ 32913 ], 16, 0 );
    const_str_plain_SSL_set_shutdown = UNSTREAM_STRING( &constant_bin[ 32929 ], 16, 1 );
    const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 0, const_str_digest_c561652c58984ec0e9541542aa405594 ); Py_INCREF( const_str_digest_c561652c58984ec0e9541542aa405594 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_plain_use_context = UNSTREAM_STRING( &constant_bin[ 32945 ], 11, 1 );
    const_str_digest_68d768407778bc3b4c8ffc953440b717 = UNSTREAM_STRING( &constant_bin[ 32956 ], 293, 0 );
    const_str_plain_outp = UNSTREAM_STRING( &constant_bin[ 33249 ], 4, 1 );
    const_str_digest_fe9d923dffe7ca07e210d76d45bba668 = UNSTREAM_STRING( &constant_bin[ 33253 ], 170, 0 );
    const_str_plain__npn_select_callback = UNSTREAM_STRING( &constant_bin[ 21781 ], 20, 1 );
    const_str_digest_71f502d97e845c89ec13eb6ef271f294 = UNSTREAM_STRING( &constant_bin[ 33423 ], 23, 0 );
    const_str_plain_get_cipher_list = UNSTREAM_STRING( &constant_bin[ 5168 ], 15, 1 );
    const_tuple_str_plain_platform_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_platform_tuple, 0, const_str_plain_platform ); Py_INCREF( const_str_plain_platform );
    const_str_digest_75d74458faf9dee1d9b7a20a034cfad7 = UNSTREAM_STRING( &constant_bin[ 33446 ], 31, 0 );
    const_str_plain_set_mode = UNSTREAM_STRING( &constant_bin[ 5156 ], 8, 1 );
    const_str_digest_bd36e8cd21056831af843bc4658cec96 = UNSTREAM_STRING( &constant_bin[ 33477 ], 209, 0 );
    const_str_plain_SSL_CB_READ = UNSTREAM_STRING( &constant_bin[ 2165 ], 11, 1 );
    const_str_plain_SSL_OP_ALL = UNSTREAM_STRING( &constant_bin[ 33686 ], 10, 1 );
    const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 2, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_str_plain__ocsp_callback = UNSTREAM_STRING( &constant_bin[ 33696 ], 14, 1 );
    const_str_plain_set_session_id = UNSTREAM_STRING( &constant_bin[ 33710 ], 14, 1 );
    const_str_digest_5e63447161ff7f7c21b2ac874cc6500c = UNSTREAM_STRING( &constant_bin[ 33724 ], 498, 0 );
    const_str_digest_92d0e5bbbb594d3595c30b16879df5a0 = UNSTREAM_STRING( &constant_bin[ 34222 ], 128, 0 );
    const_str_digest_1f9e090d5f76db9e818dd53fef9b8465 = UNSTREAM_STRING( &constant_bin[ 34350 ], 115, 0 );
    const_str_plain_set_ocsp_client_callback = UNSTREAM_STRING( &constant_bin[ 9870 ], 24, 1 );
    const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd = UNSTREAM_STRING( &constant_bin[ 34465 ], 293, 0 );
    const_str_digest_03a9c0f25246f86801453ac49af67056 = UNSTREAM_STRING( &constant_bin[ 34758 ], 453, 0 );
    const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP = UNSTREAM_STRING( &constant_bin[ 35211 ], 33, 1 );
    const_str_plain_X509_get_default_cert_file_env = UNSTREAM_STRING( &constant_bin[ 35244 ], 30, 1 );
    const_str_digest_a9a754c6f4c1dd488de35af4ae59537f = UNSTREAM_STRING( &constant_bin[ 35274 ], 81, 0 );
    const_str_plain_WantX509LookupError = UNSTREAM_STRING( &constant_bin[ 2454 ], 19, 1 );
    const_str_plain_SSLEAY_VERSION = UNSTREAM_STRING( &constant_bin[ 806 ], 14, 1 );
    const_str_plain_set_npn_advertise_callback = UNSTREAM_STRING( &constant_bin[ 35355 ], 26, 1 );
    const_str_plain_get_peer_finished = UNSTREAM_STRING( &constant_bin[ 23622 ], 17, 1 );
    const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 1, const_str_plain_label ); Py_INCREF( const_str_plain_label );
    const_str_plain_olen = UNSTREAM_STRING( &constant_bin[ 5348 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 2, const_str_plain_olen ); Py_INCREF( const_str_plain_olen );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 3, const_str_plain_context ); Py_INCREF( const_str_plain_context );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 4, const_str_plain_outp ); Py_INCREF( const_str_plain_outp );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 5, const_str_plain_use_context ); Py_INCREF( const_str_plain_use_context );
    const_str_plain_success = UNSTREAM_STRING( &constant_bin[ 26217 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 6, const_str_plain_success ); Py_INCREF( const_str_plain_success );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 7, const_str_plain_context_buf ); Py_INCREF( const_str_plain_context_buf );
    const_str_plain_context_len = UNSTREAM_STRING( &constant_bin[ 35381 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 8, const_str_plain_context_len ); Py_INCREF( const_str_plain_context_len );
    const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 1, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 3, const_str_plain_rc ); Py_INCREF( const_str_plain_rc );
    const_str_plain_want_write = UNSTREAM_STRING( &constant_bin[ 28903 ], 10, 1 );
    const_str_plain_SSL_OP_COOKIE_EXCHANGE = UNSTREAM_STRING( &constant_bin[ 35392 ], 22, 1 );
    const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, const_str_plain_outp ); Py_INCREF( const_str_plain_outp );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 2, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 3, const_str_plain_length ); Py_INCREF( const_str_plain_length );
    const_str_digest_447836721d7454a13033957e012d7688 = UNSTREAM_STRING( &constant_bin[ 35414 ], 247, 0 );
    const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 2, const_str_plain_use_result ); Py_INCREF( const_str_plain_use_result );
    const_str_digest_94e7111e03f9422114930bb75dfc492c = UNSTREAM_STRING( &constant_bin[ 35661 ], 239, 0 );
    const_str_digest_8d7c284f25a4b19db8bcbef7a9895745 = UNSTREAM_STRING( &constant_bin[ 35900 ], 114, 0 );
    const_str_plain_SSL_get_version = UNSTREAM_STRING( &constant_bin[ 36014 ], 15, 1 );
    const_str_plain_SESS_CACHE_CLIENT = UNSTREAM_STRING( &constant_bin[ 1893 ], 17, 1 );
    const_str_plain_get_client_ca_list = UNSTREAM_STRING( &constant_bin[ 36029 ], 18, 1 );
    const_str_plain_get_cert_store = UNSTREAM_STRING( &constant_bin[ 20621 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_result_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_result_tuple, 1, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_SSL_get_current_cipher = UNSTREAM_STRING( &constant_bin[ 36047 ], 22, 1 );
    const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade = UNSTREAM_STRING( &constant_bin[ 36069 ], 32, 0 );
    const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 1, const_str_plain_cipher_list ); Py_INCREF( const_str_plain_cipher_list );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 2, const_str_plain_tmpconn ); Py_INCREF( const_str_plain_tmpconn );
    const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx = UNSTREAM_STRING( &constant_bin[ 36101 ], 34, 1 );
    const_str_plain__set_ocsp_callback = UNSTREAM_STRING( &constant_bin[ 36135 ], 18, 1 );
    const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 1, const_str_plain_certificate_authority ); Py_INCREF( const_str_plain_certificate_authority );
    PyTuple_SET_ITEM( const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 2, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_plain_set_accept_state = UNSTREAM_STRING( &constant_bin[ 14792 ], 16, 1 );
    const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2 = UNSTREAM_STRING( &constant_bin[ 36153 ], 20, 0 );
    const_str_plain__ocsp_helper = UNSTREAM_STRING( &constant_bin[ 36173 ], 12, 1 );
    const_str_plain_SSL_CTX_set_session_id_context = UNSTREAM_STRING( &constant_bin[ 36185 ], 30, 1 );
    const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 1, const_str_plain_dir_env_var ); Py_INCREF( const_str_plain_dir_env_var );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 2, const_str_plain_file_env_var ); Py_INCREF( const_str_plain_file_env_var );
    const_str_plain_certificate_authorities = UNSTREAM_STRING( &constant_bin[ 36215 ], 23, 1 );
    const_str_plain_SSL_CTX_free = UNSTREAM_STRING( &constant_bin[ 36238 ], 12, 1 );
    const_str_digest_215c056443df9aa1456b62fe40673d54 = UNSTREAM_STRING( &constant_bin[ 36250 ], 31, 0 );
    const_tuple_fb64e812782e9f70f19909e310070a01_tuple = PyTuple_New( 13 );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 0, const_str_plain_ok ); Py_INCREF( const_str_plain_ok );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 1, const_str_plain_store_ctx ); Py_INCREF( const_str_plain_store_ctx );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 2, const_str_plain_index ); Py_INCREF( const_str_plain_index );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 3, const_str_plain_error_number ); Py_INCREF( const_str_plain_error_number );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 5, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 6, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 7, const_str_plain_connection ); Py_INCREF( const_str_plain_connection );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 8, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 9, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 10, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 11, const_str_plain_error_depth ); Py_INCREF( const_str_plain_error_depth );
    PyTuple_SET_ITEM( const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 12, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    const_str_plain_SSL_OP_TLS_D5_BUG = UNSTREAM_STRING( &constant_bin[ 36281 ], 17, 1 );
    const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG = UNSTREAM_STRING( &constant_bin[ 1417 ], 27, 1 );
    const_str_plain_SSL_get_finished = UNSTREAM_STRING( &constant_bin[ 23682 ], 16, 1 );
    const_str_plain_SSL_ST_MASK = UNSTREAM_STRING( &constant_bin[ 2117 ], 11, 1 );
    const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 1, const_str_plain_certificate_authorities ); Py_INCREF( const_str_plain_certificate_authorities );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 2, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 3, const_str_plain_name_stack ); Py_INCREF( const_str_plain_name_stack );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 4, const_str_plain_ca_name ); Py_INCREF( const_str_plain_ca_name );
    PyTuple_SET_ITEM( const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 5, const_str_plain_push_result ); Py_INCREF( const_str_plain_push_result );
    const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 1, const_str_plain_bufsiz ); Py_INCREF( const_str_plain_bufsiz );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 2, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e = UNSTREAM_STRING( &constant_bin[ 36298 ], 174, 0 );
    const_str_plain_SSL_set_session = UNSTREAM_STRING( &constant_bin[ 36472 ], 15, 1 );
    const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG = UNSTREAM_STRING( &constant_bin[ 1318 ], 30, 1 );
    const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    const_str_digest_428eff9fedd3b449496fa307af56b948 = UNSTREAM_STRING( &constant_bin[ 36487 ], 34, 0 );
    const_str_plain_SSL_CTX_add_client_CA = UNSTREAM_STRING( &constant_bin[ 36521 ], 21, 1 );
    const_str_plain_sk_X509_NAME_new_null = UNSTREAM_STRING( &constant_bin[ 36542 ], 21, 1 );
    const_str_plain_SSL_OP_TLS_ROLLBACK_BUG = UNSTREAM_STRING( &constant_bin[ 36563 ], 23, 1 );
    const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 0, const_str_plain_flag ); Py_INCREF( const_str_plain_flag );
    PyTuple_SET_ITEM( const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 1, const_str_plain_error ); Py_INCREF( const_str_plain_error );
    PyTuple_SET_ITEM( const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 2, const_str_plain__requires_decorator ); Py_INCREF( const_str_plain__requires_decorator );
    const_str_plain_SESS_CACHE_NO_INTERNAL = UNSTREAM_STRING( &constant_bin[ 1986 ], 22, 1 );
    const_str_plain_get_protocol_version = UNSTREAM_STRING( &constant_bin[ 22935 ], 20, 1 );
    const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 2, const_str_plain_ciphers ); Py_INCREF( const_str_plain_ciphers );
    PyTuple_SET_ITEM( const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_SSL_CB_READ_ALERT = UNSTREAM_STRING( &constant_bin[ 2215 ], 17, 1 );
    const_str_plain_set_tlsext_use_srtp = UNSTREAM_STRING( &constant_bin[ 20767 ], 19, 1 );
    const_str_plain_SSL_OP_NO_COMPRESSION = UNSTREAM_STRING( &constant_bin[ 36586 ], 21, 1 );
    const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 1, const_str_plain_cdata ); Py_INCREF( const_str_plain_cdata );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 2, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 3, const_str_plain_ocsp_data_length ); Py_INCREF( const_str_plain_ocsp_data_length );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 4, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 5, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 6, const_str_plain_ocsp_data ); Py_INCREF( const_str_plain_ocsp_data );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 7, const_str_plain_data_ptr ); Py_INCREF( const_str_plain_data_ptr );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 8, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 9, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121 = UNSTREAM_STRING( &constant_bin[ 36607 ], 51, 0 );
    const_str_plain_MODE_RELEASE_BUFFERS = UNSTREAM_STRING( &constant_bin[ 1129 ], 20, 1 );
    const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 1, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 2, const_str_plain_pysession ); Py_INCREF( const_str_plain_pysession );
    const_str_plain__passphrase_helper = UNSTREAM_STRING( &constant_bin[ 36658 ], 18, 1 );
    const_str_plain_SSL_set_tlsext_status_ocsp_resp = UNSTREAM_STRING( &constant_bin[ 36676 ], 31, 1 );
    const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 0, const_str_plain_ssl ); Py_INCREF( const_str_plain_ssl );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 1, const_str_plain_out ); Py_INCREF( const_str_plain_out );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 2, const_str_plain_outlen ); Py_INCREF( const_str_plain_outlen );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 3, const_str_plain_arg ); Py_INCREF( const_str_plain_arg );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 4, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 5, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 6, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 7, const_str_plain_protos ); Py_INCREF( const_str_plain_protos );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 8, const_str_plain_protostr ); Py_INCREF( const_str_plain_protostr );
    PyTuple_SET_ITEM( const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 9, const_str_plain_conn ); Py_INCREF( const_str_plain_conn );
    const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0 = UNSTREAM_STRING( &constant_bin[ 36707 ], 26, 0 );
    const_str_plain_SENT_SHUTDOWN = UNSTREAM_STRING( &constant_bin[ 898 ], 13, 1 );
    const_str_plain__passphrase_callback = UNSTREAM_STRING( &constant_bin[ 36733 ], 20, 1 );
    const_str_plain_SSL_export_keying_material = UNSTREAM_STRING( &constant_bin[ 36753 ], 26, 1 );
    const_str_plain_SSL_CTX_set_default_verify_paths = UNSTREAM_STRING( &constant_bin[ 36779 ], 32, 1 );
    const_str_plain_get_state_string = UNSTREAM_STRING( &constant_bin[ 36811 ], 16, 1 );
    const_str_plain_SSL_CTX_set_cipher_list = UNSTREAM_STRING( &constant_bin[ 36827 ], 23, 1 );
    const_str_plain_SSL_OP_NO_TICKET = UNSTREAM_STRING( &constant_bin[ 36850 ], 16, 1 );
    const_str_plain_ConnectionType = UNSTREAM_STRING( &constant_bin[ 289 ], 14, 1 );
    const_list_3574eb54ef4ecf6f2c0597b9df34708e_list = PyList_New( 4 );
    PyList_SET_ITEM( const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 0, const_str_plain_SSL_ST_INIT ); Py_INCREF( const_str_plain_SSL_ST_INIT );
    PyList_SET_ITEM( const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 1, const_str_plain_SSL_ST_BEFORE ); Py_INCREF( const_str_plain_SSL_ST_BEFORE );
    PyList_SET_ITEM( const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 2, const_str_plain_SSL_ST_OK ); Py_INCREF( const_str_plain_SSL_ST_OK );
    PyList_SET_ITEM( const_list_3574eb54ef4ecf6f2c0597b9df34708e_list, 3, const_str_plain_SSL_ST_RENEGOTIATE ); Py_INCREF( const_str_plain_SSL_ST_RENEGOTIATE );
    const_str_plain_SSL_OP_PKCS1_CHECK_1 = UNSTREAM_STRING( &constant_bin[ 36866 ], 20, 1 );
    const_str_plain_SSL_OP_PKCS1_CHECK_2 = UNSTREAM_STRING( &constant_bin[ 36886 ], 20, 1 );
    const_str_plain_set_shutdown = UNSTREAM_STRING( &constant_bin[ 32933 ], 12, 1 );
    const_str_plain_isfile = UNSTREAM_STRING( &constant_bin[ 36906 ], 6, 1 );
    const_str_plain_get_peer_cert_chain = UNSTREAM_STRING( &constant_bin[ 30700 ], 19, 1 );
    const_str_plain_OP_NETSCAPE_CA_DN_BUG = UNSTREAM_STRING( &constant_bin[ 1629 ], 21, 1 );
    const_str_plain_SSL_CTX_set_tmp_ecdh = UNSTREAM_STRING( &constant_bin[ 36912 ], 20, 1 );
    const_str_plain_SSL_CTX_set_timeout = UNSTREAM_STRING( &constant_bin[ 25128 ], 19, 1 );
    const_str_plain__npn_advertise_callback_args = UNSTREAM_STRING( &constant_bin[ 36932 ], 28, 1 );
    const_str_digest_8cde8912e8f2207155a1addb0752791f = UNSTREAM_STRING( &constant_bin[ 36960 ], 44, 0 );
    const_str_plain__raise_passphrase_exception = UNSTREAM_STRING( &constant_bin[ 37004 ], 27, 1 );
    const_str_digest_a94ef27b6600318cb26f98532a46ec7d = UNSTREAM_STRING( &constant_bin[ 37031 ], 122, 0 );
    const_str_plain_OP_TLS_ROLLBACK_BUG = UNSTREAM_STRING( &constant_bin[ 1563 ], 19, 1 );
    const_str_plain_SSL_CTX_set_verify_depth = UNSTREAM_STRING( &constant_bin[ 37153 ], 24, 1 );
    const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR = UNSTREAM_STRING( &constant_bin[ 37177 ], 31, 1 );
    const_str_plain_SSL_CB_WRITE_ALERT = UNSTREAM_STRING( &constant_bin[ 2237 ], 18, 1 );
    const_str_plain_get_context = UNSTREAM_STRING( &constant_bin[ 37208 ], 11, 1 );
    const_str_plain_TLSv1_2_method = UNSTREAM_STRING( &constant_bin[ 37219 ], 14, 1 );
    const_str_digest_6a85cdfe995e144af7c992d7adff36a9 = UNSTREAM_STRING( &constant_bin[ 37233 ], 289, 0 );
    const_str_plain_set_tlsext_servername_callback = UNSTREAM_STRING( &constant_bin[ 28278 ], 30, 1 );
    const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 1, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, const_str_plain_wrapper ); Py_INCREF( const_str_plain_wrapper );
    const_str_digest_b6ee2740f619fbeb4f2040d74693ca57 = UNSTREAM_STRING( &constant_bin[ 37522 ], 194, 0 );
    const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248 = UNSTREAM_STRING( &constant_bin[ 37716 ], 25, 0 );
    const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 1, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 2, const_str_plain_version ); Py_INCREF( const_str_plain_version );
    const_str_digest_f6ccda911266ccc3bb4cd038d18beb52 = UNSTREAM_STRING( &constant_bin[ 37741 ], 25, 0 );
    const_str_plain_SSL_CTX_check_private_key = UNSTREAM_STRING( &constant_bin[ 37766 ], 25, 1 );
    const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1 = UNSTREAM_STRING( &constant_bin[ 37791 ], 205, 0 );
    const_str_digest_f7bf61568f9564a7aee5354f80d84343 = UNSTREAM_STRING( &constant_bin[ 37996 ], 351, 0 );
    const_str_plain_SSL_get_client_random = UNSTREAM_STRING( &constant_bin[ 38347 ], 21, 1 );
    const_str_plain_SSL_RECEIVED_SHUTDOWN = UNSTREAM_STRING( &constant_bin[ 38368 ], 21, 1 );
    const_str_digest_3f54294273e4f6390044ae027b11e5ae = UNSTREAM_STRING( &constant_bin[ 38389 ], 150, 0 );
    const_str_plain_SSL_CB_LOOP = UNSTREAM_STRING( &constant_bin[ 2133 ], 11, 1 );
    const_str_digest_e0c534afee902e78ce11df02f380dfa7 = UNSTREAM_STRING( &constant_bin[ 38539 ], 48, 0 );
    const_str_plain_BIO_set_mem_eof_return = UNSTREAM_STRING( &constant_bin[ 38587 ], 22, 1 );
    const_str_plain_OP_NO_TICKET = UNSTREAM_STRING( &constant_bin[ 1759 ], 12, 1 );
    const_str_plain_set_tmp_ecdh = UNSTREAM_STRING( &constant_bin[ 36920 ], 12, 1 );
    const_str_digest_91c07271f44b73503e7c77deea91aef1 = UNSTREAM_STRING( &constant_bin[ 38609 ], 139, 0 );
    const_str_plain_SSL_SESSION_get_master_key = UNSTREAM_STRING( &constant_bin[ 38748 ], 26, 1 );
    const_str_plain_OP_MSIE_SSLV2_RSA_PADDING = UNSTREAM_STRING( &constant_bin[ 1387 ], 25, 1 );
    const_str_digest_770cbd653c9b65a44061ec243e0b5fd3 = UNSTREAM_STRING( &constant_bin[ 38774 ], 97, 0 );
    const_str_digest_3319904791e7df62e14d88cc362facc1 = UNSTREAM_STRING( &constant_bin[ 38871 ], 150, 0 );
    const_str_plain__CERTIFICATE_FILE_LOCATIONS = UNSTREAM_STRING( &constant_bin[ 39021 ], 27, 1 );
    const_str_digest_627e1a07a1a60af86ff9e544428f2f09 = UNSTREAM_STRING( &constant_bin[ 39048 ], 34, 0 );
    const_str_digest_f4ac5993e0eb53c16d6349308d51d30e = UNSTREAM_STRING( &constant_bin[ 39082 ], 39, 0 );
    const_str_digest_1ba1651f4266e42e9b568d28fa131281 = UNSTREAM_STRING( &constant_bin[ 39121 ], 207, 0 );
    const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5 = UNSTREAM_STRING( &constant_bin[ 39328 ], 163, 0 );
    const_str_plain_sk_X509_NAME_num = UNSTREAM_STRING( &constant_bin[ 39491 ], 16, 1 );
    const_str_plain_set_alpn_select_callback = UNSTREAM_STRING( &constant_bin[ 39507 ], 24, 1 );
    const_str_digest_149b7c0937a6a666f182d0520ebdf631 = UNSTREAM_STRING( &constant_bin[ 39531 ], 242, 0 );
    const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8 = UNSTREAM_STRING( &constant_bin[ 39773 ], 115, 0 );
    const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 1, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 2, const_str_plain_error ); Py_INCREF( const_str_plain_error );
    const_str_plain_renegotiate = UNSTREAM_STRING( &constant_bin[ 14754 ], 11, 1 );
    const_str_digest_9071118ef0006cb5d28d9100761be8e9 = UNSTREAM_STRING( &constant_bin[ 39888 ], 337, 0 );
    const_str_plain_master_key = UNSTREAM_STRING( &constant_bin[ 38764 ], 10, 1 );
    const_str_digest_0d994cfb9823ffc5647bea3454d1e646 = UNSTREAM_STRING( &constant_bin[ 40225 ], 119, 0 );
    const_str_plain_SSL_do_handshake = UNSTREAM_STRING( &constant_bin[ 40344 ], 16, 1 );
    const_str_plain_server_random = UNSTREAM_STRING( &constant_bin[ 26535 ], 13, 1 );
    const_str_plain_SSL_CTX_set_session_cache_mode = UNSTREAM_STRING( &constant_bin[ 40360 ], 30, 1 );
    const_str_plain_SSL_set_accept_state = UNSTREAM_STRING( &constant_bin[ 40390 ], 20, 1 );
    const_str_plain_sock_shutdown = UNSTREAM_STRING( &constant_bin[ 40410 ], 13, 1 );
    const_str_plain_BIO_read = UNSTREAM_STRING( &constant_bin[ 40423 ], 8, 1 );
    const_str_digest_592776beca582822ed747da68adba670 = UNSTREAM_STRING( &constant_bin[ 40431 ], 395, 0 );
    const_str_plain_X509_STORE_CTX_set_error = UNSTREAM_STRING( &constant_bin[ 40826 ], 24, 1 );
    const_str_plain_TLSEXT_STATUSTYPE_ocsp = UNSTREAM_STRING( &constant_bin[ 40850 ], 22, 1 );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_OpenSSL$SSL( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_00de5af8bcc556d3b5f411523cf5f22f;
static PyCodeObject *codeobj_cec7563bb25263789866daaecc893973;
static PyCodeObject *codeobj_116f97c7c996ca860bb0997e5690d1a7;
static PyCodeObject *codeobj_cf55bf501be28e7c7373cad88603c30e;
static PyCodeObject *codeobj_cd5d88529d58a411fd9144e06350d5f3;
static PyCodeObject *codeobj_2352c5a15d14192c9a7a25a5a1b6a81c;
static PyCodeObject *codeobj_876568a907b5dca527860ce47378562e;
static PyCodeObject *codeobj_204254c22f810b893ed5f77ec88d6f93;
static PyCodeObject *codeobj_d66630988e992039e8c615ca57600ec8;
static PyCodeObject *codeobj_bb92ca164e88d1244448eb99fa29cdfe;
static PyCodeObject *codeobj_81b26713a856ff526d48f6708e171c70;
static PyCodeObject *codeobj_317cb4b84876aa5d1575cb60d91624c5;
static PyCodeObject *codeobj_fa7b831ecbe4fb78f1e881fefdd3ba51;
static PyCodeObject *codeobj_cc5d77cb8b65c7f8f33a60eea1cc2796;
static PyCodeObject *codeobj_886a66a4ce2fa5c90a928ff54c46cf35;
static PyCodeObject *codeobj_ef30387d2b22fe29bb41f5ab3b946a84;
static PyCodeObject *codeobj_075afde1753398fa4800587279bd54f8;
static PyCodeObject *codeobj_118684193660e42e7b532200be083df8;
static PyCodeObject *codeobj_1560700e571808ac63152799e0da7758;
static PyCodeObject *codeobj_1749b0d26efcd1f0dcbb3767913140b7;
static PyCodeObject *codeobj_112a0593b8266700f63d535b5382f3e7;
static PyCodeObject *codeobj_24fd8871d29e3f8af568578862db4e2f;
static PyCodeObject *codeobj_69ff2c23544b1c72fc03755bb35fb253;
static PyCodeObject *codeobj_de53eb30beb3bfb2cf34ab422b4bde7e;
static PyCodeObject *codeobj_59384c424ee4f4c7331a4d2bae2ebb3f;
static PyCodeObject *codeobj_e64d814c39cb7a48505598e16da6bb25;
static PyCodeObject *codeobj_074a5e32739c565bb89c90a9ea0fbc5d;
static PyCodeObject *codeobj_1fd679ce963858fb95fb0f532483b704;
static PyCodeObject *codeobj_55c43580106a1e6e54d95041d3a9eb77;
static PyCodeObject *codeobj_d90925d66d5cf1b0980da015a4674b00;
static PyCodeObject *codeobj_e2e477e47ecef45d6f6b262be274a428;
static PyCodeObject *codeobj_6b208ca591bc09f3db3e2b7a669fdf49;
static PyCodeObject *codeobj_e2e44a36909f5df8646b2e1f8b0a8741;
static PyCodeObject *codeobj_85ded3b492f290b648fbd8dbdb475788;
static PyCodeObject *codeobj_7a00a7cb18c1f008e8d4f4e6d2d91473;
static PyCodeObject *codeobj_96932aa6f568d4909cbd83290f84e650;
static PyCodeObject *codeobj_cad1093edb1e34fb4531b6283b02fe19;
static PyCodeObject *codeobj_e74b0d670d825333142ebe15f0fa8d7c;
static PyCodeObject *codeobj_01faaa9c80c48cd540120e4e857f6ece;
static PyCodeObject *codeobj_c41b1a3f0450c7a475885eaa3a67dae8;
static PyCodeObject *codeobj_19e73d50ebb8a5ae5b740ae60c6415e2;
static PyCodeObject *codeobj_53861ad8ddc3409044175f205fdf735e;
static PyCodeObject *codeobj_47022de59f7f92385677b91a2a86bc8b;
static PyCodeObject *codeobj_f958b28da4ca6aab9d6b653c2268ae69;
static PyCodeObject *codeobj_32e837ccb250942a0b72b517687f5b19;
static PyCodeObject *codeobj_3601ce3f1589b8f9d54de158108a95af;
static PyCodeObject *codeobj_40161c7dc5bd3470776c2c8e35eca36d;
static PyCodeObject *codeobj_5bc5fbaf9e45b62d2dbba7be971ca669;
static PyCodeObject *codeobj_a8cab1d99611ab8877a7b8259839e592;
static PyCodeObject *codeobj_3f4dd1ce7e70d48a2f48706b38cf746b;
static PyCodeObject *codeobj_81e335f349b11a09b01d6602680546e3;
static PyCodeObject *codeobj_0bd8f781f5883f7dd44ea21f5d030f6f;
static PyCodeObject *codeobj_abe3e219ee6e1aa4dabcb63168931b9b;
static PyCodeObject *codeobj_47d32c13661b74e6d0131e9414f24fc2;
static PyCodeObject *codeobj_d929b359a62116e3db27379ddc74f6e5;
static PyCodeObject *codeobj_c825b51890ba6e544f0a67ddfa92ae8a;
static PyCodeObject *codeobj_408236438062f833e577752ad530c24f;
static PyCodeObject *codeobj_424167e2ffaae8f272268d954605a539;
static PyCodeObject *codeobj_eb42686584dbda55dff0f68021ee3d63;
static PyCodeObject *codeobj_b96d6d845ac2b66cff0a22f12fd41c93;
static PyCodeObject *codeobj_f32210b1a6041e23f6080980ed862744;
static PyCodeObject *codeobj_279a26537d72f5f735cb2f57754efcf5;
static PyCodeObject *codeobj_1fc2be28988ba2299e0f3db3940125b8;
static PyCodeObject *codeobj_be6cb0488266a27981ef336bc64c1840;
static PyCodeObject *codeobj_1b54bcdee7de522cee916ad54d2f1ede;
static PyCodeObject *codeobj_68087fd292b2546ec5a640d5c97808d9;
static PyCodeObject *codeobj_32829766e145fc1efe2f877d2ae9b983;
static PyCodeObject *codeobj_f1ff26acd5f4673b85900278fccfa353;
static PyCodeObject *codeobj_6a517aa52cd15acbda7c46151157c02c;
static PyCodeObject *codeobj_fae4a37dc5886e31059db0e90dc6bcda;
static PyCodeObject *codeobj_31c49f0051a1276b7d55df95d6624040;
static PyCodeObject *codeobj_72bb665d288c66555372d0602d766fd8;
static PyCodeObject *codeobj_a928f1b20a0225cfbe69803a6f04e72f;
static PyCodeObject *codeobj_05cf5483bca2509bcd0b3c906d201953;
static PyCodeObject *codeobj_8e722a698c7d80a26ae8e7f38e2a9516;
static PyCodeObject *codeobj_b629e495f4ca5d31617df1d720289b76;
static PyCodeObject *codeobj_992b138da987129c02121bdece9bbd42;
static PyCodeObject *codeobj_30fbf84052a7d1bcffa3c18a7999cd6f;
static PyCodeObject *codeobj_0c7560e59f4396437ef373315ed7cd5c;
static PyCodeObject *codeobj_208ce3a2e4e4eaea65e206e298e51f61;
static PyCodeObject *codeobj_5a1358d55560963927bee18bb9d8968e;
static PyCodeObject *codeobj_ce3644339e9eda748037fea603eecb61;
static PyCodeObject *codeobj_f6837856edf570e4bd43a28f747a059d;
static PyCodeObject *codeobj_04f440036e2b2c35459569a981c6b41b;
static PyCodeObject *codeobj_250a4ae7f401cdf63a568e77d373460c;
static PyCodeObject *codeobj_92150b73fda83014548edff967541a31;
static PyCodeObject *codeobj_6e82bf48752d997d2ba9c4cb6ca57dc0;
static PyCodeObject *codeobj_47a8b871086e72be9e62b12178457475;
static PyCodeObject *codeobj_f362b683cf087e1099fdf014aa93bacd;
static PyCodeObject *codeobj_f07b4d307d82823816d3b33cd173a678;
static PyCodeObject *codeobj_4595e7f22fd27934c99d0779b3a36d8a;
static PyCodeObject *codeobj_79fd12729a50896c6b068d07adf12958;
static PyCodeObject *codeobj_caafd991eb739c67f9b0132a1e25e9b3;
static PyCodeObject *codeobj_1f9c33e10eab708a76d6954065cc1282;
static PyCodeObject *codeobj_2cb565234df87e31bd5093a06c903ab0;
static PyCodeObject *codeobj_f7131a7728aa55e97242ea844954e2d3;
static PyCodeObject *codeobj_bcacbcc345964cd40d55a8ded45cab48;
static PyCodeObject *codeobj_c84e069d6460014d6980972db9133002;
static PyCodeObject *codeobj_9c360624a33744b74644bf01d1e328dc;
static PyCodeObject *codeobj_355fcfa300882710f491f60c8724e180;
static PyCodeObject *codeobj_292c28a762938b6a8045d2808b664ec1;
static PyCodeObject *codeobj_5411f7a0e5a468d33cbabda972ebdebe;
static PyCodeObject *codeobj_276464dd595899f2dceb721f57191727;
static PyCodeObject *codeobj_df9b0f7b3f68a04bf8de49673c90bc52;
static PyCodeObject *codeobj_0a78b45fe82072741d967a7116be55e3;
static PyCodeObject *codeobj_e718cae76ed96e3a285678549a1a9741;
static PyCodeObject *codeobj_0197cdd72b2974669ab0cb1f129cf2f4;
static PyCodeObject *codeobj_84be2e2654ef2638907dd2c10cb860ec;
static PyCodeObject *codeobj_4a87892876c4589d9c9a13b1feca9117;
static PyCodeObject *codeobj_62907623253c538bdf755fd12f970dd3;
static PyCodeObject *codeobj_80da3cb70b526050748feefac39aa753;
static PyCodeObject *codeobj_3c210d5bc83108fc5f8b8621b4b96e97;
static PyCodeObject *codeobj_7594156bee4df5719976741b68595a11;
static PyCodeObject *codeobj_f89df5132055bf6ccda906b72a60bfc3;
static PyCodeObject *codeobj_a10c241273a2cfd5b8ca6cac4d75c1bf;
static PyCodeObject *codeobj_05a1faeaf48c61a421aaa55c489d7360;
static PyCodeObject *codeobj_41c71643654412e463e2e01067134703;
static PyCodeObject *codeobj_655c4c817ba68f8293b5e5f773a9c3b6;
static PyCodeObject *codeobj_0f658e91b4d3f853eeaf63330d1f8c09;
static PyCodeObject *codeobj_02c1cad644039385b8a3726221761ce2;
static PyCodeObject *codeobj_f5158618828ea79b360b2b4d785102df;
static PyCodeObject *codeobj_952cfd5b63ecd1dd4f987c147c539d39;
static PyCodeObject *codeobj_4f2247f2b870626a6f520ab00ca5767f;
static PyCodeObject *codeobj_8676d0373d5f8b05f118b297b9bb18ac;
static PyCodeObject *codeobj_ff5454a954382e81b4077a213567d6a1;
static PyCodeObject *codeobj_162a5a1926e2d87c5196f76de69fc199;
static PyCodeObject *codeobj_84469bc26b1b18a7587749a007b2f9d0;
static PyCodeObject *codeobj_d2ee4bcf609725335171733079f6b33c;
static PyCodeObject *codeobj_ab7c6851b751f003fc9405d2a2e9ea43;
static PyCodeObject *codeobj_e318d411854900096ecb90aa4ea274a9;
static PyCodeObject *codeobj_990bffb794119d86150b99fa6491e939;
static PyCodeObject *codeobj_f026f64ff0ca0abcc464653172e19868;

static void createModuleCodeObjects(void)
{
    module_filename_obj = const_str_digest_3284a0d54b2aa35ff31d3f6e48d74aec;
    codeobj_00de5af8bcc556d3b5f411523cf5f22f = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 353, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_cec7563bb25263789866daaecc893973 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 696, const_tuple_b5f59418c193d572a22cf854b821fa76_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_116f97c7c996ca860bb0997e5690d1a7 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 1448, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cf55bf501be28e7c7373cad88603c30e = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 2460, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_p_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cd5d88529d58a411fd9144e06350d5f3 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_a8ac54b3ed8845d56dee411b1beed5c2, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_2352c5a15d14192c9a7a25a5a1b6a81c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Connection, 1537, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_876568a907b5dca527860ce47378562e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Context, 679, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_204254c22f810b893ed5f77ec88d6f93 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_SSLeay_version, 622, const_tuple_str_plain_type_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d66630988e992039e8c615ca57600ec8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getattr__, 1596, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bb92ca164e88d1244448eb99fa29cdfe = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 281, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_81b26713a856ff526d48f6708e171c70 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 303, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_317cb4b84876aa5d1575cb60d91624c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 341, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fa7b831ecbe4fb78f1e881fefdd3ba51 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 382, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cc5d77cb8b65c7f8f33a60eea1cc2796 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 431, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_886a66a4ce2fa5c90a928ff54c46cf35 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 499, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ef30387d2b22fe29bb41f5ab3b946a84 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 566, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_075afde1753398fa4800587279bd54f8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 700, const_tuple_62a32d899dc1fe37f6d326f7d9a44911_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_118684193660e42e7b532200be083df8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1542, const_tuple_7c3b7701dcc867dc417afc0b7dd18be0_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1560700e571808ac63152799e0da7758 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__asFileDescriptor, 603, const_tuple_str_plain_obj_str_plain_fd_str_plain_meth_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1749b0d26efcd1f0dcbb3767913140b7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__check_env_vars_set, 862, const_tuple_str_plain_self_str_plain_dir_env_var_str_plain_file_env_var_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_112a0593b8266700f63d535b5382f3e7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__fallback_default_verify_paths, 873, const_tuple_e3219c972e1d9320fe91a603e3df8d39_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_24fd8871d29e3f8af568578862db4e2f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_finished_message, 2298, const_tuple_fdf14ad5fcee8ba941991b04122d5521_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_69ff2c23544b1c72fc03755bb35fb253 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__handle_bio_errors, 1832, const_tuple_str_plain_self_str_plain_bio_str_plain_result_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_de53eb30beb3bfb2cf34ab422b4bde7e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__make_requires, 631, const_tuple_str_plain_flag_str_plain_error_str_plain__requires_decorator_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_59384c424ee4f4c7331a4d2bae2ebb3f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__raise_passphrase_exception, 963, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e64d814c39cb7a48505598e16da6bb25 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__raise_ssl_error, 1608, const_tuple_e7183725d38a187a36c7befeae938036_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_074a5e32739c565bb89c90a9ea0fbc5d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__requires_decorator, 641, const_tuple_str_plain_func_str_plain_explode_str_plain_flag_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_1fd679ce963858fb95fb0f532483b704 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_ocsp_callback, 1472, const_tuple_str_plain_self_str_plain_helper_str_plain_data_str_plain_rc_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_55c43580106a1e6e54d95041d3a9eb77 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__wrap_callback, 778, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d90925d66d5cf1b0980da015a4674b00 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_accept, 1962, const_tuple_72afa5cdf95db9f073bb963f13be50a9_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e2e477e47ecef45d6f6b262be274a428 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_client_ca, 1239, const_tuple_a13720a5c6ce612466cecad70ab66e75_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6b208ca591bc09f3db3e2b7a669fdf49 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_extra_chain_cert, 946, const_tuple_711d722f51d6d6accf419f2bb9aeb5b5_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e2e44a36909f5df8646b2e1f8b0a8741 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bio_read, 1850, const_tuple_0070fc91ecaec455401a06d1a7f4f5e8_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_85ded3b492f290b648fbd8dbdb475788 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bio_shutdown, 1977, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7a00a7cb18c1f008e8d4f4e6d2d91473 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bio_write, 1874, const_tuple_str_plain_self_str_plain_buf_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_96932aa6f568d4909cbd83290f84e650 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_check_privatekey, 1006, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cad1093edb1e34fb4531b6283b02fe19 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_client_random, 2122, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e74b0d670d825333142ebe15f0fa8d7c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_connect, 1936, const_tuple_str_plain_self_str_plain_addr_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_01faaa9c80c48cd540120e4e857f6ece = MAKE_CODEOBJ( module_filename_obj, const_str_plain_connect_ex, 1948, const_tuple_str_plain_self_str_plain_addr_str_plain_connect_ex_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c41b1a3f0450c7a475885eaa3a67dae8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_do_handshake, 1906, const_tuple_str_plain_self_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_19e73d50ebb8a5ae5b740ae60c6415e2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_explode, 643, const_tuple_str_plain_args_str_plain_kwargs_str_plain_error_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS );
    codeobj_53861ad8ddc3409044175f205fdf735e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_export_keying_material, 2154, const_tuple_24e396011cc987e1c1e91fc8d67969c7_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_47022de59f7f92385677b91a2a86bc8b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_alpn_proto_negotiated, 2468, const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f958b28da4ca6aab9d6b653c2268ae69 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_app_data, 1301, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_32e837ccb250942a0b72b517687f5b19 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_app_data, 2060, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3601ce3f1589b8f9d54de158108a95af = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cert_store, 1318, const_tuple_str_plain_self_str_plain_pystore_str_plain_store_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_40161c7dc5bd3470776c2c8e35eca36d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_certificate, 2187, const_tuple_str_plain_self_str_plain_cert_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5bc5fbaf9e45b62d2dbba7be971ca669 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_bits, 2373, const_tuple_str_plain_self_str_plain_cipher_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a8cab1d99611ab8877a7b8259839e592 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_list, 2007, const_tuple_12babed94f04a9287de33a0a7ed4bbf2_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3f4dd1ce7e70d48a2f48706b38cf746b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_name, 2356, const_tuple_str_plain_self_str_plain_cipher_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_81e335f349b11a09b01d6602680546e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_cipher_version, 2389, const_tuple_str_plain_self_str_plain_cipher_str_plain_version_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0bd8f781f5883f7dd44ea21f5d030f6f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_client_ca_list, 2021, const_tuple_40c019df00fadc68e051d5153056e038_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_abe3e219ee6e1aa4dabcb63168931b9b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_context, 1649, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_47d32c13661b74e6d0131e9414f24fc2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_finished, 2332, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d929b359a62116e3db27379ddc74f6e5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_next_proto_negotiated, 2429, const_tuple_str_plain_self_str_plain_data_len_str_plain_data_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c825b51890ba6e544f0a67ddfa92ae8a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_peer_cert_chain, 2210, const_tuple_1bf74246b679aacbbc5982cad038a099_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_408236438062f833e577752ad530c24f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_peer_certificate, 2199, const_tuple_str_plain_self_str_plain_cert_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_424167e2ffaae8f272268d954605a539 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_peer_finished, 2344, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eb42686584dbda55dff0f68021ee3d63 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_protocol_version, 2418, const_tuple_str_plain_self_str_plain_version_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b96d6d845ac2b66cff0a22f12fd41c93 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_protocol_version_name, 2406, const_tuple_str_plain_self_str_plain_version_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f32210b1a6041e23f6080980ed862744 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_servername, 1669, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_279a26537d72f5f735cb2f57754efcf5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_session, 2265, const_tuple_str_plain_self_str_plain_session_str_plain_pysession_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1fc2be28988ba2299e0f3db3940125b8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_session_cache_mode, 1068, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_be6cb0488266a27981ef336bc64c1840 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_shutdown, 2077, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1b54bcdee7de522cee916ad54d2f1ede = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_state_string, 2098, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_68087fd292b2546ec5a640d5c97808d9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_timeout, 1273, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_32829766e145fc1efe2f877d2ae9b983 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_verify_depth, 1129, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f1ff26acd5f4673b85900278fccfa353 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_verify_mode, 1120, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6a517aa52cd15acbda7c46151157c02c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_client_ca, 1016, const_tuple_str_plain_self_str_plain_cafile_str_plain_ca_list_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fae4a37dc5886e31059db0e90dc6bcda = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_tmp_dh, 1138, const_tuple_str_plain_self_str_plain_dhfile_str_plain_bio_str_plain_dh_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_31c49f0051a1276b7d55df95d6624040 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_verify_locations, 746, const_tuple_6f3d7ce791b29c8b2ccceca21130b973_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_72bb665d288c66555372d0602d766fd8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_makefile, 2050, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_a928f1b20a0225cfbe69803a6f04e72f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_master_key, 2138, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_05cf5483bca2509bcd0b3c906d201953 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pending, 1704, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8e722a698c7d80a26ae8e7f38e2a9516 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_raise_if_problem, 284, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b629e495f4ca5d31617df1d720289b76 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recv, 1777, const_tuple_ddbbebd3154d4430c5c187b2eaf912ed_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_992b138da987129c02121bdece9bbd42 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recv_into, 1795, const_tuple_a67b1154f8342873401b8122b6389ba8_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_30fbf84052a7d1bcffa3c18a7999cd6f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_renegotiate, 1894, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0c7560e59f4396437ef373315ed7cd5c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_renegotiate_pending, 1917, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_208ce3a2e4e4eaea65e206e298e51f61 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_request_ocsp, 2486, const_tuple_str_plain_self_str_plain_rc_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5a1358d55560963927bee18bb9d8968e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_send, 1713, const_tuple_59ab6bd6bf9c850fdd6c5d8aae933618_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ce3644339e9eda748037fea603eecb61 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sendall, 1741, const_tuple_27b415f5f1545c164c69e92aa878cdf0_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f6837856edf570e4bd43a28f747a059d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_server_random, 2107, const_tuple_5a901cf5390bbd925e09951ee9017d23_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_04f440036e2b2c35459569a981c6b41b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_accept_state, 2247, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_250a4ae7f401cdf63a568e77d373460c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_alpn_protos, 1434, const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_92150b73fda83014548edff967541a31 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_alpn_protos, 2446, const_tuple_cf035770f08c8746b05138973d8b64b8_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6e82bf48752d997d2ba9c4cb6ca57dc0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_alpn_select_callback, 1456, const_tuple_str_plain_self_str_plain_callback_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_47a8b871086e72be9e62b12178457475 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_app_data, 1309, const_tuple_str_plain_self_str_plain_data_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f362b683cf087e1099fdf014aa93bacd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_app_data, 2068, const_tuple_str_plain_self_str_plain_data_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f07b4d307d82823816d3b33cd173a678 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_cipher_list, 1170, const_tuple_str_plain_self_str_plain_cipher_list_str_plain_tmpconn_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4595e7f22fd27934c99d0779b3a36d8a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_client_ca_list, 1202, const_tuple_2fe4e23a8c490304baac2b73b87c6ea5_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_79fd12729a50896c6b068d07adf12958 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_connect_state, 2256, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_caafd991eb739c67f9b0132a1e25e9b3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_context, 1656, const_tuple_str_plain_self_str_plain_context_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1f9c33e10eab708a76d6954065cc1282 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_default_verify_paths, 813, const_tuple_20d4fe6eb6129b69f70ca0570507a3f9_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2cb565234df87e31bd5093a06c903ab0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_info_callback, 1282, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f7131a7728aa55e97242ea844954e2d3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_mode, 1348, const_tuple_str_plain_self_str_plain_mode_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bcacbcc345964cd40d55a8ded45cab48 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_npn_advertise_callback, 1397, const_tuple_str_plain_self_str_plain_callback_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c84e069d6460014d6980972db9133002 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_npn_select_callback, 1416, const_tuple_str_plain_self_str_plain_callback_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9c360624a33744b74644bf01d1e328dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_ocsp_client_callback, 1510, const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_355fcfa300882710f491f60c8724e180 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_ocsp_server_callback, 1492, const_tuple_09a9274d23abfb5c21510ecab74e4636_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_292c28a762938b6a8045d2808b664ec1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_options, 1335, const_tuple_str_plain_self_str_plain_options_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5411f7a0e5a468d33cbabda972ebdebe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_passwd_cb, 785, const_tuple_str_plain_self_str_plain_callback_str_plain_userdata_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_276464dd595899f2dceb721f57191727 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_session, 2282, const_tuple_str_plain_self_str_plain_session_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_df9b0f7b3f68a04bf8de49673c90bc52 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_session_cache_mode, 1051, const_tuple_str_plain_self_str_plain_mode_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0a78b45fe82072741d967a7116be55e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_session_id, 1031, const_tuple_str_plain_self_str_plain_buf_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e718cae76ed96e3a285678549a1a9741 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_shutdown, 2086, const_tuple_str_plain_self_str_plain_state_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0197cdd72b2974669ab0cb1f129cf2f4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_timeout, 1259, const_tuple_str_plain_self_str_plain_timeout_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_84be2e2654ef2638907dd2c10cb860ec = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tlsext_host_name, 1687, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4a87892876c4589d9c9a13b1feca9117 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tlsext_servername_callback, 1361, const_tuple_str_plain_self_str_plain_callback_str_plain_wrapper_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_62907623253c538bdf755fd12f970dd3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tlsext_use_srtp, 1382, const_tuple_str_plain_self_str_plain_profiles_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_80da3cb70b526050748feefac39aa753 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_tmp_ecdh, 1158, const_tuple_str_plain_self_str_plain_curve_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3c210d5bc83108fc5f8b8621b4b96e97 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_verify, 1078, const_tuple_str_plain_self_str_plain_mode_str_plain_callback_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7594156bee4df5719976741b68595a11 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_verify_depth, 1107, const_tuple_str_plain_self_str_plain_depth_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f89df5132055bf6ccda906b72a60bfc3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shutdown, 1990, const_tuple_str_plain_self_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a10c241273a2cfd5b8ca6cac4d75c1bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sock_shutdown, 2178, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_05a1faeaf48c61a421aaa55c489d7360 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_total_renegotiations, 1927, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_41c71643654412e463e2e01067134703 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_certificate, 932, const_tuple_str_plain_self_str_plain_cert_str_plain_use_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_655c4c817ba68f8293b5e5f773a9c3b6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_certificate_chain_file, 893, const_tuple_str_plain_self_str_plain_certfile_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0f658e91b4d3f853eeaf63330d1f8c09 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_certificate_file, 910, const_tuple_70adcf8f254ece362639433ee96fdafb_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_02c1cad644039385b8a3726221761ce2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_privatekey, 992, const_tuple_str_plain_self_str_plain_pkey_str_plain_use_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f5158618828ea79b360b2b4d785102df = MAKE_CODEOBJ( module_filename_obj, const_str_plain_use_privatekey_file, 969, const_tuple_70b3e830bf27ee786cecd70f5eebc82a_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_952cfd5b63ecd1dd4f987c147c539d39 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_want_read, 2229, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4f2247f2b870626a6f520ab00ca5767f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_want_write, 2238, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8676d0373d5f8b05f118b297b9bb18ac = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 306, const_tuple_fb64e812782e9f70f19909e310070a01_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_ff5454a954382e81b4077a213567d6a1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 344, const_tuple_22496b7900b49af1635f455cd8f3e9ef_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_162a5a1926e2d87c5196f76de69fc199 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 385, const_tuple_6740a501bdf22f33fca4ec6a09ab8a62_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_84469bc26b1b18a7587749a007b2f9d0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 434, const_tuple_8f082d20432d2aa73d41a80627094b27_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_d2ee4bcf609725335171733079f6b33c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 502, const_tuple_f85e0b49580abdb5d9ebc1ace31ffe3d_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_ab7c6851b751f003fc9405d2a2e9ea43 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 569, const_tuple_617fe238ea11ea0890ce2460de3bd68e_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_e318d411854900096ecb90aa4ea274a9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 779, const_tuple_3ac1ec4ea6ba07372fe57d858ff0148f_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_990bffb794119d86150b99fa6491e939 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 1294, const_tuple_78e460fdd8266d432328f4bff5207c29_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_f026f64ff0ca0abcc464653172e19868 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrapper, 1372, const_tuple_7e6126bff16a8a76a713850dcb042242_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS );
}

// The module function declarations.
static PyObject *OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_maker( void );


static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_maker( void );


static PyObject *OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_maker( void );


static PyObject *OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_maker( void );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_100_set_connect_state(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_101_get_session(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_102_set_session(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_103__get_finished_message(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_finished(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_peer_finished(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_bits(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_cipher_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_10_SSLeay_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_110_get_protocol_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_next_proto_negotiated(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_112_set_alpn_protos(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_114_request_ocsp(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_13_load_verify_locations( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_15_set_passwd_cb( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_16_set_default_verify_paths(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_17__check_env_vars_set(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_18__fallback_default_verify_paths(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate_chain_file(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_20_use_certificate_file( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_21_use_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_22_add_extra_chain_cert(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_23__raise_passphrase_exception(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_24_use_privatekey_file( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_25_use_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_26_check_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_27_load_client_ca(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_28_set_session_id(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_session_cache_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_30_get_session_cache_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_31_set_verify(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_32_set_verify_depth(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_33_get_verify_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_34_get_verify_depth(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_35_load_tmp_dh(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_tmp_ecdh(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_37_set_cipher_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_client_ca_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_39_add_client_ca(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_timeout(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_get_timeout(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_43_get_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_44_set_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_45_get_cert_store(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_options(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_mode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_npn_advertise_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_51_set_npn_select_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_alpn_protos(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_alpn_select_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_54__set_ocsp_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_55_set_ocsp_server_callback( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_56_set_ocsp_client_callback( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_57___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_58___getattr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_59__raise_ssl_error(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_60_get_context(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_61_set_context(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_62_get_servername(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_63_set_tlsext_host_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_64_pending(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_65_send( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_66_sendall( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_67_recv( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_68_recv_into( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_69__handle_bio_errors(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_70_bio_read(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_71_bio_write(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_72_renegotiate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_73_do_handshake(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_74_renegotiate_pending(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_75_total_renegotiations(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_76_connect(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_77_connect_ex(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_78_accept(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_79_bio_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_80_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_cipher_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_82_get_client_ca_list(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_83_makefile(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_84_get_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_85_set_app_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_86_get_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_87_set_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_88_get_state_string(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_89_server_random(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_90_client_random(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_91_master_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_92_export_keying_material( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_93_sock_shutdown(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_peer_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_96_get_peer_cert_chain(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_read(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_98_want_write(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_accept_state(  );


static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__asFileDescriptor(  );


// The module function definitions.
static PyObject *impl_OpenSSL$SSL$$$function_1___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_bb92ca164e88d1244448eb99fa29cdfe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bb92ca164e88d1244448eb99fa29cdfe = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bb92ca164e88d1244448eb99fa29cdfe, codeobj_bb92ca164e88d1244448eb99fa29cdfe, module_OpenSSL$SSL, sizeof(void *) );
    frame_bb92ca164e88d1244448eb99fa29cdfe = cache_frame_bb92ca164e88d1244448eb99fa29cdfe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bb92ca164e88d1244448eb99fa29cdfe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bb92ca164e88d1244448eb99fa29cdfe ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = PyList_New( 0 );
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__problems, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 282;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb92ca164e88d1244448eb99fa29cdfe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb92ca164e88d1244448eb99fa29cdfe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bb92ca164e88d1244448eb99fa29cdfe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bb92ca164e88d1244448eb99fa29cdfe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bb92ca164e88d1244448eb99fa29cdfe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bb92ca164e88d1244448eb99fa29cdfe,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_bb92ca164e88d1244448eb99fa29cdfe == cache_frame_bb92ca164e88d1244448eb99fa29cdfe )
    {
        Py_DECREF( frame_bb92ca164e88d1244448eb99fa29cdfe );
    }
    cache_frame_bb92ca164e88d1244448eb99fa29cdfe = NULL;

    assertFrameObject( frame_bb92ca164e88d1244448eb99fa29cdfe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_1___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_1___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_2_raise_if_problem( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8e722a698c7d80a26ae8e7f38e2a9516;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8e722a698c7d80a26ae8e7f38e2a9516 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8e722a698c7d80a26ae8e7f38e2a9516, codeobj_8e722a698c7d80a26ae8e7f38e2a9516, module_OpenSSL$SSL, sizeof(void *) );
    frame_8e722a698c7d80a26ae8e7f38e2a9516 = cache_frame_8e722a698c7d80a26ae8e7f38e2a9516;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8e722a698c7d80a26ae8e7f38e2a9516 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8e722a698c7d80a26ae8e7f38e2a9516 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__problems );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 289;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 289;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 291;
                type_description_1 = "o";
                goto try_except_handler_2;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            frame_8e722a698c7d80a26ae8e7f38e2a9516->m_frame.f_lineno = 291;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 291;
                type_description_1 = "o";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION( frame_8e722a698c7d80a26ae8e7f38e2a9516 );
        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_8e722a698c7d80a26ae8e7f38e2a9516, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_8e722a698c7d80a26ae8e7f38e2a9516, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_mvar_value_2;
            tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
                exception_tb = NULL;

                exception_lineno = 292;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_1 = tmp_mvar_value_2;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 292;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 292;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 290;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_8e722a698c7d80a26ae8e7f38e2a9516->m_frame) frame_8e722a698c7d80a26ae8e7f38e2a9516->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "o";
            goto frame_exception_exit_1;
            branch_no_2:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_2_raise_if_problem );
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__problems );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 294;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_8e722a698c7d80a26ae8e7f38e2a9516->m_frame.f_lineno = 294;
            tmp_raise_type_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_pop, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 294;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 294;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8e722a698c7d80a26ae8e7f38e2a9516 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8e722a698c7d80a26ae8e7f38e2a9516 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8e722a698c7d80a26ae8e7f38e2a9516, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8e722a698c7d80a26ae8e7f38e2a9516->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8e722a698c7d80a26ae8e7f38e2a9516, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8e722a698c7d80a26ae8e7f38e2a9516,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8e722a698c7d80a26ae8e7f38e2a9516 == cache_frame_8e722a698c7d80a26ae8e7f38e2a9516 )
    {
        Py_DECREF( frame_8e722a698c7d80a26ae8e7f38e2a9516 );
    }
    cache_frame_8e722a698c7d80a26ae8e7f38e2a9516 = NULL;

    assertFrameObject( frame_8e722a698c7d80a26ae8e7f38e2a9516 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_2_raise_if_problem );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_2_raise_if_problem );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_3___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_81b26713a856ff526d48f6708e171c70;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_81b26713a856ff526d48f6708e171c70 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81b26713a856ff526d48f6708e171c70, codeobj_81b26713a856ff526d48f6708e171c70, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_81b26713a856ff526d48f6708e171c70 = cache_frame_81b26713a856ff526d48f6708e171c70;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81b26713a856ff526d48f6708e171c70 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81b26713a856ff526d48f6708e171c70 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 304;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_1 = PyCell_GET( par_self );
        frame_81b26713a856ff526d48f6708e171c70->m_frame.f_lineno = 304;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 304;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 306;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_2 = PyCell_GET( par_callback );
        frame_81b26713a856ff526d48f6708e171c70->m_frame.f_lineno = 306;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 306;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] );


        frame_81b26713a856ff526d48f6708e171c70->m_frame.f_lineno = 306;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 306;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 332;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_aa8d23211c54bc521e23e53a6e431cd2;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_5 = var_wrapper;
        frame_81b26713a856ff526d48f6708e171c70->m_frame.f_lineno = 332;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 332;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_assattr_target_1 = PyCell_GET( par_self );
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 332;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81b26713a856ff526d48f6708e171c70 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81b26713a856ff526d48f6708e171c70 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81b26713a856ff526d48f6708e171c70, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81b26713a856ff526d48f6708e171c70->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81b26713a856ff526d48f6708e171c70, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_81b26713a856ff526d48f6708e171c70,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_81b26713a856ff526d48f6708e171c70 == cache_frame_81b26713a856ff526d48f6708e171c70 )
    {
        Py_DECREF( frame_81b26713a856ff526d48f6708e171c70 );
    }
    cache_frame_81b26713a856ff526d48f6708e171c70 = NULL;

    assertFrameObject( frame_81b26713a856ff526d48f6708e171c70 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ok = python_pars[ 0 ];
    PyObject *par_store_ctx = python_pars[ 1 ];
    PyObject *var_index = NULL;
    PyObject *var_error_number = NULL;
    PyObject *var_x509 = NULL;
    PyObject *var_connection = NULL;
    PyObject *var_ssl = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_result = NULL;
    PyObject *var_error_depth = NULL;
    PyObject *var_e = NULL;
    struct Nuitka_FrameObject *frame_8676d0373d5f8b05f118b297b9bb18ac;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8676d0373d5f8b05f118b297b9bb18ac = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8676d0373d5f8b05f118b297b9bb18ac, codeobj_8676d0373d5f8b05f118b297b9bb18ac, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8676d0373d5f8b05f118b297b9bb18ac = cache_frame_8676d0373d5f8b05f118b297b9bb18ac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8676d0373d5f8b05f118b297b9bb18ac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8676d0373d5f8b05f118b297b9bb18ac ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 308;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_store_ctx );
        tmp_args_element_name_1 = par_store_ctx;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 308;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_STORE_CTX_get_current_cert, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 308;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert( var_x509 == NULL );
        var_x509 = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 309;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_x509 );
        tmp_args_element_name_2 = var_x509;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 309;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509_up_ref, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 309;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 310;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_3;
        CHECK_OBJECT( var_x509 );
        tmp_args_element_name_3 = var_x509;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 310;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__from_raw_x509_ptr, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 310;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert( var_cert == NULL );
        var_cert = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 311;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_4;
        CHECK_OBJECT( par_store_ctx );
        tmp_args_element_name_4 = par_store_ctx;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 311;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_X509_STORE_CTX_get_error, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert( var_error_number == NULL );
        var_error_number = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 312;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_5 = tmp_mvar_value_5;
        CHECK_OBJECT( par_store_ctx );
        tmp_args_element_name_5 = par_store_ctx;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 312;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_X509_STORE_CTX_get_error_depth, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 312;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert( var_error_depth == NULL );
        var_error_depth = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 314;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_6 = tmp_mvar_value_6;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 314;
        tmp_assign_source_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_SSL_get_ex_data_X509_STORE_CTX_idx );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 314;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert( var_index == NULL );
        var_index = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 315;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_7 = tmp_mvar_value_7;
        CHECK_OBJECT( par_store_ctx );
        tmp_args_element_name_6 = par_store_ctx;
        CHECK_OBJECT( var_index );
        tmp_args_element_name_7 = var_index;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 315;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_7, const_str_plain_X509_STORE_CTX_get_ex_data, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 315;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert( var_ssl == NULL );
        var_ssl = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 316;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_8;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 316;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ssl );
        tmp_subscript_name_1 = var_ssl;
        tmp_assign_source_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 316;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        assert( var_connection == NULL );
        var_connection = tmp_assign_source_7;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 319;
            type_description_1 = "oooococoooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( var_connection );
        tmp_args_element_name_8 = var_connection;
        CHECK_OBJECT( var_cert );
        tmp_args_element_name_9 = var_cert;
        CHECK_OBJECT( var_error_number );
        tmp_args_element_name_10 = var_error_number;
        CHECK_OBJECT( var_error_depth );
        tmp_args_element_name_11 = var_error_depth;
        CHECK_OBJECT( par_ok );
        tmp_args_element_name_12 = par_ok;
        frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 319;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS5( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;
            type_description_1 = "oooococoooooo";
            goto try_except_handler_2;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_8;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_8676d0373d5f8b05f118b297b9bb18ac );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_8676d0373d5f8b05f118b297b9bb18ac, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_8676d0373d5f8b05f118b297b9bb18ac, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 322;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_9;
            tmp_assign_source_9 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_9 );
            var_e = tmp_assign_source_9;
        }
        {
            PyObject *tmp_called_instance_8;
            PyObject *tmp_source_name_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_13;
            if ( PyCell_GET( self->m_closure[1] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                exception_tb = NULL;

                exception_lineno = 323;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = PyCell_GET( self->m_closure[1] );
            tmp_called_instance_8 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__problems );
            if ( tmp_called_instance_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 323;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_e );
            tmp_args_element_name_13 = var_e;
            frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 323;
            {
                PyObject *call_args[] = { tmp_args_element_name_13 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_append, call_args );
            }

            Py_DECREF( tmp_called_instance_8 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 323;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        tmp_return_value = const_int_0;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 318;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame) frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooococoooooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_result );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_result );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 326;
            type_description_1 = "oooococoooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_14;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_9;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_STORE_CTX_set_error );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_store_ctx );
            tmp_args_element_name_14 = par_store_ctx;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_10 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_10;
            tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_V_OK );
            if ( tmp_args_element_name_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame.f_lineno = 327;
            {
                PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_15 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 327;
                type_description_1 = "oooococoooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        tmp_return_value = const_int_pos_1;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_return_value = const_int_0;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_end_2:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8676d0373d5f8b05f118b297b9bb18ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_8676d0373d5f8b05f118b297b9bb18ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_8676d0373d5f8b05f118b297b9bb18ac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8676d0373d5f8b05f118b297b9bb18ac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8676d0373d5f8b05f118b297b9bb18ac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8676d0373d5f8b05f118b297b9bb18ac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8676d0373d5f8b05f118b297b9bb18ac,
        type_description_1,
        par_ok,
        par_store_ctx,
        var_index,
        var_error_number,
        self->m_closure[0],
        var_x509,
        self->m_closure[1],
        var_connection,
        var_ssl,
        var_cert,
        var_result,
        var_error_depth,
        var_e
    );


    // Release cached frame.
    if ( frame_8676d0373d5f8b05f118b297b9bb18ac == cache_frame_8676d0373d5f8b05f118b297b9bb18ac )
    {
        Py_DECREF( frame_8676d0373d5f8b05f118b297b9bb18ac );
    }
    cache_frame_8676d0373d5f8b05f118b297b9bb18ac = NULL;

    assertFrameObject( frame_8676d0373d5f8b05f118b297b9bb18ac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_index );
    Py_DECREF( var_index );
    var_index = NULL;

    CHECK_OBJECT( (PyObject *)var_error_number );
    Py_DECREF( var_error_number );
    var_error_number = NULL;

    CHECK_OBJECT( (PyObject *)par_ok );
    Py_DECREF( par_ok );
    par_ok = NULL;

    CHECK_OBJECT( (PyObject *)var_x509 );
    Py_DECREF( var_x509 );
    var_x509 = NULL;

    CHECK_OBJECT( (PyObject *)var_connection );
    Py_DECREF( var_connection );
    var_connection = NULL;

    CHECK_OBJECT( (PyObject *)var_ssl );
    Py_DECREF( var_ssl );
    var_ssl = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)var_error_depth );
    Py_DECREF( var_error_depth );
    var_error_depth = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_store_ctx );
    Py_DECREF( par_store_ctx );
    par_store_ctx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_index );
    var_index = NULL;

    Py_XDECREF( var_error_number );
    var_error_number = NULL;

    CHECK_OBJECT( (PyObject *)par_ok );
    Py_DECREF( par_ok );
    par_ok = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    Py_XDECREF( var_connection );
    var_connection = NULL;

    Py_XDECREF( var_ssl );
    var_ssl = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_error_depth );
    var_error_depth = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_store_ctx );
    Py_DECREF( par_store_ctx );
    par_store_ctx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_4___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_317cb4b84876aa5d1575cb60d91624c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_317cb4b84876aa5d1575cb60d91624c5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_317cb4b84876aa5d1575cb60d91624c5, codeobj_317cb4b84876aa5d1575cb60d91624c5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_317cb4b84876aa5d1575cb60d91624c5 = cache_frame_317cb4b84876aa5d1575cb60d91624c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_317cb4b84876aa5d1575cb60d91624c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_317cb4b84876aa5d1575cb60d91624c5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 342;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_1 = PyCell_GET( par_self );
        frame_317cb4b84876aa5d1575cb60d91624c5->m_frame.f_lineno = 342;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 342;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 344;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_2 = PyCell_GET( par_callback );
        frame_317cb4b84876aa5d1575cb60d91624c5->m_frame.f_lineno = 344;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 344;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] );


        frame_317cb4b84876aa5d1575cb60d91624c5->m_frame.f_lineno = 344;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 344;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 371;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_b6f7e6068b1690fa00ff377454fad5cf;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_5 = var_wrapper;
        frame_317cb4b84876aa5d1575cb60d91624c5->m_frame.f_lineno = 371;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_assattr_target_1 = PyCell_GET( par_self );
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_317cb4b84876aa5d1575cb60d91624c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_317cb4b84876aa5d1575cb60d91624c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_317cb4b84876aa5d1575cb60d91624c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_317cb4b84876aa5d1575cb60d91624c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_317cb4b84876aa5d1575cb60d91624c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_317cb4b84876aa5d1575cb60d91624c5,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_317cb4b84876aa5d1575cb60d91624c5 == cache_frame_317cb4b84876aa5d1575cb60d91624c5 )
    {
        Py_DECREF( frame_317cb4b84876aa5d1575cb60d91624c5 );
    }
    cache_frame_317cb4b84876aa5d1575cb60d91624c5 = NULL;

    assertFrameObject( frame_317cb4b84876aa5d1575cb60d91624c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_out = python_pars[ 1 ];
    PyObject *par_outlen = python_pars[ 2 ];
    PyObject *par_arg = python_pars[ 3 ];
    PyObject *var_e = NULL;
    PyObject *var_protos = NULL;
    PyObject *var_protostr = NULL;
    PyObject *var_conn = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_ff5454a954382e81b4077a213567d6a1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ff5454a954382e81b4077a213567d6a1 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ff5454a954382e81b4077a213567d6a1, codeobj_ff5454a954382e81b4077a213567d6a1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ff5454a954382e81b4077a213567d6a1 = cache_frame_ff5454a954382e81b4077a213567d6a1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ff5454a954382e81b4077a213567d6a1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ff5454a954382e81b4077a213567d6a1 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 347;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 347;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_ssl );
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 347;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        assert( var_conn == NULL );
        var_conn = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 348;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( var_conn );
        tmp_args_element_name_1 = var_conn;
        frame_ff5454a954382e81b4077a213567d6a1->m_frame.f_lineno = 348;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 348;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        assert( var_protos == NULL );
        var_protos = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        tmp_source_name_2 = const_str_empty;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_join );
        assert( !(tmp_called_name_2 == NULL) );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_chain );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "chain" );
            exception_tb = NULL;

            exception_lineno = 353;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_from_iterable );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 353;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( var_protos );
            tmp_iter_arg_1 = var_protos;
            tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 353;
                type_description_1 = "oooooccooo";
                goto try_except_handler_2;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_4;
        }
        // Tried code:
        tmp_args_element_name_3 = OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_3)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );


        goto try_return_handler_3;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper );
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper );
        return NULL;
        outline_result_1:;
        frame_ff5454a954382e81b4077a213567d6a1->m_frame.f_lineno = 353;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 353;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        frame_ff5454a954382e81b4077a213567d6a1->m_frame.f_lineno = 352;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 352;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        assert( var_protostr == NULL );
        var_protostr = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_new );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_4 = const_str_digest_e33a7f733650e687efe98e5491512b82;
        CHECK_OBJECT( var_protostr );
        tmp_len_arg_1 = var_protostr;
        tmp_args_element_name_5 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        frame_ff5454a954382e81b4077a213567d6a1->m_frame.f_lineno = 361;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 361;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_assattr_name_1 = PyList_New( 2 );
        PyList_SET_ITEM( tmp_assattr_name_1, 0, tmp_list_element_1 );
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_assattr_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 362;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        tmp_args_element_name_6 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_protostr );
        tmp_args_element_name_7 = var_protostr;
        frame_ff5454a954382e81b4077a213567d6a1->m_frame.f_lineno = 362;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_list_element_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, call_args );
        }

        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assattr_name_1 );

            exception_lineno = 362;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        PyList_SET_ITEM( tmp_assattr_name_1, 1, tmp_list_element_1 );
        CHECK_OBJECT( var_conn );
        tmp_assattr_target_1 = var_conn;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__npn_advertise_callback_args, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 360;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT( var_conn );
        tmp_source_name_5 = var_conn;
        tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__npn_advertise_callback_args );
        if ( tmp_subscribed_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_2 = const_int_0;
        tmp_subscribed_name_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_2, 0 );
        Py_DECREF( tmp_subscribed_name_3 );
        if ( tmp_subscribed_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_3 = const_int_0;
        tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_3, 0 );
        Py_DECREF( tmp_subscribed_name_2 );
        if ( tmp_ass_subvalue_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_outlen );
        tmp_ass_subscribed_1 = par_outlen;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subvalue_1 );
        if ( tmp_ass_subscript_res_1 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 364;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        int tmp_ass_subscript_res_2;
        CHECK_OBJECT( var_conn );
        tmp_source_name_6 = var_conn;
        tmp_subscribed_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__npn_advertise_callback_args );
        if ( tmp_subscribed_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 365;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 1 );
        Py_DECREF( tmp_subscribed_name_4 );
        if ( tmp_ass_subvalue_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 365;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_out );
        tmp_ass_subscribed_2 = par_out;
        tmp_ass_subscript_2 = const_int_0;
        tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
        Py_DECREF( tmp_ass_subvalue_2 );
        if ( tmp_ass_subscript_res_2 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 365;
            type_description_1 = "oooooccooo";
            goto try_except_handler_2;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_ff5454a954382e81b4077a213567d6a1 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_ff5454a954382e81b4077a213567d6a1, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_ff5454a954382e81b4077a213567d6a1, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 367;
            type_description_1 = "oooooccooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_5;
            tmp_assign_source_5 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_5 );
            var_e = tmp_assign_source_5;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_7;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_8;
            if ( PyCell_GET( self->m_closure[1] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                exception_tb = NULL;

                exception_lineno = 368;
                type_description_1 = "oooooccooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_7 = PyCell_GET( self->m_closure[1] );
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__problems );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 368;
                type_description_1 = "oooooccooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_e );
            tmp_args_element_name_8 = var_e;
            frame_ff5454a954382e81b4077a213567d6a1->m_frame.f_lineno = 368;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 368;
                type_description_1 = "oooooccooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 346;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_ff5454a954382e81b4077a213567d6a1->m_frame) frame_ff5454a954382e81b4077a213567d6a1->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooccooo";
        goto frame_exception_exit_1;
        branch_end_1:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_ff5454a954382e81b4077a213567d6a1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_ff5454a954382e81b4077a213567d6a1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_ff5454a954382e81b4077a213567d6a1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ff5454a954382e81b4077a213567d6a1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ff5454a954382e81b4077a213567d6a1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ff5454a954382e81b4077a213567d6a1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff5454a954382e81b4077a213567d6a1,
        type_description_1,
        par_ssl,
        par_out,
        par_outlen,
        par_arg,
        var_e,
        self->m_closure[0],
        self->m_closure[1],
        var_protos,
        var_protostr,
        var_conn
    );


    // Release cached frame.
    if ( frame_ff5454a954382e81b4077a213567d6a1 == cache_frame_ff5454a954382e81b4077a213567d6a1 )
    {
        Py_DECREF( frame_ff5454a954382e81b4077a213567d6a1 );
    }
    cache_frame_ff5454a954382e81b4077a213567d6a1 = NULL;

    assertFrameObject( frame_ff5454a954382e81b4077a213567d6a1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_protos );
    var_protos = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    Py_XDECREF( var_protostr );
    var_protostr = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_protos );
    var_protos = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    Py_XDECREF( var_protostr );
    var_protostr = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals {
    PyObject *var_p;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_p = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_00de5af8bcc556d3b5f411523cf5f22f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 353;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_p;
            generator_heap->var_p = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_p );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "int2byte" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_p );
        tmp_len_arg_1 = generator_heap->var_p;
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 353;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( generator_heap->var_p );
        tmp_tuple_element_1 = generator_heap->var_p;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 353;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 353;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_p
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_p );
    generator_heap->var_p = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_p );
    generator_heap->var_p = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_00de5af8bcc556d3b5f411523cf5f22f,
        1,
        sizeof(struct OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_5___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_fa7b831ecbe4fb78f1e881fefdd3ba51;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_fa7b831ecbe4fb78f1e881fefdd3ba51 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fa7b831ecbe4fb78f1e881fefdd3ba51, codeobj_fa7b831ecbe4fb78f1e881fefdd3ba51, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fa7b831ecbe4fb78f1e881fefdd3ba51 = cache_frame_fa7b831ecbe4fb78f1e881fefdd3ba51;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fa7b831ecbe4fb78f1e881fefdd3ba51 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fa7b831ecbe4fb78f1e881fefdd3ba51 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 383;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_1 = PyCell_GET( par_self );
        frame_fa7b831ecbe4fb78f1e881fefdd3ba51->m_frame.f_lineno = 383;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 383;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 385;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_2 = PyCell_GET( par_callback );
        frame_fa7b831ecbe4fb78f1e881fefdd3ba51->m_frame.f_lineno = 385;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 385;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] );


        frame_fa7b831ecbe4fb78f1e881fefdd3ba51->m_frame.f_lineno = 385;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 385;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 419;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_1bd7405e218c8a579c48801956097e27;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_5 = var_wrapper;
        frame_fa7b831ecbe4fb78f1e881fefdd3ba51->m_frame.f_lineno = 419;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 419;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_assattr_target_1 = PyCell_GET( par_self );
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 419;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa7b831ecbe4fb78f1e881fefdd3ba51 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fa7b831ecbe4fb78f1e881fefdd3ba51 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fa7b831ecbe4fb78f1e881fefdd3ba51, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fa7b831ecbe4fb78f1e881fefdd3ba51->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fa7b831ecbe4fb78f1e881fefdd3ba51, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fa7b831ecbe4fb78f1e881fefdd3ba51,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_fa7b831ecbe4fb78f1e881fefdd3ba51 == cache_frame_fa7b831ecbe4fb78f1e881fefdd3ba51 )
    {
        Py_DECREF( frame_fa7b831ecbe4fb78f1e881fefdd3ba51 );
    }
    cache_frame_fa7b831ecbe4fb78f1e881fefdd3ba51 = NULL;

    assertFrameObject( frame_fa7b831ecbe4fb78f1e881fefdd3ba51 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_out = python_pars[ 1 ];
    PyObject *par_outlen = python_pars[ 2 ];
    PyObject *par_in_ = python_pars[ 3 ];
    PyObject *par_inlen = python_pars[ 4 ];
    PyObject *par_arg = python_pars[ 5 ];
    PyObject *var_outstr = NULL;
    PyObject *var_protolist = NULL;
    PyObject *var_e = NULL;
    PyObject *var_instr = NULL;
    PyObject *var_proto = NULL;
    PyObject *var_length = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_162a5a1926e2d87c5196f76de69fc199;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_162a5a1926e2d87c5196f76de69fc199 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_162a5a1926e2d87c5196f76de69fc199, codeobj_162a5a1926e2d87c5196f76de69fc199, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_162a5a1926e2d87c5196f76de69fc199 = cache_frame_162a5a1926e2d87c5196f76de69fc199;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_162a5a1926e2d87c5196f76de69fc199 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_162a5a1926e2d87c5196f76de69fc199 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 388;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 388;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_ssl );
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 388;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        assert( var_conn == NULL );
        var_conn = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 393;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_in_ );
        tmp_args_element_name_1 = par_in_;
        CHECK_OBJECT( par_inlen );
        tmp_args_element_name_2 = par_inlen;
        frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = 393;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 393;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assign_source_2 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 393;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        assert( var_instr == NULL );
        var_instr = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New( 0 );
        assert( var_protolist == NULL );
        var_protolist = tmp_assign_source_3;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_instr );
        tmp_operand_name_1 = var_instr;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 395;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_indexbytes );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "indexbytes" );
            exception_tb = NULL;

            exception_lineno = 396;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_instr );
        tmp_args_element_name_3 = var_instr;
        tmp_args_element_name_4 = const_int_0;
        frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = 396;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 396;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_length;
            var_length = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_slice_source_2;
        PyObject *tmp_slice_lower_1;
        PyObject *tmp_slice_upper_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( var_instr );
        tmp_slice_source_2 = var_instr;
        tmp_slice_lower_1 = const_int_pos_1;
        CHECK_OBJECT( var_length );
        tmp_left_name_1 = var_length;
        tmp_right_name_1 = const_int_pos_1;
        tmp_slice_upper_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_slice_upper_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 397;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assign_source_5 = LOOKUP_SLICE( tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_1 );
        Py_DECREF( tmp_slice_upper_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 397;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_proto;
            var_proto = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT( var_protolist );
        tmp_called_instance_2 = var_protolist;
        CHECK_OBJECT( var_proto );
        tmp_args_element_name_5 = var_proto;
        frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = 398;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 398;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_slice_source_3;
        PyObject *tmp_slice_lower_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( var_instr );
        tmp_slice_source_3 = var_instr;
        CHECK_OBJECT( var_length );
        tmp_left_name_2 = var_length;
        tmp_right_name_2 = const_int_pos_1;
        tmp_slice_lower_2 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_slice_lower_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 399;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assign_source_6 = LOOKUP_SLICE( tmp_slice_source_3, tmp_slice_lower_2, Py_None );
        Py_DECREF( tmp_slice_lower_2 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 399;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_instr;
            assert( old != NULL );
            var_instr = tmp_assign_source_6;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description_1 = "oooooooooocooco";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 402;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( var_conn );
        tmp_args_element_name_6 = var_conn;
        CHECK_OBJECT( var_protolist );
        tmp_args_element_name_7 = var_protolist;
        frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = 402;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 402;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        assert( var_outstr == NULL );
        var_outstr = tmp_assign_source_7;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_new );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_args_element_name_8 = const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
        CHECK_OBJECT( var_outstr );
        tmp_len_arg_1 = var_outstr;
        tmp_args_element_name_9 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = 409;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 409;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_assattr_name_1 = PyList_New( 2 );
        PyList_SET_ITEM( tmp_assattr_name_1, 0, tmp_list_element_1 );
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_assattr_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 410;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        tmp_args_element_name_10 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_outstr );
        tmp_args_element_name_11 = var_outstr;
        frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = 410;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_list_element_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_new, call_args );
        }

        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assattr_name_1 );

            exception_lineno = 410;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        PyList_SET_ITEM( tmp_assattr_name_1, 1, tmp_list_element_1 );
        CHECK_OBJECT( var_conn );
        tmp_assattr_target_1 = var_conn;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__npn_select_callback_args, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 408;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT( var_conn );
        tmp_source_name_3 = var_conn;
        tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__npn_select_callback_args );
        if ( tmp_subscribed_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_subscript_name_2 = const_int_0;
        tmp_subscribed_name_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_2, 0 );
        Py_DECREF( tmp_subscribed_name_3 );
        if ( tmp_subscribed_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_subscript_name_3 = const_int_0;
        tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_3, 0 );
        Py_DECREF( tmp_subscribed_name_2 );
        if ( tmp_ass_subvalue_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_outlen );
        tmp_ass_subscribed_1 = par_outlen;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subvalue_1 );
        if ( tmp_ass_subscript_res_1 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 412;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        int tmp_ass_subscript_res_2;
        CHECK_OBJECT( var_conn );
        tmp_source_name_4 = var_conn;
        tmp_subscribed_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__npn_select_callback_args );
        if ( tmp_subscribed_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 413;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 1 );
        Py_DECREF( tmp_subscribed_name_4 );
        if ( tmp_ass_subvalue_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 413;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_out );
        tmp_ass_subscribed_2 = par_out;
        tmp_ass_subscript_2 = const_int_0;
        tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
        Py_DECREF( tmp_ass_subvalue_2 );
        if ( tmp_ass_subscript_res_2 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 413;
            type_description_1 = "oooooooooocooco";
            goto try_except_handler_2;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_162a5a1926e2d87c5196f76de69fc199 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_162a5a1926e2d87c5196f76de69fc199, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_162a5a1926e2d87c5196f76de69fc199, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 415;
            type_description_1 = "oooooooooocooco";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_8;
            tmp_assign_source_8 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_8 );
            var_e = tmp_assign_source_8;
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_12;
            if ( PyCell_GET( self->m_closure[1] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                exception_tb = NULL;

                exception_lineno = 416;
                type_description_1 = "oooooooooocooco";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = PyCell_GET( self->m_closure[1] );
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__problems );
            if ( tmp_called_instance_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 416;
                type_description_1 = "oooooooooocooco";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_e );
            tmp_args_element_name_12 = var_e;
            frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = 416;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
            }

            Py_DECREF( tmp_called_instance_4 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 416;
                type_description_1 = "oooooooooocooco";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 387;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_162a5a1926e2d87c5196f76de69fc199->m_frame) frame_162a5a1926e2d87c5196f76de69fc199->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooocooco";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_162a5a1926e2d87c5196f76de69fc199 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_162a5a1926e2d87c5196f76de69fc199 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_162a5a1926e2d87c5196f76de69fc199 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_162a5a1926e2d87c5196f76de69fc199, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_162a5a1926e2d87c5196f76de69fc199->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_162a5a1926e2d87c5196f76de69fc199, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_162a5a1926e2d87c5196f76de69fc199,
        type_description_1,
        par_ssl,
        par_out,
        par_outlen,
        par_in_,
        par_inlen,
        par_arg,
        var_outstr,
        var_protolist,
        var_e,
        var_instr,
        self->m_closure[1],
        var_proto,
        var_length,
        self->m_closure[0],
        var_conn
    );


    // Release cached frame.
    if ( frame_162a5a1926e2d87c5196f76de69fc199 == cache_frame_162a5a1926e2d87c5196f76de69fc199 )
    {
        Py_DECREF( frame_162a5a1926e2d87c5196f76de69fc199 );
    }
    cache_frame_162a5a1926e2d87c5196f76de69fc199 = NULL;

    assertFrameObject( frame_162a5a1926e2d87c5196f76de69fc199 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_outstr );
    var_outstr = NULL;

    Py_XDECREF( var_protolist );
    var_protolist = NULL;

    CHECK_OBJECT( (PyObject *)par_in_ );
    Py_DECREF( par_in_ );
    par_in_ = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_instr );
    var_instr = NULL;

    Py_XDECREF( var_proto );
    var_proto = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_inlen );
    Py_DECREF( par_inlen );
    par_inlen = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outstr );
    var_outstr = NULL;

    Py_XDECREF( var_protolist );
    var_protolist = NULL;

    CHECK_OBJECT( (PyObject *)par_in_ );
    Py_DECREF( par_in_ );
    par_in_ = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_instr );
    var_instr = NULL;

    Py_XDECREF( var_proto );
    var_proto = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_inlen );
    Py_DECREF( par_inlen );
    par_inlen = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_6___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_cc5d77cb8b65c7f8f33a60eea1cc2796;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_cc5d77cb8b65c7f8f33a60eea1cc2796 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cc5d77cb8b65c7f8f33a60eea1cc2796, codeobj_cc5d77cb8b65c7f8f33a60eea1cc2796, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cc5d77cb8b65c7f8f33a60eea1cc2796 = cache_frame_cc5d77cb8b65c7f8f33a60eea1cc2796;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cc5d77cb8b65c7f8f33a60eea1cc2796 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cc5d77cb8b65c7f8f33a60eea1cc2796 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 432;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_1 = PyCell_GET( par_self );
        frame_cc5d77cb8b65c7f8f33a60eea1cc2796->m_frame.f_lineno = 432;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 432;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 434;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_2 = PyCell_GET( par_callback );
        frame_cc5d77cb8b65c7f8f33a60eea1cc2796->m_frame.f_lineno = 434;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 434;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] );


        frame_cc5d77cb8b65c7f8f33a60eea1cc2796->m_frame.f_lineno = 434;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 434;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 470;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_1bd7405e218c8a579c48801956097e27;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_5 = var_wrapper;
        frame_cc5d77cb8b65c7f8f33a60eea1cc2796->m_frame.f_lineno = 470;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 470;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_assattr_target_1 = PyCell_GET( par_self );
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 470;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc5d77cb8b65c7f8f33a60eea1cc2796 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cc5d77cb8b65c7f8f33a60eea1cc2796 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cc5d77cb8b65c7f8f33a60eea1cc2796, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cc5d77cb8b65c7f8f33a60eea1cc2796->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cc5d77cb8b65c7f8f33a60eea1cc2796, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cc5d77cb8b65c7f8f33a60eea1cc2796,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_cc5d77cb8b65c7f8f33a60eea1cc2796 == cache_frame_cc5d77cb8b65c7f8f33a60eea1cc2796 )
    {
        Py_DECREF( frame_cc5d77cb8b65c7f8f33a60eea1cc2796 );
    }
    cache_frame_cc5d77cb8b65c7f8f33a60eea1cc2796 = NULL;

    assertFrameObject( frame_cc5d77cb8b65c7f8f33a60eea1cc2796 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_out = python_pars[ 1 ];
    PyObject *par_outlen = python_pars[ 2 ];
    PyObject *par_in_ = python_pars[ 3 ];
    PyObject *par_inlen = python_pars[ 4 ];
    PyObject *par_arg = python_pars[ 5 ];
    PyObject *var_encoded_len = NULL;
    PyObject *var_protolist = NULL;
    PyObject *var_e = NULL;
    PyObject *var_instr = NULL;
    PyObject *var_proto = NULL;
    PyObject *var_outstr = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_84469bc26b1b18a7587749a007b2f9d0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_84469bc26b1b18a7587749a007b2f9d0 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_84469bc26b1b18a7587749a007b2f9d0, codeobj_84469bc26b1b18a7587749a007b2f9d0, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_84469bc26b1b18a7587749a007b2f9d0 = cache_frame_84469bc26b1b18a7587749a007b2f9d0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84469bc26b1b18a7587749a007b2f9d0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84469bc26b1b18a7587749a007b2f9d0 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 437;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 437;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_ssl );
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 437;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        assert( var_conn == NULL );
        var_conn = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 442;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_in_ );
        tmp_args_element_name_1 = par_in_;
        CHECK_OBJECT( par_inlen );
        tmp_args_element_name_2 = par_inlen;
        frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 442;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 442;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assign_source_2 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 442;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        assert( var_instr == NULL );
        var_instr = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New( 0 );
        assert( var_protolist == NULL );
        var_protolist = tmp_assign_source_3;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_instr );
        tmp_operand_name_1 = var_instr;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 444;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_indexbytes );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "indexbytes" );
            exception_tb = NULL;

            exception_lineno = 445;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_instr );
        tmp_args_element_name_3 = var_instr;
        tmp_args_element_name_4 = const_int_0;
        frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 445;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 445;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_encoded_len;
            var_encoded_len = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_slice_source_2;
        PyObject *tmp_slice_lower_1;
        PyObject *tmp_slice_upper_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( var_instr );
        tmp_slice_source_2 = var_instr;
        tmp_slice_lower_1 = const_int_pos_1;
        CHECK_OBJECT( var_encoded_len );
        tmp_left_name_1 = var_encoded_len;
        tmp_right_name_1 = const_int_pos_1;
        tmp_slice_upper_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_slice_upper_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 446;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assign_source_5 = LOOKUP_SLICE( tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_1 );
        Py_DECREF( tmp_slice_upper_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 446;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_proto;
            var_proto = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT( var_protolist );
        tmp_called_instance_2 = var_protolist;
        CHECK_OBJECT( var_proto );
        tmp_args_element_name_5 = var_proto;
        frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 447;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 447;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_slice_source_3;
        PyObject *tmp_slice_lower_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( var_instr );
        tmp_slice_source_3 = var_instr;
        CHECK_OBJECT( var_encoded_len );
        tmp_left_name_2 = var_encoded_len;
        tmp_right_name_2 = const_int_pos_1;
        tmp_slice_lower_2 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_slice_lower_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 448;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assign_source_6 = LOOKUP_SLICE( tmp_slice_source_3, tmp_slice_lower_2, Py_None );
        Py_DECREF( tmp_slice_lower_2 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 448;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_instr;
            assert( old != NULL );
            var_instr = tmp_assign_source_6;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 444;
        type_description_1 = "oooooooooococoo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 451;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( var_conn );
        tmp_args_element_name_6 = var_conn;
        CHECK_OBJECT( var_protolist );
        tmp_args_element_name_7 = var_protolist;
        frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 451;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 451;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        assert( var_outstr == NULL );
        var_outstr = tmp_assign_source_7;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_outstr );
        tmp_isinstance_inst_1 = var_outstr;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__binary_type );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__binary_type );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_binary_type" );
            exception_tb = NULL;

            exception_lineno = 453;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_4;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 453;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 453;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_360fff1f759f48242850b1a03fa368f8;
            frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 454;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 454;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_new );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_8 = const_str_digest_2aaae8e99c54112dad0b0da3957413a9;
        CHECK_OBJECT( var_outstr );
        tmp_len_arg_1 = var_outstr;
        tmp_args_element_name_9 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 460;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 460;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_assattr_name_1 = PyList_New( 2 );
        PyList_SET_ITEM( tmp_assattr_name_1, 0, tmp_list_element_1 );
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_assattr_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 461;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        tmp_args_element_name_10 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_outstr );
        tmp_args_element_name_11 = var_outstr;
        frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 461;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_list_element_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_new, call_args );
        }

        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assattr_name_1 );

            exception_lineno = 461;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        PyList_SET_ITEM( tmp_assattr_name_1, 1, tmp_list_element_1 );
        CHECK_OBJECT( var_conn );
        tmp_assattr_target_1 = var_conn;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__alpn_select_callback_args, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 459;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT( var_conn );
        tmp_source_name_3 = var_conn;
        tmp_subscribed_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__alpn_select_callback_args );
        if ( tmp_subscribed_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_2 = const_int_0;
        tmp_subscribed_name_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_2, 0 );
        Py_DECREF( tmp_subscribed_name_3 );
        if ( tmp_subscribed_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_3 = const_int_0;
        tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_3, 0 );
        Py_DECREF( tmp_subscribed_name_2 );
        if ( tmp_ass_subvalue_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_outlen );
        tmp_ass_subscribed_1 = par_outlen;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subvalue_1 );
        if ( tmp_ass_subscript_res_1 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        int tmp_ass_subscript_res_2;
        CHECK_OBJECT( var_conn );
        tmp_source_name_4 = var_conn;
        tmp_subscribed_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__alpn_select_callback_args );
        if ( tmp_subscribed_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 464;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        tmp_subscript_name_4 = const_int_pos_1;
        tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 1 );
        Py_DECREF( tmp_subscribed_name_4 );
        if ( tmp_ass_subvalue_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 464;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_out );
        tmp_ass_subscribed_2 = par_out;
        tmp_ass_subscript_2 = const_int_0;
        tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
        Py_DECREF( tmp_ass_subvalue_2 );
        if ( tmp_ass_subscript_res_2 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 464;
            type_description_1 = "oooooooooococoo";
            goto try_except_handler_2;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_84469bc26b1b18a7587749a007b2f9d0 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_84469bc26b1b18a7587749a007b2f9d0, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_84469bc26b1b18a7587749a007b2f9d0, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 466;
            type_description_1 = "oooooooooococoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_8;
            tmp_assign_source_8 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_8 );
            var_e = tmp_assign_source_8;
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_12;
            if ( PyCell_GET( self->m_closure[1] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                exception_tb = NULL;

                exception_lineno = 467;
                type_description_1 = "oooooooooococoo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = PyCell_GET( self->m_closure[1] );
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__problems );
            if ( tmp_called_instance_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 467;
                type_description_1 = "oooooooooococoo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_e );
            tmp_args_element_name_12 = var_e;
            frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = 467;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
            }

            Py_DECREF( tmp_called_instance_4 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 467;
                type_description_1 = "oooooooooococoo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 436;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_84469bc26b1b18a7587749a007b2f9d0->m_frame) frame_84469bc26b1b18a7587749a007b2f9d0->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooococoo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_84469bc26b1b18a7587749a007b2f9d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_84469bc26b1b18a7587749a007b2f9d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_84469bc26b1b18a7587749a007b2f9d0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84469bc26b1b18a7587749a007b2f9d0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84469bc26b1b18a7587749a007b2f9d0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84469bc26b1b18a7587749a007b2f9d0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84469bc26b1b18a7587749a007b2f9d0,
        type_description_1,
        par_ssl,
        par_out,
        par_outlen,
        par_in_,
        par_inlen,
        par_arg,
        var_encoded_len,
        var_protolist,
        var_e,
        var_instr,
        self->m_closure[1],
        var_proto,
        self->m_closure[0],
        var_outstr,
        var_conn
    );


    // Release cached frame.
    if ( frame_84469bc26b1b18a7587749a007b2f9d0 == cache_frame_84469bc26b1b18a7587749a007b2f9d0 )
    {
        Py_DECREF( frame_84469bc26b1b18a7587749a007b2f9d0 );
    }
    cache_frame_84469bc26b1b18a7587749a007b2f9d0 = NULL;

    assertFrameObject( frame_84469bc26b1b18a7587749a007b2f9d0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_encoded_len );
    var_encoded_len = NULL;

    Py_XDECREF( var_protolist );
    var_protolist = NULL;

    CHECK_OBJECT( (PyObject *)par_in_ );
    Py_DECREF( par_in_ );
    par_in_ = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_instr );
    var_instr = NULL;

    Py_XDECREF( var_proto );
    var_proto = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_outstr );
    var_outstr = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_inlen );
    Py_DECREF( par_inlen );
    par_inlen = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_encoded_len );
    var_encoded_len = NULL;

    Py_XDECREF( var_protolist );
    var_protolist = NULL;

    CHECK_OBJECT( (PyObject *)par_in_ );
    Py_DECREF( par_in_ );
    par_in_ = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_instr );
    var_instr = NULL;

    Py_XDECREF( var_proto );
    var_proto = NULL;

    CHECK_OBJECT( (PyObject *)par_outlen );
    Py_DECREF( par_outlen );
    par_outlen = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_outstr );
    var_outstr = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_out );
    Py_DECREF( par_out );
    par_out = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    CHECK_OBJECT( (PyObject *)par_inlen );
    Py_DECREF( par_inlen );
    par_inlen = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_7___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_886a66a4ce2fa5c90a928ff54c46cf35;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_886a66a4ce2fa5c90a928ff54c46cf35 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_886a66a4ce2fa5c90a928ff54c46cf35, codeobj_886a66a4ce2fa5c90a928ff54c46cf35, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_886a66a4ce2fa5c90a928ff54c46cf35 = cache_frame_886a66a4ce2fa5c90a928ff54c46cf35;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_886a66a4ce2fa5c90a928ff54c46cf35 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_886a66a4ce2fa5c90a928ff54c46cf35 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 500;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_1 = PyCell_GET( par_self );
        frame_886a66a4ce2fa5c90a928ff54c46cf35->m_frame.f_lineno = 500;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 500;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 502;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_2 = PyCell_GET( par_callback );
        frame_886a66a4ce2fa5c90a928ff54c46cf35->m_frame.f_lineno = 502;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 502;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] );


        frame_886a66a4ce2fa5c90a928ff54c46cf35->m_frame.f_lineno = 502;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 502;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 541;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_5 = var_wrapper;
        frame_886a66a4ce2fa5c90a928ff54c46cf35->m_frame.f_lineno = 541;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 541;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_assattr_target_1 = PyCell_GET( par_self );
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 541;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_886a66a4ce2fa5c90a928ff54c46cf35 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_886a66a4ce2fa5c90a928ff54c46cf35 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_886a66a4ce2fa5c90a928ff54c46cf35, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_886a66a4ce2fa5c90a928ff54c46cf35->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_886a66a4ce2fa5c90a928ff54c46cf35, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_886a66a4ce2fa5c90a928ff54c46cf35,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_886a66a4ce2fa5c90a928ff54c46cf35 == cache_frame_886a66a4ce2fa5c90a928ff54c46cf35 )
    {
        Py_DECREF( frame_886a66a4ce2fa5c90a928ff54c46cf35 );
    }
    cache_frame_886a66a4ce2fa5c90a928ff54c46cf35 = NULL;

    assertFrameObject( frame_886a66a4ce2fa5c90a928ff54c46cf35 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_7___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_7___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_cdata = python_pars[ 1 ];
    PyObject *var_e = NULL;
    PyObject *var_ocsp_data_length = NULL;
    PyObject *var_ocsp_data = NULL;
    PyObject *var_data_ptr = NULL;
    PyObject *var_data = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_d2ee4bcf609725335171733079f6b33c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_d2ee4bcf609725335171733079f6b33c = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d2ee4bcf609725335171733079f6b33c, codeobj_d2ee4bcf609725335171733079f6b33c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d2ee4bcf609725335171733079f6b33c = cache_frame_d2ee4bcf609725335171733079f6b33c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d2ee4bcf609725335171733079f6b33c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d2ee4bcf609725335171733079f6b33c ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 505;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 505;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_ssl );
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 505;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert( var_conn == NULL );
        var_conn = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_cdata );
        tmp_compexpr_left_1 = par_cdata;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 508;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 508;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 508;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 509;
                type_description_1 = "ooooccoooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_cdata );
            tmp_args_element_name_1 = par_cdata;
            frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = 509;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_from_handle, call_args );
            }

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 509;
                type_description_1 = "ooooccoooo";
                goto try_except_handler_2;
            }
            assert( var_data == NULL );
            var_data = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = Py_None;
            assert( var_data == NULL );
            Py_INCREF( tmp_assign_source_3 );
            var_data = tmp_assign_source_3;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 514;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( var_conn );
        tmp_args_element_name_2 = var_conn;
        CHECK_OBJECT( var_data );
        tmp_args_element_name_3 = var_data;
        frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = 514;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 514;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert( var_ocsp_data == NULL );
        var_ocsp_data = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_ocsp_data );
        tmp_isinstance_inst_1 = var_ocsp_data;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__binary_type );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__binary_type );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_binary_type" );
            exception_tb = NULL;

            exception_lineno = 516;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_4;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 516;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 516;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f4ac5993e0eb53c16d6349308d51d30e;
            frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = 517;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 517;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_ocsp_data );
        tmp_operand_name_2 = var_ocsp_data;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 523;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = const_int_pos_3;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( var_ocsp_data );
        tmp_len_arg_1 = var_ocsp_data;
        tmp_assign_source_5 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 528;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert( var_ocsp_data_length == NULL );
        var_ocsp_data_length = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 529;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT( var_ocsp_data_length );
        tmp_args_element_name_4 = var_ocsp_data_length;
        frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = 529;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OPENSSL_malloc, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 529;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        assert( var_data_ptr == NULL );
        var_data_ptr = tmp_assign_source_6;
    }
    {
        PyObject *tmp_sliceass_value_1;
        PyObject *tmp_sliceass_target_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        Py_ssize_t tmp_sliceassslicedel_index_lower_1;
        Py_ssize_t tmp_sliceass_index_upper_1;
        CHECK_OBJECT( var_ocsp_data );
        tmp_sliceass_value_1 = var_ocsp_data;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 530;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        CHECK_OBJECT( var_data_ptr );
        tmp_args_element_name_5 = var_data_ptr;
        CHECK_OBJECT( var_ocsp_data_length );
        tmp_args_element_name_6 = var_ocsp_data_length;
        frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = 530;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_sliceass_target_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_buffer, call_args );
        }

        if ( tmp_sliceass_target_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 530;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        tmp_sliceassslicedel_index_lower_1 = 0;
        tmp_sliceass_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_result = SET_INDEX_SLICE( tmp_sliceass_target_1, tmp_sliceassslicedel_index_lower_1, tmp_sliceass_index_upper_1, tmp_sliceass_value_1 );
        Py_DECREF( tmp_sliceass_target_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 530;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 532;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_4 = tmp_mvar_value_7;
        CHECK_OBJECT( par_ssl );
        tmp_args_element_name_7 = par_ssl;
        CHECK_OBJECT( var_data_ptr );
        tmp_args_element_name_8 = var_data_ptr;
        CHECK_OBJECT( var_ocsp_data_length );
        tmp_args_element_name_9 = var_ocsp_data_length;
        frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = 532;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_4, const_str_plain_SSL_set_tlsext_status_ocsp_resp, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 532;
            type_description_1 = "ooooccoooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_d2ee4bcf609725335171733079f6b33c );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_d2ee4bcf609725335171733079f6b33c, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_d2ee4bcf609725335171733079f6b33c, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 537;
            type_description_1 = "ooooccoooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_7 );
            var_e = tmp_assign_source_7;
        }
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_10;
            if ( PyCell_GET( self->m_closure[1] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                exception_tb = NULL;

                exception_lineno = 538;
                type_description_1 = "ooooccoooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = PyCell_GET( self->m_closure[1] );
            tmp_called_instance_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__problems );
            if ( tmp_called_instance_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_1 = "ooooccoooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_e );
            tmp_args_element_name_10 = var_e;
            frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = 538;
            {
                PyObject *call_args[] = { tmp_args_element_name_10 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_append, call_args );
            }

            Py_DECREF( tmp_called_instance_5 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 538;
                type_description_1 = "ooooccoooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        tmp_return_value = const_int_pos_2;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_4;
        branch_no_4:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 504;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_d2ee4bcf609725335171733079f6b33c->m_frame) frame_d2ee4bcf609725335171733079f6b33c->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooccoooo";
        goto frame_exception_exit_1;
        branch_end_4:;
    }
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d2ee4bcf609725335171733079f6b33c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_d2ee4bcf609725335171733079f6b33c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d2ee4bcf609725335171733079f6b33c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d2ee4bcf609725335171733079f6b33c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d2ee4bcf609725335171733079f6b33c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d2ee4bcf609725335171733079f6b33c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d2ee4bcf609725335171733079f6b33c,
        type_description_1,
        par_ssl,
        par_cdata,
        var_e,
        var_ocsp_data_length,
        self->m_closure[0],
        self->m_closure[1],
        var_ocsp_data,
        var_data_ptr,
        var_data,
        var_conn
    );


    // Release cached frame.
    if ( frame_d2ee4bcf609725335171733079f6b33c == cache_frame_d2ee4bcf609725335171733079f6b33c )
    {
        Py_DECREF( frame_d2ee4bcf609725335171733079f6b33c );
    }
    cache_frame_d2ee4bcf609725335171733079f6b33c = NULL;

    assertFrameObject( frame_d2ee4bcf609725335171733079f6b33c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_ocsp_data_length );
    var_ocsp_data_length = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data_ptr );
    var_data_ptr = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_ocsp_data_length );
    var_ocsp_data_length = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data_ptr );
    var_data_ptr = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_8___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_ef30387d2b22fe29bb41f5ab3b946a84;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ef30387d2b22fe29bb41f5ab3b946a84 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ef30387d2b22fe29bb41f5ab3b946a84, codeobj_ef30387d2b22fe29bb41f5ab3b946a84, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ef30387d2b22fe29bb41f5ab3b946a84 = cache_frame_ef30387d2b22fe29bb41f5ab3b946a84;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ef30387d2b22fe29bb41f5ab3b946a84 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ef30387d2b22fe29bb41f5ab3b946a84 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 567;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_1 = PyCell_GET( par_self );
        frame_ef30387d2b22fe29bb41f5ab3b946a84->m_frame.f_lineno = 567;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 567;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 569;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_2 = PyCell_GET( par_callback );
        frame_ef30387d2b22fe29bb41f5ab3b946a84->m_frame.f_lineno = 569;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 569;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_3)->m_closure[1] );


        frame_ef30387d2b22fe29bb41f5ab3b946a84->m_frame.f_lineno = 569;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 569;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 600;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        tmp_args_element_name_4 = const_str_digest_9575fec1eee4d60c15d3f7c228d8045c;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_5 = var_wrapper;
        frame_ef30387d2b22fe29bb41f5ab3b946a84->m_frame.f_lineno = 600;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 600;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_assattr_target_1 = PyCell_GET( par_self );
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 600;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef30387d2b22fe29bb41f5ab3b946a84 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef30387d2b22fe29bb41f5ab3b946a84 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ef30387d2b22fe29bb41f5ab3b946a84, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ef30387d2b22fe29bb41f5ab3b946a84->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ef30387d2b22fe29bb41f5ab3b946a84, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ef30387d2b22fe29bb41f5ab3b946a84,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_ef30387d2b22fe29bb41f5ab3b946a84 == cache_frame_ef30387d2b22fe29bb41f5ab3b946a84 )
    {
        Py_DECREF( frame_ef30387d2b22fe29bb41f5ab3b946a84 );
    }
    cache_frame_ef30387d2b22fe29bb41f5ab3b946a84 = NULL;

    assertFrameObject( frame_ef30387d2b22fe29bb41f5ab3b946a84 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_8___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_8___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_cdata = python_pars[ 1 ];
    PyObject *var_ocsp_len = NULL;
    PyObject *var_e = NULL;
    PyObject *var_valid = NULL;
    PyObject *var_ocsp_ptr = NULL;
    PyObject *var_ocsp_data = NULL;
    PyObject *var_data = NULL;
    PyObject *var_conn = NULL;
    struct Nuitka_FrameObject *frame_ab7c6851b751f003fc9405d2a2e9ea43;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ab7c6851b751f003fc9405d2a2e9ea43 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ab7c6851b751f003fc9405d2a2e9ea43, codeobj_ab7c6851b751f003fc9405d2a2e9ea43, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ab7c6851b751f003fc9405d2a2e9ea43 = cache_frame_ab7c6851b751f003fc9405d2a2e9ea43;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ab7c6851b751f003fc9405d2a2e9ea43 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ab7c6851b751f003fc9405d2a2e9ea43 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 572;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 572;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_ssl );
        tmp_subscript_name_1 = par_ssl;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 572;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert( var_conn == NULL );
        var_conn = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_cdata );
        tmp_compexpr_left_1 = par_cdata;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 575;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 575;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 575;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 576;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT( par_cdata );
            tmp_args_element_name_1 = par_cdata;
            frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame.f_lineno = 576;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_from_handle, call_args );
            }

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 576;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            assert( var_data == NULL );
            var_data = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = Py_None;
            assert( var_data == NULL );
            Py_INCREF( tmp_assign_source_3 );
            var_data = tmp_assign_source_3;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 581;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame.f_lineno = 581;
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0 ) );

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 581;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert( var_ocsp_ptr == NULL );
        var_ocsp_ptr = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 582;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT( par_ssl );
        tmp_args_element_name_2 = par_ssl;
        CHECK_OBJECT( var_ocsp_ptr );
        tmp_args_element_name_3 = var_ocsp_ptr;
        frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame.f_lineno = 582;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_SSL_get_tlsext_status_ocsp_resp, call_args );
        }

        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 582;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert( var_ocsp_len == NULL );
        var_ocsp_len = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_ocsp_len );
        tmp_compexpr_left_2 = var_ocsp_len;
        tmp_compexpr_right_2 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 583;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_6;
            tmp_assign_source_6 = const_str_empty;
            assert( var_ocsp_data == NULL );
            Py_INCREF( tmp_assign_source_6 );
            var_ocsp_data = tmp_assign_source_6;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_7;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            PyObject *tmp_args_element_name_5;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_buffer );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( var_ocsp_ptr );
            tmp_subscribed_name_2 = var_ocsp_ptr;
            tmp_subscript_name_2 = const_int_0;
            tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( var_ocsp_len );
            tmp_args_element_name_5 = var_ocsp_len;
            frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame.f_lineno = 588;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_slice_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_7 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
            Py_DECREF( tmp_slice_source_1 );
            if ( tmp_assign_source_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 588;
                type_description_1 = "ooooccooooo";
                goto try_except_handler_2;
            }
            assert( var_ocsp_data == NULL );
            var_ocsp_data = tmp_assign_source_7;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 590;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( var_conn );
        tmp_args_element_name_6 = var_conn;
        CHECK_OBJECT( var_ocsp_data );
        tmp_args_element_name_7 = var_ocsp_data;
        CHECK_OBJECT( var_data );
        tmp_args_element_name_8 = var_data;
        frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame.f_lineno = 590;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 590;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        assert( var_valid == NULL );
        var_valid = tmp_assign_source_8;
    }
    {
        PyObject *tmp_int_arg_1;
        PyObject *tmp_value_name_1;
        CHECK_OBJECT( var_valid );
        tmp_value_name_1 = var_valid;
        tmp_res = CHECK_IF_TRUE( tmp_value_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 593;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        tmp_int_arg_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_return_value = PyNumber_Int( tmp_int_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 593;
            type_description_1 = "ooooccooooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_ab7c6851b751f003fc9405d2a2e9ea43 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_ab7c6851b751f003fc9405d2a2e9ea43, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_ab7c6851b751f003fc9405d2a2e9ea43, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 595;
            type_description_1 = "ooooccooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_9;
            tmp_assign_source_9 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_9 );
            var_e = tmp_assign_source_9;
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_9;
            if ( PyCell_GET( self->m_closure[1] ) == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
                exception_tb = NULL;

                exception_lineno = 596;
                type_description_1 = "ooooccooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = PyCell_GET( self->m_closure[1] );
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__problems );
            if ( tmp_called_instance_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 596;
                type_description_1 = "ooooccooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_e );
            tmp_args_element_name_9 = var_e;
            frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame.f_lineno = 596;
            {
                PyObject *call_args[] = { tmp_args_element_name_9 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
            }

            Py_DECREF( tmp_called_instance_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 596;
                type_description_1 = "ooooccooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        tmp_return_value = const_int_neg_1;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 571;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame) frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ooooccooooo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_ab7c6851b751f003fc9405d2a2e9ea43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_ab7c6851b751f003fc9405d2a2e9ea43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_ab7c6851b751f003fc9405d2a2e9ea43 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ab7c6851b751f003fc9405d2a2e9ea43, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ab7c6851b751f003fc9405d2a2e9ea43->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ab7c6851b751f003fc9405d2a2e9ea43, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ab7c6851b751f003fc9405d2a2e9ea43,
        type_description_1,
        par_ssl,
        par_cdata,
        var_ocsp_len,
        var_e,
        self->m_closure[0],
        self->m_closure[1],
        var_valid,
        var_ocsp_ptr,
        var_ocsp_data,
        var_data,
        var_conn
    );


    // Release cached frame.
    if ( frame_ab7c6851b751f003fc9405d2a2e9ea43 == cache_frame_ab7c6851b751f003fc9405d2a2e9ea43 )
    {
        Py_DECREF( frame_ab7c6851b751f003fc9405d2a2e9ea43 );
    }
    cache_frame_ab7c6851b751f003fc9405d2a2e9ea43 = NULL;

    assertFrameObject( frame_ab7c6851b751f003fc9405d2a2e9ea43 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_ocsp_len );
    var_ocsp_len = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_valid );
    var_valid = NULL;

    Py_XDECREF( var_ocsp_ptr );
    var_ocsp_ptr = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ocsp_len );
    var_ocsp_len = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    Py_XDECREF( var_valid );
    var_valid = NULL;

    Py_XDECREF( var_ocsp_ptr );
    var_ocsp_ptr = NULL;

    CHECK_OBJECT( (PyObject *)par_cdata );
    Py_DECREF( par_cdata );
    par_cdata = NULL;

    Py_XDECREF( var_ocsp_data );
    var_ocsp_data = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_9__asFileDescriptor( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_obj = python_pars[ 0 ];
    PyObject *var_fd = NULL;
    PyObject *var_meth = NULL;
    struct Nuitka_FrameObject *frame_1560700e571808ac63152799e0da7758;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1560700e571808ac63152799e0da7758 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert( var_fd == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_fd = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1560700e571808ac63152799e0da7758, codeobj_1560700e571808ac63152799e0da7758, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1560700e571808ac63152799e0da7758 = cache_frame_1560700e571808ac63152799e0da7758;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1560700e571808ac63152799e0da7758 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1560700e571808ac63152799e0da7758 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_obj );
        tmp_isinstance_inst_1 = par_obj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 605;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 605;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 605;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_getattr_target_1;
            PyObject *tmp_getattr_attr_1;
            PyObject *tmp_getattr_default_1;
            CHECK_OBJECT( par_obj );
            tmp_getattr_target_1 = par_obj;
            tmp_getattr_attr_1 = const_str_plain_fileno;
            tmp_getattr_default_1 = Py_None;
            tmp_assign_source_2 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 606;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( var_meth == NULL );
            var_meth = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            CHECK_OBJECT( var_meth );
            tmp_compexpr_left_1 = var_meth;
            tmp_compexpr_right_1 = Py_None;
            tmp_condition_result_2 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_1;
                CHECK_OBJECT( var_meth );
                tmp_called_name_1 = var_meth;
                frame_1560700e571808ac63152799e0da7758->m_frame.f_lineno = 608;
                tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 608;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_obj;
                    assert( old != NULL );
                    par_obj = tmp_assign_source_3;
                    Py_DECREF( old );
                }

            }
            branch_no_2:;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        if ( par_obj == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
            exception_tb = NULL;

            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_2 = par_obj;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 610;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_4;
            if ( par_obj == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
                exception_tb = NULL;

                exception_lineno = 611;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_4 = par_obj;
            {
                PyObject *old = var_fd;
                assert( old != NULL );
                var_fd = tmp_assign_source_4;
                Py_INCREF( var_fd );
                Py_DECREF( old );
            }

        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_fd );
        tmp_isinstance_inst_3 = var_fd;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_3 = tmp_mvar_value_3;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 613;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_9e9a42d8484d15cb8253ecb92e0c7121;
            frame_1560700e571808ac63152799e0da7758->m_frame.f_lineno = 614;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 614;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_4;
        branch_no_4:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( var_fd );
            tmp_compexpr_left_2 = var_fd;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 615;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_1;
                tmp_left_name_1 = const_str_digest_afa60644cf27716474a6bbd780185867;
                CHECK_OBJECT( var_fd );
                tmp_tuple_element_1 = var_fd;
                tmp_right_name_1 = PyTuple_New( 1 );
                Py_INCREF( tmp_tuple_element_1 );
                PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
                tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_make_exception_arg_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 617;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                frame_1560700e571808ac63152799e0da7758->m_frame.f_lineno = 616;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_2 );
                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 616;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            branch_no_5:;
        }
        branch_end_4:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1560700e571808ac63152799e0da7758 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1560700e571808ac63152799e0da7758 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1560700e571808ac63152799e0da7758, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1560700e571808ac63152799e0da7758->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1560700e571808ac63152799e0da7758, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1560700e571808ac63152799e0da7758,
        type_description_1,
        par_obj,
        var_fd,
        var_meth
    );


    // Release cached frame.
    if ( frame_1560700e571808ac63152799e0da7758 == cache_frame_1560700e571808ac63152799e0da7758 )
    {
        Py_DECREF( frame_1560700e571808ac63152799e0da7758 );
    }
    cache_frame_1560700e571808ac63152799e0da7758 = NULL;

    assertFrameObject( frame_1560700e571808ac63152799e0da7758 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_fd );
    tmp_return_value = var_fd;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__asFileDescriptor );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_fd );
    Py_DECREF( var_fd );
    var_fd = NULL;

    Py_XDECREF( var_meth );
    var_meth = NULL;

    Py_XDECREF( par_obj );
    par_obj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_fd );
    var_fd = NULL;

    Py_XDECREF( var_meth );
    var_meth = NULL;

    Py_XDECREF( par_obj );
    par_obj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_9__asFileDescriptor );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_10_SSLeay_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_204254c22f810b893ed5f77ec88d6f93;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_204254c22f810b893ed5f77ec88d6f93 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_204254c22f810b893ed5f77ec88d6f93, codeobj_204254c22f810b893ed5f77ec88d6f93, module_OpenSSL$SSL, sizeof(void *) );
    frame_204254c22f810b893ed5f77ec88d6f93 = cache_frame_204254c22f810b893ed5f77ec88d6f93;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_204254c22f810b893ed5f77ec88d6f93 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_204254c22f810b893ed5f77ec88d6f93 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_type );
        tmp_args_element_name_2 = par_type;
        frame_204254c22f810b893ed5f77ec88d6f93->m_frame.f_lineno = 628;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSLeay_version, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_204254c22f810b893ed5f77ec88d6f93->m_frame.f_lineno = 628;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 628;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_204254c22f810b893ed5f77ec88d6f93 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_204254c22f810b893ed5f77ec88d6f93 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_204254c22f810b893ed5f77ec88d6f93 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_204254c22f810b893ed5f77ec88d6f93, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_204254c22f810b893ed5f77ec88d6f93->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_204254c22f810b893ed5f77ec88d6f93, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_204254c22f810b893ed5f77ec88d6f93,
        type_description_1,
        par_type
    );


    // Release cached frame.
    if ( frame_204254c22f810b893ed5f77ec88d6f93 == cache_frame_204254c22f810b893ed5f77ec88d6f93 )
    {
        Py_DECREF( frame_204254c22f810b893ed5f77ec88d6f93 );
    }
    cache_frame_204254c22f810b893ed5f77ec88d6f93 = NULL;

    assertFrameObject( frame_204254c22f810b893ed5f77ec88d6f93 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_10_SSLeay_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_10_SSLeay_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_11__make_requires( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_flag = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_error = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var__requires_decorator = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_error;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] = par_flag;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[1] );


        assert( var__requires_decorator == NULL );
        var__requires_decorator = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT( var__requires_decorator );
    tmp_return_value = var__requires_decorator;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11__make_requires );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_flag );
    Py_DECREF( par_flag );
    par_flag = NULL;

    CHECK_OBJECT( (PyObject *)var__requires_decorator );
    Py_DECREF( var__requires_decorator );
    var__requires_decorator = NULL;

    CHECK_OBJECT( (PyObject *)par_error );
    Py_DECREF( par_error );
    par_error = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11__make_requires );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_func = python_pars[ 0 ];
    PyObject *var_explode = NULL;
    struct Nuitka_FrameObject *frame_074a5e32739c565bb89c90a9ea0fbc5d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_074a5e32739c565bb89c90a9ea0fbc5d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_074a5e32739c565bb89c90a9ea0fbc5d, codeobj_074a5e32739c565bb89c90a9ea0fbc5d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_074a5e32739c565bb89c90a9ea0fbc5d = cache_frame_074a5e32739c565bb89c90a9ea0fbc5d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_074a5e32739c565bb89c90a9ea0fbc5d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_074a5e32739c565bb89c90a9ea0fbc5d ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        if ( PyCell_GET( self->m_closure[1] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "flag" );
            exception_tb = NULL;

            exception_lineno = 642;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_operand_name_1 = PyCell_GET( self->m_closure[1] );
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 642;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
                exception_tb = NULL;

                exception_lineno = 643;
                type_description_1 = "ooc";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_1;
            CHECK_OBJECT( par_func );
            tmp_args_element_name_1 = par_func;
            frame_074a5e32739c565bb89c90a9ea0fbc5d->m_frame.f_lineno = 643;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 643;
                type_description_1 = "ooc";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode(  );

            ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = self->m_closure[0];
            Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );


            frame_074a5e32739c565bb89c90a9ea0fbc5d->m_frame.f_lineno = 643;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 643;
                type_description_1 = "ooc";
                goto frame_exception_exit_1;
            }
            assert( var_explode == NULL );
            var_explode = tmp_assign_source_1;
        }
        CHECK_OBJECT( var_explode );
        tmp_return_value = var_explode;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        CHECK_OBJECT( par_func );
        tmp_return_value = par_func;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_074a5e32739c565bb89c90a9ea0fbc5d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_074a5e32739c565bb89c90a9ea0fbc5d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_074a5e32739c565bb89c90a9ea0fbc5d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_074a5e32739c565bb89c90a9ea0fbc5d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_074a5e32739c565bb89c90a9ea0fbc5d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_074a5e32739c565bb89c90a9ea0fbc5d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_074a5e32739c565bb89c90a9ea0fbc5d,
        type_description_1,
        par_func,
        var_explode,
        self->m_closure[1]
    );


    // Release cached frame.
    if ( frame_074a5e32739c565bb89c90a9ea0fbc5d == cache_frame_074a5e32739c565bb89c90a9ea0fbc5d )
    {
        Py_DECREF( frame_074a5e32739c565bb89c90a9ea0fbc5d );
    }
    cache_frame_074a5e32739c565bb89c90a9ea0fbc5d = NULL;

    assertFrameObject( frame_074a5e32739c565bb89c90a9ea0fbc5d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_explode );
    var_explode = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwargs = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_19e73d50ebb8a5ae5b740ae60c6415e2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_19e73d50ebb8a5ae5b740ae60c6415e2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_19e73d50ebb8a5ae5b740ae60c6415e2, codeobj_19e73d50ebb8a5ae5b740ae60c6415e2, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_19e73d50ebb8a5ae5b740ae60c6415e2 = cache_frame_19e73d50ebb8a5ae5b740ae60c6415e2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_19e73d50ebb8a5ae5b740ae60c6415e2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_19e73d50ebb8a5ae5b740ae60c6415e2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "error" );
            exception_tb = NULL;

            exception_lineno = 645;
            type_description_1 = "ooc";
            goto frame_exception_exit_1;
        }

        tmp_make_exception_arg_1 = PyCell_GET( self->m_closure[0] );
        frame_19e73d50ebb8a5ae5b740ae60c6415e2->m_frame.f_lineno = 645;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 645;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooc";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19e73d50ebb8a5ae5b740ae60c6415e2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19e73d50ebb8a5ae5b740ae60c6415e2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_19e73d50ebb8a5ae5b740ae60c6415e2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_19e73d50ebb8a5ae5b740ae60c6415e2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_19e73d50ebb8a5ae5b740ae60c6415e2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_19e73d50ebb8a5ae5b740ae60c6415e2,
        type_description_1,
        par_args,
        par_kwargs,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_19e73d50ebb8a5ae5b740ae60c6415e2 == cache_frame_19e73d50ebb8a5ae5b740ae60c6415e2 )
    {
        Py_DECREF( frame_19e73d50ebb8a5ae5b740ae60c6415e2 );
    }
    cache_frame_19e73d50ebb8a5ae5b740ae60c6415e2 = NULL;

    assertFrameObject( frame_19e73d50ebb8a5ae5b740ae60c6415e2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}



struct OpenSSL$SSL$$$genexpr_1_genexpr_locals {
    PyObject *var_identifier;
    PyObject *var_name;
    PyObject *tmp_iter_value_0;
    PyObject *tmp_tuple_unpack_1__element_1;
    PyObject *tmp_tuple_unpack_1__element_2;
    PyObject *tmp_tuple_unpack_1__source_iter;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    int exception_keeper_lineno_4;
};

static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct OpenSSL$SSL$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_identifier = NULL;
    generator_heap->var_name = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_cec7563bb25263789866daaecc893973, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Noo";
                generator_heap->exception_lineno = 696;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_iter_arg_1 = generator_heap->tmp_iter_value_0;
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 696;
            generator_heap->type_description_1 = "Noo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = generator_heap->tmp_tuple_unpack_1__source_iter;
            generator_heap->tmp_tuple_unpack_1__source_iter = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = generator_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                generator_heap->exception_type = PyExc_StopIteration;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = NULL;
                generator_heap->exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            }


            generator_heap->type_description_1 = "Noo";
            generator_heap->exception_lineno = 696;
            goto try_except_handler_4;
        }
        {
            PyObject *old = generator_heap->tmp_tuple_unpack_1__element_1;
            generator_heap->tmp_tuple_unpack_1__element_1 = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = generator_heap->tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                generator_heap->exception_type = PyExc_StopIteration;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = NULL;
                generator_heap->exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            }


            generator_heap->type_description_1 = "Noo";
            generator_heap->exception_lineno = 696;
            goto try_except_handler_4;
        }
        {
            PyObject *old = generator_heap->tmp_tuple_unpack_1__element_2;
            generator_heap->tmp_tuple_unpack_1__element_2 = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = generator_heap->tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        generator_heap->tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( generator_heap->tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

                    generator_heap->type_description_1 = "Noo";
                    generator_heap->exception_lineno = 696;
                    goto try_except_handler_4;
                }
            }
        }
        else
        {
            Py_DECREF( generator_heap->tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );

            generator_heap->type_description_1 = "Noo";
            generator_heap->exception_lineno = 696;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_1__source_iter );
    Py_DECREF( generator_heap->tmp_tuple_unpack_1__source_iter );
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_1 );
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_2 );
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)generator_heap->tmp_tuple_unpack_1__source_iter );
    Py_DECREF( generator_heap->tmp_tuple_unpack_1__source_iter );
    generator_heap->tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_5 = generator_heap->tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = generator_heap->var_identifier;
            generator_heap->var_identifier = tmp_assign_source_5;
            Py_INCREF( generator_heap->var_identifier );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_1 );
    generator_heap->tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( generator_heap->tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_6 = generator_heap->tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = generator_heap->var_name;
            generator_heap->var_name = tmp_assign_source_6;
            Py_INCREF( generator_heap->var_name );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( generator_heap->tmp_tuple_unpack_1__element_2 );
    generator_heap->tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_getattr_attr_1;
        PyObject *tmp_getattr_default_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 698;
            generator_heap->type_description_1 = "Noo";
            goto try_except_handler_2;
        }

        tmp_getattr_target_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_name );
        tmp_getattr_attr_1 = generator_heap->var_name;
        tmp_getattr_default_1 = Py_None;
        tmp_compexpr_left_1 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 698;
            generator_heap->type_description_1 = "Noo";
            goto try_except_handler_2;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_expression_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_getattr_target_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_getattr_attr_2;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            CHECK_OBJECT( generator_heap->var_identifier );
            tmp_tuple_element_1 = generator_heap->var_identifier;
            tmp_expression_name_1 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_2 == NULL )
            {
                Py_DECREF( tmp_expression_name_1 );
                generator_heap->exception_type = PyExc_NameError;
                Py_INCREF( generator_heap->exception_type );
                generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                generator_heap->exception_tb = NULL;

                generator_heap->exception_lineno = 696;
                generator_heap->type_description_1 = "Noo";
                goto try_except_handler_2;
            }

            tmp_getattr_target_2 = tmp_mvar_value_2;
            CHECK_OBJECT( generator_heap->var_name );
            tmp_getattr_attr_2 = generator_heap->var_name;
            tmp_tuple_element_1 = BUILTIN_GETATTR( tmp_getattr_target_2, tmp_getattr_attr_2, NULL );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                Py_DECREF( tmp_expression_name_1 );

                generator_heap->exception_lineno = 696;
                generator_heap->type_description_1 = "Noo";
                goto try_except_handler_2;
            }
            PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
            Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_getattr_target_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_getattr_attr_1, sizeof(PyObject *), &tmp_getattr_default_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_getattr_target_2, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_getattr_attr_2, sizeof(PyObject *), NULL );
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_getattr_target_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_getattr_attr_1, sizeof(PyObject *), &tmp_getattr_default_1, sizeof(PyObject *), &tmp_tuple_element_1, sizeof(PyObject *), &tmp_getattr_target_2, sizeof(PyObject *), &tmp_mvar_value_2, sizeof(PyObject *), &tmp_getattr_attr_2, sizeof(PyObject *), NULL );
            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 696;
                generator_heap->type_description_1 = "Noo";
                goto try_except_handler_2;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 696;
        generator_heap->type_description_1 = "Noo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_3 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_3 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_3 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_3 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_3;
    generator_heap->exception_value = generator_heap->exception_keeper_value_3;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_3;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_identifier,
            generator_heap->var_name
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_4 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_4 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_4 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_4 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_identifier );
    generator_heap->var_identifier = NULL;

    Py_XDECREF( generator_heap->var_name );
    generator_heap->var_name = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_4;
    generator_heap->exception_value = generator_heap->exception_keeper_value_4;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_4;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:
    try_end_4:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_identifier );
    generator_heap->var_identifier = NULL;

    Py_XDECREF( generator_heap->var_name );
    generator_heap->var_name = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *OpenSSL$SSL$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_cec7563bb25263789866daaecc893973,
        1,
        sizeof(struct OpenSSL$SSL$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_12___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_method = python_pars[ 1 ];
    PyObject *var_method_obj = NULL;
    PyObject *var_res = NULL;
    PyObject *var_context = NULL;
    PyObject *var_method_func = NULL;
    struct Nuitka_FrameObject *frame_075afde1753398fa4800587279bd54f8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_075afde1753398fa4800587279bd54f8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_075afde1753398fa4800587279bd54f8, codeobj_075afde1753398fa4800587279bd54f8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_075afde1753398fa4800587279bd54f8 = cache_frame_075afde1753398fa4800587279bd54f8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_075afde1753398fa4800587279bd54f8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_075afde1753398fa4800587279bd54f8 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_method );
        tmp_isinstance_inst_1 = par_method;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 701;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 701;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 701;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c8e9b5ff5b00d8190ecae28b8a410248;
            frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 702;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 702;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__methods );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 705;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_method );
        tmp_subscript_name_1 = par_method;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 705;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        assert( var_method_func == NULL );
        var_method_func = tmp_assign_source_1;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_075afde1753398fa4800587279bd54f8 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_075afde1753398fa4800587279bd54f8, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_075afde1753398fa4800587279bd54f8, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_KeyError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 706;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_685ba6a7380a18939915178358979194;
            frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 707;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 707;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 704;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_075afde1753398fa4800587279bd54f8->m_frame) frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        branch_end_2:;
    }
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT( var_method_func );
        tmp_called_name_1 = var_method_func;
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 709;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 709;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_method_obj == NULL );
        var_method_obj = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_method_obj );
        tmp_compexpr_left_2 = var_method_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 710;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 710;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 712;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT( var_method_obj );
        tmp_args_element_name_2 = var_method_obj;
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 712;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSL_CTX_new, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 712;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_context == NULL );
        var_context = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        CHECK_OBJECT( var_context );
        tmp_compexpr_left_3 = var_context;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 713;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 713;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_context );
        tmp_args_element_name_4 = var_context;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SSL_CTX_free );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 714;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 714;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_context;
            assert( old != NULL );
            var_context = tmp_assign_source_4;
            Py_DECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 720;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_2 = tmp_mvar_value_9;
        CHECK_OBJECT( var_context );
        tmp_args_element_name_6 = var_context;
        tmp_args_element_name_7 = const_int_pos_1;
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 720;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_SSL_CTX_set_ecdh_auto, call_args );
        }

        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 720;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        assert( var_res == NULL );
        var_res = tmp_assign_source_5;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 721;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_name_5 = tmp_mvar_value_10;
        CHECK_OBJECT( var_res );
        tmp_compexpr_left_4 = var_res;
        tmp_compexpr_right_4 = const_int_pos_1;
        tmp_args_element_name_8 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 721;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 721;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 721;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_075afde1753398fa4800587279bd54f8 );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_075afde1753398fa4800587279bd54f8, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_075afde1753398fa4800587279bd54f8, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        tmp_compexpr_left_5 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_5 = PyExc_AttributeError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 722;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 722;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 719;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_075afde1753398fa4800587279bd54f8->m_frame) frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        branch_no_3:;
    }
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_12___init__ );
    return NULL;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( var_context );
        tmp_assattr_name_1 = var_context;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 725;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__passphrase_helper, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 726;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__passphrase_callback, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 727;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__passphrase_userdata, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 728;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        tmp_assattr_name_5 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__verify_helper, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 729;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        tmp_assattr_name_6 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain__verify_callback, tmp_assattr_name_6 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 730;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_7;
        PyObject *tmp_assattr_target_7;
        tmp_assattr_name_7 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_7 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain__info_callback, tmp_assattr_name_7 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 731;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_assattr_target_8;
        tmp_assattr_name_8 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain__tlsext_servername_callback, tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 732;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        tmp_assattr_name_9 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__app_data, tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 733;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_assattr_target_10;
        tmp_assattr_name_10 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__npn_advertise_helper, tmp_assattr_name_10 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 734;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_assattr_target_11;
        tmp_assattr_name_11 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain__npn_advertise_callback, tmp_assattr_name_11 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 735;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_12;
        PyObject *tmp_assattr_target_12;
        tmp_assattr_name_12 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_12 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain__npn_select_helper, tmp_assattr_name_12 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 736;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_13;
        PyObject *tmp_assattr_target_13;
        tmp_assattr_name_13 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_13 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_13, const_str_plain__npn_select_callback, tmp_assattr_name_13 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 737;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_14;
        PyObject *tmp_assattr_target_14;
        tmp_assattr_name_14 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_14 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_14, const_str_plain__alpn_select_helper, tmp_assattr_name_14 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 738;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_15;
        PyObject *tmp_assattr_target_15;
        tmp_assattr_name_15 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_15 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_15, const_str_plain__alpn_select_callback, tmp_assattr_name_15 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 739;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_16;
        PyObject *tmp_assattr_target_16;
        tmp_assattr_name_16 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_16 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_16, const_str_plain__ocsp_helper, tmp_assattr_name_16 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 740;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_17;
        PyObject *tmp_assattr_target_17;
        tmp_assattr_name_17 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_17 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_17, const_str_plain__ocsp_callback, tmp_assattr_name_17 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 741;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_18;
        PyObject *tmp_assattr_target_18;
        tmp_assattr_name_18 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_18 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_18, const_str_plain__ocsp_data, tmp_assattr_name_18 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 742;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_set_mode );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_11 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_MODE_ENABLE_PARTIAL_WRITE );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_075afde1753398fa4800587279bd54f8->m_frame.f_lineno = 744;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 744;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_075afde1753398fa4800587279bd54f8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_075afde1753398fa4800587279bd54f8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_075afde1753398fa4800587279bd54f8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_075afde1753398fa4800587279bd54f8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_075afde1753398fa4800587279bd54f8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_075afde1753398fa4800587279bd54f8,
        type_description_1,
        par_self,
        par_method,
        var_method_obj,
        var_res,
        var_context,
        var_method_func
    );


    // Release cached frame.
    if ( frame_075afde1753398fa4800587279bd54f8 == cache_frame_075afde1753398fa4800587279bd54f8 )
    {
        Py_DECREF( frame_075afde1753398fa4800587279bd54f8 );
    }
    cache_frame_075afde1753398fa4800587279bd54f8 = NULL;

    assertFrameObject( frame_075afde1753398fa4800587279bd54f8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_12___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_method_obj );
    Py_DECREF( var_method_obj );
    var_method_obj = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_context );
    Py_DECREF( var_context );
    var_context = NULL;

    CHECK_OBJECT( (PyObject *)par_method );
    Py_DECREF( par_method );
    par_method = NULL;

    CHECK_OBJECT( (PyObject *)var_method_func );
    Py_DECREF( var_method_func );
    var_method_func = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_method_obj );
    var_method_obj = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_context );
    var_context = NULL;

    CHECK_OBJECT( (PyObject *)par_method );
    Py_DECREF( par_method );
    par_method = NULL;

    Py_XDECREF( var_method_func );
    var_method_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_12___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_13_load_verify_locations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cafile = python_pars[ 1 ];
    PyObject *par_capath = python_pars[ 2 ];
    PyObject *var_load_result = NULL;
    struct Nuitka_FrameObject *frame_31c49f0051a1276b7d55df95d6624040;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_31c49f0051a1276b7d55df95d6624040 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_31c49f0051a1276b7d55df95d6624040, codeobj_31c49f0051a1276b7d55df95d6624040, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_31c49f0051a1276b7d55df95d6624040 = cache_frame_31c49f0051a1276b7d55df95d6624040;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_31c49f0051a1276b7d55df95d6624040 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_31c49f0051a1276b7d55df95d6624040 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_cafile );
        tmp_compexpr_left_1 = par_cafile;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 763;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_1;
            tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 763;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_cafile;
                assert( old != NULL );
                par_cafile = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
                exception_tb = NULL;

                exception_lineno = 765;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_cafile );
            tmp_args_element_name_1 = par_cafile;
            frame_31c49f0051a1276b7d55df95d6624040->m_frame.f_lineno = 765;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 765;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_cafile;
                assert( old != NULL );
                par_cafile = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_capath );
        tmp_compexpr_left_2 = par_capath;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 768;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 768;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_capath;
                assert( old != NULL );
                par_capath = tmp_assign_source_3;
                Py_DECREF( old );
            }

        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
                exception_tb = NULL;

                exception_lineno = 770;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_4;
            CHECK_OBJECT( par_capath );
            tmp_args_element_name_2 = par_capath;
            frame_31c49f0051a1276b7d55df95d6624040->m_frame.f_lineno = 770;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 770;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_capath;
                assert( old != NULL );
                par_capath = tmp_assign_source_4;
                Py_DECREF( old );
            }

        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 772;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_load_verify_locations );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 772;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 773;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cafile );
        tmp_args_element_name_4 = par_cafile;
        CHECK_OBJECT( par_capath );
        tmp_args_element_name_5 = par_capath;
        frame_31c49f0051a1276b7d55df95d6624040->m_frame.f_lineno = 772;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 772;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_load_result == NULL );
        var_load_result = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_load_result );
        tmp_operand_name_1 = var_load_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 775;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 776;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_6;
            frame_31c49f0051a1276b7d55df95d6624040->m_frame.f_lineno = 776;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 776;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31c49f0051a1276b7d55df95d6624040 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_31c49f0051a1276b7d55df95d6624040 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_31c49f0051a1276b7d55df95d6624040, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_31c49f0051a1276b7d55df95d6624040->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_31c49f0051a1276b7d55df95d6624040, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_31c49f0051a1276b7d55df95d6624040,
        type_description_1,
        par_self,
        par_cafile,
        par_capath,
        var_load_result
    );


    // Release cached frame.
    if ( frame_31c49f0051a1276b7d55df95d6624040 == cache_frame_31c49f0051a1276b7d55df95d6624040 )
    {
        Py_DECREF( frame_31c49f0051a1276b7d55df95d6624040 );
    }
    cache_frame_31c49f0051a1276b7d55df95d6624040 = NULL;

    assertFrameObject( frame_31c49f0051a1276b7d55df95d6624040 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_13_load_verify_locations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_capath );
    Py_DECREF( par_capath );
    par_capath = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    CHECK_OBJECT( (PyObject *)var_load_result );
    Py_DECREF( var_load_result );
    var_load_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_capath );
    par_capath = NULL;

    Py_XDECREF( par_cafile );
    par_cafile = NULL;

    Py_XDECREF( var_load_result );
    var_load_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_13_load_verify_locations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_14__wrap_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_55c43580106a1e6e54d95041d3a9eb77;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_55c43580106a1e6e54d95041d3a9eb77 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_55c43580106a1e6e54d95041d3a9eb77, codeobj_55c43580106a1e6e54d95041d3a9eb77, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_55c43580106a1e6e54d95041d3a9eb77 = cache_frame_55c43580106a1e6e54d95041d3a9eb77;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_55c43580106a1e6e54d95041d3a9eb77 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_55c43580106a1e6e54d95041d3a9eb77 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 779;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_1 = PyCell_GET( par_callback );
        frame_55c43580106a1e6e54d95041d3a9eb77->m_frame.f_lineno = 779;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 779;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );
        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[1] );


        frame_55c43580106a1e6e54d95041d3a9eb77->m_frame.f_lineno = 779;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 779;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_kw_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_PassphraseHelper" );
            exception_tb = NULL;

            exception_lineno = 782;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 783;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_3;
        tmp_args_name_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( var_wrapper );
        tmp_tuple_element_1 = var_wrapper;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
        tmp_kw_name_1 = PyDict_Copy( const_dict_4a96d2f6310f0842d222254905a83466 );
        frame_55c43580106a1e6e54d95041d3a9eb77->m_frame.f_lineno = 782;
        tmp_return_value = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 782;
            type_description_1 = "cco";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55c43580106a1e6e54d95041d3a9eb77 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_55c43580106a1e6e54d95041d3a9eb77 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55c43580106a1e6e54d95041d3a9eb77 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_55c43580106a1e6e54d95041d3a9eb77, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_55c43580106a1e6e54d95041d3a9eb77->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_55c43580106a1e6e54d95041d3a9eb77, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_55c43580106a1e6e54d95041d3a9eb77,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_55c43580106a1e6e54d95041d3a9eb77 == cache_frame_55c43580106a1e6e54d95041d3a9eb77 )
    {
        Py_DECREF( frame_55c43580106a1e6e54d95041d3a9eb77 );
    }
    cache_frame_55c43580106a1e6e54d95041d3a9eb77 = NULL;

    assertFrameObject( frame_55c43580106a1e6e54d95041d3a9eb77 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_14__wrap_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_14__wrap_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_size = python_pars[ 0 ];
    PyObject *par_verify = python_pars[ 1 ];
    PyObject *par_userdata = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_e318d411854900096ecb90aa4ea274a9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e318d411854900096ecb90aa4ea274a9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e318d411854900096ecb90aa4ea274a9, codeobj_e318d411854900096ecb90aa4ea274a9, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e318d411854900096ecb90aa4ea274a9 = cache_frame_e318d411854900096ecb90aa4ea274a9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e318d411854900096ecb90aa4ea274a9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e318d411854900096ecb90aa4ea274a9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( par_size );
        tmp_args_element_name_1 = par_size;
        CHECK_OBJECT( par_verify );
        tmp_args_element_name_2 = par_verify;
        if ( PyCell_GET( self->m_closure[1] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            exception_tb = NULL;

            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( self->m_closure[1] );
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase_userdata );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }
        frame_e318d411854900096ecb90aa4ea274a9->m_frame.f_lineno = 781;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 781;
            type_description_1 = "ooocc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e318d411854900096ecb90aa4ea274a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e318d411854900096ecb90aa4ea274a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e318d411854900096ecb90aa4ea274a9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e318d411854900096ecb90aa4ea274a9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e318d411854900096ecb90aa4ea274a9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e318d411854900096ecb90aa4ea274a9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e318d411854900096ecb90aa4ea274a9,
        type_description_1,
        par_size,
        par_verify,
        par_userdata,
        self->m_closure[1],
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_e318d411854900096ecb90aa4ea274a9 == cache_frame_e318d411854900096ecb90aa4ea274a9 )
    {
        Py_DECREF( frame_e318d411854900096ecb90aa4ea274a9 );
    }
    cache_frame_e318d411854900096ecb90aa4ea274a9 = NULL;

    assertFrameObject( frame_e318d411854900096ecb90aa4ea274a9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_verify );
    Py_DECREF( par_verify );
    par_verify = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_verify );
    Py_DECREF( par_verify );
    par_verify = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_15_set_passwd_cb( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_userdata = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_5411f7a0e5a468d33cbabda972ebdebe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_5411f7a0e5a468d33cbabda972ebdebe = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5411f7a0e5a468d33cbabda972ebdebe, codeobj_5411f7a0e5a468d33cbabda972ebdebe, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5411f7a0e5a468d33cbabda972ebdebe = cache_frame_5411f7a0e5a468d33cbabda972ebdebe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5411f7a0e5a468d33cbabda972ebdebe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5411f7a0e5a468d33cbabda972ebdebe ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
        assert( tmp_called_name_1 != NULL );
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_5411f7a0e5a468d33cbabda972ebdebe->m_frame.f_lineno = 804;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 804;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 804;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_3462bf983701fbd7caf2f521f5975fff;
            frame_5411f7a0e5a468d33cbabda972ebdebe->m_frame.f_lineno = 805;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 805;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_2 = par_callback;
        frame_5411f7a0e5a468d33cbabda972ebdebe->m_frame.f_lineno = 807;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__wrap_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 807;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__passphrase_helper, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 807;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__passphrase_helper );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 808;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 808;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__passphrase_callback, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 808;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 809;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_default_passwd_cb );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 809;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 810;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__passphrase_callback );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 810;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5411f7a0e5a468d33cbabda972ebdebe->m_frame.f_lineno = 809;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 809;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_userdata );
        tmp_assattr_name_3 = par_userdata;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__passphrase_userdata, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 811;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5411f7a0e5a468d33cbabda972ebdebe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5411f7a0e5a468d33cbabda972ebdebe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5411f7a0e5a468d33cbabda972ebdebe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5411f7a0e5a468d33cbabda972ebdebe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5411f7a0e5a468d33cbabda972ebdebe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5411f7a0e5a468d33cbabda972ebdebe,
        type_description_1,
        par_self,
        par_callback,
        par_userdata
    );


    // Release cached frame.
    if ( frame_5411f7a0e5a468d33cbabda972ebdebe == cache_frame_5411f7a0e5a468d33cbabda972ebdebe )
    {
        Py_DECREF( frame_5411f7a0e5a468d33cbabda972ebdebe );
    }
    cache_frame_5411f7a0e5a468d33cbabda972ebdebe = NULL;

    assertFrameObject( frame_5411f7a0e5a468d33cbabda972ebdebe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_15_set_passwd_cb );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_15_set_passwd_cb );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_16_set_default_verify_paths( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_default_dir = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_dir_env_var = NULL;
    PyObject *var_file_env_var = NULL;
    PyObject *var_default_file = NULL;
    struct Nuitka_FrameObject *frame_1f9c33e10eab708a76d6954065cc1282;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1f9c33e10eab708a76d6954065cc1282 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1f9c33e10eab708a76d6954065cc1282, codeobj_1f9c33e10eab708a76d6954065cc1282, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1f9c33e10eab708a76d6954065cc1282 = cache_frame_1f9c33e10eab708a76d6954065cc1282;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1f9c33e10eab708a76d6954065cc1282 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1f9c33e10eab708a76d6954065cc1282 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_default_verify_paths );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 833;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 833;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_set_result == NULL );
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 834;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_set_result );
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_2 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 834;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 834;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 834;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_string );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 841;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 841;
        tmp_args_element_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_X509_get_default_cert_dir_env );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 841;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 840;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_called_instance_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 840;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 840;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_dir_env_var == NULL );
        var_dir_env_var = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_string );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 844;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_6;
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 844;
        tmp_args_element_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_X509_get_default_cert_file_env );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 844;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 843;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_called_instance_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_called_instance_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 843;
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_3 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 843;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_file_env_var == NULL );
        var_file_env_var = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT( par_self );
        tmp_called_instance_5 = par_self;
        CHECK_OBJECT( var_dir_env_var );
        tmp_args_element_name_5 = var_dir_env_var;
        CHECK_OBJECT( var_file_env_var );
        tmp_args_element_name_6 = var_file_env_var;
        frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 846;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_operand_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_5, const_str_plain__check_env_vars_set, call_args );
        }

        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 846;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 846;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_called_instance_6;
            PyObject *tmp_mvar_value_8;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_7;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_string );
            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_8 == NULL )
            {
                Py_DECREF( tmp_called_name_5 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_6 = tmp_mvar_value_8;
            frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 847;
            tmp_args_element_name_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_X509_get_default_cert_dir );
            if ( tmp_args_element_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 847;
            {
                PyObject *call_args[] = { tmp_args_element_name_7 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 847;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_default_dir == NULL );
            var_default_dir = tmp_assign_source_4;
        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_called_instance_7;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_9;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_string );
            if ( tmp_called_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_10 == NULL )
            {
                Py_DECREF( tmp_called_name_6 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_7 = tmp_mvar_value_10;
            frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 848;
            tmp_args_element_name_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_X509_get_default_cert_file );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_6 );

                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 848;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_called_name_6 );
            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 848;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_default_file == NULL );
            var_default_file = tmp_assign_source_5;
        }
        {
            nuitka_bool tmp_condition_result_2;
            int tmp_and_left_truth_1;
            nuitka_bool tmp_and_left_value_1;
            nuitka_bool tmp_and_right_value_1;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_12;
            CHECK_OBJECT( var_default_dir );
            tmp_compexpr_left_2 = var_default_dir;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CRYPTOGRAPHY_MANYLINUX1_CA_DIR" );
                exception_tb = NULL;

                exception_lineno = 853;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_11;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 853;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_1 == 1 )
            {
                goto and_right_1;
            }
            else
            {
                goto and_left_1;
            }
            and_right_1:;
            CHECK_OBJECT( var_default_file );
            tmp_compexpr_left_3 = var_default_file;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CRYPTOGRAPHY_MANYLINUX1_CA_FILE" );
                exception_tb = NULL;

                exception_lineno = 854;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_12;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 854;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_2 = tmp_and_right_value_1;
            goto and_end_1;
            and_left_1:;
            tmp_condition_result_2 = tmp_and_left_value_1;
            and_end_1:;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_name_7;
                PyObject *tmp_source_name_7;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_9;
                PyObject *tmp_mvar_value_13;
                PyObject *tmp_args_element_name_10;
                PyObject *tmp_mvar_value_14;
                CHECK_OBJECT( par_self );
                tmp_source_name_7 = par_self;
                tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__fallback_default_verify_paths );
                if ( tmp_called_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 857;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS );

                if (unlikely( tmp_mvar_value_13 == NULL ))
                {
                    tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS );
                }

                if ( tmp_mvar_value_13 == NULL )
                {
                    Py_DECREF( tmp_called_name_7 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CERTIFICATE_FILE_LOCATIONS" );
                    exception_tb = NULL;

                    exception_lineno = 858;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }

                tmp_args_element_name_9 = tmp_mvar_value_13;
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS );

                if (unlikely( tmp_mvar_value_14 == NULL ))
                {
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS );
                }

                if ( tmp_mvar_value_14 == NULL )
                {
                    Py_DECREF( tmp_called_name_7 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_CERTIFICATE_PATH_LOCATIONS" );
                    exception_tb = NULL;

                    exception_lineno = 859;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }

                tmp_args_element_name_10 = tmp_mvar_value_14;
                frame_1f9c33e10eab708a76d6954065cc1282->m_frame.f_lineno = 857;
                {
                    PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
                }

                Py_DECREF( tmp_called_name_7 );
                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 857;
                    type_description_1 = "oooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_no_2:;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f9c33e10eab708a76d6954065cc1282 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f9c33e10eab708a76d6954065cc1282 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1f9c33e10eab708a76d6954065cc1282, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1f9c33e10eab708a76d6954065cc1282->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1f9c33e10eab708a76d6954065cc1282, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1f9c33e10eab708a76d6954065cc1282,
        type_description_1,
        par_self,
        var_default_dir,
        var_set_result,
        var_dir_env_var,
        var_file_env_var,
        var_default_file
    );


    // Release cached frame.
    if ( frame_1f9c33e10eab708a76d6954065cc1282 == cache_frame_1f9c33e10eab708a76d6954065cc1282 )
    {
        Py_DECREF( frame_1f9c33e10eab708a76d6954065cc1282 );
    }
    cache_frame_1f9c33e10eab708a76d6954065cc1282 = NULL;

    assertFrameObject( frame_1f9c33e10eab708a76d6954065cc1282 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_16_set_default_verify_paths );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_default_dir );
    var_default_dir = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    CHECK_OBJECT( (PyObject *)var_dir_env_var );
    Py_DECREF( var_dir_env_var );
    var_dir_env_var = NULL;

    CHECK_OBJECT( (PyObject *)var_file_env_var );
    Py_DECREF( var_file_env_var );
    var_file_env_var = NULL;

    Py_XDECREF( var_default_file );
    var_default_file = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_default_dir );
    var_default_dir = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    Py_XDECREF( var_dir_env_var );
    var_dir_env_var = NULL;

    Py_XDECREF( var_file_env_var );
    var_file_env_var = NULL;

    Py_XDECREF( var_default_file );
    var_default_file = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_16_set_default_verify_paths );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_17__check_env_vars_set( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_dir_env_var = python_pars[ 1 ];
    PyObject *par_file_env_var = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_1749b0d26efcd1f0dcbb3767913140b7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1749b0d26efcd1f0dcbb3767913140b7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1749b0d26efcd1f0dcbb3767913140b7, codeobj_1749b0d26efcd1f0dcbb3767913140b7, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1749b0d26efcd1f0dcbb3767913140b7 = cache_frame_1749b0d26efcd1f0dcbb3767913140b7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1749b0d26efcd1f0dcbb3767913140b7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1749b0d26efcd1f0dcbb3767913140b7 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
            exception_tb = NULL;

            exception_lineno = 869;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_environ );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 869;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_file_env_var );
        tmp_args_element_name_1 = par_file_env_var;
        frame_1749b0d26efcd1f0dcbb3767913140b7->m_frame.f_lineno = 869;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 869;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_or_left_value_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? Py_True : Py_False;
        Py_DECREF( tmp_compexpr_left_1 );
        tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
            exception_tb = NULL;

            exception_lineno = 870;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_environ );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 870;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_dir_env_var );
        tmp_args_element_name_2 = par_dir_env_var;
        frame_1749b0d26efcd1f0dcbb3767913140b7->m_frame.f_lineno = 870;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_compexpr_left_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_get, call_args );
        }

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 870;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_or_right_value_1 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? Py_True : Py_False;
        Py_DECREF( tmp_compexpr_left_2 );
        tmp_return_value = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_return_value = tmp_or_left_value_1;
        or_end_1:;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1749b0d26efcd1f0dcbb3767913140b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1749b0d26efcd1f0dcbb3767913140b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1749b0d26efcd1f0dcbb3767913140b7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1749b0d26efcd1f0dcbb3767913140b7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1749b0d26efcd1f0dcbb3767913140b7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1749b0d26efcd1f0dcbb3767913140b7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1749b0d26efcd1f0dcbb3767913140b7,
        type_description_1,
        par_self,
        par_dir_env_var,
        par_file_env_var
    );


    // Release cached frame.
    if ( frame_1749b0d26efcd1f0dcbb3767913140b7 == cache_frame_1749b0d26efcd1f0dcbb3767913140b7 )
    {
        Py_DECREF( frame_1749b0d26efcd1f0dcbb3767913140b7 );
    }
    cache_frame_1749b0d26efcd1f0dcbb3767913140b7 = NULL;

    assertFrameObject( frame_1749b0d26efcd1f0dcbb3767913140b7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_17__check_env_vars_set );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dir_env_var );
    Py_DECREF( par_dir_env_var );
    par_dir_env_var = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_file_env_var );
    Py_DECREF( par_file_env_var );
    par_file_env_var = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dir_env_var );
    Py_DECREF( par_dir_env_var );
    par_dir_env_var = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_file_env_var );
    Py_DECREF( par_file_env_var );
    par_file_env_var = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_17__check_env_vars_set );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_18__fallback_default_verify_paths( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_file_path = python_pars[ 1 ];
    PyObject *par_dir_path = python_pars[ 2 ];
    PyObject *var_capath = NULL;
    PyObject *var_cafile = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    struct Nuitka_FrameObject *frame_112a0593b8266700f63d535b5382f3e7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_112a0593b8266700f63d535b5382f3e7 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_112a0593b8266700f63d535b5382f3e7, codeobj_112a0593b8266700f63d535b5382f3e7, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_112a0593b8266700f63d535b5382f3e7 = cache_frame_112a0593b8266700f63d535b5382f3e7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_112a0593b8266700f63d535b5382f3e7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_112a0593b8266700f63d535b5382f3e7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_file_path );
        tmp_iter_arg_1 = par_file_path;
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 883;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                exception_lineno = 883;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_cafile;
            var_cafile = tmp_assign_source_3;
            Py_INCREF( var_cafile );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
            exception_tb = NULL;

            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_path );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_cafile );
        tmp_args_element_name_1 = var_cafile;
        frame_112a0593b8266700f63d535b5382f3e7->m_frame.f_lineno = 884;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_isfile, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 884;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( var_cafile );
            tmp_args_element_name_2 = var_cafile;
            frame_112a0593b8266700f63d535b5382f3e7->m_frame.f_lineno = 885;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_load_verify_locations, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 885;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto loop_end_1;
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 883;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( par_dir_path );
        tmp_iter_arg_2 = par_dir_path;
        tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 888;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_2__for_iterator == NULL );
        tmp_for_loop_2__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_2:;
    {
        PyObject *tmp_next_source_2;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_2__for_iterator );
        tmp_next_source_2 = tmp_for_loop_2__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_2;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                exception_lineno = 888;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_2__iter_value;
            tmp_for_loop_2__iter_value = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_2__iter_value );
        tmp_assign_source_6 = tmp_for_loop_2__iter_value;
        {
            PyObject *old = var_capath;
            var_capath = tmp_assign_source_6;
            Py_INCREF( var_capath );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_3;
        int tmp_truth_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
            exception_tb = NULL;

            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_path );
        if ( tmp_called_instance_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_capath );
        tmp_args_element_name_3 = var_capath;
        frame_112a0593b8266700f63d535b5382f3e7->m_frame.f_lineno = 889;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_isdir, call_args );
        }

        Py_DECREF( tmp_called_instance_3 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }
        tmp_truth_name_2 = CHECK_IF_TRUE( tmp_call_result_3 );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_3 );

            exception_lineno = 889;
            type_description_1 = "ooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_3 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_call_result_4;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( par_self );
            tmp_called_instance_4 = par_self;
            tmp_args_element_name_4 = Py_None;
            CHECK_OBJECT( var_capath );
            tmp_args_element_name_5 = var_capath;
            frame_112a0593b8266700f63d535b5382f3e7->m_frame.f_lineno = 890;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_call_result_4 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_load_verify_locations, call_args );
            }

            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 890;
                type_description_1 = "ooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        goto loop_end_2;
        branch_no_2:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 888;
        type_description_1 = "ooooo";
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_112a0593b8266700f63d535b5382f3e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_112a0593b8266700f63d535b5382f3e7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_112a0593b8266700f63d535b5382f3e7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_112a0593b8266700f63d535b5382f3e7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_112a0593b8266700f63d535b5382f3e7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_112a0593b8266700f63d535b5382f3e7,
        type_description_1,
        par_self,
        par_file_path,
        par_dir_path,
        var_capath,
        var_cafile
    );


    // Release cached frame.
    if ( frame_112a0593b8266700f63d535b5382f3e7 == cache_frame_112a0593b8266700f63d535b5382f3e7 )
    {
        Py_DECREF( frame_112a0593b8266700f63d535b5382f3e7 );
    }
    cache_frame_112a0593b8266700f63d535b5382f3e7 = NULL;

    assertFrameObject( frame_112a0593b8266700f63d535b5382f3e7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_18__fallback_default_verify_paths );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_capath );
    var_capath = NULL;

    Py_XDECREF( var_cafile );
    var_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_file_path );
    Py_DECREF( par_file_path );
    par_file_path = NULL;

    CHECK_OBJECT( (PyObject *)par_dir_path );
    Py_DECREF( par_dir_path );
    par_dir_path = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_capath );
    var_capath = NULL;

    Py_XDECREF( var_cafile );
    var_cafile = NULL;

    CHECK_OBJECT( (PyObject *)par_file_path );
    Py_DECREF( par_file_path );
    par_file_path = NULL;

    CHECK_OBJECT( (PyObject *)par_dir_path );
    Py_DECREF( par_dir_path );
    par_dir_path = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_18__fallback_default_verify_paths );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_19_use_certificate_chain_file( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certfile = python_pars[ 1 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_655c4c817ba68f8293b5e5f773a9c3b6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_655c4c817ba68f8293b5e5f773a9c3b6 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_655c4c817ba68f8293b5e5f773a9c3b6, codeobj_655c4c817ba68f8293b5e5f773a9c3b6, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_655c4c817ba68f8293b5e5f773a9c3b6 = cache_frame_655c4c817ba68f8293b5e5f773a9c3b6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_655c4c817ba68f8293b5e5f773a9c3b6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_655c4c817ba68f8293b5e5f773a9c3b6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
            exception_tb = NULL;

            exception_lineno = 902;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_certfile );
        tmp_args_element_name_1 = par_certfile;
        frame_655c4c817ba68f8293b5e5f773a9c3b6->m_frame.f_lineno = 902;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 902;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_certfile;
            assert( old != NULL );
            par_certfile = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 904;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate_chain_file );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 904;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 905;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_certfile );
        tmp_args_element_name_3 = par_certfile;
        frame_655c4c817ba68f8293b5e5f773a9c3b6->m_frame.f_lineno = 904;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 904;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_result );
        tmp_operand_name_1 = var_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 907;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 908;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_3;
            frame_655c4c817ba68f8293b5e5f773a9c3b6->m_frame.f_lineno = 908;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 908;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_655c4c817ba68f8293b5e5f773a9c3b6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_655c4c817ba68f8293b5e5f773a9c3b6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_655c4c817ba68f8293b5e5f773a9c3b6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_655c4c817ba68f8293b5e5f773a9c3b6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_655c4c817ba68f8293b5e5f773a9c3b6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_655c4c817ba68f8293b5e5f773a9c3b6,
        type_description_1,
        par_self,
        par_certfile,
        var_result
    );


    // Release cached frame.
    if ( frame_655c4c817ba68f8293b5e5f773a9c3b6 == cache_frame_655c4c817ba68f8293b5e5f773a9c3b6 )
    {
        Py_DECREF( frame_655c4c817ba68f8293b5e5f773a9c3b6 );
    }
    cache_frame_655c4c817ba68f8293b5e5f773a9c3b6 = NULL;

    assertFrameObject( frame_655c4c817ba68f8293b5e5f773a9c3b6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_19_use_certificate_chain_file );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_19_use_certificate_chain_file );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_20_use_certificate_file( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certfile = python_pars[ 1 ];
    PyObject *par_filetype = python_pars[ 2 ];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_0f658e91b4d3f853eeaf63330d1f8c09;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0f658e91b4d3f853eeaf63330d1f8c09 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0f658e91b4d3f853eeaf63330d1f8c09, codeobj_0f658e91b4d3f853eeaf63330d1f8c09, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0f658e91b4d3f853eeaf63330d1f8c09 = cache_frame_0f658e91b4d3f853eeaf63330d1f8c09;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0f658e91b4d3f853eeaf63330d1f8c09 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0f658e91b4d3f853eeaf63330d1f8c09 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
            exception_tb = NULL;

            exception_lineno = 922;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_certfile );
        tmp_args_element_name_1 = par_certfile;
        frame_0f658e91b4d3f853eeaf63330d1f8c09->m_frame.f_lineno = 922;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 922;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_certfile;
            assert( old != NULL );
            par_certfile = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_filetype );
        tmp_isinstance_inst_1 = par_filetype;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 923;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 923;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 923;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
            frame_0f658e91b4d3f853eeaf63330d1f8c09->m_frame.f_lineno = 924;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 924;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate_file );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 927;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_certfile );
        tmp_args_element_name_3 = par_certfile;
        CHECK_OBJECT( par_filetype );
        tmp_args_element_name_4 = par_filetype;
        frame_0f658e91b4d3f853eeaf63330d1f8c09->m_frame.f_lineno = 926;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_use_result == NULL );
        var_use_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_use_result );
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 929;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 930;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            frame_0f658e91b4d3f853eeaf63330d1f8c09->m_frame.f_lineno = 930;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 930;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f658e91b4d3f853eeaf63330d1f8c09 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f658e91b4d3f853eeaf63330d1f8c09 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0f658e91b4d3f853eeaf63330d1f8c09, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0f658e91b4d3f853eeaf63330d1f8c09->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0f658e91b4d3f853eeaf63330d1f8c09, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0f658e91b4d3f853eeaf63330d1f8c09,
        type_description_1,
        par_self,
        par_certfile,
        par_filetype,
        var_use_result
    );


    // Release cached frame.
    if ( frame_0f658e91b4d3f853eeaf63330d1f8c09 == cache_frame_0f658e91b4d3f853eeaf63330d1f8c09 )
    {
        Py_DECREF( frame_0f658e91b4d3f853eeaf63330d1f8c09 );
    }
    cache_frame_0f658e91b4d3f853eeaf63330d1f8c09 = NULL;

    assertFrameObject( frame_0f658e91b4d3f853eeaf63330d1f8c09 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_20_use_certificate_file );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_filetype );
    Py_DECREF( par_filetype );
    par_filetype = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certfile );
    Py_DECREF( par_certfile );
    par_certfile = NULL;

    CHECK_OBJECT( (PyObject *)par_filetype );
    Py_DECREF( par_filetype );
    par_filetype = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_20_use_certificate_file );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_21_use_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_41c71643654412e463e2e01067134703;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_41c71643654412e463e2e01067134703 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_41c71643654412e463e2e01067134703, codeobj_41c71643654412e463e2e01067134703, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_41c71643654412e463e2e01067134703 = cache_frame_41c71643654412e463e2e01067134703;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_41c71643654412e463e2e01067134703 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_41c71643654412e463e2e01067134703 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cert );
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 939;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 939;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 939;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
            frame_41c71643654412e463e2e01067134703->m_frame.f_lineno = 940;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 940;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_certificate );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cert );
        tmp_source_name_3 = par_cert;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_41c71643654412e463e2e01067134703->m_frame.f_lineno = 942;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 942;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_use_result == NULL );
        var_use_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_use_result );
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 943;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 944;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_41c71643654412e463e2e01067134703->m_frame.f_lineno = 944;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 944;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_41c71643654412e463e2e01067134703 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_41c71643654412e463e2e01067134703 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_41c71643654412e463e2e01067134703, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_41c71643654412e463e2e01067134703->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_41c71643654412e463e2e01067134703, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_41c71643654412e463e2e01067134703,
        type_description_1,
        par_self,
        par_cert,
        var_use_result
    );


    // Release cached frame.
    if ( frame_41c71643654412e463e2e01067134703 == cache_frame_41c71643654412e463e2e01067134703 )
    {
        Py_DECREF( frame_41c71643654412e463e2e01067134703 );
    }
    cache_frame_41c71643654412e463e2e01067134703 = NULL;

    assertFrameObject( frame_41c71643654412e463e2e01067134703 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_21_use_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_21_use_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_22_add_extra_chain_cert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certobj = python_pars[ 1 ];
    PyObject *var_copy = NULL;
    PyObject *var_add_result = NULL;
    struct Nuitka_FrameObject *frame_6b208ca591bc09f3db3e2b7a669fdf49;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_6b208ca591bc09f3db3e2b7a669fdf49 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6b208ca591bc09f3db3e2b7a669fdf49, codeobj_6b208ca591bc09f3db3e2b7a669fdf49, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6b208ca591bc09f3db3e2b7a669fdf49 = cache_frame_6b208ca591bc09f3db3e2b7a669fdf49;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6b208ca591bc09f3db3e2b7a669fdf49 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6b208ca591bc09f3db3e2b7a669fdf49 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_certobj );
        tmp_isinstance_inst_1 = par_certobj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 953;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 953;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 953;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_e51bcf1ff2d3a73499a1380c77d20ade;
            frame_6b208ca591bc09f3db3e2b7a669fdf49->m_frame.f_lineno = 954;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 954;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_dup );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_certobj );
        tmp_source_name_2 = par_certobj;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_6b208ca591bc09f3db3e2b7a669fdf49->m_frame.f_lineno = 956;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_copy == NULL );
        var_copy = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_add_extra_chain_cert );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_copy );
        tmp_args_element_name_3 = var_copy;
        frame_6b208ca591bc09f3db3e2b7a669fdf49->m_frame.f_lineno = 957;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 957;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_add_result == NULL );
        var_add_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_add_result );
        tmp_operand_name_2 = var_add_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 958;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 960;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_4;
            CHECK_OBJECT( var_copy );
            tmp_args_element_name_4 = var_copy;
            frame_6b208ca591bc09f3db3e2b7a669fdf49->m_frame.f_lineno = 960;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_free, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 960;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 961;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            frame_6b208ca591bc09f3db3e2b7a669fdf49->m_frame.f_lineno = 961;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 961;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6b208ca591bc09f3db3e2b7a669fdf49 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6b208ca591bc09f3db3e2b7a669fdf49 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6b208ca591bc09f3db3e2b7a669fdf49, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6b208ca591bc09f3db3e2b7a669fdf49->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6b208ca591bc09f3db3e2b7a669fdf49, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6b208ca591bc09f3db3e2b7a669fdf49,
        type_description_1,
        par_self,
        par_certobj,
        var_copy,
        var_add_result
    );


    // Release cached frame.
    if ( frame_6b208ca591bc09f3db3e2b7a669fdf49 == cache_frame_6b208ca591bc09f3db3e2b7a669fdf49 )
    {
        Py_DECREF( frame_6b208ca591bc09f3db3e2b7a669fdf49 );
    }
    cache_frame_6b208ca591bc09f3db3e2b7a669fdf49 = NULL;

    assertFrameObject( frame_6b208ca591bc09f3db3e2b7a669fdf49 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_22_add_extra_chain_cert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_copy );
    Py_DECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_certobj );
    Py_DECREF( par_certobj );
    par_certobj = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_certobj );
    Py_DECREF( par_certobj );
    par_certobj = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_22_add_extra_chain_cert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_23__raise_passphrase_exception( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_59384c424ee4f4c7331a4d2bae2ebb3f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_59384c424ee4f4c7331a4d2bae2ebb3f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_59384c424ee4f4c7331a4d2bae2ebb3f, codeobj_59384c424ee4f4c7331a4d2bae2ebb3f, module_OpenSSL$SSL, sizeof(void *) );
    frame_59384c424ee4f4c7331a4d2bae2ebb3f = cache_frame_59384c424ee4f4c7331a4d2bae2ebb3f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_59384c424ee4f4c7331a4d2bae2ebb3f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_59384c424ee4f4c7331a4d2bae2ebb3f ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase_helper );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 964;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__passphrase_helper );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_raise_if_problem );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
            }

            if ( tmp_mvar_value_1 == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
                exception_tb = NULL;

                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_1 = tmp_mvar_value_1;
            frame_59384c424ee4f4c7331a4d2bae2ebb3f->m_frame.f_lineno = 965;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 965;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
            exception_tb = NULL;

            exception_lineno = 967;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        frame_59384c424ee4f4c7331a4d2bae2ebb3f->m_frame.f_lineno = 967;
        tmp_call_result_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 967;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59384c424ee4f4c7331a4d2bae2ebb3f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59384c424ee4f4c7331a4d2bae2ebb3f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_59384c424ee4f4c7331a4d2bae2ebb3f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_59384c424ee4f4c7331a4d2bae2ebb3f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_59384c424ee4f4c7331a4d2bae2ebb3f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_59384c424ee4f4c7331a4d2bae2ebb3f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_59384c424ee4f4c7331a4d2bae2ebb3f == cache_frame_59384c424ee4f4c7331a4d2bae2ebb3f )
    {
        Py_DECREF( frame_59384c424ee4f4c7331a4d2bae2ebb3f );
    }
    cache_frame_59384c424ee4f4c7331a4d2bae2ebb3f = NULL;

    assertFrameObject( frame_59384c424ee4f4c7331a4d2bae2ebb3f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_23__raise_passphrase_exception );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_23__raise_passphrase_exception );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_24_use_privatekey_file( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_keyfile = python_pars[ 1 ];
    PyObject *par_filetype = python_pars[ 2 ];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_f5158618828ea79b360b2b4d785102df;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f5158618828ea79b360b2b4d785102df = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f5158618828ea79b360b2b4d785102df, codeobj_f5158618828ea79b360b2b4d785102df, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f5158618828ea79b360b2b4d785102df = cache_frame_f5158618828ea79b360b2b4d785102df;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f5158618828ea79b360b2b4d785102df );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f5158618828ea79b360b2b4d785102df ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
            exception_tb = NULL;

            exception_lineno = 980;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_keyfile );
        tmp_args_element_name_1 = par_keyfile;
        frame_f5158618828ea79b360b2b4d785102df->m_frame.f_lineno = 980;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 980;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_keyfile;
            assert( old != NULL );
            par_keyfile = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_filetype );
        tmp_compexpr_left_1 = par_filetype;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_UNSPECIFIED" );
            exception_tb = NULL;

            exception_lineno = 982;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
                exception_tb = NULL;

                exception_lineno = 983;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_assign_source_2 = tmp_mvar_value_3;
            {
                PyObject *old = par_filetype;
                assert( old != NULL );
                par_filetype = tmp_assign_source_2;
                Py_INCREF( par_filetype );
                Py_DECREF( old );
            }

        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT( par_filetype );
            tmp_isinstance_inst_1 = par_filetype;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
                exception_tb = NULL;

                exception_lineno = 984;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_4;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 984;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 984;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_7cf2d06a8643ddce5d0ceedd61c750e1;
                frame_f5158618828ea79b360b2b4d785102df->m_frame.f_lineno = 985;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 985;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 987;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_5;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_PrivateKey_file );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 987;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 988;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_keyfile );
        tmp_args_element_name_3 = par_keyfile;
        CHECK_OBJECT( par_filetype );
        tmp_args_element_name_4 = par_filetype;
        frame_f5158618828ea79b360b2b4d785102df->m_frame.f_lineno = 987;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 987;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_use_result == NULL );
        var_use_result = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_use_result );
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 989;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            frame_f5158618828ea79b360b2b4d785102df->m_frame.f_lineno = 990;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__raise_passphrase_exception );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 990;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5158618828ea79b360b2b4d785102df );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f5158618828ea79b360b2b4d785102df );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f5158618828ea79b360b2b4d785102df, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f5158618828ea79b360b2b4d785102df->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f5158618828ea79b360b2b4d785102df, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f5158618828ea79b360b2b4d785102df,
        type_description_1,
        par_self,
        par_keyfile,
        par_filetype,
        var_use_result
    );


    // Release cached frame.
    if ( frame_f5158618828ea79b360b2b4d785102df == cache_frame_f5158618828ea79b360b2b4d785102df )
    {
        Py_DECREF( frame_f5158618828ea79b360b2b4d785102df );
    }
    cache_frame_f5158618828ea79b360b2b4d785102df = NULL;

    assertFrameObject( frame_f5158618828ea79b360b2b4d785102df );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_24_use_privatekey_file );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    CHECK_OBJECT( (PyObject *)par_filetype );
    Py_DECREF( par_filetype );
    par_filetype = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_keyfile );
    Py_DECREF( par_keyfile );
    par_keyfile = NULL;

    Py_XDECREF( par_filetype );
    par_filetype = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_24_use_privatekey_file );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_25_use_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_use_result = NULL;
    struct Nuitka_FrameObject *frame_02c1cad644039385b8a3726221761ce2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_02c1cad644039385b8a3726221761ce2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_02c1cad644039385b8a3726221761ce2, codeobj_02c1cad644039385b8a3726221761ce2, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_02c1cad644039385b8a3726221761ce2 = cache_frame_02c1cad644039385b8a3726221761ce2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_02c1cad644039385b8a3726221761ce2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_02c1cad644039385b8a3726221761ce2 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_pkey );
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 999;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 999;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 999;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_02c1cad644039385b8a3726221761ce2->m_frame.f_lineno = 1000;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1000;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_use_PrivateKey );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_02c1cad644039385b8a3726221761ce2->m_frame.f_lineno = 1002;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1002;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_use_result == NULL );
        var_use_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_use_result );
        tmp_operand_name_2 = var_use_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1003;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            frame_02c1cad644039385b8a3726221761ce2->m_frame.f_lineno = 1004;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__raise_passphrase_exception );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1004;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02c1cad644039385b8a3726221761ce2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02c1cad644039385b8a3726221761ce2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_02c1cad644039385b8a3726221761ce2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_02c1cad644039385b8a3726221761ce2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_02c1cad644039385b8a3726221761ce2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_02c1cad644039385b8a3726221761ce2,
        type_description_1,
        par_self,
        par_pkey,
        var_use_result
    );


    // Release cached frame.
    if ( frame_02c1cad644039385b8a3726221761ce2 == cache_frame_02c1cad644039385b8a3726221761ce2 )
    {
        Py_DECREF( frame_02c1cad644039385b8a3726221761ce2 );
    }
    cache_frame_02c1cad644039385b8a3726221761ce2 = NULL;

    assertFrameObject( frame_02c1cad644039385b8a3726221761ce2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_25_use_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_use_result );
    Py_DECREF( var_use_result );
    var_use_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_use_result );
    var_use_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_25_use_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_26_check_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_96932aa6f568d4909cbd83290f84e650;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_96932aa6f568d4909cbd83290f84e650 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_96932aa6f568d4909cbd83290f84e650, codeobj_96932aa6f568d4909cbd83290f84e650, module_OpenSSL$SSL, sizeof(void *) );
    frame_96932aa6f568d4909cbd83290f84e650 = cache_frame_96932aa6f568d4909cbd83290f84e650;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_96932aa6f568d4909cbd83290f84e650 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_96932aa6f568d4909cbd83290f84e650 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_check_private_key );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_96932aa6f568d4909cbd83290f84e650->m_frame.f_lineno = 1013;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1013;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1014;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            frame_96932aa6f568d4909cbd83290f84e650->m_frame.f_lineno = 1014;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1014;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_96932aa6f568d4909cbd83290f84e650 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_96932aa6f568d4909cbd83290f84e650 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_96932aa6f568d4909cbd83290f84e650, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_96932aa6f568d4909cbd83290f84e650->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_96932aa6f568d4909cbd83290f84e650, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_96932aa6f568d4909cbd83290f84e650,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_96932aa6f568d4909cbd83290f84e650 == cache_frame_96932aa6f568d4909cbd83290f84e650 )
    {
        Py_DECREF( frame_96932aa6f568d4909cbd83290f84e650 );
    }
    cache_frame_96932aa6f568d4909cbd83290f84e650 = NULL;

    assertFrameObject( frame_96932aa6f568d4909cbd83290f84e650 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_26_check_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_26_check_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_27_load_client_ca( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cafile = python_pars[ 1 ];
    PyObject *var_ca_list = NULL;
    struct Nuitka_FrameObject *frame_6a517aa52cd15acbda7c46151157c02c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6a517aa52cd15acbda7c46151157c02c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a517aa52cd15acbda7c46151157c02c, codeobj_6a517aa52cd15acbda7c46151157c02c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6a517aa52cd15acbda7c46151157c02c = cache_frame_6a517aa52cd15acbda7c46151157c02c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a517aa52cd15acbda7c46151157c02c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a517aa52cd15acbda7c46151157c02c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1025;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_load_client_CA_file );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1025;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 1026;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_args_element_name_2 = const_str_plain_cafile;
        CHECK_OBJECT( par_cafile );
        tmp_args_element_name_3 = par_cafile;
        frame_6a517aa52cd15acbda7c46151157c02c->m_frame.f_lineno = 1026;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1026;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_6a517aa52cd15acbda7c46151157c02c->m_frame.f_lineno = 1025;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1025;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_ca_list == NULL );
        var_ca_list = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT( var_ca_list );
        tmp_compexpr_left_1 = var_ca_list;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_6a517aa52cd15acbda7c46151157c02c->m_frame.f_lineno = 1028;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1028;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_client_CA_list );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ca_list );
        tmp_args_element_name_6 = var_ca_list;
        frame_6a517aa52cd15acbda7c46151157c02c->m_frame.f_lineno = 1029;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1029;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a517aa52cd15acbda7c46151157c02c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a517aa52cd15acbda7c46151157c02c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a517aa52cd15acbda7c46151157c02c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a517aa52cd15acbda7c46151157c02c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a517aa52cd15acbda7c46151157c02c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6a517aa52cd15acbda7c46151157c02c,
        type_description_1,
        par_self,
        par_cafile,
        var_ca_list
    );


    // Release cached frame.
    if ( frame_6a517aa52cd15acbda7c46151157c02c == cache_frame_6a517aa52cd15acbda7c46151157c02c )
    {
        Py_DECREF( frame_6a517aa52cd15acbda7c46151157c02c );
    }
    cache_frame_6a517aa52cd15acbda7c46151157c02c = NULL;

    assertFrameObject( frame_6a517aa52cd15acbda7c46151157c02c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_27_load_client_ca );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_ca_list );
    Py_DECREF( var_ca_list );
    var_ca_list = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ca_list );
    var_ca_list = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cafile );
    Py_DECREF( par_cafile );
    par_cafile = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_27_load_client_ca );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_28_set_session_id( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0a78b45fe82072741d967a7116be55e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0a78b45fe82072741d967a7116be55e3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0a78b45fe82072741d967a7116be55e3, codeobj_0a78b45fe82072741d967a7116be55e3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_0a78b45fe82072741d967a7116be55e3 = cache_frame_0a78b45fe82072741d967a7116be55e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0a78b45fe82072741d967a7116be55e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0a78b45fe82072741d967a7116be55e3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 1042;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT( par_buf );
        tmp_args_element_name_2 = par_buf;
        frame_0a78b45fe82072741d967a7116be55e3->m_frame.f_lineno = 1042;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1042;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert( old != NULL );
            par_buf = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1043;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_session_id_context );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1045;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_buf );
        tmp_args_element_name_5 = par_buf;
        CHECK_OBJECT( par_buf );
        tmp_len_arg_1 = par_buf;
        tmp_args_element_name_6 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_4 );

            exception_lineno = 1047;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_0a78b45fe82072741d967a7116be55e3->m_frame.f_lineno = 1044;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1044;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_0a78b45fe82072741d967a7116be55e3->m_frame.f_lineno = 1043;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1043;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0a78b45fe82072741d967a7116be55e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0a78b45fe82072741d967a7116be55e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0a78b45fe82072741d967a7116be55e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0a78b45fe82072741d967a7116be55e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0a78b45fe82072741d967a7116be55e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0a78b45fe82072741d967a7116be55e3,
        type_description_1,
        par_self,
        par_buf
    );


    // Release cached frame.
    if ( frame_0a78b45fe82072741d967a7116be55e3 == cache_frame_0a78b45fe82072741d967a7116be55e3 )
    {
        Py_DECREF( frame_0a78b45fe82072741d967a7116be55e3 );
    }
    cache_frame_0a78b45fe82072741d967a7116be55e3 = NULL;

    assertFrameObject( frame_0a78b45fe82072741d967a7116be55e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_28_set_session_id );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_28_set_session_id );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_29_set_session_cache_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mode = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_df9b0f7b3f68a04bf8de49673c90bc52;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_df9b0f7b3f68a04bf8de49673c90bc52 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df9b0f7b3f68a04bf8de49673c90bc52, codeobj_df9b0f7b3f68a04bf8de49673c90bc52, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_df9b0f7b3f68a04bf8de49673c90bc52 = cache_frame_df9b0f7b3f68a04bf8de49673c90bc52;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df9b0f7b3f68a04bf8de49673c90bc52 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df9b0f7b3f68a04bf8de49673c90bc52 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_mode );
        tmp_isinstance_inst_1 = par_mode;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
            frame_df9b0f7b3f68a04bf8de49673c90bc52->m_frame.f_lineno = 1064;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1064;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_session_cache_mode );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_mode );
        tmp_args_element_name_2 = par_mode;
        frame_df9b0f7b3f68a04bf8de49673c90bc52->m_frame.f_lineno = 1066;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1066;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df9b0f7b3f68a04bf8de49673c90bc52 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_df9b0f7b3f68a04bf8de49673c90bc52 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df9b0f7b3f68a04bf8de49673c90bc52 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df9b0f7b3f68a04bf8de49673c90bc52, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df9b0f7b3f68a04bf8de49673c90bc52->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df9b0f7b3f68a04bf8de49673c90bc52, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df9b0f7b3f68a04bf8de49673c90bc52,
        type_description_1,
        par_self,
        par_mode
    );


    // Release cached frame.
    if ( frame_df9b0f7b3f68a04bf8de49673c90bc52 == cache_frame_df9b0f7b3f68a04bf8de49673c90bc52 )
    {
        Py_DECREF( frame_df9b0f7b3f68a04bf8de49673c90bc52 );
    }
    cache_frame_df9b0f7b3f68a04bf8de49673c90bc52 = NULL;

    assertFrameObject( frame_df9b0f7b3f68a04bf8de49673c90bc52 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_29_set_session_cache_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_29_set_session_cache_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_30_get_session_cache_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1fc2be28988ba2299e0f3db3940125b8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1fc2be28988ba2299e0f3db3940125b8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1fc2be28988ba2299e0f3db3940125b8, codeobj_1fc2be28988ba2299e0f3db3940125b8, module_OpenSSL$SSL, sizeof(void *) );
    frame_1fc2be28988ba2299e0f3db3940125b8 = cache_frame_1fc2be28988ba2299e0f3db3940125b8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1fc2be28988ba2299e0f3db3940125b8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1fc2be28988ba2299e0f3db3940125b8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_session_cache_mode );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1fc2be28988ba2299e0f3db3940125b8->m_frame.f_lineno = 1076;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1076;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fc2be28988ba2299e0f3db3940125b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fc2be28988ba2299e0f3db3940125b8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fc2be28988ba2299e0f3db3940125b8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1fc2be28988ba2299e0f3db3940125b8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1fc2be28988ba2299e0f3db3940125b8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1fc2be28988ba2299e0f3db3940125b8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1fc2be28988ba2299e0f3db3940125b8,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1fc2be28988ba2299e0f3db3940125b8 == cache_frame_1fc2be28988ba2299e0f3db3940125b8 )
    {
        Py_DECREF( frame_1fc2be28988ba2299e0f3db3940125b8 );
    }
    cache_frame_1fc2be28988ba2299e0f3db3940125b8 = NULL;

    assertFrameObject( frame_1fc2be28988ba2299e0f3db3940125b8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_30_get_session_cache_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_30_get_session_cache_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_31_set_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mode = python_pars[ 1 ];
    PyObject *par_callback = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_3c210d5bc83108fc5f8b8621b4b96e97;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3c210d5bc83108fc5f8b8621b4b96e97 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3c210d5bc83108fc5f8b8621b4b96e97, codeobj_3c210d5bc83108fc5f8b8621b4b96e97, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3c210d5bc83108fc5f8b8621b4b96e97 = cache_frame_3c210d5bc83108fc5f8b8621b4b96e97;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3c210d5bc83108fc5f8b8621b4b96e97 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3c210d5bc83108fc5f8b8621b4b96e97 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_mode );
        tmp_isinstance_inst_1 = par_mode;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
            frame_3c210d5bc83108fc5f8b8621b4b96e97->m_frame.f_lineno = 1098;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1098;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
        assert( tmp_called_name_1 != NULL );
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_3c210d5bc83108fc5f8b8621b4b96e97->m_frame.f_lineno = 1100;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_operand_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1100;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1100;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_3462bf983701fbd7caf2f521f5975fff;
            frame_3c210d5bc83108fc5f8b8621b4b96e97->m_frame.f_lineno = 1101;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1101;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__VerifyHelper );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__VerifyHelper );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_VerifyHelper" );
            exception_tb = NULL;

            exception_lineno = 1103;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_2 = par_callback;
        frame_3c210d5bc83108fc5f8b8621b4b96e97->m_frame.f_lineno = 1103;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1103;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__verify_helper, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1103;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__verify_helper );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1104;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1104;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__verify_callback, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1104;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_verify );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_mode );
        tmp_args_element_name_4 = par_mode;
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__verify_callback );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3c210d5bc83108fc5f8b8621b4b96e97->m_frame.f_lineno = 1105;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1105;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c210d5bc83108fc5f8b8621b4b96e97 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c210d5bc83108fc5f8b8621b4b96e97 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3c210d5bc83108fc5f8b8621b4b96e97, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3c210d5bc83108fc5f8b8621b4b96e97->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3c210d5bc83108fc5f8b8621b4b96e97, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3c210d5bc83108fc5f8b8621b4b96e97,
        type_description_1,
        par_self,
        par_mode,
        par_callback
    );


    // Release cached frame.
    if ( frame_3c210d5bc83108fc5f8b8621b4b96e97 == cache_frame_3c210d5bc83108fc5f8b8621b4b96e97 )
    {
        Py_DECREF( frame_3c210d5bc83108fc5f8b8621b4b96e97 );
    }
    cache_frame_3c210d5bc83108fc5f8b8621b4b96e97 = NULL;

    assertFrameObject( frame_3c210d5bc83108fc5f8b8621b4b96e97 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_31_set_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_31_set_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_32_set_verify_depth( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_depth = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_7594156bee4df5719976741b68595a11;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_7594156bee4df5719976741b68595a11 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7594156bee4df5719976741b68595a11, codeobj_7594156bee4df5719976741b68595a11, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_7594156bee4df5719976741b68595a11 = cache_frame_7594156bee4df5719976741b68595a11;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7594156bee4df5719976741b68595a11 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7594156bee4df5719976741b68595a11 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_depth );
        tmp_isinstance_inst_1 = par_depth;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 1115;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1115;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1115;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d242bea258df0e7212519aa660c5f53d;
            frame_7594156bee4df5719976741b68595a11->m_frame.f_lineno = 1116;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1116;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_verify_depth );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_depth );
        tmp_args_element_name_2 = par_depth;
        frame_7594156bee4df5719976741b68595a11->m_frame.f_lineno = 1118;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1118;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7594156bee4df5719976741b68595a11 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7594156bee4df5719976741b68595a11 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7594156bee4df5719976741b68595a11, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7594156bee4df5719976741b68595a11->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7594156bee4df5719976741b68595a11, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7594156bee4df5719976741b68595a11,
        type_description_1,
        par_self,
        par_depth
    );


    // Release cached frame.
    if ( frame_7594156bee4df5719976741b68595a11 == cache_frame_7594156bee4df5719976741b68595a11 )
    {
        Py_DECREF( frame_7594156bee4df5719976741b68595a11 );
    }
    cache_frame_7594156bee4df5719976741b68595a11 = NULL;

    assertFrameObject( frame_7594156bee4df5719976741b68595a11 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_32_set_verify_depth );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_depth );
    Py_DECREF( par_depth );
    par_depth = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_depth );
    Py_DECREF( par_depth );
    par_depth = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_32_set_verify_depth );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_33_get_verify_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f1ff26acd5f4673b85900278fccfa353;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f1ff26acd5f4673b85900278fccfa353 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f1ff26acd5f4673b85900278fccfa353, codeobj_f1ff26acd5f4673b85900278fccfa353, module_OpenSSL$SSL, sizeof(void *) );
    frame_f1ff26acd5f4673b85900278fccfa353 = cache_frame_f1ff26acd5f4673b85900278fccfa353;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f1ff26acd5f4673b85900278fccfa353 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f1ff26acd5f4673b85900278fccfa353 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_verify_mode );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_f1ff26acd5f4673b85900278fccfa353->m_frame.f_lineno = 1127;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1ff26acd5f4673b85900278fccfa353 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1ff26acd5f4673b85900278fccfa353 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1ff26acd5f4673b85900278fccfa353 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f1ff26acd5f4673b85900278fccfa353, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f1ff26acd5f4673b85900278fccfa353->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f1ff26acd5f4673b85900278fccfa353, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f1ff26acd5f4673b85900278fccfa353,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f1ff26acd5f4673b85900278fccfa353 == cache_frame_f1ff26acd5f4673b85900278fccfa353 )
    {
        Py_DECREF( frame_f1ff26acd5f4673b85900278fccfa353 );
    }
    cache_frame_f1ff26acd5f4673b85900278fccfa353 = NULL;

    assertFrameObject( frame_f1ff26acd5f4673b85900278fccfa353 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_33_get_verify_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_33_get_verify_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_34_get_verify_depth( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_32829766e145fc1efe2f877d2ae9b983;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_32829766e145fc1efe2f877d2ae9b983 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_32829766e145fc1efe2f877d2ae9b983, codeobj_32829766e145fc1efe2f877d2ae9b983, module_OpenSSL$SSL, sizeof(void *) );
    frame_32829766e145fc1efe2f877d2ae9b983 = cache_frame_32829766e145fc1efe2f877d2ae9b983;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_32829766e145fc1efe2f877d2ae9b983 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_32829766e145fc1efe2f877d2ae9b983 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_verify_depth );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_32829766e145fc1efe2f877d2ae9b983->m_frame.f_lineno = 1136;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32829766e145fc1efe2f877d2ae9b983 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_32829766e145fc1efe2f877d2ae9b983 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32829766e145fc1efe2f877d2ae9b983 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_32829766e145fc1efe2f877d2ae9b983, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_32829766e145fc1efe2f877d2ae9b983->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_32829766e145fc1efe2f877d2ae9b983, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_32829766e145fc1efe2f877d2ae9b983,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_32829766e145fc1efe2f877d2ae9b983 == cache_frame_32829766e145fc1efe2f877d2ae9b983 )
    {
        Py_DECREF( frame_32829766e145fc1efe2f877d2ae9b983 );
    }
    cache_frame_32829766e145fc1efe2f877d2ae9b983 = NULL;

    assertFrameObject( frame_32829766e145fc1efe2f877d2ae9b983 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_34_get_verify_depth );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_34_get_verify_depth );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_35_load_tmp_dh( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_dhfile = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_dh = NULL;
    struct Nuitka_FrameObject *frame_fae4a37dc5886e31059db0e90dc6bcda;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_fae4a37dc5886e31059db0e90dc6bcda = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fae4a37dc5886e31059db0e90dc6bcda, codeobj_fae4a37dc5886e31059db0e90dc6bcda, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fae4a37dc5886e31059db0e90dc6bcda = cache_frame_fae4a37dc5886e31059db0e90dc6bcda;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fae4a37dc5886e31059db0e90dc6bcda );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fae4a37dc5886e31059db0e90dc6bcda ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__path_string );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_path_string" );
            exception_tb = NULL;

            exception_lineno = 1147;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_dhfile );
        tmp_args_element_name_1 = par_dhfile;
        frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame.f_lineno = 1147;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1147;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_dhfile;
            assert( old != NULL );
            par_dhfile = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_dhfile );
        tmp_args_element_name_2 = par_dhfile;
        tmp_args_element_name_3 = const_str_plain_r;
        frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame.f_lineno = 1149;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_BIO_new_file, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_bio );
        tmp_compexpr_left_1 = var_bio;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1151;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_4;
            frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame.f_lineno = 1151;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1151;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_gc );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_4 = var_bio;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_BIO_free );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame.f_lineno = 1152;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_bio;
            assert( old != NULL );
            var_bio = tmp_assign_source_3;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_PEM_read_bio_DHparams );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_6 = var_bio;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_9 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_7 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_9;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_7 );

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_10 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_7 );
            Py_DECREF( tmp_args_element_name_8 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_10;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_7 );
            Py_DECREF( tmp_args_element_name_8 );

            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame.f_lineno = 1154;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );
        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1154;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_dh == NULL );
        var_dh = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_11;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_gc );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_dh );
        tmp_args_element_name_10 = var_dh;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_12 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_12;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_DH_free );
        if ( tmp_args_element_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame.f_lineno = 1155;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_11 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1155;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_dh;
            assert( old != NULL );
            var_dh = tmp_assign_source_5;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_11;
        PyObject *tmp_args_element_name_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_13;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_SSL_CTX_set_tmp_dh );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_11 = par_self;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__context );
        if ( tmp_args_element_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_dh );
        tmp_args_element_name_13 = var_dh;
        frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame.f_lineno = 1156;
        {
            PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_12 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1156;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fae4a37dc5886e31059db0e90dc6bcda );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fae4a37dc5886e31059db0e90dc6bcda );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fae4a37dc5886e31059db0e90dc6bcda, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fae4a37dc5886e31059db0e90dc6bcda->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fae4a37dc5886e31059db0e90dc6bcda, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fae4a37dc5886e31059db0e90dc6bcda,
        type_description_1,
        par_self,
        par_dhfile,
        var_bio,
        var_dh
    );


    // Release cached frame.
    if ( frame_fae4a37dc5886e31059db0e90dc6bcda == cache_frame_fae4a37dc5886e31059db0e90dc6bcda )
    {
        Py_DECREF( frame_fae4a37dc5886e31059db0e90dc6bcda );
    }
    cache_frame_fae4a37dc5886e31059db0e90dc6bcda = NULL;

    assertFrameObject( frame_fae4a37dc5886e31059db0e90dc6bcda );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_35_load_tmp_dh );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dhfile );
    Py_DECREF( par_dhfile );
    par_dhfile = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_dh );
    Py_DECREF( var_dh );
    var_dh = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_dhfile );
    Py_DECREF( par_dhfile );
    par_dhfile = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_dh );
    var_dh = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_35_load_tmp_dh );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_36_set_tmp_ecdh( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_curve = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_80da3cb70b526050748feefac39aa753;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_80da3cb70b526050748feefac39aa753 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_80da3cb70b526050748feefac39aa753, codeobj_80da3cb70b526050748feefac39aa753, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_80da3cb70b526050748feefac39aa753 = cache_frame_80da3cb70b526050748feefac39aa753;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_80da3cb70b526050748feefac39aa753 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_80da3cb70b526050748feefac39aa753 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_instance_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_tmp_ecdh );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_curve );
        tmp_called_instance_1 = par_curve;
        frame_80da3cb70b526050748feefac39aa753->m_frame.f_lineno = 1168;
        tmp_args_element_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__to_EC_KEY );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_80da3cb70b526050748feefac39aa753->m_frame.f_lineno = 1168;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1168;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_80da3cb70b526050748feefac39aa753 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_80da3cb70b526050748feefac39aa753 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_80da3cb70b526050748feefac39aa753, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_80da3cb70b526050748feefac39aa753->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_80da3cb70b526050748feefac39aa753, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_80da3cb70b526050748feefac39aa753,
        type_description_1,
        par_self,
        par_curve
    );


    // Release cached frame.
    if ( frame_80da3cb70b526050748feefac39aa753 == cache_frame_80da3cb70b526050748feefac39aa753 )
    {
        Py_DECREF( frame_80da3cb70b526050748feefac39aa753 );
    }
    cache_frame_80da3cb70b526050748feefac39aa753 = NULL;

    assertFrameObject( frame_80da3cb70b526050748feefac39aa753 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_36_set_tmp_ecdh );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_curve );
    Py_DECREF( par_curve );
    par_curve = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_curve );
    Py_DECREF( par_curve );
    par_curve = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_36_set_tmp_ecdh );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_37_set_cipher_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cipher_list = python_pars[ 1 ];
    PyObject *var_tmpconn = NULL;
    struct Nuitka_FrameObject *frame_f07b4d307d82823816d3b33cd173a678;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f07b4d307d82823816d3b33cd173a678 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f07b4d307d82823816d3b33cd173a678, codeobj_f07b4d307d82823816d3b33cd173a678, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f07b4d307d82823816d3b33cd173a678 = cache_frame_f07b4d307d82823816d3b33cd173a678;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f07b4d307d82823816d3b33cd173a678 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f07b4d307d82823816d3b33cd173a678 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 1180;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_cipher_list;
        CHECK_OBJECT( par_cipher_list );
        tmp_args_element_name_2 = par_cipher_list;
        frame_f07b4d307d82823816d3b33cd173a678->m_frame.f_lineno = 1180;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1180;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_cipher_list;
            assert( old != NULL );
            par_cipher_list = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_cipher_list );
        tmp_isinstance_inst_1 = par_cipher_list;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_428eff9fedd3b449496fa307af56b948;
            frame_f07b4d307d82823816d3b33cd173a678->m_frame.f_lineno = 1183;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1183;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_cipher_list );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cipher_list );
        tmp_args_element_name_5 = par_cipher_list;
        frame_f07b4d307d82823816d3b33cd173a678->m_frame.f_lineno = 1186;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1186;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_f07b4d307d82823816d3b33cd173a678->m_frame.f_lineno = 1185;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 1193;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_4;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_6 = par_self;
        tmp_args_element_name_7 = Py_None;
        frame_f07b4d307d82823816d3b33cd173a678->m_frame.f_lineno = 1193;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1193;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_tmpconn == NULL );
        var_tmpconn = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_called_instance_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1194;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_5;
        CHECK_OBJECT( var_tmpconn );
        tmp_called_instance_1 = var_tmpconn;
        frame_f07b4d307d82823816d3b33cd173a678->m_frame.f_lineno = 1195;
        tmp_compexpr_left_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_get_cipher_list );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1195;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = LIST_COPY( const_list_6fa8c3d8587ec1659fa28b2f58883e42_list );
        tmp_args_element_name_8 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1195;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_f07b4d307d82823816d3b33cd173a678->m_frame.f_lineno = 1194;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1194;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f07b4d307d82823816d3b33cd173a678 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f07b4d307d82823816d3b33cd173a678 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f07b4d307d82823816d3b33cd173a678, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f07b4d307d82823816d3b33cd173a678->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f07b4d307d82823816d3b33cd173a678, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f07b4d307d82823816d3b33cd173a678,
        type_description_1,
        par_self,
        par_cipher_list,
        var_tmpconn
    );


    // Release cached frame.
    if ( frame_f07b4d307d82823816d3b33cd173a678 == cache_frame_f07b4d307d82823816d3b33cd173a678 )
    {
        Py_DECREF( frame_f07b4d307d82823816d3b33cd173a678 );
    }
    cache_frame_f07b4d307d82823816d3b33cd173a678 = NULL;

    assertFrameObject( frame_f07b4d307d82823816d3b33cd173a678 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_37_set_cipher_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher_list );
    Py_DECREF( par_cipher_list );
    par_cipher_list = NULL;

    CHECK_OBJECT( (PyObject *)var_tmpconn );
    Py_DECREF( var_tmpconn );
    var_tmpconn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher_list );
    Py_DECREF( par_cipher_list );
    par_cipher_list = NULL;

    Py_XDECREF( var_tmpconn );
    var_tmpconn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_37_set_cipher_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_38_set_client_ca_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certificate_authorities = python_pars[ 1 ];
    PyObject *var_copy = NULL;
    PyObject *var_name_stack = NULL;
    PyObject *var_ca_name = NULL;
    PyObject *var_push_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_4595e7f22fd27934c99d0779b3a36d8a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_4595e7f22fd27934c99d0779b3a36d8a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4595e7f22fd27934c99d0779b3a36d8a, codeobj_4595e7f22fd27934c99d0779b3a36d8a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4595e7f22fd27934c99d0779b3a36d8a = cache_frame_4595e7f22fd27934c99d0779b3a36d8a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4595e7f22fd27934c99d0779b3a36d8a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4595e7f22fd27934c99d0779b3a36d8a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1215;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1215;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_sk_X509_NAME_new_null );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1215;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_name_stack == NULL );
        var_name_stack = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_name_stack );
        tmp_compexpr_left_1 = var_name_stack;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1216;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1216;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_certificate_authorities );
        tmp_iter_arg_1 = par_certificate_authorities;
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1219;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooo";
                exception_lineno = 1219;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ca_name;
            var_ca_name = tmp_assign_source_4;
            Py_INCREF( var_ca_name );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_ca_name );
        tmp_isinstance_inst_1 = var_ca_name;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 1220;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_4;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1220;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1220;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_type_arg_1;
            tmp_left_name_1 = const_str_digest_4387d84e76f6b2a931cf315cb767f6ce;
            CHECK_OBJECT( var_ca_name );
            tmp_type_arg_1 = var_ca_name;
            tmp_source_name_2 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_source_name_2 == NULL) );
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___name__ );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1224;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            tmp_right_name_1 = PyTuple_New( 1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1222;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1221;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1221;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_NAME_dup );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_ca_name );
        tmp_source_name_4 = var_ca_name;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1227;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1227;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_copy;
            var_copy = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_name_3 = tmp_mvar_value_6;
        CHECK_OBJECT( var_copy );
        tmp_compexpr_left_2 = var_copy;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1228;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1228;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1229;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_2 = tmp_mvar_value_8;
        CHECK_OBJECT( var_name_stack );
        tmp_args_element_name_4 = var_name_stack;
        CHECK_OBJECT( var_copy );
        tmp_args_element_name_5 = var_copy;
        frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1229;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_NAME_push, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1229;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_push_result;
            var_push_result = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_push_result );
        tmp_operand_name_2 = var_push_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1230;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_6;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1231;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }

            tmp_called_instance_3 = tmp_mvar_value_9;
            CHECK_OBJECT( var_copy );
            tmp_args_element_name_6 = var_copy;
            frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1231;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_NAME_free, call_args );
            }

            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1231;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_call_result_4;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_10 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1232;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_4 = tmp_mvar_value_10;
            frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1232;
            tmp_call_result_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1232;
                type_description_1 = "oooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        branch_no_2:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1219;
        type_description_1 = "oooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_4595e7f22fd27934c99d0779b3a36d8a );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_4595e7f22fd27934c99d0779b3a36d8a, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_4595e7f22fd27934c99d0779b3a36d8a, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1233;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_call_result_5;
            PyObject *tmp_args_element_name_7;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1234;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_4 = tmp_mvar_value_11;
            CHECK_OBJECT( var_name_stack );
            tmp_args_element_name_7 = var_name_stack;
            frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1234;
            {
                PyObject *call_args[] = { tmp_args_element_name_7 };
                tmp_call_result_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_sk_X509_NAME_free, call_args );
            }

            if ( tmp_call_result_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1234;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_5 );
        }
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1235;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame) frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        goto branch_end_3;
        branch_no_3:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 1218;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame) frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto frame_exception_exit_1;
        branch_end_3:;
    }
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_call_result_6;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_12;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_CTX_set_client_CA_list );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__context );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_name_stack );
        tmp_args_element_name_9 = var_name_stack;
        frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame.f_lineno = 1237;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_call_result_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_call_result_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1237;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_6 );
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_4595e7f22fd27934c99d0779b3a36d8a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_4595e7f22fd27934c99d0779b3a36d8a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4595e7f22fd27934c99d0779b3a36d8a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4595e7f22fd27934c99d0779b3a36d8a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4595e7f22fd27934c99d0779b3a36d8a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4595e7f22fd27934c99d0779b3a36d8a,
        type_description_1,
        par_self,
        par_certificate_authorities,
        var_copy,
        var_name_stack,
        var_ca_name,
        var_push_result
    );


    // Release cached frame.
    if ( frame_4595e7f22fd27934c99d0779b3a36d8a == cache_frame_4595e7f22fd27934c99d0779b3a36d8a )
    {
        Py_DECREF( frame_4595e7f22fd27934c99d0779b3a36d8a );
    }
    cache_frame_4595e7f22fd27934c99d0779b3a36d8a = NULL;

    assertFrameObject( frame_4595e7f22fd27934c99d0779b3a36d8a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_38_set_client_ca_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authorities );
    Py_DECREF( par_certificate_authorities );
    par_certificate_authorities = NULL;

    CHECK_OBJECT( (PyObject *)var_name_stack );
    Py_DECREF( var_name_stack );
    var_name_stack = NULL;

    Py_XDECREF( var_ca_name );
    var_ca_name = NULL;

    Py_XDECREF( var_push_result );
    var_push_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authorities );
    Py_DECREF( par_certificate_authorities );
    par_certificate_authorities = NULL;

    Py_XDECREF( var_name_stack );
    var_name_stack = NULL;

    Py_XDECREF( var_ca_name );
    var_ca_name = NULL;

    Py_XDECREF( var_push_result );
    var_push_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_38_set_client_ca_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_39_add_client_ca( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_certificate_authority = python_pars[ 1 ];
    PyObject *var_add_result = NULL;
    struct Nuitka_FrameObject *frame_e2e477e47ecef45d6f6b262be274a428;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e2e477e47ecef45d6f6b262be274a428 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e2e477e47ecef45d6f6b262be274a428, codeobj_e2e477e47ecef45d6f6b262be274a428, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e2e477e47ecef45d6f6b262be274a428 = cache_frame_e2e477e47ecef45d6f6b262be274a428;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e2e477e47ecef45d6f6b262be274a428 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e2e477e47ecef45d6f6b262be274a428 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_certificate_authority );
        tmp_isinstance_inst_1 = par_certificate_authority;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 1252;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1252;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1252;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f5111f918158679228186076f422f85e;
            frame_e2e477e47ecef45d6f6b262be274a428->m_frame.f_lineno = 1253;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1253;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1255;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_add_client_CA );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1255;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1256;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_certificate_authority );
        tmp_source_name_3 = par_certificate_authority;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1256;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_e2e477e47ecef45d6f6b262be274a428->m_frame.f_lineno = 1255;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1255;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_add_result == NULL );
        var_add_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1257;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_add_result );
        tmp_compexpr_left_1 = var_add_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1257;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_e2e477e47ecef45d6f6b262be274a428->m_frame.f_lineno = 1257;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1257;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2e477e47ecef45d6f6b262be274a428 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2e477e47ecef45d6f6b262be274a428 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e2e477e47ecef45d6f6b262be274a428, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e2e477e47ecef45d6f6b262be274a428->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e2e477e47ecef45d6f6b262be274a428, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2e477e47ecef45d6f6b262be274a428,
        type_description_1,
        par_self,
        par_certificate_authority,
        var_add_result
    );


    // Release cached frame.
    if ( frame_e2e477e47ecef45d6f6b262be274a428 == cache_frame_e2e477e47ecef45d6f6b262be274a428 )
    {
        Py_DECREF( frame_e2e477e47ecef45d6f6b262be274a428 );
    }
    cache_frame_e2e477e47ecef45d6f6b262be274a428 = NULL;

    assertFrameObject( frame_e2e477e47ecef45d6f6b262be274a428 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_39_add_client_ca );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authority );
    Py_DECREF( par_certificate_authority );
    par_certificate_authority = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate_authority );
    Py_DECREF( par_certificate_authority );
    par_certificate_authority = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_39_add_client_ca );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_40_set_timeout( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_timeout = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0197cdd72b2974669ab0cb1f129cf2f4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0197cdd72b2974669ab0cb1f129cf2f4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0197cdd72b2974669ab0cb1f129cf2f4, codeobj_0197cdd72b2974669ab0cb1f129cf2f4, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_0197cdd72b2974669ab0cb1f129cf2f4 = cache_frame_0197cdd72b2974669ab0cb1f129cf2f4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0197cdd72b2974669ab0cb1f129cf2f4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0197cdd72b2974669ab0cb1f129cf2f4 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_timeout );
        tmp_isinstance_inst_1 = par_timeout;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1268;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7ac3fb96e522dea60117802c4a4274df;
            frame_0197cdd72b2974669ab0cb1f129cf2f4->m_frame.f_lineno = 1269;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1269;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_timeout );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_timeout );
        tmp_args_element_name_2 = par_timeout;
        frame_0197cdd72b2974669ab0cb1f129cf2f4->m_frame.f_lineno = 1271;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0197cdd72b2974669ab0cb1f129cf2f4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0197cdd72b2974669ab0cb1f129cf2f4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0197cdd72b2974669ab0cb1f129cf2f4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0197cdd72b2974669ab0cb1f129cf2f4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0197cdd72b2974669ab0cb1f129cf2f4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0197cdd72b2974669ab0cb1f129cf2f4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0197cdd72b2974669ab0cb1f129cf2f4,
        type_description_1,
        par_self,
        par_timeout
    );


    // Release cached frame.
    if ( frame_0197cdd72b2974669ab0cb1f129cf2f4 == cache_frame_0197cdd72b2974669ab0cb1f129cf2f4 )
    {
        Py_DECREF( frame_0197cdd72b2974669ab0cb1f129cf2f4 );
    }
    cache_frame_0197cdd72b2974669ab0cb1f129cf2f4 = NULL;

    assertFrameObject( frame_0197cdd72b2974669ab0cb1f129cf2f4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_40_set_timeout );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_timeout );
    Py_DECREF( par_timeout );
    par_timeout = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_timeout );
    Py_DECREF( par_timeout );
    par_timeout = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_40_set_timeout );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_41_get_timeout( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_68087fd292b2546ec5a640d5c97808d9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_68087fd292b2546ec5a640d5c97808d9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_68087fd292b2546ec5a640d5c97808d9, codeobj_68087fd292b2546ec5a640d5c97808d9, module_OpenSSL$SSL, sizeof(void *) );
    frame_68087fd292b2546ec5a640d5c97808d9 = cache_frame_68087fd292b2546ec5a640d5c97808d9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_68087fd292b2546ec5a640d5c97808d9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_68087fd292b2546ec5a640d5c97808d9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_timeout );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_68087fd292b2546ec5a640d5c97808d9->m_frame.f_lineno = 1280;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1280;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68087fd292b2546ec5a640d5c97808d9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_68087fd292b2546ec5a640d5c97808d9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68087fd292b2546ec5a640d5c97808d9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_68087fd292b2546ec5a640d5c97808d9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_68087fd292b2546ec5a640d5c97808d9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_68087fd292b2546ec5a640d5c97808d9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_68087fd292b2546ec5a640d5c97808d9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_68087fd292b2546ec5a640d5c97808d9 == cache_frame_68087fd292b2546ec5a640d5c97808d9 )
    {
        Py_DECREF( frame_68087fd292b2546ec5a640d5c97808d9 );
    }
    cache_frame_68087fd292b2546ec5a640d5c97808d9 = NULL;

    assertFrameObject( frame_68087fd292b2546ec5a640d5c97808d9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_41_get_timeout );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_41_get_timeout );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_42_set_info_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_2cb565234df87e31bd5093a06c903ab0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_2cb565234df87e31bd5093a06c903ab0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2cb565234df87e31bd5093a06c903ab0, codeobj_2cb565234df87e31bd5093a06c903ab0, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2cb565234df87e31bd5093a06c903ab0 = cache_frame_2cb565234df87e31bd5093a06c903ab0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2cb565234df87e31bd5093a06c903ab0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2cb565234df87e31bd5093a06c903ab0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 1294;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_1 = PyCell_GET( par_callback );
        frame_2cb565234df87e31bd5093a06c903ab0->m_frame.f_lineno = 1294;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1294;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );


        frame_2cb565234df87e31bd5093a06c903ab0->m_frame.f_lineno = 1294;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1294;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1297;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_215c056443df9aa1456b62fe40673d54;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_4 = var_wrapper;
        frame_2cb565234df87e31bd5093a06c903ab0->m_frame.f_lineno = 1297;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1297;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__info_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1297;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_info_callback );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__info_callback );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );

            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        frame_2cb565234df87e31bd5093a06c903ab0->m_frame.f_lineno = 1299;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1299;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cb565234df87e31bd5093a06c903ab0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cb565234df87e31bd5093a06c903ab0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2cb565234df87e31bd5093a06c903ab0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2cb565234df87e31bd5093a06c903ab0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2cb565234df87e31bd5093a06c903ab0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2cb565234df87e31bd5093a06c903ab0,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_2cb565234df87e31bd5093a06c903ab0 == cache_frame_2cb565234df87e31bd5093a06c903ab0 )
    {
        Py_DECREF( frame_2cb565234df87e31bd5093a06c903ab0 );
    }
    cache_frame_2cb565234df87e31bd5093a06c903ab0 = NULL;

    assertFrameObject( frame_2cb565234df87e31bd5093a06c903ab0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_42_set_info_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_42_set_info_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_where = python_pars[ 1 ];
    PyObject *par_return_code = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_990bffb794119d86150b99fa6491e939;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_990bffb794119d86150b99fa6491e939 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_990bffb794119d86150b99fa6491e939, codeobj_990bffb794119d86150b99fa6491e939, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_990bffb794119d86150b99fa6491e939 = cache_frame_990bffb794119d86150b99fa6491e939;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_990bffb794119d86150b99fa6491e939 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_990bffb794119d86150b99fa6491e939 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_ssl );
        tmp_subscript_name_1 = par_ssl;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_where );
        tmp_args_element_name_2 = par_where;
        CHECK_OBJECT( par_return_code );
        tmp_args_element_name_3 = par_return_code;
        frame_990bffb794119d86150b99fa6491e939->m_frame.f_lineno = 1296;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1296;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_990bffb794119d86150b99fa6491e939 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_990bffb794119d86150b99fa6491e939 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_990bffb794119d86150b99fa6491e939, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_990bffb794119d86150b99fa6491e939->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_990bffb794119d86150b99fa6491e939, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_990bffb794119d86150b99fa6491e939,
        type_description_1,
        par_ssl,
        par_where,
        par_return_code,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_990bffb794119d86150b99fa6491e939 == cache_frame_990bffb794119d86150b99fa6491e939 )
    {
        Py_DECREF( frame_990bffb794119d86150b99fa6491e939 );
    }
    cache_frame_990bffb794119d86150b99fa6491e939 = NULL;

    assertFrameObject( frame_990bffb794119d86150b99fa6491e939 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_where );
    Py_DECREF( par_where );
    par_where = NULL;

    CHECK_OBJECT( (PyObject *)par_return_code );
    Py_DECREF( par_return_code );
    par_return_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_where );
    Py_DECREF( par_where );
    par_where = NULL;

    CHECK_OBJECT( (PyObject *)par_return_code );
    Py_DECREF( par_return_code );
    par_return_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_43_get_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f958b28da4ca6aab9d6b653c2268ae69;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f958b28da4ca6aab9d6b653c2268ae69 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f958b28da4ca6aab9d6b653c2268ae69, codeobj_f958b28da4ca6aab9d6b653c2268ae69, module_OpenSSL$SSL, sizeof(void *) );
    frame_f958b28da4ca6aab9d6b653c2268ae69 = cache_frame_f958b28da4ca6aab9d6b653c2268ae69;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f958b28da4ca6aab9d6b653c2268ae69 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f958b28da4ca6aab9d6b653c2268ae69 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__app_data );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1307;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f958b28da4ca6aab9d6b653c2268ae69 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f958b28da4ca6aab9d6b653c2268ae69 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f958b28da4ca6aab9d6b653c2268ae69 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f958b28da4ca6aab9d6b653c2268ae69, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f958b28da4ca6aab9d6b653c2268ae69->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f958b28da4ca6aab9d6b653c2268ae69, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f958b28da4ca6aab9d6b653c2268ae69,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f958b28da4ca6aab9d6b653c2268ae69 == cache_frame_f958b28da4ca6aab9d6b653c2268ae69 )
    {
        Py_DECREF( frame_f958b28da4ca6aab9d6b653c2268ae69 );
    }
    cache_frame_f958b28da4ca6aab9d6b653c2268ae69 = NULL;

    assertFrameObject( frame_f958b28da4ca6aab9d6b653c2268ae69 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_43_get_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_43_get_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_44_set_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_47a8b871086e72be9e62b12178457475;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_47a8b871086e72be9e62b12178457475 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_47a8b871086e72be9e62b12178457475, codeobj_47a8b871086e72be9e62b12178457475, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_47a8b871086e72be9e62b12178457475 = cache_frame_47a8b871086e72be9e62b12178457475;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_47a8b871086e72be9e62b12178457475 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_47a8b871086e72be9e62b12178457475 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_data );
        tmp_assattr_name_1 = par_data;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__app_data, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1316;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47a8b871086e72be9e62b12178457475 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47a8b871086e72be9e62b12178457475 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_47a8b871086e72be9e62b12178457475, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_47a8b871086e72be9e62b12178457475->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_47a8b871086e72be9e62b12178457475, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_47a8b871086e72be9e62b12178457475,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if ( frame_47a8b871086e72be9e62b12178457475 == cache_frame_47a8b871086e72be9e62b12178457475 )
    {
        Py_DECREF( frame_47a8b871086e72be9e62b12178457475 );
    }
    cache_frame_47a8b871086e72be9e62b12178457475 = NULL;

    assertFrameObject( frame_47a8b871086e72be9e62b12178457475 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_44_set_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_44_set_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_45_get_cert_store( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pystore = NULL;
    PyObject *var_store = NULL;
    struct Nuitka_FrameObject *frame_3601ce3f1589b8f9d54de158108a95af;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3601ce3f1589b8f9d54de158108a95af = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3601ce3f1589b8f9d54de158108a95af, codeobj_3601ce3f1589b8f9d54de158108a95af, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3601ce3f1589b8f9d54de158108a95af = cache_frame_3601ce3f1589b8f9d54de158108a95af;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3601ce3f1589b8f9d54de158108a95af );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3601ce3f1589b8f9d54de158108a95af ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_get_cert_store );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3601ce3f1589b8f9d54de158108a95af->m_frame.f_lineno = 1326;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1326;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_store == NULL );
        var_store = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_store );
        tmp_compexpr_left_1 = var_store;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1327;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1327;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1327;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Store" );
            exception_tb = NULL;

            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___new__ );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Store" );
            exception_tb = NULL;

            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_4;
        frame_3601ce3f1589b8f9d54de158108a95af->m_frame.f_lineno = 1331;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_pystore == NULL );
        var_pystore = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( var_store );
        tmp_assattr_name_1 = var_store;
        CHECK_OBJECT( var_pystore );
        tmp_assattr_target_1 = var_pystore;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1332;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3601ce3f1589b8f9d54de158108a95af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3601ce3f1589b8f9d54de158108a95af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3601ce3f1589b8f9d54de158108a95af );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3601ce3f1589b8f9d54de158108a95af, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3601ce3f1589b8f9d54de158108a95af->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3601ce3f1589b8f9d54de158108a95af, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3601ce3f1589b8f9d54de158108a95af,
        type_description_1,
        par_self,
        var_pystore,
        var_store
    );


    // Release cached frame.
    if ( frame_3601ce3f1589b8f9d54de158108a95af == cache_frame_3601ce3f1589b8f9d54de158108a95af )
    {
        Py_DECREF( frame_3601ce3f1589b8f9d54de158108a95af );
    }
    cache_frame_3601ce3f1589b8f9d54de158108a95af = NULL;

    assertFrameObject( frame_3601ce3f1589b8f9d54de158108a95af );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pystore );
    tmp_return_value = var_pystore;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_45_get_cert_store );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pystore );
    var_pystore = NULL;

    CHECK_OBJECT( (PyObject *)var_store );
    Py_DECREF( var_store );
    var_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pystore );
    var_pystore = NULL;

    Py_XDECREF( var_store );
    var_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_45_get_cert_store );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_46_set_options( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_options = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_292c28a762938b6a8045d2808b664ec1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_292c28a762938b6a8045d2808b664ec1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_292c28a762938b6a8045d2808b664ec1, codeobj_292c28a762938b6a8045d2808b664ec1, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_292c28a762938b6a8045d2808b664ec1 = cache_frame_292c28a762938b6a8045d2808b664ec1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_292c28a762938b6a8045d2808b664ec1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_292c28a762938b6a8045d2808b664ec1 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_options );
        tmp_isinstance_inst_1 = par_options;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_a068c39f2c9878239ba2a3b47e83e1e0;
            frame_292c28a762938b6a8045d2808b664ec1->m_frame.f_lineno = 1344;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1344;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_options );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_options );
        tmp_args_element_name_2 = par_options;
        frame_292c28a762938b6a8045d2808b664ec1->m_frame.f_lineno = 1346;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1346;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_292c28a762938b6a8045d2808b664ec1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_292c28a762938b6a8045d2808b664ec1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_292c28a762938b6a8045d2808b664ec1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_292c28a762938b6a8045d2808b664ec1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_292c28a762938b6a8045d2808b664ec1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_292c28a762938b6a8045d2808b664ec1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_292c28a762938b6a8045d2808b664ec1,
        type_description_1,
        par_self,
        par_options
    );


    // Release cached frame.
    if ( frame_292c28a762938b6a8045d2808b664ec1 == cache_frame_292c28a762938b6a8045d2808b664ec1 )
    {
        Py_DECREF( frame_292c28a762938b6a8045d2808b664ec1 );
    }
    cache_frame_292c28a762938b6a8045d2808b664ec1 = NULL;

    assertFrameObject( frame_292c28a762938b6a8045d2808b664ec1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_46_set_options );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_options );
    Py_DECREF( par_options );
    par_options = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_options );
    Py_DECREF( par_options );
    par_options = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_46_set_options );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_47_set_mode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mode = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_f7131a7728aa55e97242ea844954e2d3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f7131a7728aa55e97242ea844954e2d3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f7131a7728aa55e97242ea844954e2d3, codeobj_f7131a7728aa55e97242ea844954e2d3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_f7131a7728aa55e97242ea844954e2d3 = cache_frame_f7131a7728aa55e97242ea844954e2d3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f7131a7728aa55e97242ea844954e2d3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f7131a7728aa55e97242ea844954e2d3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_mode );
        tmp_isinstance_inst_1 = par_mode;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 1356;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1356;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1356;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_71f502d97e845c89ec13eb6ef271f294;
            frame_f7131a7728aa55e97242ea844954e2d3->m_frame.f_lineno = 1357;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1357;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_mode );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_mode );
        tmp_args_element_name_2 = par_mode;
        frame_f7131a7728aa55e97242ea844954e2d3->m_frame.f_lineno = 1359;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1359;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7131a7728aa55e97242ea844954e2d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7131a7728aa55e97242ea844954e2d3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7131a7728aa55e97242ea844954e2d3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f7131a7728aa55e97242ea844954e2d3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f7131a7728aa55e97242ea844954e2d3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f7131a7728aa55e97242ea844954e2d3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f7131a7728aa55e97242ea844954e2d3,
        type_description_1,
        par_self,
        par_mode
    );


    // Release cached frame.
    if ( frame_f7131a7728aa55e97242ea844954e2d3 == cache_frame_f7131a7728aa55e97242ea844954e2d3 )
    {
        Py_DECREF( frame_f7131a7728aa55e97242ea844954e2d3 );
    }
    cache_frame_f7131a7728aa55e97242ea844954e2d3 = NULL;

    assertFrameObject( frame_f7131a7728aa55e97242ea844954e2d3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_47_set_mode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mode );
    Py_DECREF( par_mode );
    par_mode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_47_set_mode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_callback = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_wrapper = NULL;
    struct Nuitka_FrameObject *frame_4a87892876c4589d9c9a13b1feca9117;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_4a87892876c4589d9c9a13b1feca9117 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4a87892876c4589d9c9a13b1feca9117, codeobj_4a87892876c4589d9c9a13b1feca9117, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4a87892876c4589d9c9a13b1feca9117 = cache_frame_4a87892876c4589d9c9a13b1feca9117;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4a87892876c4589d9c9a13b1feca9117 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4a87892876c4589d9c9a13b1feca9117 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_wraps );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "wraps" );
            exception_tb = NULL;

            exception_lineno = 1372;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_callback ) );
        tmp_args_element_name_1 = PyCell_GET( par_callback );
        frame_4a87892876c4589d9c9a13b1feca9117->m_frame.f_lineno = 1372;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1372;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_callback;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );


        frame_4a87892876c4589d9c9a13b1feca9117->m_frame.f_lineno = 1372;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1372;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        assert( var_wrapper == NULL );
        var_wrapper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1377;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_b02795b9590127f96a3b627129a2fbd2;
        CHECK_OBJECT( var_wrapper );
        tmp_args_element_name_4 = var_wrapper;
        frame_4a87892876c4589d9c9a13b1feca9117->m_frame.f_lineno = 1377;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_callback, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1377;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__tlsext_servername_callback, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1377;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1379;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_tlsext_servername_callback );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1379;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1380;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__tlsext_servername_callback );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );

            exception_lineno = 1380;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        frame_4a87892876c4589d9c9a13b1feca9117->m_frame.f_lineno = 1379;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1379;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4a87892876c4589d9c9a13b1feca9117 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4a87892876c4589d9c9a13b1feca9117 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4a87892876c4589d9c9a13b1feca9117, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4a87892876c4589d9c9a13b1feca9117->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4a87892876c4589d9c9a13b1feca9117, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4a87892876c4589d9c9a13b1feca9117,
        type_description_1,
        par_self,
        par_callback,
        var_wrapper
    );


    // Release cached frame.
    if ( frame_4a87892876c4589d9c9a13b1feca9117 == cache_frame_4a87892876c4589d9c9a13b1feca9117 )
    {
        Py_DECREF( frame_4a87892876c4589d9c9a13b1feca9117 );
    }
    cache_frame_4a87892876c4589d9c9a13b1feca9117 = NULL;

    assertFrameObject( frame_4a87892876c4589d9c9a13b1feca9117 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_48_set_tlsext_servername_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_wrapper );
    Py_DECREF( var_wrapper );
    var_wrapper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_wrapper );
    var_wrapper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_48_set_tlsext_servername_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_ssl = python_pars[ 0 ];
    PyObject *par_alert = python_pars[ 1 ];
    PyObject *par_arg = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_f026f64ff0ca0abcc464653172e19868;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f026f64ff0ca0abcc464653172e19868 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f026f64ff0ca0abcc464653172e19868, codeobj_f026f64ff0ca0abcc464653172e19868, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f026f64ff0ca0abcc464653172e19868 = cache_frame_f026f64ff0ca0abcc464653172e19868;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f026f64ff0ca0abcc464653172e19868 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f026f64ff0ca0abcc464653172e19868 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_subscript_name_1;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "callback" );
            exception_tb = NULL;

            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = PyCell_GET( self->m_closure[0] );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__reverse_mapping );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_ssl );
        tmp_subscript_name_1 = par_ssl;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        frame_f026f64ff0ca0abcc464653172e19868->m_frame.f_lineno = 1374;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1374;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f026f64ff0ca0abcc464653172e19868 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f026f64ff0ca0abcc464653172e19868 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f026f64ff0ca0abcc464653172e19868, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f026f64ff0ca0abcc464653172e19868->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f026f64ff0ca0abcc464653172e19868, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f026f64ff0ca0abcc464653172e19868,
        type_description_1,
        par_ssl,
        par_alert,
        par_arg,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_f026f64ff0ca0abcc464653172e19868 == cache_frame_f026f64ff0ca0abcc464653172e19868 )
    {
        Py_DECREF( frame_f026f64ff0ca0abcc464653172e19868 );
    }
    cache_frame_f026f64ff0ca0abcc464653172e19868 = NULL;

    assertFrameObject( frame_f026f64ff0ca0abcc464653172e19868 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_alert );
    Py_DECREF( par_alert );
    par_alert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_arg );
    Py_DECREF( par_arg );
    par_arg = NULL;

    CHECK_OBJECT( (PyObject *)par_alert );
    Py_DECREF( par_alert );
    par_alert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_profiles = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_62907623253c538bdf755fd12f970dd3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_62907623253c538bdf755fd12f970dd3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_62907623253c538bdf755fd12f970dd3, codeobj_62907623253c538bdf755fd12f970dd3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_62907623253c538bdf755fd12f970dd3 = cache_frame_62907623253c538bdf755fd12f970dd3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_62907623253c538bdf755fd12f970dd3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_62907623253c538bdf755fd12f970dd3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_profiles );
        tmp_isinstance_inst_1 = par_profiles;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1390;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1390;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_75d74458faf9dee1d9b7a20a034cfad7;
            frame_62907623253c538bdf755fd12f970dd3->m_frame.f_lineno = 1391;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1391;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1393;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_CTX_set_tlsext_use_srtp );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_profiles );
        tmp_args_element_name_3 = par_profiles;
        frame_62907623253c538bdf755fd12f970dd3->m_frame.f_lineno = 1394;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_62907623253c538bdf755fd12f970dd3->m_frame.f_lineno = 1393;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1393;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_62907623253c538bdf755fd12f970dd3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_62907623253c538bdf755fd12f970dd3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_62907623253c538bdf755fd12f970dd3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_62907623253c538bdf755fd12f970dd3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_62907623253c538bdf755fd12f970dd3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_62907623253c538bdf755fd12f970dd3,
        type_description_1,
        par_self,
        par_profiles
    );


    // Release cached frame.
    if ( frame_62907623253c538bdf755fd12f970dd3 == cache_frame_62907623253c538bdf755fd12f970dd3 )
    {
        Py_DECREF( frame_62907623253c538bdf755fd12f970dd3 );
    }
    cache_frame_62907623253c538bdf755fd12f970dd3 = NULL;

    assertFrameObject( frame_62907623253c538bdf755fd12f970dd3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_49_set_tlsext_use_srtp );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profiles );
    Py_DECREF( par_profiles );
    par_profiles = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profiles );
    Py_DECREF( par_profiles );
    par_profiles = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_49_set_tlsext_use_srtp );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_50_set_npn_advertise_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_bcacbcc345964cd40d55a8ded45cab48;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_bcacbcc345964cd40d55a8ded45cab48 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bcacbcc345964cd40d55a8ded45cab48, codeobj_bcacbcc345964cd40d55a8ded45cab48, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_bcacbcc345964cd40d55a8ded45cab48 = cache_frame_bcacbcc345964cd40d55a8ded45cab48;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bcacbcc345964cd40d55a8ded45cab48 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bcacbcc345964cd40d55a8ded45cab48 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnAdvertiseHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__NpnAdvertiseHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_NpnAdvertiseHelper" );
            exception_tb = NULL;

            exception_lineno = 1411;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_bcacbcc345964cd40d55a8ded45cab48->m_frame.f_lineno = 1411;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1411;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__npn_advertise_helper, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1411;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__npn_advertise_helper );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__npn_advertise_callback, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1412;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1413;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_next_protos_advertised_cb );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1413;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__npn_advertise_callback );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_3;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_bcacbcc345964cd40d55a8ded45cab48->m_frame.f_lineno = 1413;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1413;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bcacbcc345964cd40d55a8ded45cab48 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bcacbcc345964cd40d55a8ded45cab48 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bcacbcc345964cd40d55a8ded45cab48, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bcacbcc345964cd40d55a8ded45cab48->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bcacbcc345964cd40d55a8ded45cab48, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bcacbcc345964cd40d55a8ded45cab48,
        type_description_1,
        par_self,
        par_callback
    );


    // Release cached frame.
    if ( frame_bcacbcc345964cd40d55a8ded45cab48 == cache_frame_bcacbcc345964cd40d55a8ded45cab48 )
    {
        Py_DECREF( frame_bcacbcc345964cd40d55a8ded45cab48 );
    }
    cache_frame_bcacbcc345964cd40d55a8ded45cab48 = NULL;

    assertFrameObject( frame_bcacbcc345964cd40d55a8ded45cab48 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_50_set_npn_advertise_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_50_set_npn_advertise_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_51_set_npn_select_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_c84e069d6460014d6980972db9133002;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_c84e069d6460014d6980972db9133002 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c84e069d6460014d6980972db9133002, codeobj_c84e069d6460014d6980972db9133002, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_c84e069d6460014d6980972db9133002 = cache_frame_c84e069d6460014d6980972db9133002;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c84e069d6460014d6980972db9133002 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c84e069d6460014d6980972db9133002 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnSelectHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__NpnSelectHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_NpnSelectHelper" );
            exception_tb = NULL;

            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_c84e069d6460014d6980972db9133002->m_frame.f_lineno = 1429;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__npn_select_helper, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1429;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__npn_select_helper );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__npn_select_callback, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_next_proto_select_cb );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__npn_select_callback );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_3;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1432;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c84e069d6460014d6980972db9133002->m_frame.f_lineno = 1431;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c84e069d6460014d6980972db9133002 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c84e069d6460014d6980972db9133002 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c84e069d6460014d6980972db9133002, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c84e069d6460014d6980972db9133002->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c84e069d6460014d6980972db9133002, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c84e069d6460014d6980972db9133002,
        type_description_1,
        par_self,
        par_callback
    );


    // Release cached frame.
    if ( frame_c84e069d6460014d6980972db9133002 == cache_frame_c84e069d6460014d6980972db9133002 )
    {
        Py_DECREF( frame_c84e069d6460014d6980972db9133002 );
    }
    cache_frame_c84e069d6460014d6980972db9133002 = NULL;

    assertFrameObject( frame_c84e069d6460014d6980972db9133002 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_51_set_npn_select_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_51_set_npn_select_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_52_set_alpn_protos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_protos = python_pars[ 1 ];
    PyObject *var_protostr = NULL;
    PyObject *var_input_str = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_250a4ae7f401cdf63a568e77d373460c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_250a4ae7f401cdf63a568e77d373460c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_250a4ae7f401cdf63a568e77d373460c, codeobj_250a4ae7f401cdf63a568e77d373460c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_250a4ae7f401cdf63a568e77d373460c = cache_frame_250a4ae7f401cdf63a568e77d373460c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_250a4ae7f401cdf63a568e77d373460c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_250a4ae7f401cdf63a568e77d373460c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        tmp_source_name_1 = const_str_empty;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
        assert( !(tmp_called_name_1 == NULL) );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_chain );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "chain" );
            exception_tb = NULL;

            exception_lineno = 1448;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_from_iterable );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1448;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_protos );
            tmp_iter_arg_1 = par_protos;
            tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1448;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_args_element_name_2 = OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_2)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_52_set_alpn_protos );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_52_set_alpn_protos );
        return NULL;
        outline_result_1:;
        frame_250a4ae7f401cdf63a568e77d373460c->m_frame.f_lineno = 1448;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1448;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_250a4ae7f401cdf63a568e77d373460c->m_frame.f_lineno = 1447;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1447;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_protostr == NULL );
        var_protostr = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1453;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_protostr );
        tmp_args_element_name_4 = var_protostr;
        frame_250a4ae7f401cdf63a568e77d373460c->m_frame.f_lineno = 1453;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1453;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_input_str == NULL );
        var_input_str = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_alpn_protos );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_input_str );
        tmp_args_element_name_6 = var_input_str;
        CHECK_OBJECT( var_protostr );
        tmp_len_arg_1 = var_protostr;
        tmp_args_element_name_7 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );

            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_250a4ae7f401cdf63a568e77d373460c->m_frame.f_lineno = 1454;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1454;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_250a4ae7f401cdf63a568e77d373460c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_250a4ae7f401cdf63a568e77d373460c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_250a4ae7f401cdf63a568e77d373460c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_250a4ae7f401cdf63a568e77d373460c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_250a4ae7f401cdf63a568e77d373460c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_250a4ae7f401cdf63a568e77d373460c,
        type_description_1,
        par_self,
        par_protos,
        var_protostr,
        var_input_str
    );


    // Release cached frame.
    if ( frame_250a4ae7f401cdf63a568e77d373460c == cache_frame_250a4ae7f401cdf63a568e77d373460c )
    {
        Py_DECREF( frame_250a4ae7f401cdf63a568e77d373460c );
    }
    cache_frame_250a4ae7f401cdf63a568e77d373460c = NULL;

    assertFrameObject( frame_250a4ae7f401cdf63a568e77d373460c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_52_set_alpn_protos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    CHECK_OBJECT( (PyObject *)var_protostr );
    Py_DECREF( var_protostr );
    var_protostr = NULL;

    CHECK_OBJECT( (PyObject *)var_input_str );
    Py_DECREF( var_input_str );
    var_input_str = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    Py_XDECREF( var_protostr );
    var_protostr = NULL;

    Py_XDECREF( var_input_str );
    var_input_str = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_52_set_alpn_protos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals {
    PyObject *var_p;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_p = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_116f97c7c996ca860bb0997e5690d1a7, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 1448;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_p;
            generator_heap->var_p = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_p );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "int2byte" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_p );
        tmp_len_arg_1 = generator_heap->var_p;
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 1448;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( generator_heap->var_p );
        tmp_tuple_element_1 = generator_heap->var_p;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1448;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 1448;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_p
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_p );
    generator_heap->var_p = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_p );
    generator_heap->var_p = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_116f97c7c996ca860bb0997e5690d1a7,
        1,
        sizeof(struct OpenSSL$SSL$$$function_52_set_alpn_protos$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_53_set_alpn_select_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_6e82bf48752d997d2ba9c4cb6ca57dc0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6e82bf48752d997d2ba9c4cb6ca57dc0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6e82bf48752d997d2ba9c4cb6ca57dc0, codeobj_6e82bf48752d997d2ba9c4cb6ca57dc0, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_6e82bf48752d997d2ba9c4cb6ca57dc0 = cache_frame_6e82bf48752d997d2ba9c4cb6ca57dc0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6e82bf48752d997d2ba9c4cb6ca57dc0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6e82bf48752d997d2ba9c4cb6ca57dc0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ALPNSelectHelper" );
            exception_tb = NULL;

            exception_lineno = 1467;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_6e82bf48752d997d2ba9c4cb6ca57dc0->m_frame.f_lineno = 1467;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1467;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__alpn_select_helper, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1467;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__alpn_select_helper );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__alpn_select_callback, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1469;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_alpn_select_cb );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1469;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__alpn_select_callback );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_3;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_6e82bf48752d997d2ba9c4cb6ca57dc0->m_frame.f_lineno = 1469;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1469;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e82bf48752d997d2ba9c4cb6ca57dc0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e82bf48752d997d2ba9c4cb6ca57dc0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6e82bf48752d997d2ba9c4cb6ca57dc0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6e82bf48752d997d2ba9c4cb6ca57dc0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6e82bf48752d997d2ba9c4cb6ca57dc0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6e82bf48752d997d2ba9c4cb6ca57dc0,
        type_description_1,
        par_self,
        par_callback
    );


    // Release cached frame.
    if ( frame_6e82bf48752d997d2ba9c4cb6ca57dc0 == cache_frame_6e82bf48752d997d2ba9c4cb6ca57dc0 )
    {
        Py_DECREF( frame_6e82bf48752d997d2ba9c4cb6ca57dc0 );
    }
    cache_frame_6e82bf48752d997d2ba9c4cb6ca57dc0 = NULL;

    assertFrameObject( frame_6e82bf48752d997d2ba9c4cb6ca57dc0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_53_set_alpn_select_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_53_set_alpn_select_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_54__set_ocsp_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_helper = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *var_rc = NULL;
    struct Nuitka_FrameObject *frame_1fd679ce963858fb95fb0f532483b704;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1fd679ce963858fb95fb0f532483b704 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1fd679ce963858fb95fb0f532483b704, codeobj_1fd679ce963858fb95fb0f532483b704, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1fd679ce963858fb95fb0f532483b704 = cache_frame_1fd679ce963858fb95fb0f532483b704;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1fd679ce963858fb95fb0f532483b704 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1fd679ce963858fb95fb0f532483b704 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_helper );
        tmp_assattr_name_1 = par_helper;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__ocsp_helper, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1478;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_helper );
        tmp_source_name_1 = par_helper;
        tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_callback );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1479;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__ocsp_callback, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1479;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_data );
        tmp_compexpr_left_1 = par_data;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_assattr_target_3;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1481;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_1;
            tmp_assattr_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_assattr_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1481;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_3 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__ocsp_data, tmp_assattr_name_3 );
            Py_DECREF( tmp_assattr_name_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1481;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assattr_name_4;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_assattr_target_4;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1483;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_data );
            tmp_args_element_name_1 = par_data;
            frame_1fd679ce963858fb95fb0f532483b704->m_frame.f_lineno = 1483;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assattr_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new_handle, call_args );
            }

            if ( tmp_assattr_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1483;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_4 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__ocsp_data, tmp_assattr_name_4 );
            Py_DECREF( tmp_assattr_name_4 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1483;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1485;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_CTX_set_tlsext_status_cb );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1485;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1486;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ocsp_callback );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 1486;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_1fd679ce963858fb95fb0f532483b704->m_frame.f_lineno = 1485;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1485;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_rc == NULL );
        var_rc = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1488;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_4;
        CHECK_OBJECT( var_rc );
        tmp_compexpr_left_2 = var_rc;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_4 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1488;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_1fd679ce963858fb95fb0f532483b704->m_frame.f_lineno = 1488;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1488;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_8;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_CTX_set_tlsext_status_arg );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__context );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__ocsp_data );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );

            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_1fd679ce963858fb95fb0f532483b704->m_frame.f_lineno = 1489;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1489;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_rc;
            assert( old != NULL );
            var_rc = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1490;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT( var_rc );
        tmp_compexpr_left_3 = var_rc;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_args_element_name_7 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1490;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_1fd679ce963858fb95fb0f532483b704->m_frame.f_lineno = 1490;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1490;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fd679ce963858fb95fb0f532483b704 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fd679ce963858fb95fb0f532483b704 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1fd679ce963858fb95fb0f532483b704, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1fd679ce963858fb95fb0f532483b704->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1fd679ce963858fb95fb0f532483b704, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1fd679ce963858fb95fb0f532483b704,
        type_description_1,
        par_self,
        par_helper,
        par_data,
        var_rc
    );


    // Release cached frame.
    if ( frame_1fd679ce963858fb95fb0f532483b704 == cache_frame_1fd679ce963858fb95fb0f532483b704 )
    {
        Py_DECREF( frame_1fd679ce963858fb95fb0f532483b704 );
    }
    cache_frame_1fd679ce963858fb95fb0f532483b704 = NULL;

    assertFrameObject( frame_1fd679ce963858fb95fb0f532483b704 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_54__set_ocsp_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_helper );
    Py_DECREF( par_helper );
    par_helper = NULL;

    CHECK_OBJECT( (PyObject *)var_rc );
    Py_DECREF( var_rc );
    var_rc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_helper );
    Py_DECREF( par_helper );
    par_helper = NULL;

    Py_XDECREF( var_rc );
    var_rc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_54__set_ocsp_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_55_set_ocsp_server_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *var_helper = NULL;
    struct Nuitka_FrameObject *frame_355fcfa300882710f491f60c8724e180;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_355fcfa300882710f491f60c8724e180 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_355fcfa300882710f491f60c8724e180, codeobj_355fcfa300882710f491f60c8724e180, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_355fcfa300882710f491f60c8724e180 = cache_frame_355fcfa300882710f491f60c8724e180;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_355fcfa300882710f491f60c8724e180 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_355fcfa300882710f491f60c8724e180 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_OCSPServerCallbackHelper" );
            exception_tb = NULL;

            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_355fcfa300882710f491f60c8724e180->m_frame.f_lineno = 1507;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_helper == NULL );
        var_helper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( var_helper );
        tmp_args_element_name_2 = var_helper;
        CHECK_OBJECT( par_data );
        tmp_args_element_name_3 = par_data;
        frame_355fcfa300882710f491f60c8724e180->m_frame.f_lineno = 1508;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__set_ocsp_callback, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1508;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_355fcfa300882710f491f60c8724e180 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_355fcfa300882710f491f60c8724e180 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_355fcfa300882710f491f60c8724e180, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_355fcfa300882710f491f60c8724e180->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_355fcfa300882710f491f60c8724e180, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_355fcfa300882710f491f60c8724e180,
        type_description_1,
        par_self,
        par_callback,
        par_data,
        var_helper
    );


    // Release cached frame.
    if ( frame_355fcfa300882710f491f60c8724e180 == cache_frame_355fcfa300882710f491f60c8724e180 )
    {
        Py_DECREF( frame_355fcfa300882710f491f60c8724e180 );
    }
    cache_frame_355fcfa300882710f491f60c8724e180 = NULL;

    assertFrameObject( frame_355fcfa300882710f491f60c8724e180 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_55_set_ocsp_server_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_55_set_ocsp_server_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_56_set_ocsp_client_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_callback = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *var_helper = NULL;
    struct Nuitka_FrameObject *frame_9c360624a33744b74644bf01d1e328dc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9c360624a33744b74644bf01d1e328dc = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9c360624a33744b74644bf01d1e328dc, codeobj_9c360624a33744b74644bf01d1e328dc, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9c360624a33744b74644bf01d1e328dc = cache_frame_9c360624a33744b74644bf01d1e328dc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9c360624a33744b74644bf01d1e328dc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9c360624a33744b74644bf01d1e328dc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_OCSPClientCallbackHelper" );
            exception_tb = NULL;

            exception_lineno = 1527;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_callback );
        tmp_args_element_name_1 = par_callback;
        frame_9c360624a33744b74644bf01d1e328dc->m_frame.f_lineno = 1527;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1527;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_helper == NULL );
        var_helper = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( var_helper );
        tmp_args_element_name_2 = var_helper;
        CHECK_OBJECT( par_data );
        tmp_args_element_name_3 = par_data;
        frame_9c360624a33744b74644bf01d1e328dc->m_frame.f_lineno = 1528;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__set_ocsp_callback, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1528;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c360624a33744b74644bf01d1e328dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c360624a33744b74644bf01d1e328dc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9c360624a33744b74644bf01d1e328dc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9c360624a33744b74644bf01d1e328dc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9c360624a33744b74644bf01d1e328dc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9c360624a33744b74644bf01d1e328dc,
        type_description_1,
        par_self,
        par_callback,
        par_data,
        var_helper
    );


    // Release cached frame.
    if ( frame_9c360624a33744b74644bf01d1e328dc == cache_frame_9c360624a33744b74644bf01d1e328dc )
    {
        Py_DECREF( frame_9c360624a33744b74644bf01d1e328dc );
    }
    cache_frame_9c360624a33744b74644bf01d1e328dc = NULL;

    assertFrameObject( frame_9c360624a33744b74644bf01d1e328dc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_56_set_ocsp_client_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_56_set_ocsp_client_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_57___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_context = python_pars[ 1 ];
    PyObject *par_socket = python_pars[ 2 ];
    PyObject *var_ssl = NULL;
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_118684193660e42e7b532200be083df8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_118684193660e42e7b532200be083df8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_118684193660e42e7b532200be083df8, codeobj_118684193660e42e7b532200be083df8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_118684193660e42e7b532200be083df8 = cache_frame_118684193660e42e7b532200be083df8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_118684193660e42e7b532200be083df8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_118684193660e42e7b532200be083df8 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_context );
        tmp_isinstance_inst_1 = par_context;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Context );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Context" );
            exception_tb = NULL;

            exception_lineno = 1550;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1550;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1550;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1551;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1551;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_new );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_context );
        tmp_source_name_2 = par_context;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1553;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1553;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_ssl == NULL );
        var_ssl = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ssl );
        tmp_args_element_name_2 = var_ssl;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_free );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1554;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__ssl, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SSL_set_mode );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__ssl );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_MODE_AUTO_RETRY );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_4 );

            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1559;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1559;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_context );
        tmp_assattr_name_2 = par_context;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__context, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1560;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__app_data, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1561;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__npn_advertise_callback_args, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1567;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        tmp_assattr_name_5 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__npn_select_callback_args, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1568;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        tmp_assattr_name_6 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain__alpn_select_callback_args, tmp_assattr_name_6 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1574;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_source_name_8;
        PyObject *tmp_ass_subscript_1;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT( par_self );
        tmp_ass_subvalue_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__reverse_mapping );
        if ( tmp_ass_subscribed_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1576;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_ass_subscript_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__ssl );
        if ( tmp_ass_subscript_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_ass_subscribed_1 );

            exception_lineno = 1576;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subscribed_1 );
        Py_DECREF( tmp_ass_subscript_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1576;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_socket );
        tmp_compexpr_left_1 = par_socket;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_assattr_target_7;
            tmp_assattr_name_7 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_7 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain__socket, tmp_assattr_name_7 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1579;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_8;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_assattr_target_8;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_7;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_BIO_new );
            if ( tmp_called_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_8 == NULL )
            {
                Py_DECREF( tmp_called_name_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_8;
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1581;
            tmp_args_element_name_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BIO_s_mem );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_4 );

                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1581;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_assattr_name_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_assattr_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_8 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain__into_ssl, tmp_assattr_name_8 );
            Py_DECREF( tmp_assattr_name_8 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1581;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_9;
            CHECK_OBJECT( par_self );
            tmp_source_name_11 = par_self;
            tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__into_ssl );
            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_10 == NULL )
            {
                Py_DECREF( tmp_compexpr_left_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_12 = tmp_mvar_value_10;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_NULL );
            if ( tmp_compexpr_right_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_2 );

                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_7 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            Py_DECREF( tmp_compexpr_right_2 );
            if ( tmp_args_element_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1582;
            {
                PyObject *call_args[] = { tmp_args_element_name_7 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1582;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            PyObject *tmp_assattr_name_9;
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_13;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_assattr_target_9;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_13 = tmp_mvar_value_11;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_BIO_new );
            if ( tmp_called_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_12 == NULL )
            {
                Py_DECREF( tmp_called_name_6 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_12;
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1584;
            tmp_args_element_name_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_BIO_s_mem );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_6 );

                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1584;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_assattr_name_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_called_name_6 );
            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_assattr_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_9 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__from_ssl, tmp_assattr_name_9 );
            Py_DECREF( tmp_assattr_name_9 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1584;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_called_name_7;
            PyObject *tmp_mvar_value_13;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_14;
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_14;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_13 == NULL ))
            {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_13 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_7 = tmp_mvar_value_13;
            CHECK_OBJECT( par_self );
            tmp_source_name_14 = par_self;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__from_ssl );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_14 == NULL ))
            {
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_14 == NULL )
            {
                Py_DECREF( tmp_compexpr_left_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_15 = tmp_mvar_value_14;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_NULL );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_3 );

                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_9 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_args_element_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1585;
            {
                PyObject *call_args[] = { tmp_args_element_name_9 };
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
            }

            Py_DECREF( tmp_args_element_name_9 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1585;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        {
            PyObject *tmp_called_name_8;
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_call_result_4;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_17;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_source_name_18;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_source_name_19;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_16 = tmp_mvar_value_15;
            tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_SSL_set_bio );
            if ( tmp_called_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_17 = par_self;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain__ssl );
            if ( tmp_args_element_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_8 );

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_18 = par_self;
            tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain__into_ssl );
            if ( tmp_args_element_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_8 );
                Py_DECREF( tmp_args_element_name_10 );

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_19 = par_self;
            tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain__from_ssl );
            if ( tmp_args_element_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_8 );
                Py_DECREF( tmp_args_element_name_10 );
                Py_DECREF( tmp_args_element_name_11 );

                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1587;
            {
                PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
                tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
            }

            Py_DECREF( tmp_called_name_8 );
            Py_DECREF( tmp_args_element_name_10 );
            Py_DECREF( tmp_args_element_name_11 );
            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1587;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assattr_name_10;
            PyObject *tmp_assattr_target_10;
            tmp_assattr_name_10 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_10 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__into_ssl, tmp_assattr_name_10 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1589;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_11;
            PyObject *tmp_assattr_target_11;
            tmp_assattr_name_11 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_11 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain__from_ssl, tmp_assattr_name_11 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1590;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_12;
            PyObject *tmp_assattr_target_12;
            CHECK_OBJECT( par_socket );
            tmp_assattr_name_12 = par_socket;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_12 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain__socket, tmp_assattr_name_12 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1591;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_9;
            PyObject *tmp_source_name_20;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_args_element_name_13;
            PyObject *tmp_source_name_21;
            PyObject *tmp_args_element_name_14;
            PyObject *tmp_called_name_10;
            PyObject *tmp_mvar_value_17;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_source_name_22;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_16 == NULL ))
            {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_16 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1592;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_20 = tmp_mvar_value_16;
            tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_SSL_set_fd );
            if ( tmp_called_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1592;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_21 = par_self;
            tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain__ssl );
            if ( tmp_args_element_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__asFileDescriptor );

            if (unlikely( tmp_mvar_value_17 == NULL ))
            {
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__asFileDescriptor );
            }

            if ( tmp_mvar_value_17 == NULL )
            {
                Py_DECREF( tmp_called_name_9 );
                Py_DECREF( tmp_args_element_name_13 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_asFileDescriptor" );
                exception_tb = NULL;

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_10 = tmp_mvar_value_17;
            CHECK_OBJECT( par_self );
            tmp_source_name_22 = par_self;
            tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain__socket );
            if ( tmp_args_element_name_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );
                Py_DECREF( tmp_args_element_name_13 );

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1593;
            {
                PyObject *call_args[] = { tmp_args_element_name_15 };
                tmp_args_element_name_14 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
            }

            Py_DECREF( tmp_args_element_name_15 );
            if ( tmp_args_element_name_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );
                Py_DECREF( tmp_args_element_name_13 );

                exception_lineno = 1593;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1592;
            {
                PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_9, call_args );
            }

            Py_DECREF( tmp_called_name_9 );
            Py_DECREF( tmp_args_element_name_13 );
            Py_DECREF( tmp_args_element_name_14 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1592;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_set_result == NULL );
            var_set_result = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_name_11;
            PyObject *tmp_mvar_value_18;
            PyObject *tmp_call_result_5;
            PyObject *tmp_args_element_name_16;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_18 == NULL ))
            {
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_18 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 1594;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_11 = tmp_mvar_value_18;
            CHECK_OBJECT( var_set_result );
            tmp_compexpr_left_4 = var_set_result;
            tmp_compexpr_right_4 = const_int_pos_1;
            tmp_args_element_name_16 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_args_element_name_16 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1594;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_118684193660e42e7b532200be083df8->m_frame.f_lineno = 1594;
            {
                PyObject *call_args[] = { tmp_args_element_name_16 };
                tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
            }

            Py_DECREF( tmp_args_element_name_16 );
            if ( tmp_call_result_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1594;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_5 );
        }
        branch_end_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_118684193660e42e7b532200be083df8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_118684193660e42e7b532200be083df8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_118684193660e42e7b532200be083df8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_118684193660e42e7b532200be083df8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_118684193660e42e7b532200be083df8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_118684193660e42e7b532200be083df8,
        type_description_1,
        par_self,
        par_context,
        par_socket,
        var_ssl,
        var_set_result
    );


    // Release cached frame.
    if ( frame_118684193660e42e7b532200be083df8 == cache_frame_118684193660e42e7b532200be083df8 )
    {
        Py_DECREF( frame_118684193660e42e7b532200be083df8 );
    }
    cache_frame_118684193660e42e7b532200be083df8 = NULL;

    assertFrameObject( frame_118684193660e42e7b532200be083df8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_57___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_ssl );
    Py_DECREF( var_ssl );
    var_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_socket );
    Py_DECREF( par_socket );
    par_socket = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ssl );
    var_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_socket );
    Py_DECREF( par_socket );
    par_socket = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_57___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_58___getattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_d66630988e992039e8c615ca57600ec8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d66630988e992039e8c615ca57600ec8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d66630988e992039e8c615ca57600ec8, codeobj_d66630988e992039e8c615ca57600ec8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_d66630988e992039e8c615ca57600ec8 = cache_frame_d66630988e992039e8c615ca57600ec8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d66630988e992039e8c615ca57600ec8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d66630988e992039e8c615ca57600ec8 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__socket );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1601;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            tmp_left_name_1 = const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_3 );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1603;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___name__ );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1603;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyTuple_New( 2 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_name );
            tmp_tuple_element_1 = par_name;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1602;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_d66630988e992039e8c615ca57600ec8->m_frame.f_lineno = 1602;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1602;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_getattr_target_1;
            PyObject *tmp_source_name_4;
            PyObject *tmp_getattr_attr_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_getattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__socket );
            if ( tmp_getattr_target_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1606;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_name );
            tmp_getattr_attr_1 = par_name;
            tmp_return_value = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
            Py_DECREF( tmp_getattr_target_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1606;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d66630988e992039e8c615ca57600ec8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d66630988e992039e8c615ca57600ec8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d66630988e992039e8c615ca57600ec8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d66630988e992039e8c615ca57600ec8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d66630988e992039e8c615ca57600ec8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d66630988e992039e8c615ca57600ec8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d66630988e992039e8c615ca57600ec8,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_d66630988e992039e8c615ca57600ec8 == cache_frame_d66630988e992039e8c615ca57600ec8 )
    {
        Py_DECREF( frame_d66630988e992039e8c615ca57600ec8 );
    }
    cache_frame_d66630988e992039e8c615ca57600ec8 = NULL;

    assertFrameObject( frame_d66630988e992039e8c615ca57600ec8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_58___getattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_58___getattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_59__raise_ssl_error( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_ssl = python_pars[ 1 ];
    PyObject *par_result = python_pars[ 2 ];
    PyObject *var_errno = NULL;
    PyObject *var_error = NULL;
    struct Nuitka_FrameObject *frame_e64d814c39cb7a48505598e16da6bb25;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e64d814c39cb7a48505598e16da6bb25 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e64d814c39cb7a48505598e16da6bb25, codeobj_e64d814c39cb7a48505598e16da6bb25, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e64d814c39cb7a48505598e16da6bb25 = cache_frame_e64d814c39cb7a48505598e16da6bb25;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e64d814c39cb7a48505598e16da6bb25 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e64d814c39cb7a48505598e16da6bb25 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1609;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__verify_helper );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1609;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__context );
            if ( tmp_source_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1610;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__verify_helper );
            Py_DECREF( tmp_source_name_3 );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1610;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1610;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_raise_if_problem );
            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1610;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__context );
        if ( tmp_source_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__npn_advertise_helper );
        Py_DECREF( tmp_source_name_5 );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_2 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_7;
            PyObject *tmp_source_name_8;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__context );
            if ( tmp_source_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1612;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__npn_advertise_helper );
            Py_DECREF( tmp_source_name_7 );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1612;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1612;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_raise_if_problem );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1612;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_9;
        PyObject *tmp_source_name_10;
        CHECK_OBJECT( par_self );
        tmp_source_name_10 = par_self;
        tmp_source_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__context );
        if ( tmp_source_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1613;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__npn_select_helper );
        Py_DECREF( tmp_source_name_9 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1613;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_3 );
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_source_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_call_result_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_12 = par_self;
            tmp_source_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__context );
            if ( tmp_source_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1614;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__npn_select_helper );
            Py_DECREF( tmp_source_name_11 );
            if ( tmp_called_instance_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1614;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1614;
            tmp_call_result_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_raise_if_problem );
            Py_DECREF( tmp_called_instance_3 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1614;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_13;
        PyObject *tmp_source_name_14;
        CHECK_OBJECT( par_self );
        tmp_source_name_14 = par_self;
        tmp_source_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__context );
        if ( tmp_source_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1615;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain__alpn_select_helper );
        Py_DECREF( tmp_source_name_13 );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1615;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_4 = Py_None;
        tmp_condition_result_4 = ( tmp_compexpr_left_4 != tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_4 );
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_source_name_15;
            PyObject *tmp_source_name_16;
            PyObject *tmp_call_result_4;
            CHECK_OBJECT( par_self );
            tmp_source_name_16 = par_self;
            tmp_source_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain__context );
            if ( tmp_source_name_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1616;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__alpn_select_helper );
            Py_DECREF( tmp_source_name_15 );
            if ( tmp_called_instance_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1616;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1616;
            tmp_call_result_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_raise_if_problem );
            Py_DECREF( tmp_called_instance_4 );
            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1616;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_17;
        PyObject *tmp_source_name_18;
        CHECK_OBJECT( par_self );
        tmp_source_name_18 = par_self;
        tmp_source_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain__context );
        if ( tmp_source_name_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1617;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain__ocsp_helper );
        Py_DECREF( tmp_source_name_17 );
        if ( tmp_compexpr_left_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1617;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_5 = Py_None;
        tmp_condition_result_5 = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_5 );
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_source_name_19;
            PyObject *tmp_source_name_20;
            PyObject *tmp_call_result_5;
            CHECK_OBJECT( par_self );
            tmp_source_name_20 = par_self;
            tmp_source_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain__context );
            if ( tmp_source_name_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1618;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_5 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain__ocsp_helper );
            Py_DECREF( tmp_source_name_19 );
            if ( tmp_called_instance_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1618;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1618;
            tmp_call_result_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_raise_if_problem );
            Py_DECREF( tmp_called_instance_5 );
            if ( tmp_call_result_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1618;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_5 );
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1620;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_6 = tmp_mvar_value_1;
        CHECK_OBJECT( par_ssl );
        tmp_args_element_name_1 = par_ssl;
        CHECK_OBJECT( par_result );
        tmp_args_element_name_2 = par_result;
        frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1620;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_6, const_str_plain_SSL_get_error, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1620;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_error == NULL );
        var_error = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_error );
        tmp_compexpr_left_6 = var_error;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1621;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_2;
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_SSL_ERROR_WANT_READ );
        if ( tmp_compexpr_right_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1621;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
        Py_DECREF( tmp_compexpr_right_6 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1621;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantReadError );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantReadError" );
                exception_tb = NULL;

                exception_lineno = 1622;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_3;
            frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1622;
            tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1622;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 1622;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto branch_end_6;
        branch_no_6:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_7;
            PyObject *tmp_compexpr_right_7;
            PyObject *tmp_source_name_22;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT( var_error );
            tmp_compexpr_left_7 = var_error;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1623;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_22 = tmp_mvar_value_4;
            tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_SSL_ERROR_WANT_WRITE );
            if ( tmp_compexpr_right_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1623;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
            Py_DECREF( tmp_compexpr_right_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1623;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_called_name_2;
                PyObject *tmp_mvar_value_5;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantWriteError );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantWriteError" );
                    exception_tb = NULL;

                    exception_lineno = 1624;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_2 = tmp_mvar_value_5;
                frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1624;
                tmp_raise_type_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
                if ( tmp_raise_type_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1624;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_2;
                exception_lineno = 1624;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_7;
            branch_no_7:;
            {
                nuitka_bool tmp_condition_result_8;
                PyObject *tmp_compexpr_left_8;
                PyObject *tmp_compexpr_right_8;
                PyObject *tmp_source_name_23;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT( var_error );
                tmp_compexpr_left_8 = var_error;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_6 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 1625;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_23 = tmp_mvar_value_6;
                tmp_compexpr_right_8 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_SSL_ERROR_ZERO_RETURN );
                if ( tmp_compexpr_right_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1625;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
                Py_DECREF( tmp_compexpr_right_8 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1625;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_8;
                }
                else
                {
                    goto branch_no_8;
                }
                branch_yes_8:;
                {
                    PyObject *tmp_raise_type_3;
                    PyObject *tmp_called_name_3;
                    PyObject *tmp_mvar_value_7;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ZeroReturnError );

                    if (unlikely( tmp_mvar_value_7 == NULL ))
                    {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ZeroReturnError );
                    }

                    if ( tmp_mvar_value_7 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ZeroReturnError" );
                        exception_tb = NULL;

                        exception_lineno = 1626;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_3 = tmp_mvar_value_7;
                    frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1626;
                    tmp_raise_type_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
                    if ( tmp_raise_type_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1626;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    exception_type = tmp_raise_type_3;
                    exception_lineno = 1626;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                goto branch_end_8;
                branch_no_8:;
                {
                    nuitka_bool tmp_condition_result_9;
                    PyObject *tmp_compexpr_left_9;
                    PyObject *tmp_compexpr_right_9;
                    PyObject *tmp_source_name_24;
                    PyObject *tmp_mvar_value_8;
                    CHECK_OBJECT( var_error );
                    tmp_compexpr_left_9 = var_error;
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_8 == NULL ))
                    {
                        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_8 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1627;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_24 = tmp_mvar_value_8;
                    tmp_compexpr_right_9 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_SSL_ERROR_WANT_X509_LOOKUP );
                    if ( tmp_compexpr_right_9 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1627;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_9, tmp_compexpr_right_9 );
                    Py_DECREF( tmp_compexpr_right_9 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1627;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_9;
                    }
                    else
                    {
                        goto branch_no_9;
                    }
                    branch_yes_9:;
                    {
                        PyObject *tmp_raise_type_4;
                        PyObject *tmp_called_name_4;
                        PyObject *tmp_mvar_value_9;
                        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantX509LookupError );

                        if (unlikely( tmp_mvar_value_9 == NULL ))
                        {
                            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantX509LookupError );
                        }

                        if ( tmp_mvar_value_9 == NULL )
                        {

                            exception_type = PyExc_NameError;
                            Py_INCREF( exception_type );
                            exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantX509LookupError" );
                            exception_tb = NULL;

                            exception_lineno = 1629;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }

                        tmp_called_name_4 = tmp_mvar_value_9;
                        frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1629;
                        tmp_raise_type_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
                        if ( tmp_raise_type_4 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 1629;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }
                        exception_type = tmp_raise_type_4;
                        exception_lineno = 1629;
                        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    goto branch_end_9;
                    branch_no_9:;
                    {
                        nuitka_bool tmp_condition_result_10;
                        PyObject *tmp_compexpr_left_10;
                        PyObject *tmp_compexpr_right_10;
                        PyObject *tmp_source_name_25;
                        PyObject *tmp_mvar_value_10;
                        CHECK_OBJECT( var_error );
                        tmp_compexpr_left_10 = var_error;
                        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

                        if (unlikely( tmp_mvar_value_10 == NULL ))
                        {
                            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                        }

                        if ( tmp_mvar_value_10 == NULL )
                        {

                            exception_type = PyExc_NameError;
                            Py_INCREF( exception_type );
                            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                            exception_tb = NULL;

                            exception_lineno = 1630;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }

                        tmp_source_name_25 = tmp_mvar_value_10;
                        tmp_compexpr_right_10 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain_SSL_ERROR_SYSCALL );
                        if ( tmp_compexpr_right_10 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 1630;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }
                        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_10, tmp_compexpr_right_10 );
                        Py_DECREF( tmp_compexpr_right_10 );
                        if ( tmp_res == -1 )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 1630;
                            type_description_1 = "ooooo";
                            goto frame_exception_exit_1;
                        }
                        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
                        {
                            goto branch_yes_10;
                        }
                        else
                        {
                            goto branch_no_10;
                        }
                        branch_yes_10:;
                        {
                            nuitka_bool tmp_condition_result_11;
                            PyObject *tmp_compexpr_left_11;
                            PyObject *tmp_compexpr_right_11;
                            PyObject *tmp_called_instance_7;
                            PyObject *tmp_mvar_value_11;
                            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

                            if (unlikely( tmp_mvar_value_11 == NULL ))
                            {
                                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                            }

                            if ( tmp_mvar_value_11 == NULL )
                            {

                                exception_type = PyExc_NameError;
                                Py_INCREF( exception_type );
                                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                                exception_tb = NULL;

                                exception_lineno = 1631;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }

                            tmp_called_instance_7 = tmp_mvar_value_11;
                            frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1631;
                            tmp_compexpr_left_11 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_ERR_peek_error );
                            if ( tmp_compexpr_left_11 == NULL )
                            {
                                assert( ERROR_OCCURRED() );

                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                exception_lineno = 1631;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_compexpr_right_11 = const_int_0;
                            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_11, tmp_compexpr_right_11 );
                            Py_DECREF( tmp_compexpr_left_11 );
                            if ( tmp_res == -1 )
                            {
                                assert( ERROR_OCCURRED() );

                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                exception_lineno = 1631;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                            if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
                            {
                                goto branch_yes_11;
                            }
                            else
                            {
                                goto branch_no_11;
                            }
                            branch_yes_11:;
                            {
                                nuitka_bool tmp_condition_result_12;
                                PyObject *tmp_compexpr_left_12;
                                PyObject *tmp_compexpr_right_12;
                                CHECK_OBJECT( par_result );
                                tmp_compexpr_left_12 = par_result;
                                tmp_compexpr_right_12 = const_int_0;
                                tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_12, tmp_compexpr_right_12 );
                                if ( tmp_res == -1 )
                                {
                                    assert( ERROR_OCCURRED() );

                                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                    exception_lineno = 1632;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                tmp_condition_result_12 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                                if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
                                {
                                    goto branch_yes_12;
                                }
                                else
                                {
                                    goto branch_no_12;
                                }
                                branch_yes_12:;
                                {
                                    nuitka_bool tmp_condition_result_13;
                                    PyObject *tmp_compexpr_left_13;
                                    PyObject *tmp_compexpr_right_13;
                                    PyObject *tmp_mvar_value_12;
                                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_platform );

                                    if (unlikely( tmp_mvar_value_12 == NULL ))
                                    {
                                        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_platform );
                                    }

                                    if ( tmp_mvar_value_12 == NULL )
                                    {

                                        exception_type = PyExc_NameError;
                                        Py_INCREF( exception_type );
                                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "platform" );
                                        exception_tb = NULL;

                                        exception_lineno = 1633;
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }

                                    tmp_compexpr_left_13 = tmp_mvar_value_12;
                                    tmp_compexpr_right_13 = const_str_plain_win32;
                                    tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_13, tmp_compexpr_right_13 );
                                    if ( tmp_res == -1 )
                                    {
                                        assert( ERROR_OCCURRED() );

                                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                        exception_lineno = 1633;
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }
                                    tmp_condition_result_13 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                                    if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
                                    {
                                        goto branch_yes_13;
                                    }
                                    else
                                    {
                                        goto branch_no_13;
                                    }
                                    branch_yes_13:;
                                    {
                                        PyObject *tmp_assign_source_2;
                                        PyObject *tmp_subscribed_name_1;
                                        PyObject *tmp_called_instance_8;
                                        PyObject *tmp_mvar_value_13;
                                        PyObject *tmp_subscript_name_1;
                                        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

                                        if (unlikely( tmp_mvar_value_13 == NULL ))
                                        {
                                            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                                        }

                                        if ( tmp_mvar_value_13 == NULL )
                                        {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF( exception_type );
                                            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                                            exception_tb = NULL;

                                            exception_lineno = 1634;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_called_instance_8 = tmp_mvar_value_13;
                                        frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1634;
                                        tmp_subscribed_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getwinerror );
                                        if ( tmp_subscribed_name_1 == NULL )
                                        {
                                            assert( ERROR_OCCURRED() );

                                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                            exception_lineno = 1634;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        tmp_subscript_name_1 = const_int_0;
                                        tmp_assign_source_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
                                        Py_DECREF( tmp_subscribed_name_1 );
                                        if ( tmp_assign_source_2 == NULL )
                                        {
                                            assert( ERROR_OCCURRED() );

                                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                            exception_lineno = 1634;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        assert( var_errno == NULL );
                                        var_errno = tmp_assign_source_2;
                                    }
                                    goto branch_end_13;
                                    branch_no_13:;
                                    {
                                        PyObject *tmp_assign_source_3;
                                        PyObject *tmp_source_name_26;
                                        PyObject *tmp_mvar_value_14;
                                        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

                                        if (unlikely( tmp_mvar_value_14 == NULL ))
                                        {
                                            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                                        }

                                        if ( tmp_mvar_value_14 == NULL )
                                        {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF( exception_type );
                                            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                                            exception_tb = NULL;

                                            exception_lineno = 1636;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_source_name_26 = tmp_mvar_value_14;
                                        tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain_errno );
                                        if ( tmp_assign_source_3 == NULL )
                                        {
                                            assert( ERROR_OCCURRED() );

                                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                            exception_lineno = 1636;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        assert( var_errno == NULL );
                                        var_errno = tmp_assign_source_3;
                                    }
                                    branch_end_13:;
                                }
                                {
                                    nuitka_bool tmp_condition_result_14;
                                    PyObject *tmp_compexpr_left_14;
                                    PyObject *tmp_compexpr_right_14;
                                    CHECK_OBJECT( var_errno );
                                    tmp_compexpr_left_14 = var_errno;
                                    tmp_compexpr_right_14 = const_int_0;
                                    tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_14, tmp_compexpr_right_14 );
                                    if ( tmp_res == -1 )
                                    {
                                        assert( ERROR_OCCURRED() );

                                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                        exception_lineno = 1638;
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }
                                    tmp_condition_result_14 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                                    if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
                                    {
                                        goto branch_yes_14;
                                    }
                                    else
                                    {
                                        goto branch_no_14;
                                    }
                                    branch_yes_14:;
                                    {
                                        PyObject *tmp_raise_type_5;
                                        PyObject *tmp_called_name_5;
                                        PyObject *tmp_mvar_value_15;
                                        PyObject *tmp_args_element_name_3;
                                        PyObject *tmp_args_element_name_4;
                                        PyObject *tmp_called_instance_9;
                                        PyObject *tmp_mvar_value_16;
                                        PyObject *tmp_args_element_name_5;
                                        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError );

                                        if (unlikely( tmp_mvar_value_15 == NULL ))
                                        {
                                            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SysCallError );
                                        }

                                        if ( tmp_mvar_value_15 == NULL )
                                        {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF( exception_type );
                                            exception_value = PyString_FromFormat( "global name '%s' is not defined", "SysCallError" );
                                            exception_tb = NULL;

                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_called_name_5 = tmp_mvar_value_15;
                                        CHECK_OBJECT( var_errno );
                                        tmp_args_element_name_3 = var_errno;
                                        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_errorcode );

                                        if (unlikely( tmp_mvar_value_16 == NULL ))
                                        {
                                            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_errorcode );
                                        }

                                        if ( tmp_mvar_value_16 == NULL )
                                        {

                                            exception_type = PyExc_NameError;
                                            Py_INCREF( exception_type );
                                            exception_value = PyString_FromFormat( "global name '%s' is not defined", "errorcode" );
                                            exception_tb = NULL;

                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }

                                        tmp_called_instance_9 = tmp_mvar_value_16;
                                        CHECK_OBJECT( var_errno );
                                        tmp_args_element_name_5 = var_errno;
                                        frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1639;
                                        {
                                            PyObject *call_args[] = { tmp_args_element_name_5 };
                                            tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_get, call_args );
                                        }

                                        if ( tmp_args_element_name_4 == NULL )
                                        {
                                            assert( ERROR_OCCURRED() );

                                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1639;
                                        {
                                            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                                            tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
                                        }

                                        Py_DECREF( tmp_args_element_name_4 );
                                        if ( tmp_raise_type_5 == NULL )
                                        {
                                            assert( ERROR_OCCURRED() );

                                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                            exception_lineno = 1639;
                                            type_description_1 = "ooooo";
                                            goto frame_exception_exit_1;
                                        }
                                        exception_type = tmp_raise_type_5;
                                        exception_lineno = 1639;
                                        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                                        type_description_1 = "ooooo";
                                        goto frame_exception_exit_1;
                                    }
                                    branch_no_14:;
                                }
                                branch_no_12:;
                            }
                            {
                                PyObject *tmp_raise_type_6;
                                PyObject *tmp_called_name_6;
                                PyObject *tmp_mvar_value_17;
                                tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError );

                                if (unlikely( tmp_mvar_value_17 == NULL ))
                                {
                                    tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SysCallError );
                                }

                                if ( tmp_mvar_value_17 == NULL )
                                {

                                    exception_type = PyExc_NameError;
                                    Py_INCREF( exception_type );
                                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "SysCallError" );
                                    exception_tb = NULL;

                                    exception_lineno = 1640;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }

                                tmp_called_name_6 = tmp_mvar_value_17;
                                frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1640;
                                tmp_raise_type_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_int_neg_1_str_digest_fa91b370bf4aa8601b20ad022c04c7f5_tuple, 0 ) );

                                if ( tmp_raise_type_6 == NULL )
                                {
                                    assert( ERROR_OCCURRED() );

                                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                    exception_lineno = 1640;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                exception_type = tmp_raise_type_6;
                                exception_lineno = 1640;
                                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            goto branch_end_11;
                            branch_no_11:;
                            {
                                PyObject *tmp_called_name_7;
                                PyObject *tmp_mvar_value_18;
                                PyObject *tmp_call_result_6;
                                tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

                                if (unlikely( tmp_mvar_value_18 == NULL ))
                                {
                                    tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
                                }

                                if ( tmp_mvar_value_18 == NULL )
                                {

                                    exception_type = PyExc_NameError;
                                    Py_INCREF( exception_type );
                                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                                    exception_tb = NULL;

                                    exception_lineno = 1643;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }

                                tmp_called_name_7 = tmp_mvar_value_18;
                                frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1643;
                                tmp_call_result_6 = CALL_FUNCTION_NO_ARGS( tmp_called_name_7 );
                                if ( tmp_call_result_6 == NULL )
                                {
                                    assert( ERROR_OCCURRED() );

                                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                    exception_lineno = 1643;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                Py_DECREF( tmp_call_result_6 );
                            }
                            branch_end_11:;
                        }
                        goto branch_end_10;
                        branch_no_10:;
                        {
                            nuitka_bool tmp_condition_result_15;
                            PyObject *tmp_operand_name_1;
                            PyObject *tmp_compexpr_left_15;
                            PyObject *tmp_compexpr_right_15;
                            PyObject *tmp_source_name_27;
                            PyObject *tmp_mvar_value_19;
                            CHECK_OBJECT( var_error );
                            tmp_compexpr_left_15 = var_error;
                            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

                            if (unlikely( tmp_mvar_value_19 == NULL ))
                            {
                                tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                            }

                            if ( tmp_mvar_value_19 == NULL )
                            {

                                exception_type = PyExc_NameError;
                                Py_INCREF( exception_type );
                                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                                exception_tb = NULL;

                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }

                            tmp_source_name_27 = tmp_mvar_value_19;
                            tmp_compexpr_right_15 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain_SSL_ERROR_NONE );
                            if ( tmp_compexpr_right_15 == NULL )
                            {
                                assert( ERROR_OCCURRED() );

                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_15, tmp_compexpr_right_15 );
                            Py_DECREF( tmp_compexpr_right_15 );
                            if ( tmp_operand_name_1 == NULL )
                            {
                                assert( ERROR_OCCURRED() );

                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
                            Py_DECREF( tmp_operand_name_1 );
                            if ( tmp_res == -1 )
                            {
                                assert( ERROR_OCCURRED() );

                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                exception_lineno = 1644;
                                type_description_1 = "ooooo";
                                goto frame_exception_exit_1;
                            }
                            tmp_condition_result_15 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                            if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
                            {
                                goto branch_yes_15;
                            }
                            else
                            {
                                goto branch_no_15;
                            }
                            branch_yes_15:;
                            {
                                PyObject *tmp_called_name_8;
                                PyObject *tmp_mvar_value_20;
                                PyObject *tmp_call_result_7;
                                tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

                                if (unlikely( tmp_mvar_value_20 == NULL ))
                                {
                                    tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
                                }

                                if ( tmp_mvar_value_20 == NULL )
                                {

                                    exception_type = PyExc_NameError;
                                    Py_INCREF( exception_type );
                                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                                    exception_tb = NULL;

                                    exception_lineno = 1647;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }

                                tmp_called_name_8 = tmp_mvar_value_20;
                                frame_e64d814c39cb7a48505598e16da6bb25->m_frame.f_lineno = 1647;
                                tmp_call_result_7 = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
                                if ( tmp_call_result_7 == NULL )
                                {
                                    assert( ERROR_OCCURRED() );

                                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                    exception_lineno = 1647;
                                    type_description_1 = "ooooo";
                                    goto frame_exception_exit_1;
                                }
                                Py_DECREF( tmp_call_result_7 );
                            }
                            branch_no_15:;
                        }
                        branch_end_10:;
                    }
                    branch_end_9:;
                }
                branch_end_8:;
            }
            branch_end_7:;
        }
        branch_end_6:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e64d814c39cb7a48505598e16da6bb25 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e64d814c39cb7a48505598e16da6bb25 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e64d814c39cb7a48505598e16da6bb25, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e64d814c39cb7a48505598e16da6bb25->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e64d814c39cb7a48505598e16da6bb25, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e64d814c39cb7a48505598e16da6bb25,
        type_description_1,
        par_self,
        par_ssl,
        par_result,
        var_errno,
        var_error
    );


    // Release cached frame.
    if ( frame_e64d814c39cb7a48505598e16da6bb25 == cache_frame_e64d814c39cb7a48505598e16da6bb25 )
    {
        Py_DECREF( frame_e64d814c39cb7a48505598e16da6bb25 );
    }
    cache_frame_e64d814c39cb7a48505598e16da6bb25 = NULL;

    assertFrameObject( frame_e64d814c39cb7a48505598e16da6bb25 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_59__raise_ssl_error );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    CHECK_OBJECT( (PyObject *)var_error );
    Py_DECREF( var_error );
    var_error = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_errno );
    var_errno = NULL;

    CHECK_OBJECT( (PyObject *)par_ssl );
    Py_DECREF( par_ssl );
    par_ssl = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    Py_XDECREF( var_error );
    var_error = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_59__raise_ssl_error );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_60_get_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_abe3e219ee6e1aa4dabcb63168931b9b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_abe3e219ee6e1aa4dabcb63168931b9b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_abe3e219ee6e1aa4dabcb63168931b9b, codeobj_abe3e219ee6e1aa4dabcb63168931b9b, module_OpenSSL$SSL, sizeof(void *) );
    frame_abe3e219ee6e1aa4dabcb63168931b9b = cache_frame_abe3e219ee6e1aa4dabcb63168931b9b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_abe3e219ee6e1aa4dabcb63168931b9b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_abe3e219ee6e1aa4dabcb63168931b9b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__context );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1654;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_abe3e219ee6e1aa4dabcb63168931b9b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_abe3e219ee6e1aa4dabcb63168931b9b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_abe3e219ee6e1aa4dabcb63168931b9b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_abe3e219ee6e1aa4dabcb63168931b9b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_abe3e219ee6e1aa4dabcb63168931b9b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_abe3e219ee6e1aa4dabcb63168931b9b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_abe3e219ee6e1aa4dabcb63168931b9b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_abe3e219ee6e1aa4dabcb63168931b9b == cache_frame_abe3e219ee6e1aa4dabcb63168931b9b )
    {
        Py_DECREF( frame_abe3e219ee6e1aa4dabcb63168931b9b );
    }
    cache_frame_abe3e219ee6e1aa4dabcb63168931b9b = NULL;

    assertFrameObject( frame_abe3e219ee6e1aa4dabcb63168931b9b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_60_get_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_60_get_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_61_set_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_context = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_caafd991eb739c67f9b0132a1e25e9b3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_caafd991eb739c67f9b0132a1e25e9b3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_caafd991eb739c67f9b0132a1e25e9b3, codeobj_caafd991eb739c67f9b0132a1e25e9b3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_caafd991eb739c67f9b0132a1e25e9b3 = cache_frame_caafd991eb739c67f9b0132a1e25e9b3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_caafd991eb739c67f9b0132a1e25e9b3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_caafd991eb739c67f9b0132a1e25e9b3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_context );
        tmp_isinstance_inst_1 = par_context;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Context );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Context" );
            exception_tb = NULL;

            exception_lineno = 1663;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1663;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1663;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_627e1a07a1a60af86ff9e544428f2f09;
            frame_caafd991eb739c67f9b0132a1e25e9b3->m_frame.f_lineno = 1664;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1664;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_SSL_CTX );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_context );
        tmp_source_name_3 = par_context;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__context );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_caafd991eb739c67f9b0132a1e25e9b3->m_frame.f_lineno = 1666;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1666;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_context );
        tmp_assattr_name_1 = par_context;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__context, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1667;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_caafd991eb739c67f9b0132a1e25e9b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_caafd991eb739c67f9b0132a1e25e9b3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_caafd991eb739c67f9b0132a1e25e9b3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_caafd991eb739c67f9b0132a1e25e9b3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_caafd991eb739c67f9b0132a1e25e9b3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_caafd991eb739c67f9b0132a1e25e9b3,
        type_description_1,
        par_self,
        par_context
    );


    // Release cached frame.
    if ( frame_caafd991eb739c67f9b0132a1e25e9b3 == cache_frame_caafd991eb739c67f9b0132a1e25e9b3 )
    {
        Py_DECREF( frame_caafd991eb739c67f9b0132a1e25e9b3 );
    }
    cache_frame_caafd991eb739c67f9b0132a1e25e9b3 = NULL;

    assertFrameObject( frame_caafd991eb739c67f9b0132a1e25e9b3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_61_set_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_61_set_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_62_get_servername( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_f32210b1a6041e23f6080980ed862744;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f32210b1a6041e23f6080980ed862744 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f32210b1a6041e23f6080980ed862744, codeobj_f32210b1a6041e23f6080980ed862744, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_f32210b1a6041e23f6080980ed862744 = cache_frame_f32210b1a6041e23f6080980ed862744;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f32210b1a6041e23f6080980ed862744 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f32210b1a6041e23f6080980ed862744 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1679;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_servername );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1679;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_TLSEXT_NAMETYPE_host_name );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1680;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_f32210b1a6041e23f6080980ed862744->m_frame.f_lineno = 1679;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1679;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_name == NULL );
        var_name = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_name );
        tmp_compexpr_left_1 = var_name;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1682;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1685;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT( var_name );
        tmp_args_element_name_3 = var_name;
        frame_f32210b1a6041e23f6080980ed862744->m_frame.f_lineno = 1685;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_string, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1685;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f32210b1a6041e23f6080980ed862744 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f32210b1a6041e23f6080980ed862744 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f32210b1a6041e23f6080980ed862744 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f32210b1a6041e23f6080980ed862744, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f32210b1a6041e23f6080980ed862744->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f32210b1a6041e23f6080980ed862744, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f32210b1a6041e23f6080980ed862744,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_f32210b1a6041e23f6080980ed862744 == cache_frame_f32210b1a6041e23f6080980ed862744 )
    {
        Py_DECREF( frame_f32210b1a6041e23f6080980ed862744 );
    }
    cache_frame_f32210b1a6041e23f6080980ed862744 = NULL;

    assertFrameObject( frame_f32210b1a6041e23f6080980ed862744 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_62_get_servername );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_62_get_servername );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_63_set_tlsext_host_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_84be2e2654ef2638907dd2c10cb860ec;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_84be2e2654ef2638907dd2c10cb860ec = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_84be2e2654ef2638907dd2c10cb860ec, codeobj_84be2e2654ef2638907dd2c10cb860ec, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_84be2e2654ef2638907dd2c10cb860ec = cache_frame_84be2e2654ef2638907dd2c10cb860ec;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84be2e2654ef2638907dd2c10cb860ec );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84be2e2654ef2638907dd2c10cb860ec ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_name );
        tmp_isinstance_inst_1 = par_name;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1696;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1696;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d89a36d0b4664ac4178af2071f30652f;
            frame_84be2e2654ef2638907dd2c10cb860ec->m_frame.f_lineno = 1697;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1697;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            tmp_compexpr_left_1 = const_str_chr_0;
            CHECK_OBJECT( par_name );
            tmp_compexpr_right_1 = par_name;
            tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1698;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_b965e7ab82e8e0c92ec2736091bc1c12;
                frame_84be2e2654ef2638907dd2c10cb860ec->m_frame.f_lineno = 1699;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 1699;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_tlsext_host_name );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_args_element_name_2 = par_name;
        frame_84be2e2654ef2638907dd2c10cb860ec->m_frame.f_lineno = 1702;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1702;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84be2e2654ef2638907dd2c10cb860ec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84be2e2654ef2638907dd2c10cb860ec );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84be2e2654ef2638907dd2c10cb860ec, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84be2e2654ef2638907dd2c10cb860ec->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84be2e2654ef2638907dd2c10cb860ec, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84be2e2654ef2638907dd2c10cb860ec,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_84be2e2654ef2638907dd2c10cb860ec == cache_frame_84be2e2654ef2638907dd2c10cb860ec )
    {
        Py_DECREF( frame_84be2e2654ef2638907dd2c10cb860ec );
    }
    cache_frame_84be2e2654ef2638907dd2c10cb860ec = NULL;

    assertFrameObject( frame_84be2e2654ef2638907dd2c10cb860ec );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_63_set_tlsext_host_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_63_set_tlsext_host_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_64_pending( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_05cf5483bca2509bcd0b3c906d201953;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_05cf5483bca2509bcd0b3c906d201953 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_05cf5483bca2509bcd0b3c906d201953, codeobj_05cf5483bca2509bcd0b3c906d201953, module_OpenSSL$SSL, sizeof(void *) );
    frame_05cf5483bca2509bcd0b3c906d201953 = cache_frame_05cf5483bca2509bcd0b3c906d201953;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_05cf5483bca2509bcd0b3c906d201953 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_05cf5483bca2509bcd0b3c906d201953 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_pending );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_05cf5483bca2509bcd0b3c906d201953->m_frame.f_lineno = 1711;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1711;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05cf5483bca2509bcd0b3c906d201953 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_05cf5483bca2509bcd0b3c906d201953 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05cf5483bca2509bcd0b3c906d201953 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_05cf5483bca2509bcd0b3c906d201953, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_05cf5483bca2509bcd0b3c906d201953->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_05cf5483bca2509bcd0b3c906d201953, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_05cf5483bca2509bcd0b3c906d201953,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_05cf5483bca2509bcd0b3c906d201953 == cache_frame_05cf5483bca2509bcd0b3c906d201953 )
    {
        Py_DECREF( frame_05cf5483bca2509bcd0b3c906d201953 );
    }
    cache_frame_05cf5483bca2509bcd0b3c906d201953 = NULL;

    assertFrameObject( frame_05cf5483bca2509bcd0b3c906d201953 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_64_pending );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_64_pending );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_65_send( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_5a1358d55560963927bee18bb9d8968e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_5a1358d55560963927bee18bb9d8968e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5a1358d55560963927bee18bb9d8968e, codeobj_5a1358d55560963927bee18bb9d8968e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5a1358d55560963927bee18bb9d8968e = cache_frame_5a1358d55560963927bee18bb9d8968e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5a1358d55560963927bee18bb9d8968e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5a1358d55560963927bee18bb9d8968e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 1725;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT( par_buf );
        tmp_args_element_name_2 = par_buf;
        frame_5a1358d55560963927bee18bb9d8968e->m_frame.f_lineno = 1725;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1725;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert( old != NULL );
            par_buf = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_buf );
        tmp_isinstance_inst_1 = par_buf;
        tmp_isinstance_cls_1 = (PyObject *)&PyMemoryView_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1727;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buf );
            tmp_called_instance_1 = par_buf;
            frame_5a1358d55560963927bee18bb9d8968e->m_frame.f_lineno = 1728;
            tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_tobytes );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1728;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert( old != NULL );
                par_buf = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_buf );
        tmp_isinstance_inst_2 = par_buf;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__buffer );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__buffer );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_buffer" );
            exception_tb = NULL;

            exception_lineno = 1729;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1729;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_str_arg_1;
            CHECK_OBJECT( par_buf );
            tmp_str_arg_1 = par_buf;
            tmp_assign_source_3 = PyObject_Str( tmp_str_arg_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1730;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert( old != NULL );
                par_buf = tmp_assign_source_3;
                Py_DECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        if ( par_buf == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "buf" );
            exception_tb = NULL;

            exception_lineno = 1731;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_3 = par_buf;
        tmp_isinstance_cls_3 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1731;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1731;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_e0c534afee902e78ce11df02f380dfa7;
            frame_5a1358d55560963927bee18bb9d8968e->m_frame.f_lineno = 1732;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1732;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        if ( par_buf == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "buf" );
            exception_tb = NULL;

            exception_lineno = 1733;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_1 = par_buf;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1733;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_2147483647;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_8cde8912e8f2207155a1addb0752791f;
            frame_5a1358d55560963927bee18bb9d8968e->m_frame.f_lineno = 1734;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1734;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_len_arg_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_write );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        if ( par_buf == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "buf" );
            exception_tb = NULL;

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = par_buf;
        if ( par_buf == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "buf" );
            exception_tb = NULL;

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_2 = par_buf;
        tmp_args_element_name_5 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_5a1358d55560963927bee18bb9d8968e->m_frame.f_lineno = 1736;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1736;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__raise_ssl_error );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1737;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1737;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result );
        tmp_args_element_name_7 = var_result;
        frame_5a1358d55560963927bee18bb9d8968e->m_frame.f_lineno = 1737;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1737;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a1358d55560963927bee18bb9d8968e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a1358d55560963927bee18bb9d8968e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5a1358d55560963927bee18bb9d8968e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5a1358d55560963927bee18bb9d8968e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5a1358d55560963927bee18bb9d8968e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5a1358d55560963927bee18bb9d8968e,
        type_description_1,
        par_self,
        par_buf,
        par_flags,
        var_result
    );


    // Release cached frame.
    if ( frame_5a1358d55560963927bee18bb9d8968e == cache_frame_5a1358d55560963927bee18bb9d8968e )
    {
        Py_DECREF( frame_5a1358d55560963927bee18bb9d8968e );
    }
    cache_frame_5a1358d55560963927bee18bb9d8968e = NULL;

    assertFrameObject( frame_5a1358d55560963927bee18bb9d8968e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_65_send );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_buf );
    par_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_buf );
    par_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_65_send );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_66_sendall( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    PyObject *var_left_to_send = NULL;
    PyObject *var_data = NULL;
    PyObject *var_result = NULL;
    PyObject *var_total_sent = NULL;
    struct Nuitka_FrameObject *frame_ce3644339e9eda748037fea603eecb61;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ce3644339e9eda748037fea603eecb61 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ce3644339e9eda748037fea603eecb61, codeobj_ce3644339e9eda748037fea603eecb61, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ce3644339e9eda748037fea603eecb61 = cache_frame_ce3644339e9eda748037fea603eecb61;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ce3644339e9eda748037fea603eecb61 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ce3644339e9eda748037fea603eecb61 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 1752;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT( par_buf );
        tmp_args_element_name_2 = par_buf;
        frame_ce3644339e9eda748037fea603eecb61->m_frame.f_lineno = 1752;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1752;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert( old != NULL );
            par_buf = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_buf );
        tmp_isinstance_inst_1 = par_buf;
        tmp_isinstance_cls_1 = (PyObject *)&PyMemoryView_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1754;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buf );
            tmp_called_instance_1 = par_buf;
            frame_ce3644339e9eda748037fea603eecb61->m_frame.f_lineno = 1755;
            tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_tobytes );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1755;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert( old != NULL );
                par_buf = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_buf );
        tmp_isinstance_inst_2 = par_buf;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__buffer );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__buffer );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_buffer" );
            exception_tb = NULL;

            exception_lineno = 1756;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1756;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_str_arg_1;
            CHECK_OBJECT( par_buf );
            tmp_str_arg_1 = par_buf;
            tmp_assign_source_3 = PyObject_Str( tmp_str_arg_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1757;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buf;
                assert( old != NULL );
                par_buf = tmp_assign_source_3;
                Py_DECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        if ( par_buf == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "buf" );
            exception_tb = NULL;

            exception_lineno = 1758;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_inst_3 = par_buf;
        tmp_isinstance_cls_3 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1758;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1758;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_f64bec1377ff9f22e4ed4c823f6a5647;
            frame_ce3644339e9eda748037fea603eecb61->m_frame.f_lineno = 1759;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1759;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_len_arg_1;
        if ( par_buf == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "buf" );
            exception_tb = NULL;

            exception_lineno = 1761;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_len_arg_1 = par_buf;
        tmp_assign_source_4 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1761;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_left_to_send == NULL );
        var_left_to_send = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        tmp_assign_source_5 = const_int_0;
        assert( var_total_sent == NULL );
        Py_INCREF( tmp_assign_source_5 );
        var_total_sent = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_new );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_str_digest_c561652c58984ec0e9541542aa405594;
        if ( par_buf == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "buf" );
            exception_tb = NULL;

            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = par_buf;
        frame_ce3644339e9eda748037fea603eecb61->m_frame.f_lineno = 1763;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1763;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_data == NULL );
        var_data = tmp_assign_source_6;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_left_to_send );
        tmp_operand_name_2 = var_left_to_send;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1765;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        goto loop_end_1;
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_write );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1768;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1769;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_data );
        tmp_left_name_1 = var_data;
        CHECK_OBJECT( var_total_sent );
        tmp_right_name_1 = var_total_sent;
        tmp_args_element_name_6 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );

            exception_lineno = 1770;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_4 = LOOKUP_BUILTIN( const_str_plain_min );
        assert( tmp_called_name_4 != NULL );
        CHECK_OBJECT( var_left_to_send );
        tmp_args_element_name_8 = var_left_to_send;
        tmp_args_element_name_9 = const_int_pos_2147483647;
        frame_ce3644339e9eda748037fea603eecb61->m_frame.f_lineno = 1771;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_args_element_name_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );
            Py_DECREF( tmp_args_element_name_6 );

            exception_lineno = 1771;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_ce3644339e9eda748037fea603eecb61->m_frame.f_lineno = 1768;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1768;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_result;
            var_result = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_11;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__raise_ssl_error );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1773;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 1773;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result );
        tmp_args_element_name_11 = var_result;
        frame_ce3644339e9eda748037fea603eecb61->m_frame.f_lineno = 1773;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1773;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( var_total_sent );
        tmp_left_name_2 = var_total_sent;
        CHECK_OBJECT( var_result );
        tmp_right_name_2 = var_result;
        tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE( &tmp_left_name_2, tmp_right_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1774;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_8 = tmp_left_name_2;
        var_total_sent = tmp_assign_source_8;

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_3;
        CHECK_OBJECT( var_left_to_send );
        tmp_left_name_3 = var_left_to_send;
        CHECK_OBJECT( var_result );
        tmp_right_name_3 = var_result;
        tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceSubtract, &tmp_left_name_3, tmp_right_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1775;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_9 = tmp_left_name_3;
        var_left_to_send = tmp_assign_source_9;

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1765;
        type_description_1 = "ooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce3644339e9eda748037fea603eecb61 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ce3644339e9eda748037fea603eecb61 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ce3644339e9eda748037fea603eecb61, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ce3644339e9eda748037fea603eecb61->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ce3644339e9eda748037fea603eecb61, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ce3644339e9eda748037fea603eecb61,
        type_description_1,
        par_self,
        par_buf,
        par_flags,
        var_left_to_send,
        var_data,
        var_result,
        var_total_sent
    );


    // Release cached frame.
    if ( frame_ce3644339e9eda748037fea603eecb61 == cache_frame_ce3644339e9eda748037fea603eecb61 )
    {
        Py_DECREF( frame_ce3644339e9eda748037fea603eecb61 );
    }
    cache_frame_ce3644339e9eda748037fea603eecb61 = NULL;

    assertFrameObject( frame_ce3644339e9eda748037fea603eecb61 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_66_sendall );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_left_to_send );
    Py_DECREF( var_left_to_send );
    var_left_to_send = NULL;

    CHECK_OBJECT( (PyObject *)var_data );
    Py_DECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)var_total_sent );
    Py_DECREF( var_total_sent );
    var_total_sent = NULL;

    Py_XDECREF( par_buf );
    par_buf = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_left_to_send );
    var_left_to_send = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_total_sent );
    var_total_sent = NULL;

    Py_XDECREF( par_buf );
    par_buf = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_66_sendall );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_67_recv( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_bufsiz = python_pars[ 1 ];
    PyObject *par_flags = python_pars[ 2 ];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_b629e495f4ca5d31617df1d720289b76;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b629e495f4ca5d31617df1d720289b76 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b629e495f4ca5d31617df1d720289b76, codeobj_b629e495f4ca5d31617df1d720289b76, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b629e495f4ca5d31617df1d720289b76 = cache_frame_b629e495f4ca5d31617df1d720289b76;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b629e495f4ca5d31617df1d720289b76 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b629e495f4ca5d31617df1d720289b76 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 1786;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT( par_bufsiz );
        tmp_args_element_name_2 = par_bufsiz;
        frame_b629e495f4ca5d31617df1d720289b76->m_frame.f_lineno = 1786;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1786;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_buf == NULL );
        var_buf = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_op_bitand_res_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_flags );
        tmp_compexpr_left_1 = par_flags;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_flags );
        tmp_left_name_1 = par_flags;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_socket );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "socket" );
            exception_tb = NULL;

            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_MSG_PEEK );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_op_bitand_res_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_op_bitand_res_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_op_bitand_res_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_op_bitand_res_1 );

            exception_lineno = 1787;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_op_bitand_res_1 );
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_peek );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_buf );
            tmp_args_element_name_4 = var_buf;
            CHECK_OBJECT( par_bufsiz );
            tmp_args_element_name_5 = par_bufsiz;
            frame_b629e495f4ca5d31617df1d720289b76->m_frame.f_lineno = 1788;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1788;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_result == NULL );
            var_result = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_4;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_read );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_buf );
            tmp_args_element_name_7 = var_buf;
            CHECK_OBJECT( par_bufsiz );
            tmp_args_element_name_8 = par_bufsiz;
            frame_b629e495f4ca5d31617df1d720289b76->m_frame.f_lineno = 1790;
            {
                PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1790;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_result == NULL );
            var_result = tmp_assign_source_3;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_10;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__raise_ssl_error );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1791;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__ssl );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1791;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result );
        tmp_args_element_name_10 = var_result;
        frame_b629e495f4ca5d31617df1d720289b76->m_frame.f_lineno = 1791;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1791;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1792;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT( var_buf );
        tmp_args_element_name_11 = var_buf;
        CHECK_OBJECT( var_result );
        tmp_args_element_name_12 = var_result;
        frame_b629e495f4ca5d31617df1d720289b76->m_frame.f_lineno = 1792;
        {
            PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1792;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1792;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b629e495f4ca5d31617df1d720289b76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b629e495f4ca5d31617df1d720289b76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b629e495f4ca5d31617df1d720289b76 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b629e495f4ca5d31617df1d720289b76, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b629e495f4ca5d31617df1d720289b76->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b629e495f4ca5d31617df1d720289b76, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b629e495f4ca5d31617df1d720289b76,
        type_description_1,
        par_self,
        par_bufsiz,
        par_flags,
        var_buf,
        var_result
    );


    // Release cached frame.
    if ( frame_b629e495f4ca5d31617df1d720289b76 == cache_frame_b629e495f4ca5d31617df1d720289b76 )
    {
        Py_DECREF( frame_b629e495f4ca5d31617df1d720289b76 );
    }
    cache_frame_b629e495f4ca5d31617df1d720289b76 = NULL;

    assertFrameObject( frame_b629e495f4ca5d31617df1d720289b76 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_67_recv );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_buf );
    Py_DECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_67_recv );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_68_recv_into( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *par_nbytes = python_pars[ 2 ];
    PyObject *par_flags = python_pars[ 3 ];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_992b138da987129c02121bdece9bbd42;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_992b138da987129c02121bdece9bbd42 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_992b138da987129c02121bdece9bbd42, codeobj_992b138da987129c02121bdece9bbd42, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_992b138da987129c02121bdece9bbd42 = cache_frame_992b138da987129c02121bdece9bbd42;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_992b138da987129c02121bdece9bbd42 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_992b138da987129c02121bdece9bbd42 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_nbytes );
        tmp_compexpr_left_1 = par_nbytes;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( par_buffer );
            tmp_len_arg_1 = par_buffer;
            tmp_assign_source_1 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1810;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_nbytes;
                assert( old != NULL );
                par_nbytes = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_len_arg_2;
            tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_min );
            assert( tmp_called_name_1 != NULL );
            CHECK_OBJECT( par_nbytes );
            tmp_args_element_name_1 = par_nbytes;
            CHECK_OBJECT( par_buffer );
            tmp_len_arg_2 = par_buffer;
            tmp_args_element_name_2 = BUILTIN_LEN( tmp_len_arg_2 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1812;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            frame_992b138da987129c02121bdece9bbd42->m_frame.f_lineno = 1812;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1812;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_nbytes;
                assert( old != NULL );
                par_nbytes = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 1817;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_3 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT( par_nbytes );
        tmp_args_element_name_4 = par_nbytes;
        frame_992b138da987129c02121bdece9bbd42->m_frame.f_lineno = 1817;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1817;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_buf == NULL );
        var_buf = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_op_bitand_res_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_flags );
        tmp_compexpr_left_2 = par_flags;
        tmp_compexpr_right_2 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_flags );
        tmp_left_name_1 = par_flags;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_socket );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "socket" );
            exception_tb = NULL;

            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_MSG_PEEK );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_op_bitand_res_1 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_op_bitand_res_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_op_bitand_res_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_op_bitand_res_1 );

            exception_lineno = 1818;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_op_bitand_res_1 );
        tmp_condition_result_2 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_2 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_peek );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_buf );
            tmp_args_element_name_6 = var_buf;
            CHECK_OBJECT( par_nbytes );
            tmp_args_element_name_7 = par_nbytes;
            frame_992b138da987129c02121bdece9bbd42->m_frame.f_lineno = 1819;
            {
                PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1819;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_result == NULL );
            var_result = tmp_assign_source_4;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_4;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_read );
            if ( tmp_called_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_4 );

                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_buf );
            tmp_args_element_name_9 = var_buf;
            CHECK_OBJECT( par_nbytes );
            tmp_args_element_name_10 = par_nbytes;
            frame_992b138da987129c02121bdece9bbd42->m_frame.f_lineno = 1821;
            {
                PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1821;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            assert( var_result == NULL );
            var_result = tmp_assign_source_5;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_12;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__raise_ssl_error );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1822;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__ssl );
        if ( tmp_args_element_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 1822;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result );
        tmp_args_element_name_12 = var_result;
        frame_992b138da987129c02121bdece9bbd42->m_frame.f_lineno = 1822;
        {
            PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_11 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1822;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_sliceass_value_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_sliceass_target_1;
        PyObject *tmp_sliceass_upper_1;
        tmp_called_name_6 = (PyObject *)&PyMemoryView_Type;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT( var_buf );
        tmp_args_element_name_14 = var_buf;
        CHECK_OBJECT( var_result );
        tmp_args_element_name_15 = var_result;
        frame_992b138da987129c02121bdece9bbd42->m_frame.f_lineno = 1828;
        {
            PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
            tmp_args_element_name_13 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_992b138da987129c02121bdece9bbd42->m_frame.f_lineno = 1828;
        {
            PyObject *call_args[] = { tmp_args_element_name_13 };
            tmp_sliceass_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_args_element_name_13 );
        if ( tmp_sliceass_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_buffer );
        tmp_sliceass_target_1 = par_buffer;
        CHECK_OBJECT( var_result );
        tmp_sliceass_upper_1 = var_result;
        tmp_result = SET_SLICE( tmp_sliceass_target_1, Py_None, tmp_sliceass_upper_1, tmp_sliceass_value_1 );
        Py_DECREF( tmp_sliceass_value_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1828;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_992b138da987129c02121bdece9bbd42 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_992b138da987129c02121bdece9bbd42 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_992b138da987129c02121bdece9bbd42, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_992b138da987129c02121bdece9bbd42->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_992b138da987129c02121bdece9bbd42, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_992b138da987129c02121bdece9bbd42,
        type_description_1,
        par_self,
        par_buffer,
        par_nbytes,
        par_flags,
        var_buf,
        var_result
    );


    // Release cached frame.
    if ( frame_992b138da987129c02121bdece9bbd42 == cache_frame_992b138da987129c02121bdece9bbd42 )
    {
        Py_DECREF( frame_992b138da987129c02121bdece9bbd42 );
    }
    cache_frame_992b138da987129c02121bdece9bbd42 = NULL;

    assertFrameObject( frame_992b138da987129c02121bdece9bbd42 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_68_recv_into );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    CHECK_OBJECT( (PyObject *)par_nbytes );
    Py_DECREF( par_nbytes );
    par_nbytes = NULL;

    CHECK_OBJECT( (PyObject *)var_buf );
    Py_DECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    Py_XDECREF( par_nbytes );
    par_nbytes = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_68_recv_into );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_69__handle_bio_errors( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_bio = python_pars[ 1 ];
    PyObject *par_result = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_69ff2c23544b1c72fc03755bb35fb253;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_69ff2c23544b1c72fc03755bb35fb253 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_69ff2c23544b1c72fc03755bb35fb253, codeobj_69ff2c23544b1c72fc03755bb35fb253, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_69ff2c23544b1c72fc03755bb35fb253 = cache_frame_69ff2c23544b1c72fc03755bb35fb253;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_69ff2c23544b1c72fc03755bb35fb253 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_69ff2c23544b1c72fc03755bb35fb253 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1833;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_bio );
        tmp_args_element_name_1 = par_bio;
        frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1833;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_BIO_should_retry, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1833;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 1833;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_2;
            int tmp_truth_name_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1834;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_2;
            CHECK_OBJECT( par_bio );
            tmp_args_element_name_2 = par_bio;
            frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1834;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_BIO_should_read, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1834;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_truth_name_2 = CHECK_IF_TRUE( tmp_call_result_2 );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_call_result_2 );

                exception_lineno = 1834;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_2 );
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_called_name_1;
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError );

                if (unlikely( tmp_mvar_value_3 == NULL ))
                {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantReadError );
                }

                if ( tmp_mvar_value_3 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantReadError" );
                    exception_tb = NULL;

                    exception_lineno = 1835;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_1 = tmp_mvar_value_3;
                frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1835;
                tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
                if ( tmp_raise_type_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1835;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_1;
                exception_lineno = 1835;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_called_instance_3;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_3;
                int tmp_truth_name_3;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_4 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 1836;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_3 = tmp_mvar_value_4;
                CHECK_OBJECT( par_bio );
                tmp_args_element_name_3 = par_bio;
                frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1836;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_BIO_should_write, call_args );
                }

                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1836;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_3 = CHECK_IF_TRUE( tmp_call_result_3 );
                if ( tmp_truth_name_3 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_call_result_3 );

                    exception_lineno = 1836;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_call_result_3 );
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_raise_type_2;
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_mvar_value_5;
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError );

                    if (unlikely( tmp_mvar_value_5 == NULL ))
                    {
                        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WantWriteError );
                    }

                    if ( tmp_mvar_value_5 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "WantWriteError" );
                        exception_tb = NULL;

                        exception_lineno = 1838;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_2 = tmp_mvar_value_5;
                    frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1838;
                    tmp_raise_type_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
                    if ( tmp_raise_type_2 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1838;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    exception_type = tmp_raise_type_2;
                    exception_lineno = 1838;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    nuitka_bool tmp_condition_result_4;
                    PyObject *tmp_called_instance_4;
                    PyObject *tmp_mvar_value_6;
                    PyObject *tmp_call_result_4;
                    PyObject *tmp_args_element_name_4;
                    int tmp_truth_name_4;
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_6 == NULL ))
                    {
                        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_6 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1839;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_4 = tmp_mvar_value_6;
                    CHECK_OBJECT( par_bio );
                    tmp_args_element_name_4 = par_bio;
                    frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1839;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_4 };
                        tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_BIO_should_io_special, call_args );
                    }

                    if ( tmp_call_result_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1839;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_truth_name_4 = CHECK_IF_TRUE( tmp_call_result_4 );
                    if ( tmp_truth_name_4 == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_call_result_4 );

                        exception_lineno = 1839;
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_condition_result_4 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    Py_DECREF( tmp_call_result_4 );
                    if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_4;
                    }
                    else
                    {
                        goto branch_no_4;
                    }
                    branch_yes_4:;
                    {
                        PyObject *tmp_raise_type_3;
                        PyObject *tmp_make_exception_arg_1;
                        tmp_make_exception_arg_1 = const_str_plain_BIO_should_io_special;
                        frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1842;
                        {
                            PyObject *call_args[] = { tmp_make_exception_arg_1 };
                            tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                        }

                        assert( !(tmp_raise_type_3 == NULL) );
                        exception_type = tmp_raise_type_3;
                        exception_lineno = 1842;
                        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    goto branch_end_4;
                    branch_no_4:;
                    {
                        PyObject *tmp_raise_type_4;
                        PyObject *tmp_make_exception_arg_2;
                        tmp_make_exception_arg_2 = const_str_digest_1491fa532da0499070a77d607dd12a0d;
                        frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1845;
                        {
                            PyObject *call_args[] = { tmp_make_exception_arg_2 };
                            tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                        }

                        assert( !(tmp_raise_type_4 == NULL) );
                        exception_type = tmp_raise_type_4;
                        exception_lineno = 1845;
                        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                        type_description_1 = "ooo";
                        goto frame_exception_exit_1;
                    }
                    branch_end_4:;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_call_result_5;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1848;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_7;
            frame_69ff2c23544b1c72fc03755bb35fb253->m_frame.f_lineno = 1848;
            tmp_call_result_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1848;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_5 );
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_69ff2c23544b1c72fc03755bb35fb253 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_69ff2c23544b1c72fc03755bb35fb253 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_69ff2c23544b1c72fc03755bb35fb253, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_69ff2c23544b1c72fc03755bb35fb253->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_69ff2c23544b1c72fc03755bb35fb253, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_69ff2c23544b1c72fc03755bb35fb253,
        type_description_1,
        par_self,
        par_bio,
        par_result
    );


    // Release cached frame.
    if ( frame_69ff2c23544b1c72fc03755bb35fb253 == cache_frame_69ff2c23544b1c72fc03755bb35fb253 )
    {
        Py_DECREF( frame_69ff2c23544b1c72fc03755bb35fb253 );
    }
    cache_frame_69ff2c23544b1c72fc03755bb35fb253 = NULL;

    assertFrameObject( frame_69ff2c23544b1c72fc03755bb35fb253 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_69__handle_bio_errors );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_69__handle_bio_errors );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_70_bio_read( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_bufsiz = python_pars[ 1 ];
    PyObject *var_buf = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_e2e44a36909f5df8646b2e1f8b0a8741;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e2e44a36909f5df8646b2e1f8b0a8741 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e2e44a36909f5df8646b2e1f8b0a8741, codeobj_e2e44a36909f5df8646b2e1f8b0a8741, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e2e44a36909f5df8646b2e1f8b0a8741 = cache_frame_e2e44a36909f5df8646b2e1f8b0a8741;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e2e44a36909f5df8646b2e1f8b0a8741 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e2e44a36909f5df8646b2e1f8b0a8741 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__from_ssl );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1861;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
            frame_e2e44a36909f5df8646b2e1f8b0a8741->m_frame.f_lineno = 1862;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1862;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_bufsiz );
        tmp_isinstance_inst_1 = par_bufsiz;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 1864;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1864;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1864;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_f6ccda911266ccc3bb4cd038d18beb52;
            frame_e2e44a36909f5df8646b2e1f8b0a8741->m_frame.f_lineno = 1865;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1865;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 1867;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        tmp_args_element_name_1 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT( par_bufsiz );
        tmp_args_element_name_2 = par_bufsiz;
        frame_e2e44a36909f5df8646b2e1f8b0a8741->m_frame.f_lineno = 1867;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1867;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_buf == NULL );
        var_buf = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_read );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__from_ssl );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_buf );
        tmp_args_element_name_4 = var_buf;
        CHECK_OBJECT( par_bufsiz );
        tmp_args_element_name_5 = par_bufsiz;
        frame_e2e44a36909f5df8646b2e1f8b0a8741->m_frame.f_lineno = 1868;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1868;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_result );
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1869;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__handle_bio_errors );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1870;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__from_ssl );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1870;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_result );
            tmp_args_element_name_7 = var_result;
            frame_e2e44a36909f5df8646b2e1f8b0a8741->m_frame.f_lineno = 1870;
            {
                PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1870;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_3:;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1872;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT( var_buf );
        tmp_args_element_name_8 = var_buf;
        CHECK_OBJECT( var_result );
        tmp_args_element_name_9 = var_result;
        frame_e2e44a36909f5df8646b2e1f8b0a8741->m_frame.f_lineno = 1872;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1872;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1872;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2e44a36909f5df8646b2e1f8b0a8741 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2e44a36909f5df8646b2e1f8b0a8741 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2e44a36909f5df8646b2e1f8b0a8741 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e2e44a36909f5df8646b2e1f8b0a8741, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e2e44a36909f5df8646b2e1f8b0a8741->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e2e44a36909f5df8646b2e1f8b0a8741, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2e44a36909f5df8646b2e1f8b0a8741,
        type_description_1,
        par_self,
        par_bufsiz,
        var_buf,
        var_result
    );


    // Release cached frame.
    if ( frame_e2e44a36909f5df8646b2e1f8b0a8741 == cache_frame_e2e44a36909f5df8646b2e1f8b0a8741 )
    {
        Py_DECREF( frame_e2e44a36909f5df8646b2e1f8b0a8741 );
    }
    cache_frame_e2e44a36909f5df8646b2e1f8b0a8741 = NULL;

    assertFrameObject( frame_e2e44a36909f5df8646b2e1f8b0a8741 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_70_bio_read );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_buf );
    Py_DECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_bufsiz );
    Py_DECREF( par_bufsiz );
    par_bufsiz = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_70_bio_read );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_71_bio_write( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_7a00a7cb18c1f008e8d4f4e6d2d91473;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_7a00a7cb18c1f008e8d4f4e6d2d91473 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7a00a7cb18c1f008e8d4f4e6d2d91473, codeobj_7a00a7cb18c1f008e8d4f4e6d2d91473, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7a00a7cb18c1f008e8d4f4e6d2d91473 = cache_frame_7a00a7cb18c1f008e8d4f4e6d2d91473;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7a00a7cb18c1f008e8d4f4e6d2d91473 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7a00a7cb18c1f008e8d4f4e6d2d91473 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 1884;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_buf;
        CHECK_OBJECT( par_buf );
        tmp_args_element_name_2 = par_buf;
        frame_7a00a7cb18c1f008e8d4f4e6d2d91473->m_frame.f_lineno = 1884;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1884;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_buf;
            assert( old != NULL );
            par_buf = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__into_ssl );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1886;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
            frame_7a00a7cb18c1f008e8d4f4e6d2d91473->m_frame.f_lineno = 1887;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1887;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_write );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__into_ssl );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_buf );
        tmp_args_element_name_4 = par_buf;
        CHECK_OBJECT( par_buf );
        tmp_len_arg_1 = par_buf;
        tmp_args_element_name_5 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_7a00a7cb18c1f008e8d4f4e6d2d91473->m_frame.f_lineno = 1889;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1889;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_result );
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1890;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__handle_bio_errors );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1891;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__into_ssl );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1891;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_result );
            tmp_args_element_name_7 = var_result;
            frame_7a00a7cb18c1f008e8d4f4e6d2d91473->m_frame.f_lineno = 1891;
            {
                PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1891;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a00a7cb18c1f008e8d4f4e6d2d91473 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a00a7cb18c1f008e8d4f4e6d2d91473 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7a00a7cb18c1f008e8d4f4e6d2d91473, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7a00a7cb18c1f008e8d4f4e6d2d91473->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7a00a7cb18c1f008e8d4f4e6d2d91473, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7a00a7cb18c1f008e8d4f4e6d2d91473,
        type_description_1,
        par_self,
        par_buf,
        var_result
    );


    // Release cached frame.
    if ( frame_7a00a7cb18c1f008e8d4f4e6d2d91473 == cache_frame_7a00a7cb18c1f008e8d4f4e6d2d91473 )
    {
        Py_DECREF( frame_7a00a7cb18c1f008e8d4f4e6d2d91473 );
    }
    cache_frame_7a00a7cb18c1f008e8d4f4e6d2d91473 = NULL;

    assertFrameObject( frame_7a00a7cb18c1f008e8d4f4e6d2d91473 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_71_bio_write );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_71_bio_write );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_72_renegotiate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_30fbf84052a7d1bcffa3c18a7999cd6f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_30fbf84052a7d1bcffa3c18a7999cd6f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_30fbf84052a7d1bcffa3c18a7999cd6f, codeobj_30fbf84052a7d1bcffa3c18a7999cd6f, module_OpenSSL$SSL, sizeof(void *) );
    frame_30fbf84052a7d1bcffa3c18a7999cd6f = cache_frame_30fbf84052a7d1bcffa3c18a7999cd6f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_30fbf84052a7d1bcffa3c18a7999cd6f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_30fbf84052a7d1bcffa3c18a7999cd6f ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_30fbf84052a7d1bcffa3c18a7999cd6f->m_frame.f_lineno = 1901;
        tmp_operand_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_renegotiate_pending );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1901;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1901;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_2;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_renegotiate );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_30fbf84052a7d1bcffa3c18a7999cd6f->m_frame.f_lineno = 1902;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_compexpr_left_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_1 = const_int_pos_1;
            tmp_args_element_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            Py_DECREF( tmp_compexpr_left_1 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            frame_30fbf84052a7d1bcffa3c18a7999cd6f->m_frame.f_lineno = 1902;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1902;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        tmp_return_value = Py_True;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_30fbf84052a7d1bcffa3c18a7999cd6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_30fbf84052a7d1bcffa3c18a7999cd6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_30fbf84052a7d1bcffa3c18a7999cd6f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_30fbf84052a7d1bcffa3c18a7999cd6f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_30fbf84052a7d1bcffa3c18a7999cd6f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_30fbf84052a7d1bcffa3c18a7999cd6f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_30fbf84052a7d1bcffa3c18a7999cd6f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_30fbf84052a7d1bcffa3c18a7999cd6f == cache_frame_30fbf84052a7d1bcffa3c18a7999cd6f )
    {
        Py_DECREF( frame_30fbf84052a7d1bcffa3c18a7999cd6f );
    }
    cache_frame_30fbf84052a7d1bcffa3c18a7999cd6f = NULL;

    assertFrameObject( frame_30fbf84052a7d1bcffa3c18a7999cd6f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_72_renegotiate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_72_renegotiate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_73_do_handshake( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_c41b1a3f0450c7a475885eaa3a67dae8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c41b1a3f0450c7a475885eaa3a67dae8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c41b1a3f0450c7a475885eaa3a67dae8, codeobj_c41b1a3f0450c7a475885eaa3a67dae8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_c41b1a3f0450c7a475885eaa3a67dae8 = cache_frame_c41b1a3f0450c7a475885eaa3a67dae8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c41b1a3f0450c7a475885eaa3a67dae8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c41b1a3f0450c7a475885eaa3a67dae8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_do_handshake );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c41b1a3f0450c7a475885eaa3a67dae8->m_frame.f_lineno = 1914;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1914;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__raise_ssl_error );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result );
        tmp_args_element_name_3 = var_result;
        frame_c41b1a3f0450c7a475885eaa3a67dae8->m_frame.f_lineno = 1915;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c41b1a3f0450c7a475885eaa3a67dae8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c41b1a3f0450c7a475885eaa3a67dae8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c41b1a3f0450c7a475885eaa3a67dae8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c41b1a3f0450c7a475885eaa3a67dae8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c41b1a3f0450c7a475885eaa3a67dae8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c41b1a3f0450c7a475885eaa3a67dae8,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if ( frame_c41b1a3f0450c7a475885eaa3a67dae8 == cache_frame_c41b1a3f0450c7a475885eaa3a67dae8 )
    {
        Py_DECREF( frame_c41b1a3f0450c7a475885eaa3a67dae8 );
    }
    cache_frame_c41b1a3f0450c7a475885eaa3a67dae8 = NULL;

    assertFrameObject( frame_c41b1a3f0450c7a475885eaa3a67dae8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_73_do_handshake );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_73_do_handshake );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_74_renegotiate_pending( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0c7560e59f4396437ef373315ed7cd5c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0c7560e59f4396437ef373315ed7cd5c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c7560e59f4396437ef373315ed7cd5c, codeobj_0c7560e59f4396437ef373315ed7cd5c, module_OpenSSL$SSL, sizeof(void *) );
    frame_0c7560e59f4396437ef373315ed7cd5c = cache_frame_0c7560e59f4396437ef373315ed7cd5c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c7560e59f4396437ef373315ed7cd5c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c7560e59f4396437ef373315ed7cd5c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_renegotiate_pending );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_0c7560e59f4396437ef373315ed7cd5c->m_frame.f_lineno = 1925;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_return_value = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1925;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c7560e59f4396437ef373315ed7cd5c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c7560e59f4396437ef373315ed7cd5c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c7560e59f4396437ef373315ed7cd5c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c7560e59f4396437ef373315ed7cd5c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c7560e59f4396437ef373315ed7cd5c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c7560e59f4396437ef373315ed7cd5c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c7560e59f4396437ef373315ed7cd5c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0c7560e59f4396437ef373315ed7cd5c == cache_frame_0c7560e59f4396437ef373315ed7cd5c )
    {
        Py_DECREF( frame_0c7560e59f4396437ef373315ed7cd5c );
    }
    cache_frame_0c7560e59f4396437ef373315ed7cd5c = NULL;

    assertFrameObject( frame_0c7560e59f4396437ef373315ed7cd5c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_74_renegotiate_pending );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_74_renegotiate_pending );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_75_total_renegotiations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_05a1faeaf48c61a421aaa55c489d7360;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_05a1faeaf48c61a421aaa55c489d7360 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_05a1faeaf48c61a421aaa55c489d7360, codeobj_05a1faeaf48c61a421aaa55c489d7360, module_OpenSSL$SSL, sizeof(void *) );
    frame_05a1faeaf48c61a421aaa55c489d7360 = cache_frame_05a1faeaf48c61a421aaa55c489d7360;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_05a1faeaf48c61a421aaa55c489d7360 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_05a1faeaf48c61a421aaa55c489d7360 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_total_renegotiations );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_05a1faeaf48c61a421aaa55c489d7360->m_frame.f_lineno = 1934;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1934;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05a1faeaf48c61a421aaa55c489d7360 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_05a1faeaf48c61a421aaa55c489d7360 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05a1faeaf48c61a421aaa55c489d7360 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_05a1faeaf48c61a421aaa55c489d7360, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_05a1faeaf48c61a421aaa55c489d7360->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_05a1faeaf48c61a421aaa55c489d7360, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_05a1faeaf48c61a421aaa55c489d7360,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_05a1faeaf48c61a421aaa55c489d7360 == cache_frame_05a1faeaf48c61a421aaa55c489d7360 )
    {
        Py_DECREF( frame_05a1faeaf48c61a421aaa55c489d7360 );
    }
    cache_frame_05a1faeaf48c61a421aaa55c489d7360 = NULL;

    assertFrameObject( frame_05a1faeaf48c61a421aaa55c489d7360 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_75_total_renegotiations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_75_total_renegotiations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_76_connect( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_addr = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_e74b0d670d825333142ebe15f0fa8d7c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e74b0d670d825333142ebe15f0fa8d7c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e74b0d670d825333142ebe15f0fa8d7c, codeobj_e74b0d670d825333142ebe15f0fa8d7c, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_e74b0d670d825333142ebe15f0fa8d7c = cache_frame_e74b0d670d825333142ebe15f0fa8d7c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e74b0d670d825333142ebe15f0fa8d7c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e74b0d670d825333142ebe15f0fa8d7c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_connect_state );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_e74b0d670d825333142ebe15f0fa8d7c->m_frame.f_lineno = 1945;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1945;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__socket );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1946;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_addr );
        tmp_args_element_name_2 = par_addr;
        frame_e74b0d670d825333142ebe15f0fa8d7c->m_frame.f_lineno = 1946;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_connect, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1946;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e74b0d670d825333142ebe15f0fa8d7c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e74b0d670d825333142ebe15f0fa8d7c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e74b0d670d825333142ebe15f0fa8d7c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e74b0d670d825333142ebe15f0fa8d7c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e74b0d670d825333142ebe15f0fa8d7c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e74b0d670d825333142ebe15f0fa8d7c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e74b0d670d825333142ebe15f0fa8d7c,
        type_description_1,
        par_self,
        par_addr
    );


    // Release cached frame.
    if ( frame_e74b0d670d825333142ebe15f0fa8d7c == cache_frame_e74b0d670d825333142ebe15f0fa8d7c )
    {
        Py_DECREF( frame_e74b0d670d825333142ebe15f0fa8d7c );
    }
    cache_frame_e74b0d670d825333142ebe15f0fa8d7c = NULL;

    assertFrameObject( frame_e74b0d670d825333142ebe15f0fa8d7c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_76_connect );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_76_connect );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_77_connect_ex( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_addr = python_pars[ 1 ];
    PyObject *var_connect_ex = NULL;
    struct Nuitka_FrameObject *frame_01faaa9c80c48cd540120e4e857f6ece;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_01faaa9c80c48cd540120e4e857f6ece = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_01faaa9c80c48cd540120e4e857f6ece, codeobj_01faaa9c80c48cd540120e4e857f6ece, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_01faaa9c80c48cd540120e4e857f6ece = cache_frame_01faaa9c80c48cd540120e4e857f6ece;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_01faaa9c80c48cd540120e4e857f6ece );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_01faaa9c80c48cd540120e4e857f6ece ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__socket );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1958;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_connect_ex );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1958;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_connect_ex == NULL );
        var_connect_ex = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_01faaa9c80c48cd540120e4e857f6ece->m_frame.f_lineno = 1959;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_set_connect_state );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1959;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( var_connect_ex );
        tmp_called_name_1 = var_connect_ex;
        CHECK_OBJECT( par_addr );
        tmp_args_element_name_1 = par_addr;
        frame_01faaa9c80c48cd540120e4e857f6ece->m_frame.f_lineno = 1960;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1960;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_01faaa9c80c48cd540120e4e857f6ece );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_01faaa9c80c48cd540120e4e857f6ece );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_01faaa9c80c48cd540120e4e857f6ece );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_01faaa9c80c48cd540120e4e857f6ece, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_01faaa9c80c48cd540120e4e857f6ece->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_01faaa9c80c48cd540120e4e857f6ece, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_01faaa9c80c48cd540120e4e857f6ece,
        type_description_1,
        par_self,
        par_addr,
        var_connect_ex
    );


    // Release cached frame.
    if ( frame_01faaa9c80c48cd540120e4e857f6ece == cache_frame_01faaa9c80c48cd540120e4e857f6ece )
    {
        Py_DECREF( frame_01faaa9c80c48cd540120e4e857f6ece );
    }
    cache_frame_01faaa9c80c48cd540120e4e857f6ece = NULL;

    assertFrameObject( frame_01faaa9c80c48cd540120e4e857f6ece );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_77_connect_ex );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_connect_ex );
    Py_DECREF( var_connect_ex );
    var_connect_ex = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_connect_ex );
    var_connect_ex = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_addr );
    Py_DECREF( par_addr );
    par_addr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_77_connect_ex );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_78_accept( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_client = NULL;
    PyObject *var_addr = NULL;
    PyObject *var_conn = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_d90925d66d5cf1b0980da015a4674b00;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_d90925d66d5cf1b0980da015a4674b00 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d90925d66d5cf1b0980da015a4674b00, codeobj_d90925d66d5cf1b0980da015a4674b00, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d90925d66d5cf1b0980da015a4674b00 = cache_frame_d90925d66d5cf1b0980da015a4674b00;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d90925d66d5cf1b0980da015a4674b00 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d90925d66d5cf1b0980da015a4674b00 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__socket );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1972;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        frame_d90925d66d5cf1b0980da015a4674b00->m_frame.f_lineno = 1972;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_accept );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1972;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1972;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        assert( tmp_tuple_unpack_1__source_iter == NULL );
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooo";
            exception_lineno = 1972;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_1 == NULL );
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooo";
            exception_lineno = 1972;
            goto try_except_handler_3;
        }
        assert( tmp_tuple_unpack_1__element_2 == NULL );
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;
    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooo";
                    exception_lineno = 1972;
                    goto try_except_handler_3;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooo";
            exception_lineno = 1972;
            goto try_except_handler_3;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_4 = tmp_tuple_unpack_1__element_1;
        assert( var_client == NULL );
        Py_INCREF( tmp_assign_source_4 );
        var_client = tmp_assign_source_4;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_5 = tmp_tuple_unpack_1__element_2;
        assert( var_addr == NULL );
        Py_INCREF( tmp_assign_source_5 );
        var_addr = tmp_assign_source_5;
    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 1973;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__context );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1973;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_client );
        tmp_args_element_name_2 = var_client;
        frame_d90925d66d5cf1b0980da015a4674b00->m_frame.f_lineno = 1973;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1973;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_conn == NULL );
        var_conn = tmp_assign_source_6;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( var_conn );
        tmp_called_instance_2 = var_conn;
        frame_d90925d66d5cf1b0980da015a4674b00->m_frame.f_lineno = 1974;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_set_accept_state );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1974;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d90925d66d5cf1b0980da015a4674b00 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d90925d66d5cf1b0980da015a4674b00 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d90925d66d5cf1b0980da015a4674b00, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d90925d66d5cf1b0980da015a4674b00->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d90925d66d5cf1b0980da015a4674b00, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d90925d66d5cf1b0980da015a4674b00,
        type_description_1,
        par_self,
        var_client,
        var_addr,
        var_conn
    );


    // Release cached frame.
    if ( frame_d90925d66d5cf1b0980da015a4674b00 == cache_frame_d90925d66d5cf1b0980da015a4674b00 )
    {
        Py_DECREF( frame_d90925d66d5cf1b0980da015a4674b00 );
    }
    cache_frame_d90925d66d5cf1b0980da015a4674b00 = NULL;

    assertFrameObject( frame_d90925d66d5cf1b0980da015a4674b00 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    {
        PyObject *tmp_tuple_element_1;
        CHECK_OBJECT( var_conn );
        tmp_tuple_element_1 = var_conn;
        tmp_return_value = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( var_addr );
        tmp_tuple_element_1 = var_addr;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
        goto try_return_handler_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_78_accept );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_client );
    Py_DECREF( var_client );
    var_client = NULL;

    CHECK_OBJECT( (PyObject *)var_addr );
    Py_DECREF( var_addr );
    var_addr = NULL;

    CHECK_OBJECT( (PyObject *)var_conn );
    Py_DECREF( var_conn );
    var_conn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_client );
    var_client = NULL;

    Py_XDECREF( var_addr );
    var_addr = NULL;

    Py_XDECREF( var_conn );
    var_conn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_78_accept );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_79_bio_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_85ded3b492f290b648fbd8dbdb475788;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_85ded3b492f290b648fbd8dbdb475788 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_85ded3b492f290b648fbd8dbdb475788, codeobj_85ded3b492f290b648fbd8dbdb475788, module_OpenSSL$SSL, sizeof(void *) );
    frame_85ded3b492f290b648fbd8dbdb475788 = cache_frame_85ded3b492f290b648fbd8dbdb475788;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_85ded3b492f290b648fbd8dbdb475788 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_85ded3b492f290b648fbd8dbdb475788 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__from_ssl );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1985;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_1fbb26888e8a93a4fffae5202f2e81a6;
            frame_85ded3b492f290b648fbd8dbdb475788->m_frame.f_lineno = 1986;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1986;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_set_mem_eof_return );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__into_ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = const_int_0;
        frame_85ded3b492f290b648fbd8dbdb475788->m_frame.f_lineno = 1988;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1988;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85ded3b492f290b648fbd8dbdb475788 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85ded3b492f290b648fbd8dbdb475788 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_85ded3b492f290b648fbd8dbdb475788, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_85ded3b492f290b648fbd8dbdb475788->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_85ded3b492f290b648fbd8dbdb475788, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_85ded3b492f290b648fbd8dbdb475788,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_85ded3b492f290b648fbd8dbdb475788 == cache_frame_85ded3b492f290b648fbd8dbdb475788 )
    {
        Py_DECREF( frame_85ded3b492f290b648fbd8dbdb475788 );
    }
    cache_frame_85ded3b492f290b648fbd8dbdb475788 = NULL;

    assertFrameObject( frame_85ded3b492f290b648fbd8dbdb475788 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_79_bio_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_79_bio_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_80_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_f89df5132055bf6ccda906b72a60bfc3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f89df5132055bf6ccda906b72a60bfc3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f89df5132055bf6ccda906b72a60bfc3, codeobj_f89df5132055bf6ccda906b72a60bfc3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_f89df5132055bf6ccda906b72a60bfc3 = cache_frame_f89df5132055bf6ccda906b72a60bfc3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f89df5132055bf6ccda906b72a60bfc3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f89df5132055bf6ccda906b72a60bfc3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_shutdown );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_f89df5132055bf6ccda906b72a60bfc3->m_frame.f_lineno = 1999;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1999;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_result );
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2000;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__raise_ssl_error );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2001;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2001;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_result );
            tmp_args_element_name_3 = var_result;
            frame_f89df5132055bf6ccda906b72a60bfc3->m_frame.f_lineno = 2001;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2001;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( var_result );
            tmp_compexpr_left_2 = var_result;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2002;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_return_value = Py_True;
            Py_INCREF( tmp_return_value );
            goto frame_return_exit_1;
            goto branch_end_2;
            branch_no_2:;
            tmp_return_value = Py_False;
            Py_INCREF( tmp_return_value );
            goto frame_return_exit_1;
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f89df5132055bf6ccda906b72a60bfc3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f89df5132055bf6ccda906b72a60bfc3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f89df5132055bf6ccda906b72a60bfc3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f89df5132055bf6ccda906b72a60bfc3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f89df5132055bf6ccda906b72a60bfc3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f89df5132055bf6ccda906b72a60bfc3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f89df5132055bf6ccda906b72a60bfc3,
        type_description_1,
        par_self,
        var_result
    );


    // Release cached frame.
    if ( frame_f89df5132055bf6ccda906b72a60bfc3 == cache_frame_f89df5132055bf6ccda906b72a60bfc3 )
    {
        Py_DECREF( frame_f89df5132055bf6ccda906b72a60bfc3 );
    }
    cache_frame_f89df5132055bf6ccda906b72a60bfc3 = NULL;

    assertFrameObject( frame_f89df5132055bf6ccda906b72a60bfc3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_80_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_80_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_81_get_cipher_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_ciphers = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_a8cab1d99611ab8877a7b8259839e592;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_a8cab1d99611ab8877a7b8259839e592 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New( 0 );
        assert( var_ciphers == NULL );
        var_ciphers = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a8cab1d99611ab8877a7b8259839e592, codeobj_a8cab1d99611ab8877a7b8259839e592, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a8cab1d99611ab8877a7b8259839e592 = cache_frame_a8cab1d99611ab8877a7b8259839e592;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a8cab1d99611ab8877a7b8259839e592 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a8cab1d99611ab8877a7b8259839e592 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_count );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_count );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "count" );
            exception_tb = NULL;

            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_a8cab1d99611ab8877a7b8259839e592->m_frame.f_lineno = 2014;
        tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 2014;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_4;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_cipher_list );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_i );
        tmp_args_element_name_2 = var_i;
        frame_a8cab1d99611ab8877a7b8259839e592->m_frame.f_lineno = 2015;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_result;
            var_result = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_result );
        tmp_compexpr_left_1 = var_result;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2016;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2016;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2016;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT( var_ciphers );
        tmp_source_name_4 = var_ciphers;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__native );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
            exception_tb = NULL;

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_name_4 = tmp_mvar_value_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT( var_result );
        tmp_args_element_name_5 = var_result;
        frame_a8cab1d99611ab8877a7b8259839e592->m_frame.f_lineno = 2018;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_string, call_args );
        }

        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        frame_a8cab1d99611ab8877a7b8259839e592->m_frame.f_lineno = 2018;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        frame_a8cab1d99611ab8877a7b8259839e592->m_frame.f_lineno = 2018;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2014;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8cab1d99611ab8877a7b8259839e592 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8cab1d99611ab8877a7b8259839e592 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a8cab1d99611ab8877a7b8259839e592, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a8cab1d99611ab8877a7b8259839e592->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a8cab1d99611ab8877a7b8259839e592, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a8cab1d99611ab8877a7b8259839e592,
        type_description_1,
        par_self,
        var_i,
        var_ciphers,
        var_result
    );


    // Release cached frame.
    if ( frame_a8cab1d99611ab8877a7b8259839e592 == cache_frame_a8cab1d99611ab8877a7b8259839e592 )
    {
        Py_DECREF( frame_a8cab1d99611ab8877a7b8259839e592 );
    }
    cache_frame_a8cab1d99611ab8877a7b8259839e592 = NULL;

    assertFrameObject( frame_a8cab1d99611ab8877a7b8259839e592 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( var_ciphers );
    tmp_return_value = var_ciphers;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_81_get_cipher_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ciphers );
    Py_DECREF( var_ciphers );
    var_ciphers = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ciphers );
    Py_DECREF( var_ciphers );
    var_ciphers = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_81_get_cipher_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_82_get_client_ca_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *var_pyname = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ca_names = NULL;
    PyObject *var_result = NULL;
    PyObject *var_copy = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_0bd8f781f5883f7dd44ea21f5d030f6f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_0bd8f781f5883f7dd44ea21f5d030f6f = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0bd8f781f5883f7dd44ea21f5d030f6f, codeobj_0bd8f781f5883f7dd44ea21f5d030f6f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0bd8f781f5883f7dd44ea21f5d030f6f = cache_frame_0bd8f781f5883f7dd44ea21f5d030f6f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0bd8f781f5883f7dd44ea21f5d030f6f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0bd8f781f5883f7dd44ea21f5d030f6f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_client_CA_list );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2034;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2034;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_ca_names == NULL );
        var_ca_names = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_ca_names );
        tmp_compexpr_left_1 = var_ca_names;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2035;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2035;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2035;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = PyList_New( 0 );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New( 0 );
        assert( var_result == NULL );
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_ca_names );
        tmp_args_element_name_2 = var_ca_names;
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2040;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_NAME_num, call_args );
        }

        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2040;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooo";
                exception_lineno = 2040;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2041;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT( var_ca_names );
        tmp_args_element_name_3 = var_ca_names;
        CHECK_OBJECT( var_i );
        tmp_args_element_name_4 = var_i;
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2041;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_NAME_value, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2041;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2042;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT( var_name );
        tmp_args_element_name_5 = var_name;
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2042;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_NAME_dup, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2042;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_copy;
            var_copy = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_2 = tmp_mvar_value_6;
        CHECK_OBJECT( var_copy );
        tmp_compexpr_left_2 = var_copy;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_6 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2043;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2043;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___new__ );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_9 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_args_element_name_7 = tmp_mvar_value_9;
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2045;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2045;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_pyname;
            var_pyname = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_6 = tmp_mvar_value_10;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_copy );
        tmp_args_element_name_8 = var_copy;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_11 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_NAME_free );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2046;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_pyname );
        tmp_assattr_target_1 = var_pyname;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2046;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_10;
        CHECK_OBJECT( var_result );
        tmp_called_instance_4 = var_result;
        CHECK_OBJECT( var_pyname );
        tmp_args_element_name_10 = var_pyname;
        frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame.f_lineno = 2047;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2047;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2040;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0bd8f781f5883f7dd44ea21f5d030f6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0bd8f781f5883f7dd44ea21f5d030f6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0bd8f781f5883f7dd44ea21f5d030f6f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0bd8f781f5883f7dd44ea21f5d030f6f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0bd8f781f5883f7dd44ea21f5d030f6f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0bd8f781f5883f7dd44ea21f5d030f6f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0bd8f781f5883f7dd44ea21f5d030f6f,
        type_description_1,
        par_self,
        var_name,
        var_pyname,
        var_i,
        var_ca_names,
        var_result,
        var_copy
    );


    // Release cached frame.
    if ( frame_0bd8f781f5883f7dd44ea21f5d030f6f == cache_frame_0bd8f781f5883f7dd44ea21f5d030f6f )
    {
        Py_DECREF( frame_0bd8f781f5883f7dd44ea21f5d030f6f );
    }
    cache_frame_0bd8f781f5883f7dd44ea21f5d030f6f = NULL;

    assertFrameObject( frame_0bd8f781f5883f7dd44ea21f5d030f6f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_82_get_client_ca_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_pyname );
    var_pyname = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ca_names );
    Py_DECREF( var_ca_names );
    var_ca_names = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_pyname );
    var_pyname = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ca_names );
    var_ca_names = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_82_get_client_ca_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_83_makefile( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_72bb665d288c66555372d0602d766fd8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_72bb665d288c66555372d0602d766fd8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_72bb665d288c66555372d0602d766fd8, codeobj_72bb665d288c66555372d0602d766fd8, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_72bb665d288c66555372d0602d766fd8 = cache_frame_72bb665d288c66555372d0602d766fd8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_72bb665d288c66555372d0602d766fd8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_72bb665d288c66555372d0602d766fd8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        tmp_make_exception_arg_1 = const_str_digest_7540551bed0e4507c2b90cdbe0aa8fb3;
        frame_72bb665d288c66555372d0602d766fd8->m_frame.f_lineno = 2057;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
        }

        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 2057;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_72bb665d288c66555372d0602d766fd8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_72bb665d288c66555372d0602d766fd8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_72bb665d288c66555372d0602d766fd8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_72bb665d288c66555372d0602d766fd8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_72bb665d288c66555372d0602d766fd8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_72bb665d288c66555372d0602d766fd8,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_72bb665d288c66555372d0602d766fd8 == cache_frame_72bb665d288c66555372d0602d766fd8 )
    {
        Py_DECREF( frame_72bb665d288c66555372d0602d766fd8 );
    }
    cache_frame_72bb665d288c66555372d0602d766fd8 = NULL;

    assertFrameObject( frame_72bb665d288c66555372d0602d766fd8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_83_makefile );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_83_makefile );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_OpenSSL$SSL$$$function_84_get_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_32e837ccb250942a0b72b517687f5b19;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_32e837ccb250942a0b72b517687f5b19 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_32e837ccb250942a0b72b517687f5b19, codeobj_32e837ccb250942a0b72b517687f5b19, module_OpenSSL$SSL, sizeof(void *) );
    frame_32e837ccb250942a0b72b517687f5b19 = cache_frame_32e837ccb250942a0b72b517687f5b19;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_32e837ccb250942a0b72b517687f5b19 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_32e837ccb250942a0b72b517687f5b19 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__app_data );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2066;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32e837ccb250942a0b72b517687f5b19 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_32e837ccb250942a0b72b517687f5b19 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_32e837ccb250942a0b72b517687f5b19 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_32e837ccb250942a0b72b517687f5b19, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_32e837ccb250942a0b72b517687f5b19->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_32e837ccb250942a0b72b517687f5b19, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_32e837ccb250942a0b72b517687f5b19,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_32e837ccb250942a0b72b517687f5b19 == cache_frame_32e837ccb250942a0b72b517687f5b19 )
    {
        Py_DECREF( frame_32e837ccb250942a0b72b517687f5b19 );
    }
    cache_frame_32e837ccb250942a0b72b517687f5b19 = NULL;

    assertFrameObject( frame_32e837ccb250942a0b72b517687f5b19 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_84_get_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_84_get_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_85_set_app_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_f362b683cf087e1099fdf014aa93bacd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f362b683cf087e1099fdf014aa93bacd = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f362b683cf087e1099fdf014aa93bacd, codeobj_f362b683cf087e1099fdf014aa93bacd, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_f362b683cf087e1099fdf014aa93bacd = cache_frame_f362b683cf087e1099fdf014aa93bacd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f362b683cf087e1099fdf014aa93bacd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f362b683cf087e1099fdf014aa93bacd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_data );
        tmp_assattr_name_1 = par_data;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__app_data, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2075;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f362b683cf087e1099fdf014aa93bacd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f362b683cf087e1099fdf014aa93bacd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f362b683cf087e1099fdf014aa93bacd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f362b683cf087e1099fdf014aa93bacd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f362b683cf087e1099fdf014aa93bacd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f362b683cf087e1099fdf014aa93bacd,
        type_description_1,
        par_self,
        par_data
    );


    // Release cached frame.
    if ( frame_f362b683cf087e1099fdf014aa93bacd == cache_frame_f362b683cf087e1099fdf014aa93bacd )
    {
        Py_DECREF( frame_f362b683cf087e1099fdf014aa93bacd );
    }
    cache_frame_f362b683cf087e1099fdf014aa93bacd = NULL;

    assertFrameObject( frame_f362b683cf087e1099fdf014aa93bacd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_85_set_app_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_85_set_app_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_86_get_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_be6cb0488266a27981ef336bc64c1840;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_be6cb0488266a27981ef336bc64c1840 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_be6cb0488266a27981ef336bc64c1840, codeobj_be6cb0488266a27981ef336bc64c1840, module_OpenSSL$SSL, sizeof(void *) );
    frame_be6cb0488266a27981ef336bc64c1840 = cache_frame_be6cb0488266a27981ef336bc64c1840;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_be6cb0488266a27981ef336bc64c1840 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_be6cb0488266a27981ef336bc64c1840 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_shutdown );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_be6cb0488266a27981ef336bc64c1840->m_frame.f_lineno = 2084;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2084;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be6cb0488266a27981ef336bc64c1840 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_be6cb0488266a27981ef336bc64c1840 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be6cb0488266a27981ef336bc64c1840 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_be6cb0488266a27981ef336bc64c1840, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_be6cb0488266a27981ef336bc64c1840->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_be6cb0488266a27981ef336bc64c1840, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_be6cb0488266a27981ef336bc64c1840,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_be6cb0488266a27981ef336bc64c1840 == cache_frame_be6cb0488266a27981ef336bc64c1840 )
    {
        Py_DECREF( frame_be6cb0488266a27981ef336bc64c1840 );
    }
    cache_frame_be6cb0488266a27981ef336bc64c1840 = NULL;

    assertFrameObject( frame_be6cb0488266a27981ef336bc64c1840 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_86_get_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_86_get_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_87_set_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_state = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_e718cae76ed96e3a285678549a1a9741;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e718cae76ed96e3a285678549a1a9741 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e718cae76ed96e3a285678549a1a9741, codeobj_e718cae76ed96e3a285678549a1a9741, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_e718cae76ed96e3a285678549a1a9741 = cache_frame_e718cae76ed96e3a285678549a1a9741;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e718cae76ed96e3a285678549a1a9741 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e718cae76ed96e3a285678549a1a9741 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_state );
        tmp_isinstance_inst_1 = par_state;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_types" );
            exception_tb = NULL;

            exception_lineno = 2093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2093;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_8cc305fc9d9a417a96ba57f2c87b94e9;
            frame_e718cae76ed96e3a285678549a1a9741->m_frame.f_lineno = 2094;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2094;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_shutdown );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_state );
        tmp_args_element_name_2 = par_state;
        frame_e718cae76ed96e3a285678549a1a9741->m_frame.f_lineno = 2096;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e718cae76ed96e3a285678549a1a9741 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e718cae76ed96e3a285678549a1a9741 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e718cae76ed96e3a285678549a1a9741, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e718cae76ed96e3a285678549a1a9741->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e718cae76ed96e3a285678549a1a9741, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e718cae76ed96e3a285678549a1a9741,
        type_description_1,
        par_self,
        par_state
    );


    // Release cached frame.
    if ( frame_e718cae76ed96e3a285678549a1a9741 == cache_frame_e718cae76ed96e3a285678549a1a9741 )
    {
        Py_DECREF( frame_e718cae76ed96e3a285678549a1a9741 );
    }
    cache_frame_e718cae76ed96e3a285678549a1a9741 = NULL;

    assertFrameObject( frame_e718cae76ed96e3a285678549a1a9741 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_87_set_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_state );
    Py_DECREF( par_state );
    par_state = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_state );
    Py_DECREF( par_state );
    par_state = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_87_set_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_88_get_state_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1b54bcdee7de522cee916ad54d2f1ede;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1b54bcdee7de522cee916ad54d2f1ede = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1b54bcdee7de522cee916ad54d2f1ede, codeobj_1b54bcdee7de522cee916ad54d2f1ede, module_OpenSSL$SSL, sizeof(void *) );
    frame_1b54bcdee7de522cee916ad54d2f1ede = cache_frame_1b54bcdee7de522cee916ad54d2f1ede;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1b54bcdee7de522cee916ad54d2f1ede );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1b54bcdee7de522cee916ad54d2f1ede ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_state_string_long );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1b54bcdee7de522cee916ad54d2f1ede->m_frame.f_lineno = 2105;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1b54bcdee7de522cee916ad54d2f1ede->m_frame.f_lineno = 2105;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2105;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b54bcdee7de522cee916ad54d2f1ede );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b54bcdee7de522cee916ad54d2f1ede );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1b54bcdee7de522cee916ad54d2f1ede );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1b54bcdee7de522cee916ad54d2f1ede, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1b54bcdee7de522cee916ad54d2f1ede->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1b54bcdee7de522cee916ad54d2f1ede, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1b54bcdee7de522cee916ad54d2f1ede,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1b54bcdee7de522cee916ad54d2f1ede == cache_frame_1b54bcdee7de522cee916ad54d2f1ede )
    {
        Py_DECREF( frame_1b54bcdee7de522cee916ad54d2f1ede );
    }
    cache_frame_1b54bcdee7de522cee916ad54d2f1ede = NULL;

    assertFrameObject( frame_1b54bcdee7de522cee916ad54d2f1ede );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_88_get_state_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_88_get_state_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_89_server_random( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    struct Nuitka_FrameObject *frame_f6837856edf570e4bd43a28f747a059d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f6837856edf570e4bd43a28f747a059d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f6837856edf570e4bd43a28f747a059d, codeobj_f6837856edf570e4bd43a28f747a059d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f6837856edf570e4bd43a28f747a059d = cache_frame_f6837856edf570e4bd43a28f747a059d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f6837856edf570e4bd43a28f747a059d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f6837856edf570e4bd43a28f747a059d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_session );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_f6837856edf570e4bd43a28f747a059d->m_frame.f_lineno = 2113;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_session == NULL );
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_session );
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2114;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2114;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2114;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_get_server_random );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = const_int_0;
        frame_f6837856edf570e4bd43a28f747a059d->m_frame.f_lineno = 2116;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2116;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_length == NULL );
        var_length = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_length );
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_operand_name_1 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2117;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2117;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF( tmp_raise_type_1 );
            exception_lineno = 2117;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 2118;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_5 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_6 = var_length;
        frame_f6837856edf570e4bd43a28f747a059d->m_frame.f_lineno = 2118;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2118;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_outp == NULL );
        var_outp = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_get_server_random );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__ssl );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_8 = var_outp;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_9 = var_length;
        frame_f6837856edf570e4bd43a28f747a059d->m_frame.f_lineno = 2119;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2119;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2120;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_7;
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_10 = var_outp;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_11 = var_length;
        frame_f6837856edf570e4bd43a28f747a059d->m_frame.f_lineno = 2120;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2120;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2120;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6837856edf570e4bd43a28f747a059d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6837856edf570e4bd43a28f747a059d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6837856edf570e4bd43a28f747a059d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f6837856edf570e4bd43a28f747a059d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f6837856edf570e4bd43a28f747a059d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f6837856edf570e4bd43a28f747a059d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f6837856edf570e4bd43a28f747a059d,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if ( frame_f6837856edf570e4bd43a28f747a059d == cache_frame_f6837856edf570e4bd43a28f747a059d )
    {
        Py_DECREF( frame_f6837856edf570e4bd43a28f747a059d );
    }
    cache_frame_f6837856edf570e4bd43a28f747a059d = NULL;

    assertFrameObject( frame_f6837856edf570e4bd43a28f747a059d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_89_server_random );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_89_server_random );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_90_client_random( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    struct Nuitka_FrameObject *frame_cad1093edb1e34fb4531b6283b02fe19;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cad1093edb1e34fb4531b6283b02fe19 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cad1093edb1e34fb4531b6283b02fe19, codeobj_cad1093edb1e34fb4531b6283b02fe19, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cad1093edb1e34fb4531b6283b02fe19 = cache_frame_cad1093edb1e34fb4531b6283b02fe19;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cad1093edb1e34fb4531b6283b02fe19 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cad1093edb1e34fb4531b6283b02fe19 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_session );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_cad1093edb1e34fb4531b6283b02fe19->m_frame.f_lineno = 2128;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2128;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_session == NULL );
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_session );
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_get_client_random );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__ssl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = const_int_0;
        frame_cad1093edb1e34fb4531b6283b02fe19->m_frame.f_lineno = 2132;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2132;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_length == NULL );
        var_length = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_length );
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_operand_name_1 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2133;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2133;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF( tmp_raise_type_1 );
            exception_lineno = 2133;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 2134;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_5 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_6 = var_length;
        frame_cad1093edb1e34fb4531b6283b02fe19->m_frame.f_lineno = 2134;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2134;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_outp == NULL );
        var_outp = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_get_client_random );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__ssl );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_8 = var_outp;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_9 = var_length;
        frame_cad1093edb1e34fb4531b6283b02fe19->m_frame.f_lineno = 2135;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2135;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_7;
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_10 = var_outp;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_11 = var_length;
        frame_cad1093edb1e34fb4531b6283b02fe19->m_frame.f_lineno = 2136;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2136;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cad1093edb1e34fb4531b6283b02fe19 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cad1093edb1e34fb4531b6283b02fe19 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cad1093edb1e34fb4531b6283b02fe19 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cad1093edb1e34fb4531b6283b02fe19, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cad1093edb1e34fb4531b6283b02fe19->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cad1093edb1e34fb4531b6283b02fe19, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cad1093edb1e34fb4531b6283b02fe19,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if ( frame_cad1093edb1e34fb4531b6283b02fe19 == cache_frame_cad1093edb1e34fb4531b6283b02fe19 )
    {
        Py_DECREF( frame_cad1093edb1e34fb4531b6283b02fe19 );
    }
    cache_frame_cad1093edb1e34fb4531b6283b02fe19 = NULL;

    assertFrameObject( frame_cad1093edb1e34fb4531b6283b02fe19 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_90_client_random );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_90_client_random );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_91_master_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_outp = NULL;
    PyObject *var_session = NULL;
    PyObject *var_length = NULL;
    struct Nuitka_FrameObject *frame_a928f1b20a0225cfbe69803a6f04e72f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_a928f1b20a0225cfbe69803a6f04e72f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a928f1b20a0225cfbe69803a6f04e72f, codeobj_a928f1b20a0225cfbe69803a6f04e72f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a928f1b20a0225cfbe69803a6f04e72f = cache_frame_a928f1b20a0225cfbe69803a6f04e72f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a928f1b20a0225cfbe69803a6f04e72f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a928f1b20a0225cfbe69803a6f04e72f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_session );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_a928f1b20a0225cfbe69803a6f04e72f->m_frame.f_lineno = 2144;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2144;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_session == NULL );
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_session );
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2145;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2145;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2145;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_SESSION_get_master_key );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_session );
        tmp_args_element_name_2 = var_session;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = const_int_0;
        frame_a928f1b20a0225cfbe69803a6f04e72f->m_frame.f_lineno = 2148;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2148;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_length == NULL );
        var_length = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( var_length );
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_operand_name_1 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2149;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF( tmp_raise_type_1 );
            exception_lineno = 2149;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 2150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_5 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_6 = var_length;
        frame_a928f1b20a0225cfbe69803a6f04e72f->m_frame.f_lineno = 2150;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2150;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_outp == NULL );
        var_outp = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2151;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_6;
        CHECK_OBJECT( var_session );
        tmp_args_element_name_7 = var_session;
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_8 = var_outp;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_9 = var_length;
        frame_a928f1b20a0225cfbe69803a6f04e72f->m_frame.f_lineno = 2151;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_SSL_SESSION_get_master_key, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2151;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_7;
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_10 = var_outp;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_11 = var_length;
        frame_a928f1b20a0225cfbe69803a6f04e72f->m_frame.f_lineno = 2152;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2152;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a928f1b20a0225cfbe69803a6f04e72f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a928f1b20a0225cfbe69803a6f04e72f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a928f1b20a0225cfbe69803a6f04e72f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a928f1b20a0225cfbe69803a6f04e72f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a928f1b20a0225cfbe69803a6f04e72f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a928f1b20a0225cfbe69803a6f04e72f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a928f1b20a0225cfbe69803a6f04e72f,
        type_description_1,
        par_self,
        var_outp,
        var_session,
        var_length
    );


    // Release cached frame.
    if ( frame_a928f1b20a0225cfbe69803a6f04e72f == cache_frame_a928f1b20a0225cfbe69803a6f04e72f )
    {
        Py_DECREF( frame_a928f1b20a0225cfbe69803a6f04e72f );
    }
    cache_frame_a928f1b20a0225cfbe69803a6f04e72f = NULL;

    assertFrameObject( frame_a928f1b20a0225cfbe69803a6f04e72f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_91_master_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_91_master_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_92_export_keying_material( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_label = python_pars[ 1 ];
    PyObject *par_olen = python_pars[ 2 ];
    PyObject *par_context = python_pars[ 3 ];
    PyObject *var_outp = NULL;
    PyObject *var_use_context = NULL;
    PyObject *var_success = NULL;
    PyObject *var_context_buf = NULL;
    PyObject *var_context_len = NULL;
    struct Nuitka_FrameObject *frame_53861ad8ddc3409044175f205fdf735e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_53861ad8ddc3409044175f205fdf735e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_53861ad8ddc3409044175f205fdf735e, codeobj_53861ad8ddc3409044175f205fdf735e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_53861ad8ddc3409044175f205fdf735e = cache_frame_53861ad8ddc3409044175f205fdf735e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_53861ad8ddc3409044175f205fdf735e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_53861ad8ddc3409044175f205fdf735e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 2163;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( par_olen );
        tmp_args_element_name_2 = par_olen;
        frame_53861ad8ddc3409044175f205fdf735e->m_frame.f_lineno = 2163;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2163;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_outp == NULL );
        var_outp = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2164;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2164;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_context_buf == NULL );
        var_context_buf = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = const_int_0;
        assert( var_context_len == NULL );
        Py_INCREF( tmp_assign_source_3 );
        var_context_len = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        tmp_assign_source_4 = const_int_0;
        assert( var_use_context == NULL );
        Py_INCREF( tmp_assign_source_4 );
        var_use_context = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_context );
        tmp_compexpr_left_1 = par_context;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT( par_context );
            tmp_assign_source_5 = par_context;
            {
                PyObject *old = var_context_buf;
                assert( old != NULL );
                var_context_buf = tmp_assign_source_5;
                Py_INCREF( var_context_buf );
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( par_context );
            tmp_len_arg_1 = par_context;
            tmp_assign_source_6 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2169;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_context_len;
                assert( old != NULL );
                var_context_len = tmp_assign_source_6;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = const_int_pos_1;
            {
                PyObject *old = var_use_context;
                assert( old != NULL );
                var_use_context = tmp_assign_source_7;
                Py_INCREF( var_use_context );
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_len_arg_2;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_export_keying_material );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_4 = var_outp;
        CHECK_OBJECT( par_olen );
        tmp_args_element_name_5 = par_olen;
        CHECK_OBJECT( par_label );
        tmp_args_element_name_6 = par_label;
        CHECK_OBJECT( par_label );
        tmp_len_arg_2 = par_label;
        tmp_args_element_name_7 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 2172;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_context_buf );
        tmp_args_element_name_8 = var_context_buf;
        CHECK_OBJECT( var_context_len );
        tmp_args_element_name_9 = var_context_len;
        CHECK_OBJECT( var_use_context );
        tmp_args_element_name_10 = var_use_context;
        frame_53861ad8ddc3409044175f205fdf735e->m_frame.f_lineno = 2171;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS8( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2171;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_success == NULL );
        var_success = tmp_assign_source_8;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2175;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT( var_success );
        tmp_compexpr_left_2 = var_success;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_11 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2175;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_53861ad8ddc3409044175f205fdf735e->m_frame.f_lineno = 2175;
        {
            PyObject *call_args[] = { tmp_args_element_name_11 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_11 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2175;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_args_element_name_13;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2176;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT( var_outp );
        tmp_args_element_name_12 = var_outp;
        CHECK_OBJECT( par_olen );
        tmp_args_element_name_13 = par_olen;
        frame_53861ad8ddc3409044175f205fdf735e->m_frame.f_lineno = 2176;
        {
            PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2176;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2176;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_53861ad8ddc3409044175f205fdf735e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_53861ad8ddc3409044175f205fdf735e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_53861ad8ddc3409044175f205fdf735e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_53861ad8ddc3409044175f205fdf735e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_53861ad8ddc3409044175f205fdf735e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_53861ad8ddc3409044175f205fdf735e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_53861ad8ddc3409044175f205fdf735e,
        type_description_1,
        par_self,
        par_label,
        par_olen,
        par_context,
        var_outp,
        var_use_context,
        var_success,
        var_context_buf,
        var_context_len
    );


    // Release cached frame.
    if ( frame_53861ad8ddc3409044175f205fdf735e == cache_frame_53861ad8ddc3409044175f205fdf735e )
    {
        Py_DECREF( frame_53861ad8ddc3409044175f205fdf735e );
    }
    cache_frame_53861ad8ddc3409044175f205fdf735e = NULL;

    assertFrameObject( frame_53861ad8ddc3409044175f205fdf735e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_92_export_keying_material );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_outp );
    Py_DECREF( var_outp );
    var_outp = NULL;

    CHECK_OBJECT( (PyObject *)var_use_context );
    Py_DECREF( var_use_context );
    var_use_context = NULL;

    CHECK_OBJECT( (PyObject *)var_success );
    Py_DECREF( var_success );
    var_success = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_label );
    Py_DECREF( par_label );
    par_label = NULL;

    CHECK_OBJECT( (PyObject *)var_context_buf );
    Py_DECREF( var_context_buf );
    var_context_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_context_len );
    Py_DECREF( var_context_len );
    var_context_len = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    CHECK_OBJECT( (PyObject *)par_olen );
    Py_DECREF( par_olen );
    par_olen = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_outp );
    var_outp = NULL;

    Py_XDECREF( var_use_context );
    var_use_context = NULL;

    Py_XDECREF( var_success );
    var_success = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_label );
    Py_DECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_context_buf );
    var_context_buf = NULL;

    Py_XDECREF( var_context_len );
    var_context_len = NULL;

    CHECK_OBJECT( (PyObject *)par_context );
    Py_DECREF( par_context );
    par_context = NULL;

    CHECK_OBJECT( (PyObject *)par_olen );
    Py_DECREF( par_olen );
    par_olen = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_92_export_keying_material );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_93_sock_shutdown( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_a10c241273a2cfd5b8ca6cac4d75c1bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a10c241273a2cfd5b8ca6cac4d75c1bf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a10c241273a2cfd5b8ca6cac4d75c1bf, codeobj_a10c241273a2cfd5b8ca6cac4d75c1bf, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a10c241273a2cfd5b8ca6cac4d75c1bf = cache_frame_a10c241273a2cfd5b8ca6cac4d75c1bf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a10c241273a2cfd5b8ca6cac4d75c1bf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a10c241273a2cfd5b8ca6cac4d75c1bf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__socket );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_shutdown );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2185;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a10c241273a2cfd5b8ca6cac4d75c1bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a10c241273a2cfd5b8ca6cac4d75c1bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a10c241273a2cfd5b8ca6cac4d75c1bf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a10c241273a2cfd5b8ca6cac4d75c1bf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a10c241273a2cfd5b8ca6cac4d75c1bf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a10c241273a2cfd5b8ca6cac4d75c1bf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a10c241273a2cfd5b8ca6cac4d75c1bf,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_a10c241273a2cfd5b8ca6cac4d75c1bf == cache_frame_a10c241273a2cfd5b8ca6cac4d75c1bf )
    {
        Py_DECREF( frame_a10c241273a2cfd5b8ca6cac4d75c1bf );
    }
    cache_frame_a10c241273a2cfd5b8ca6cac4d75c1bf = NULL;

    assertFrameObject( frame_a10c241273a2cfd5b8ca6cac4d75c1bf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_93_sock_shutdown );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_93_sock_shutdown );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_94_get_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_40161c7dc5bd3470776c2c8e35eca36d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_40161c7dc5bd3470776c2c8e35eca36d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40161c7dc5bd3470776c2c8e35eca36d, codeobj_40161c7dc5bd3470776c2c8e35eca36d, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_40161c7dc5bd3470776c2c8e35eca36d = cache_frame_40161c7dc5bd3470776c2c8e35eca36d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40161c7dc5bd3470776c2c8e35eca36d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40161c7dc5bd3470776c2c8e35eca36d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_certificate );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_40161c7dc5bd3470776c2c8e35eca36d->m_frame.f_lineno = 2193;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2193;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_cert == NULL );
        var_cert = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_cert );
        tmp_compexpr_left_1 = var_cert;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2194;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2194;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2194;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2195;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT( var_cert );
            tmp_args_element_name_2 = var_cert;
            frame_40161c7dc5bd3470776c2c8e35eca36d->m_frame.f_lineno = 2195;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_up_ref, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2195;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
                exception_tb = NULL;

                exception_lineno = 2196;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_4;
            CHECK_OBJECT( var_cert );
            tmp_args_element_name_3 = var_cert;
            frame_40161c7dc5bd3470776c2c8e35eca36d->m_frame.f_lineno = 2196;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__from_raw_x509_ptr, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2196;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40161c7dc5bd3470776c2c8e35eca36d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_40161c7dc5bd3470776c2c8e35eca36d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40161c7dc5bd3470776c2c8e35eca36d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40161c7dc5bd3470776c2c8e35eca36d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40161c7dc5bd3470776c2c8e35eca36d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40161c7dc5bd3470776c2c8e35eca36d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_40161c7dc5bd3470776c2c8e35eca36d,
        type_description_1,
        par_self,
        var_cert
    );


    // Release cached frame.
    if ( frame_40161c7dc5bd3470776c2c8e35eca36d == cache_frame_40161c7dc5bd3470776c2c8e35eca36d )
    {
        Py_DECREF( frame_40161c7dc5bd3470776c2c8e35eca36d );
    }
    cache_frame_40161c7dc5bd3470776c2c8e35eca36d = NULL;

    assertFrameObject( frame_40161c7dc5bd3470776c2c8e35eca36d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_94_get_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_94_get_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_95_get_peer_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_408236438062f833e577752ad530c24f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_408236438062f833e577752ad530c24f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_408236438062f833e577752ad530c24f, codeobj_408236438062f833e577752ad530c24f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_408236438062f833e577752ad530c24f = cache_frame_408236438062f833e577752ad530c24f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_408236438062f833e577752ad530c24f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_408236438062f833e577752ad530c24f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_peer_certificate );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_408236438062f833e577752ad530c24f->m_frame.f_lineno = 2205;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2205;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_cert == NULL );
        var_cert = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_cert );
        tmp_compexpr_left_1 = var_cert;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2206;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
                exception_tb = NULL;

                exception_lineno = 2207;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            CHECK_OBJECT( var_cert );
            tmp_args_element_name_2 = var_cert;
            frame_408236438062f833e577752ad530c24f->m_frame.f_lineno = 2207;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__from_raw_x509_ptr, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2207;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_408236438062f833e577752ad530c24f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_408236438062f833e577752ad530c24f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_408236438062f833e577752ad530c24f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_408236438062f833e577752ad530c24f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_408236438062f833e577752ad530c24f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_408236438062f833e577752ad530c24f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_408236438062f833e577752ad530c24f,
        type_description_1,
        par_self,
        var_cert
    );


    // Release cached frame.
    if ( frame_408236438062f833e577752ad530c24f == cache_frame_408236438062f833e577752ad530c24f )
    {
        Py_DECREF( frame_408236438062f833e577752ad530c24f );
    }
    cache_frame_408236438062f833e577752ad530c24f = NULL;

    assertFrameObject( frame_408236438062f833e577752ad530c24f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_95_get_peer_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_95_get_peer_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_96_get_peer_cert_chain( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_cert_stack = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_c825b51890ba6e544f0a67ddfa92ae8a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_c825b51890ba6e544f0a67ddfa92ae8a = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c825b51890ba6e544f0a67ddfa92ae8a, codeobj_c825b51890ba6e544f0a67ddfa92ae8a, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c825b51890ba6e544f0a67ddfa92ae8a = cache_frame_c825b51890ba6e544f0a67ddfa92ae8a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c825b51890ba6e544f0a67ddfa92ae8a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c825b51890ba6e544f0a67ddfa92ae8a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_peer_cert_chain );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_c825b51890ba6e544f0a67ddfa92ae8a->m_frame.f_lineno = 2217;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2217;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_cert_stack == NULL );
        var_cert_stack = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_cert_stack );
        tmp_compexpr_left_1 = var_cert_stack;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2218;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2218;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2218;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New( 0 );
        assert( var_result == NULL );
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_cert_stack );
        tmp_args_element_name_2 = var_cert_stack;
        frame_c825b51890ba6e544f0a67ddfa92ae8a->m_frame.f_lineno = 2222;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_num, call_args );
        }

        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2222;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooo";
                exception_lineno = 2222;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_dup );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT( var_cert_stack );
        tmp_args_element_name_4 = var_cert_stack;
        CHECK_OBJECT( var_i );
        tmp_args_element_name_5 = var_i;
        frame_c825b51890ba6e544f0a67ddfa92ae8a->m_frame.f_lineno = 2224;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_value, call_args );
        }

        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        frame_c825b51890ba6e544f0a67ddfa92ae8a->m_frame.f_lineno = 2224;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2224;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_cert;
            var_cert = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 2225;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        CHECK_OBJECT( var_cert );
        tmp_args_element_name_6 = var_cert;
        frame_c825b51890ba6e544f0a67ddfa92ae8a->m_frame.f_lineno = 2225;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__from_raw_x509_ptr, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2225;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_pycert;
            var_pycert = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        CHECK_OBJECT( var_result );
        tmp_called_instance_4 = var_result;
        CHECK_OBJECT( var_pycert );
        tmp_args_element_name_7 = var_pycert;
        frame_c825b51890ba6e544f0a67ddfa92ae8a->m_frame.f_lineno = 2226;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2226;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2222;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c825b51890ba6e544f0a67ddfa92ae8a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c825b51890ba6e544f0a67ddfa92ae8a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c825b51890ba6e544f0a67ddfa92ae8a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c825b51890ba6e544f0a67ddfa92ae8a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c825b51890ba6e544f0a67ddfa92ae8a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c825b51890ba6e544f0a67ddfa92ae8a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c825b51890ba6e544f0a67ddfa92ae8a,
        type_description_1,
        par_self,
        var_i,
        var_cert_stack,
        var_pycert,
        var_cert,
        var_result
    );


    // Release cached frame.
    if ( frame_c825b51890ba6e544f0a67ddfa92ae8a == cache_frame_c825b51890ba6e544f0a67ddfa92ae8a )
    {
        Py_DECREF( frame_c825b51890ba6e544f0a67ddfa92ae8a );
    }
    cache_frame_c825b51890ba6e544f0a67ddfa92ae8a = NULL;

    assertFrameObject( frame_c825b51890ba6e544f0a67ddfa92ae8a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_96_get_peer_cert_chain );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)var_cert_stack );
    Py_DECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_cert_stack );
    var_cert_stack = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_96_get_peer_cert_chain );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_97_want_read( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_952cfd5b63ecd1dd4f987c147c539d39;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_952cfd5b63ecd1dd4f987c147c539d39 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_952cfd5b63ecd1dd4f987c147c539d39, codeobj_952cfd5b63ecd1dd4f987c147c539d39, module_OpenSSL$SSL, sizeof(void *) );
    frame_952cfd5b63ecd1dd4f987c147c539d39 = cache_frame_952cfd5b63ecd1dd4f987c147c539d39;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_952cfd5b63ecd1dd4f987c147c539d39 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_952cfd5b63ecd1dd4f987c147c539d39 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_want_read );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_952cfd5b63ecd1dd4f987c147c539d39->m_frame.f_lineno = 2236;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_952cfd5b63ecd1dd4f987c147c539d39 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_952cfd5b63ecd1dd4f987c147c539d39 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_952cfd5b63ecd1dd4f987c147c539d39 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_952cfd5b63ecd1dd4f987c147c539d39, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_952cfd5b63ecd1dd4f987c147c539d39->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_952cfd5b63ecd1dd4f987c147c539d39, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_952cfd5b63ecd1dd4f987c147c539d39,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_952cfd5b63ecd1dd4f987c147c539d39 == cache_frame_952cfd5b63ecd1dd4f987c147c539d39 )
    {
        Py_DECREF( frame_952cfd5b63ecd1dd4f987c147c539d39 );
    }
    cache_frame_952cfd5b63ecd1dd4f987c147c539d39 = NULL;

    assertFrameObject( frame_952cfd5b63ecd1dd4f987c147c539d39 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_97_want_read );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_97_want_read );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_98_want_write( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_4f2247f2b870626a6f520ab00ca5767f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4f2247f2b870626a6f520ab00ca5767f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4f2247f2b870626a6f520ab00ca5767f, codeobj_4f2247f2b870626a6f520ab00ca5767f, module_OpenSSL$SSL, sizeof(void *) );
    frame_4f2247f2b870626a6f520ab00ca5767f = cache_frame_4f2247f2b870626a6f520ab00ca5767f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4f2247f2b870626a6f520ab00ca5767f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4f2247f2b870626a6f520ab00ca5767f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_want_write );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_4f2247f2b870626a6f520ab00ca5767f->m_frame.f_lineno = 2245;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2245;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4f2247f2b870626a6f520ab00ca5767f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4f2247f2b870626a6f520ab00ca5767f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4f2247f2b870626a6f520ab00ca5767f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4f2247f2b870626a6f520ab00ca5767f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4f2247f2b870626a6f520ab00ca5767f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4f2247f2b870626a6f520ab00ca5767f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f2247f2b870626a6f520ab00ca5767f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_4f2247f2b870626a6f520ab00ca5767f == cache_frame_4f2247f2b870626a6f520ab00ca5767f )
    {
        Py_DECREF( frame_4f2247f2b870626a6f520ab00ca5767f );
    }
    cache_frame_4f2247f2b870626a6f520ab00ca5767f = NULL;

    assertFrameObject( frame_4f2247f2b870626a6f520ab00ca5767f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_98_want_write );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_98_want_write );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_99_set_accept_state( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_04f440036e2b2c35459569a981c6b41b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_04f440036e2b2c35459569a981c6b41b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_04f440036e2b2c35459569a981c6b41b, codeobj_04f440036e2b2c35459569a981c6b41b, module_OpenSSL$SSL, sizeof(void *) );
    frame_04f440036e2b2c35459569a981c6b41b = cache_frame_04f440036e2b2c35459569a981c6b41b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_04f440036e2b2c35459569a981c6b41b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_04f440036e2b2c35459569a981c6b41b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_accept_state );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_04f440036e2b2c35459569a981c6b41b->m_frame.f_lineno = 2254;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2254;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04f440036e2b2c35459569a981c6b41b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04f440036e2b2c35459569a981c6b41b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_04f440036e2b2c35459569a981c6b41b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_04f440036e2b2c35459569a981c6b41b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_04f440036e2b2c35459569a981c6b41b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_04f440036e2b2c35459569a981c6b41b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_04f440036e2b2c35459569a981c6b41b == cache_frame_04f440036e2b2c35459569a981c6b41b )
    {
        Py_DECREF( frame_04f440036e2b2c35459569a981c6b41b );
    }
    cache_frame_04f440036e2b2c35459569a981c6b41b = NULL;

    assertFrameObject( frame_04f440036e2b2c35459569a981c6b41b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_99_set_accept_state );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_99_set_accept_state );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_100_set_connect_state( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_79fd12729a50896c6b068d07adf12958;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_79fd12729a50896c6b068d07adf12958 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_79fd12729a50896c6b068d07adf12958, codeobj_79fd12729a50896c6b068d07adf12958, module_OpenSSL$SSL, sizeof(void *) );
    frame_79fd12729a50896c6b068d07adf12958 = cache_frame_79fd12729a50896c6b068d07adf12958;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_79fd12729a50896c6b068d07adf12958 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_79fd12729a50896c6b068d07adf12958 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_connect_state );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_79fd12729a50896c6b068d07adf12958->m_frame.f_lineno = 2263;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2263;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_79fd12729a50896c6b068d07adf12958 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_79fd12729a50896c6b068d07adf12958 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_79fd12729a50896c6b068d07adf12958, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_79fd12729a50896c6b068d07adf12958->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_79fd12729a50896c6b068d07adf12958, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_79fd12729a50896c6b068d07adf12958,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_79fd12729a50896c6b068d07adf12958 == cache_frame_79fd12729a50896c6b068d07adf12958 )
    {
        Py_DECREF( frame_79fd12729a50896c6b068d07adf12958 );
    }
    cache_frame_79fd12729a50896c6b068d07adf12958 = NULL;

    assertFrameObject( frame_79fd12729a50896c6b068d07adf12958 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_100_set_connect_state );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_100_set_connect_state );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_101_get_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_session = NULL;
    PyObject *var_pysession = NULL;
    struct Nuitka_FrameObject *frame_279a26537d72f5f735cb2f57754efcf5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_279a26537d72f5f735cb2f57754efcf5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_279a26537d72f5f735cb2f57754efcf5, codeobj_279a26537d72f5f735cb2f57754efcf5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_279a26537d72f5f735cb2f57754efcf5 = cache_frame_279a26537d72f5f735cb2f57754efcf5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_279a26537d72f5f735cb2f57754efcf5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_279a26537d72f5f735cb2f57754efcf5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get1_session );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_279a26537d72f5f735cb2f57754efcf5->m_frame.f_lineno = 2274;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_session == NULL );
        var_session = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_session );
        tmp_compexpr_left_1 = var_session;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Session );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Session" );
            exception_tb = NULL;

            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___new__ );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Session );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Session" );
            exception_tb = NULL;

            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_4;
        frame_279a26537d72f5f735cb2f57754efcf5->m_frame.f_lineno = 2278;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2278;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_pysession == NULL );
        var_pysession = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_gc );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_session );
        tmp_args_element_name_3 = var_session;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSL_SESSION_free );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_279a26537d72f5f735cb2f57754efcf5->m_frame.f_lineno = 2279;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pysession );
        tmp_assattr_target_1 = var_pysession;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__session, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2279;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_279a26537d72f5f735cb2f57754efcf5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_279a26537d72f5f735cb2f57754efcf5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_279a26537d72f5f735cb2f57754efcf5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_279a26537d72f5f735cb2f57754efcf5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_279a26537d72f5f735cb2f57754efcf5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_279a26537d72f5f735cb2f57754efcf5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_279a26537d72f5f735cb2f57754efcf5,
        type_description_1,
        par_self,
        var_session,
        var_pysession
    );


    // Release cached frame.
    if ( frame_279a26537d72f5f735cb2f57754efcf5 == cache_frame_279a26537d72f5f735cb2f57754efcf5 )
    {
        Py_DECREF( frame_279a26537d72f5f735cb2f57754efcf5 );
    }
    cache_frame_279a26537d72f5f735cb2f57754efcf5 = NULL;

    assertFrameObject( frame_279a26537d72f5f735cb2f57754efcf5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pysession );
    tmp_return_value = var_pysession;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_101_get_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_session );
    Py_DECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_pysession );
    var_pysession = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_pysession );
    var_pysession = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_101_get_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_102_set_session( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_session = python_pars[ 1 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_276464dd595899f2dceb721f57191727;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_276464dd595899f2dceb721f57191727 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_276464dd595899f2dceb721f57191727, codeobj_276464dd595899f2dceb721f57191727, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_276464dd595899f2dceb721f57191727 = cache_frame_276464dd595899f2dceb721f57191727;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_276464dd595899f2dceb721f57191727 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_276464dd595899f2dceb721f57191727 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_session );
        tmp_isinstance_inst_1 = par_session;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Session );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Session" );
            exception_tb = NULL;

            exception_lineno = 2291;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2291;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2291;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d5ded94dafea47ce6f2b4fa579755177;
            frame_276464dd595899f2dceb721f57191727->m_frame.f_lineno = 2292;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2292;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_session );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_session );
        tmp_source_name_3 = par_session;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__session );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_276464dd595899f2dceb721f57191727->m_frame.f_lineno = 2294;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2294;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_result );
        tmp_operand_name_2 = var_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2295;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2296;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_276464dd595899f2dceb721f57191727->m_frame.f_lineno = 2296;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2296;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_276464dd595899f2dceb721f57191727 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_276464dd595899f2dceb721f57191727 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_276464dd595899f2dceb721f57191727, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_276464dd595899f2dceb721f57191727->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_276464dd595899f2dceb721f57191727, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_276464dd595899f2dceb721f57191727,
        type_description_1,
        par_self,
        par_session,
        var_result
    );


    // Release cached frame.
    if ( frame_276464dd595899f2dceb721f57191727 == cache_frame_276464dd595899f2dceb721f57191727 )
    {
        Py_DECREF( frame_276464dd595899f2dceb721f57191727 );
    }
    cache_frame_276464dd595899f2dceb721f57191727 = NULL;

    assertFrameObject( frame_276464dd595899f2dceb721f57191727 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_102_set_session );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_102_set_session );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_103__get_finished_message( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_function = python_pars[ 1 ];
    PyObject *var_buf = NULL;
    PyObject *var_empty = NULL;
    PyObject *var_size = NULL;
    struct Nuitka_FrameObject *frame_24fd8871d29e3f8af568578862db4e2f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_24fd8871d29e3f8af568578862db4e2f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_24fd8871d29e3f8af568578862db4e2f, codeobj_24fd8871d29e3f8af568578862db4e2f, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_24fd8871d29e3f8af568578862db4e2f = cache_frame_24fd8871d29e3f8af568578862db4e2f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_24fd8871d29e3f8af568578862db4e2f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_24fd8871d29e3f8af568578862db4e2f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2322;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_24fd8871d29e3f8af568578862db4e2f->m_frame.f_lineno = 2322;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_0_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2322;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_empty == NULL );
        var_empty = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_function );
        tmp_called_name_1 = par_function;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2323;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_empty );
        tmp_args_element_name_2 = var_empty;
        tmp_args_element_name_3 = const_int_0;
        frame_24fd8871d29e3f8af568578862db4e2f->m_frame.f_lineno = 2323;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2323;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_size == NULL );
        var_size = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_size );
        tmp_compexpr_left_1 = var_size;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2324;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__no_zero_allocator );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_no_zero_allocator" );
            exception_tb = NULL;

            exception_lineno = 2328;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        tmp_args_element_name_4 = const_str_digest_c561652c58984ec0e9541542aa405594;
        CHECK_OBJECT( var_size );
        tmp_args_element_name_5 = var_size;
        frame_24fd8871d29e3f8af568578862db4e2f->m_frame.f_lineno = 2328;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2328;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_buf == NULL );
        var_buf = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        CHECK_OBJECT( par_function );
        tmp_called_name_3 = par_function;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2329;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_buf );
        tmp_args_element_name_7 = var_buf;
        CHECK_OBJECT( var_size );
        tmp_args_element_name_8 = var_size;
        frame_24fd8871d29e3f8af568578862db4e2f->m_frame.f_lineno = 2329;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2329;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2330;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_buf );
        tmp_args_element_name_9 = var_buf;
        CHECK_OBJECT( var_size );
        tmp_args_element_name_10 = var_size;
        frame_24fd8871d29e3f8af568578862db4e2f->m_frame.f_lineno = 2330;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2330;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2330;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24fd8871d29e3f8af568578862db4e2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_24fd8871d29e3f8af568578862db4e2f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24fd8871d29e3f8af568578862db4e2f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_24fd8871d29e3f8af568578862db4e2f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_24fd8871d29e3f8af568578862db4e2f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_24fd8871d29e3f8af568578862db4e2f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_24fd8871d29e3f8af568578862db4e2f,
        type_description_1,
        par_self,
        par_function,
        var_buf,
        var_empty,
        var_size
    );


    // Release cached frame.
    if ( frame_24fd8871d29e3f8af568578862db4e2f == cache_frame_24fd8871d29e3f8af568578862db4e2f )
    {
        Py_DECREF( frame_24fd8871d29e3f8af568578862db4e2f );
    }
    cache_frame_24fd8871d29e3f8af568578862db4e2f = NULL;

    assertFrameObject( frame_24fd8871d29e3f8af568578862db4e2f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_103__get_finished_message );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_function );
    Py_DECREF( par_function );
    par_function = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    CHECK_OBJECT( (PyObject *)var_empty );
    Py_DECREF( var_empty );
    var_empty = NULL;

    CHECK_OBJECT( (PyObject *)var_size );
    Py_DECREF( var_size );
    var_size = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_function );
    Py_DECREF( par_function );
    par_function = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_buf );
    var_buf = NULL;

    Py_XDECREF( var_empty );
    var_empty = NULL;

    Py_XDECREF( var_size );
    var_size = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_103__get_finished_message );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_104_get_finished( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_47d32c13661b74e6d0131e9414f24fc2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_47d32c13661b74e6d0131e9414f24fc2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_47d32c13661b74e6d0131e9414f24fc2, codeobj_47d32c13661b74e6d0131e9414f24fc2, module_OpenSSL$SSL, sizeof(void *) );
    frame_47d32c13661b74e6d0131e9414f24fc2 = cache_frame_47d32c13661b74e6d0131e9414f24fc2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_47d32c13661b74e6d0131e9414f24fc2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_47d32c13661b74e6d0131e9414f24fc2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_finished_message );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_get_finished );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_47d32c13661b74e6d0131e9414f24fc2->m_frame.f_lineno = 2342;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2342;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47d32c13661b74e6d0131e9414f24fc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_47d32c13661b74e6d0131e9414f24fc2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47d32c13661b74e6d0131e9414f24fc2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_47d32c13661b74e6d0131e9414f24fc2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_47d32c13661b74e6d0131e9414f24fc2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_47d32c13661b74e6d0131e9414f24fc2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_47d32c13661b74e6d0131e9414f24fc2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_47d32c13661b74e6d0131e9414f24fc2 == cache_frame_47d32c13661b74e6d0131e9414f24fc2 )
    {
        Py_DECREF( frame_47d32c13661b74e6d0131e9414f24fc2 );
    }
    cache_frame_47d32c13661b74e6d0131e9414f24fc2 = NULL;

    assertFrameObject( frame_47d32c13661b74e6d0131e9414f24fc2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_104_get_finished );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_104_get_finished );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_105_get_peer_finished( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_424167e2ffaae8f272268d954605a539;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_424167e2ffaae8f272268d954605a539 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_424167e2ffaae8f272268d954605a539, codeobj_424167e2ffaae8f272268d954605a539, module_OpenSSL$SSL, sizeof(void *) );
    frame_424167e2ffaae8f272268d954605a539 = cache_frame_424167e2ffaae8f272268d954605a539;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_424167e2ffaae8f272268d954605a539 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_424167e2ffaae8f272268d954605a539 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_finished_message );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_get_peer_finished );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_424167e2ffaae8f272268d954605a539->m_frame.f_lineno = 2354;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2354;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_424167e2ffaae8f272268d954605a539 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_424167e2ffaae8f272268d954605a539 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_424167e2ffaae8f272268d954605a539 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_424167e2ffaae8f272268d954605a539, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_424167e2ffaae8f272268d954605a539->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_424167e2ffaae8f272268d954605a539, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_424167e2ffaae8f272268d954605a539,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_424167e2ffaae8f272268d954605a539 == cache_frame_424167e2ffaae8f272268d954605a539 )
    {
        Py_DECREF( frame_424167e2ffaae8f272268d954605a539 );
    }
    cache_frame_424167e2ffaae8f272268d954605a539 = NULL;

    assertFrameObject( frame_424167e2ffaae8f272268d954605a539 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_105_get_peer_finished );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_105_get_peer_finished );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_106_get_cipher_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cipher = NULL;
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_3f4dd1ce7e70d48a2f48706b38cf746b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3f4dd1ce7e70d48a2f48706b38cf746b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3f4dd1ce7e70d48a2f48706b38cf746b, codeobj_3f4dd1ce7e70d48a2f48706b38cf746b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3f4dd1ce7e70d48a2f48706b38cf746b = cache_frame_3f4dd1ce7e70d48a2f48706b38cf746b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3f4dd1ce7e70d48a2f48706b38cf746b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3f4dd1ce7e70d48a2f48706b38cf746b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_current_cipher );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3f4dd1ce7e70d48a2f48706b38cf746b->m_frame.f_lineno = 2366;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_cipher == NULL );
        var_cipher = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_cipher );
        tmp_compexpr_left_1 = var_cipher;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2367;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2367;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2367;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_string );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_4;
            CHECK_OBJECT( var_cipher );
            tmp_args_element_name_3 = var_cipher;
            frame_3f4dd1ce7e70d48a2f48706b38cf746b->m_frame.f_lineno = 2370;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSL_CIPHER_get_name, call_args );
            }

            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_3f4dd1ce7e70d48a2f48706b38cf746b->m_frame.f_lineno = 2370;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2370;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( var_name == NULL );
            var_name = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_instance_2;
            CHECK_OBJECT( var_name );
            tmp_called_instance_2 = var_name;
            frame_3f4dd1ce7e70d48a2f48706b38cf746b->m_frame.f_lineno = 2371;
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2371;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f4dd1ce7e70d48a2f48706b38cf746b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f4dd1ce7e70d48a2f48706b38cf746b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f4dd1ce7e70d48a2f48706b38cf746b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3f4dd1ce7e70d48a2f48706b38cf746b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3f4dd1ce7e70d48a2f48706b38cf746b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3f4dd1ce7e70d48a2f48706b38cf746b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3f4dd1ce7e70d48a2f48706b38cf746b,
        type_description_1,
        par_self,
        var_cipher,
        var_name
    );


    // Release cached frame.
    if ( frame_3f4dd1ce7e70d48a2f48706b38cf746b == cache_frame_3f4dd1ce7e70d48a2f48706b38cf746b )
    {
        Py_DECREF( frame_3f4dd1ce7e70d48a2f48706b38cf746b );
    }
    cache_frame_3f4dd1ce7e70d48a2f48706b38cf746b = NULL;

    assertFrameObject( frame_3f4dd1ce7e70d48a2f48706b38cf746b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_106_get_cipher_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher );
    Py_DECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_106_get_cipher_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_107_get_cipher_bits( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cipher = NULL;
    struct Nuitka_FrameObject *frame_5bc5fbaf9e45b62d2dbba7be971ca669;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5bc5fbaf9e45b62d2dbba7be971ca669 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5bc5fbaf9e45b62d2dbba7be971ca669, codeobj_5bc5fbaf9e45b62d2dbba7be971ca669, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_5bc5fbaf9e45b62d2dbba7be971ca669 = cache_frame_5bc5fbaf9e45b62d2dbba7be971ca669;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5bc5fbaf9e45b62d2dbba7be971ca669 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5bc5fbaf9e45b62d2dbba7be971ca669 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_current_cipher );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_5bc5fbaf9e45b62d2dbba7be971ca669->m_frame.f_lineno = 2383;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2383;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_cipher == NULL );
        var_cipher = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_cipher );
        tmp_compexpr_left_1 = var_cipher;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2384;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2384;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2384;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSL_CIPHER_get_bits );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_cipher );
            tmp_args_element_name_2 = var_cipher;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_4 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_4;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_5bc5fbaf9e45b62d2dbba7be971ca669->m_frame.f_lineno = 2387;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2387;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5bc5fbaf9e45b62d2dbba7be971ca669 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5bc5fbaf9e45b62d2dbba7be971ca669 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5bc5fbaf9e45b62d2dbba7be971ca669 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5bc5fbaf9e45b62d2dbba7be971ca669, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5bc5fbaf9e45b62d2dbba7be971ca669->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5bc5fbaf9e45b62d2dbba7be971ca669, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5bc5fbaf9e45b62d2dbba7be971ca669,
        type_description_1,
        par_self,
        var_cipher
    );


    // Release cached frame.
    if ( frame_5bc5fbaf9e45b62d2dbba7be971ca669 == cache_frame_5bc5fbaf9e45b62d2dbba7be971ca669 )
    {
        Py_DECREF( frame_5bc5fbaf9e45b62d2dbba7be971ca669 );
    }
    cache_frame_5bc5fbaf9e45b62d2dbba7be971ca669 = NULL;

    assertFrameObject( frame_5bc5fbaf9e45b62d2dbba7be971ca669 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_107_get_cipher_bits );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher );
    Py_DECREF( var_cipher );
    var_cipher = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cipher );
    var_cipher = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_107_get_cipher_bits );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_108_get_cipher_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_cipher = NULL;
    PyObject *var_version = NULL;
    struct Nuitka_FrameObject *frame_81e335f349b11a09b01d6602680546e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_81e335f349b11a09b01d6602680546e3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81e335f349b11a09b01d6602680546e3, codeobj_81e335f349b11a09b01d6602680546e3, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_81e335f349b11a09b01d6602680546e3 = cache_frame_81e335f349b11a09b01d6602680546e3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81e335f349b11a09b01d6602680546e3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81e335f349b11a09b01d6602680546e3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get_current_cipher );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_81e335f349b11a09b01d6602680546e3->m_frame.f_lineno = 2399;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2399;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_cipher == NULL );
        var_cipher = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( var_cipher );
        tmp_compexpr_left_1 = var_cipher;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_string );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_4;
            CHECK_OBJECT( var_cipher );
            tmp_args_element_name_3 = var_cipher;
            frame_81e335f349b11a09b01d6602680546e3->m_frame.f_lineno = 2403;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_SSL_CIPHER_get_version, call_args );
            }

            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_81e335f349b11a09b01d6602680546e3->m_frame.f_lineno = 2403;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2403;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( var_version == NULL );
            var_version = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_instance_2;
            CHECK_OBJECT( var_version );
            tmp_called_instance_2 = var_version;
            frame_81e335f349b11a09b01d6602680546e3->m_frame.f_lineno = 2404;
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2404;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81e335f349b11a09b01d6602680546e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_81e335f349b11a09b01d6602680546e3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81e335f349b11a09b01d6602680546e3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81e335f349b11a09b01d6602680546e3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81e335f349b11a09b01d6602680546e3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81e335f349b11a09b01d6602680546e3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_81e335f349b11a09b01d6602680546e3,
        type_description_1,
        par_self,
        var_cipher,
        var_version
    );


    // Release cached frame.
    if ( frame_81e335f349b11a09b01d6602680546e3 == cache_frame_81e335f349b11a09b01d6602680546e3 )
    {
        Py_DECREF( frame_81e335f349b11a09b01d6602680546e3 );
    }
    cache_frame_81e335f349b11a09b01d6602680546e3 = NULL;

    assertFrameObject( frame_81e335f349b11a09b01d6602680546e3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_108_get_cipher_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher );
    Py_DECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_version );
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cipher );
    var_cipher = NULL;

    Py_XDECREF( var_version );
    var_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_108_get_cipher_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_109_get_protocol_version_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_version = NULL;
    struct Nuitka_FrameObject *frame_b96d6d845ac2b66cff0a22f12fd41c93;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b96d6d845ac2b66cff0a22f12fd41c93 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b96d6d845ac2b66cff0a22f12fd41c93, codeobj_b96d6d845ac2b66cff0a22f12fd41c93, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_b96d6d845ac2b66cff0a22f12fd41c93 = cache_frame_b96d6d845ac2b66cff0a22f12fd41c93;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b96d6d845ac2b66cff0a22f12fd41c93 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b96d6d845ac2b66cff0a22f12fd41c93 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_get_version );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__ssl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b96d6d845ac2b66cff0a22f12fd41c93->m_frame.f_lineno = 2415;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b96d6d845ac2b66cff0a22f12fd41c93->m_frame.f_lineno = 2415;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2415;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_version == NULL );
        var_version = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( var_version );
        tmp_called_instance_1 = var_version;
        frame_b96d6d845ac2b66cff0a22f12fd41c93->m_frame.f_lineno = 2416;
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2416;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b96d6d845ac2b66cff0a22f12fd41c93 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b96d6d845ac2b66cff0a22f12fd41c93 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b96d6d845ac2b66cff0a22f12fd41c93 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b96d6d845ac2b66cff0a22f12fd41c93, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b96d6d845ac2b66cff0a22f12fd41c93->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b96d6d845ac2b66cff0a22f12fd41c93, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b96d6d845ac2b66cff0a22f12fd41c93,
        type_description_1,
        par_self,
        var_version
    );


    // Release cached frame.
    if ( frame_b96d6d845ac2b66cff0a22f12fd41c93 == cache_frame_b96d6d845ac2b66cff0a22f12fd41c93 )
    {
        Py_DECREF( frame_b96d6d845ac2b66cff0a22f12fd41c93 );
    }
    cache_frame_b96d6d845ac2b66cff0a22f12fd41c93 = NULL;

    assertFrameObject( frame_b96d6d845ac2b66cff0a22f12fd41c93 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_109_get_protocol_version_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_version );
    Py_DECREF( var_version );
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_version );
    var_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_109_get_protocol_version_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_110_get_protocol_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_version = NULL;
    struct Nuitka_FrameObject *frame_eb42686584dbda55dff0f68021ee3d63;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_eb42686584dbda55dff0f68021ee3d63 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eb42686584dbda55dff0f68021ee3d63, codeobj_eb42686584dbda55dff0f68021ee3d63, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_eb42686584dbda55dff0f68021ee3d63 = cache_frame_eb42686584dbda55dff0f68021ee3d63;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eb42686584dbda55dff0f68021ee3d63 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eb42686584dbda55dff0f68021ee3d63 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_version );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_eb42686584dbda55dff0f68021ee3d63->m_frame.f_lineno = 2426;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_version == NULL );
        var_version = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eb42686584dbda55dff0f68021ee3d63 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eb42686584dbda55dff0f68021ee3d63 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eb42686584dbda55dff0f68021ee3d63, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eb42686584dbda55dff0f68021ee3d63->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eb42686584dbda55dff0f68021ee3d63, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eb42686584dbda55dff0f68021ee3d63,
        type_description_1,
        par_self,
        var_version
    );


    // Release cached frame.
    if ( frame_eb42686584dbda55dff0f68021ee3d63 == cache_frame_eb42686584dbda55dff0f68021ee3d63 )
    {
        Py_DECREF( frame_eb42686584dbda55dff0f68021ee3d63 );
    }
    cache_frame_eb42686584dbda55dff0f68021ee3d63 = NULL;

    assertFrameObject( frame_eb42686584dbda55dff0f68021ee3d63 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_version );
    tmp_return_value = var_version;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_110_get_protocol_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_version );
    Py_DECREF( var_version );
    var_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_110_get_protocol_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_111_get_next_proto_negotiated( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_data_len = NULL;
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_d929b359a62116e3db27379ddc74f6e5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d929b359a62116e3db27379ddc74f6e5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d929b359a62116e3db27379ddc74f6e5, codeobj_d929b359a62116e3db27379ddc74f6e5, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d929b359a62116e3db27379ddc74f6e5 = cache_frame_d929b359a62116e3db27379ddc74f6e5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d929b359a62116e3db27379ddc74f6e5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d929b359a62116e3db27379ddc74f6e5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2439;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_d929b359a62116e3db27379ddc74f6e5->m_frame.f_lineno = 2439;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2439;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_data == NULL );
        var_data = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2440;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_d929b359a62116e3db27379ddc74f6e5->m_frame.f_lineno = 2440;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0 ) );

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2440;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_data_len == NULL );
        var_data_len = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get0_next_proto_negotiated );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_data );
        tmp_args_element_name_2 = var_data;
        CHECK_OBJECT( var_data_len );
        tmp_args_element_name_3 = var_data_len;
        frame_d929b359a62116e3db27379ddc74f6e5->m_frame.f_lineno = 2442;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2442;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_buffer );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_data );
        tmp_subscribed_name_1 = var_data;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_data_len );
        tmp_subscribed_name_2 = var_data_len;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_4 );

            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d929b359a62116e3db27379ddc74f6e5->m_frame.f_lineno = 2444;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2444;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d929b359a62116e3db27379ddc74f6e5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d929b359a62116e3db27379ddc74f6e5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d929b359a62116e3db27379ddc74f6e5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d929b359a62116e3db27379ddc74f6e5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d929b359a62116e3db27379ddc74f6e5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d929b359a62116e3db27379ddc74f6e5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d929b359a62116e3db27379ddc74f6e5,
        type_description_1,
        par_self,
        var_data_len,
        var_data
    );


    // Release cached frame.
    if ( frame_d929b359a62116e3db27379ddc74f6e5 == cache_frame_d929b359a62116e3db27379ddc74f6e5 )
    {
        Py_DECREF( frame_d929b359a62116e3db27379ddc74f6e5 );
    }
    cache_frame_d929b359a62116e3db27379ddc74f6e5 = NULL;

    assertFrameObject( frame_d929b359a62116e3db27379ddc74f6e5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_111_get_next_proto_negotiated );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_data_len );
    Py_DECREF( var_data_len );
    var_data_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_data );
    Py_DECREF( var_data );
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_data_len );
    var_data_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_111_get_next_proto_negotiated );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_112_set_alpn_protos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_protos = python_pars[ 1 ];
    PyObject *var_protostr = NULL;
    PyObject *var_input_str = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_92150b73fda83014548edff967541a31;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_92150b73fda83014548edff967541a31 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_92150b73fda83014548edff967541a31, codeobj_92150b73fda83014548edff967541a31, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_92150b73fda83014548edff967541a31 = cache_frame_92150b73fda83014548edff967541a31;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_92150b73fda83014548edff967541a31 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_92150b73fda83014548edff967541a31 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        tmp_source_name_1 = const_str_empty;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
        assert( !(tmp_called_name_1 == NULL) );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_chain );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "chain" );
            exception_tb = NULL;

            exception_lineno = 2460;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_from_iterable );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2460;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_protos );
            tmp_iter_arg_1 = par_protos;
            tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2460;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_args_element_name_2 = OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_2)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_112_set_alpn_protos );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_112_set_alpn_protos );
        return NULL;
        outline_result_1:;
        frame_92150b73fda83014548edff967541a31->m_frame.f_lineno = 2460;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2460;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_92150b73fda83014548edff967541a31->m_frame.f_lineno = 2459;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2459;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_protostr == NULL );
        var_protostr = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2465;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_protostr );
        tmp_args_element_name_4 = var_protostr;
        frame_92150b73fda83014548edff967541a31->m_frame.f_lineno = 2465;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2465;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_input_str == NULL );
        var_input_str = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSL_set_alpn_protos );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__ssl );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_input_str );
        tmp_args_element_name_6 = var_input_str;
        CHECK_OBJECT( var_protostr );
        tmp_len_arg_1 = var_protostr;
        tmp_args_element_name_7 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );

            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_92150b73fda83014548edff967541a31->m_frame.f_lineno = 2466;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_92150b73fda83014548edff967541a31 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_92150b73fda83014548edff967541a31 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_92150b73fda83014548edff967541a31, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_92150b73fda83014548edff967541a31->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_92150b73fda83014548edff967541a31, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_92150b73fda83014548edff967541a31,
        type_description_1,
        par_self,
        par_protos,
        var_protostr,
        var_input_str
    );


    // Release cached frame.
    if ( frame_92150b73fda83014548edff967541a31 == cache_frame_92150b73fda83014548edff967541a31 )
    {
        Py_DECREF( frame_92150b73fda83014548edff967541a31 );
    }
    cache_frame_92150b73fda83014548edff967541a31 = NULL;

    assertFrameObject( frame_92150b73fda83014548edff967541a31 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_112_set_alpn_protos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    CHECK_OBJECT( (PyObject *)var_protostr );
    Py_DECREF( var_protostr );
    var_protostr = NULL;

    CHECK_OBJECT( (PyObject *)var_input_str );
    Py_DECREF( var_input_str );
    var_input_str = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_protos );
    Py_DECREF( par_protos );
    par_protos = NULL;

    Py_XDECREF( var_protostr );
    var_protostr = NULL;

    Py_XDECREF( var_input_str );
    var_input_str = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_112_set_alpn_protos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals {
    PyObject *var_p;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_p = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_cf55bf501be28e7c7373cad88603c30e, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 2460;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_p;
            generator_heap->var_p = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_p );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_int2byte );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "int2byte" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_p );
        tmp_len_arg_1 = generator_heap->var_p;
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 2460;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_expression_name_1 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( generator_heap->var_p );
        tmp_tuple_element_1 = generator_heap->var_p;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_tuple_element_1, sizeof(PyObject *), &tmp_called_name_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_len_arg_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 2460;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 2460;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_p
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_p );
    generator_heap->var_p = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_p );
    generator_heap->var_p = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_context,
        module_OpenSSL$SSL,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_cf55bf501be28e7c7373cad88603c30e,
        1,
        sizeof(struct OpenSSL$SSL$$$function_112_set_alpn_protos$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_data_len = NULL;
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_47022de59f7f92385677b91a2a86bc8b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_47022de59f7f92385677b91a2a86bc8b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_47022de59f7f92385677b91a2a86bc8b, codeobj_47022de59f7f92385677b91a2a86bc8b, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_47022de59f7f92385677b91a2a86bc8b = cache_frame_47022de59f7f92385677b91a2a86bc8b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_47022de59f7f92385677b91a2a86bc8b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_47022de59f7f92385677b91a2a86bc8b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2476;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_47022de59f7f92385677b91a2a86bc8b->m_frame.f_lineno = 2476;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_52773e1185116024389d12c91a4ccf3d_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2476;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_data == NULL );
        var_data = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2477;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_47022de59f7f92385677b91a2a86bc8b->m_frame.f_lineno = 2477;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0 ) );

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2477;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_data_len == NULL );
        var_data_len = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_get0_alpn_selected );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_data );
        tmp_args_element_name_2 = var_data;
        CHECK_OBJECT( var_data_len );
        tmp_args_element_name_3 = var_data_len;
        frame_47022de59f7f92385677b91a2a86bc8b->m_frame.f_lineno = 2479;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_data_len );
        tmp_operand_name_1 = var_data_len;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2481;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = const_str_empty;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_buffer );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_data );
        tmp_subscribed_name_1 = var_data;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_data_len );
        tmp_subscribed_name_2 = var_data_len;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_4 );

            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_47022de59f7f92385677b91a2a86bc8b->m_frame.f_lineno = 2484;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2484;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47022de59f7f92385677b91a2a86bc8b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_47022de59f7f92385677b91a2a86bc8b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47022de59f7f92385677b91a2a86bc8b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_47022de59f7f92385677b91a2a86bc8b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_47022de59f7f92385677b91a2a86bc8b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_47022de59f7f92385677b91a2a86bc8b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_47022de59f7f92385677b91a2a86bc8b,
        type_description_1,
        par_self,
        var_data_len,
        var_data
    );


    // Release cached frame.
    if ( frame_47022de59f7f92385677b91a2a86bc8b == cache_frame_47022de59f7f92385677b91a2a86bc8b )
    {
        Py_DECREF( frame_47022de59f7f92385677b91a2a86bc8b );
    }
    cache_frame_47022de59f7f92385677b91a2a86bc8b = NULL;

    assertFrameObject( frame_47022de59f7f92385677b91a2a86bc8b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_data_len );
    Py_DECREF( var_data_len );
    var_data_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_data );
    Py_DECREF( var_data );
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_data_len );
    var_data_len = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$SSL$$$function_114_request_ocsp( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_rc = NULL;
    struct Nuitka_FrameObject *frame_208ce3a2e4e4eaea65e206e298e51f61;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_208ce3a2e4e4eaea65e206e298e51f61 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_208ce3a2e4e4eaea65e206e298e51f61, codeobj_208ce3a2e4e4eaea65e206e298e51f61, module_OpenSSL$SSL, sizeof(void *)+sizeof(void *) );
    frame_208ce3a2e4e4eaea65e206e298e51f61 = cache_frame_208ce3a2e4e4eaea65e206e298e51f61;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_208ce3a2e4e4eaea65e206e298e51f61 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_208ce3a2e4e4eaea65e206e298e51f61 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_set_tlsext_status_type );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__ssl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2494;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2494;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_TLSEXT_STATUSTYPE_ocsp );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 2494;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_208ce3a2e4e4eaea65e206e298e51f61->m_frame.f_lineno = 2493;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_rc == NULL );
        var_rc = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2496;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_rc );
        tmp_compexpr_left_1 = var_rc;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2496;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_208ce3a2e4e4eaea65e206e298e51f61->m_frame.f_lineno = 2496;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2496;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_208ce3a2e4e4eaea65e206e298e51f61 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_208ce3a2e4e4eaea65e206e298e51f61 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_208ce3a2e4e4eaea65e206e298e51f61, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_208ce3a2e4e4eaea65e206e298e51f61->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_208ce3a2e4e4eaea65e206e298e51f61, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_208ce3a2e4e4eaea65e206e298e51f61,
        type_description_1,
        par_self,
        var_rc
    );


    // Release cached frame.
    if ( frame_208ce3a2e4e4eaea65e206e298e51f61 == cache_frame_208ce3a2e4e4eaea65e206e298e51f61 )
    {
        Py_DECREF( frame_208ce3a2e4e4eaea65e206e298e51f61 );
    }
    cache_frame_208ce3a2e4e4eaea65e206e298e51f61 = NULL;

    assertFrameObject( frame_208ce3a2e4e4eaea65e206e298e51f61 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_114_request_ocsp );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_rc );
    Py_DECREF( var_rc );
    var_rc = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rc );
    var_rc = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$SSL$$$function_114_request_ocsp );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_100_set_connect_state(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_100_set_connect_state,
        const_str_plain_set_connect_state,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_79fd12729a50896c6b068d07adf12958,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3f54294273e4f6390044ae027b11e5ae,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_101_get_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_101_get_session,
        const_str_plain_get_session,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_279a26537d72f5f735cb2f57754efcf5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ef6e6485863cf611499d4e66d7c8cb32,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_102_set_session(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_102_set_session,
        const_str_plain_set_session,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_276464dd595899f2dceb721f57191727,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_099382aff2f4e6520a621b385fae4992,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_103__get_finished_message(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_103__get_finished_message,
        const_str_plain__get_finished_message,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_24fd8871d29e3f8af568578862db4e2f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_38eb25c1dd31f1c93831bc586a51d94a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_finished(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_104_get_finished,
        const_str_plain_get_finished,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_47d32c13661b74e6d0131e9414f24fc2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a824ae6766bf79c53a58510064186c32,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_peer_finished(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_105_get_peer_finished,
        const_str_plain_get_peer_finished,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_424167e2ffaae8f272268d954605a539,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6a85cdfe995e144af7c992d7adff36a9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_106_get_cipher_name,
        const_str_plain_get_cipher_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3f4dd1ce7e70d48a2f48706b38cf746b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_09af89b9aab79bc5666da647371af25d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_bits(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_107_get_cipher_bits,
        const_str_plain_get_cipher_bits,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5bc5fbaf9e45b62d2dbba7be971ca669,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b8ccf81a020f16490de1c8527ea9e4d6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_cipher_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_108_get_cipher_version,
        const_str_plain_get_cipher_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_81e335f349b11a09b01d6602680546e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0e87e25b0ab76d44ec1e50f187ee33bd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_109_get_protocol_version_name,
        const_str_plain_get_protocol_version_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b96d6d845ac2b66cff0a22f12fd41c93,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_39e6e3efbf37d872dab9cfbddc398ebf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_10_SSLeay_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_10_SSLeay_version,
        const_str_plain_SSLeay_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_204254c22f810b893ed5f77ec88d6f93,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1c06dc4166e08805f38a8dca82ce4339,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_110_get_protocol_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_110_get_protocol_version,
        const_str_plain_get_protocol_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_eb42686584dbda55dff0f68021ee3d63,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_776556dd9343f57c1cd72ff937153f0f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_next_proto_negotiated(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_111_get_next_proto_negotiated,
        const_str_plain_get_next_proto_negotiated,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d929b359a62116e3db27379ddc74f6e5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_536ef6d81295f4591dd87bc79e8440e7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_112_set_alpn_protos(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_112_set_alpn_protos,
        const_str_plain_set_alpn_protos,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_92150b73fda83014548edff967541a31,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a971aca8bab65513da2005120ca529f5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated,
        const_str_plain_get_alpn_proto_negotiated,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_47022de59f7f92385677b91a2a86bc8b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_aa803484dcfcfaec3d1d830a5ef1f026,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_114_request_ocsp(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_114_request_ocsp,
        const_str_plain_request_ocsp,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_208ce3a2e4e4eaea65e206e298e51f61,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1c1aa9b3fa80807ae10c68cfa1a0b8e6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_11__make_requires,
        const_str_plain__make_requires,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_de53eb30beb3bfb2cf34ab422b4bde7e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b8ec26ebdab81fb3d5f36275b48d4beb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator,
        const_str_plain__requires_decorator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_074a5e32739c565bb89c90a9ea0fbc5d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_11__make_requires$$$function_1__requires_decorator$$$function_1_explode,
        const_str_plain_explode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_19e73d50ebb8a5ae5b740ae60c6415e2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_12___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_12___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_075afde1753398fa4800587279bd54f8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_13_load_verify_locations( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_13_load_verify_locations,
        const_str_plain_load_verify_locations,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_31c49f0051a1276b7d55df95d6624040,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_85e95361903fe71cece52bb01216866e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_14__wrap_callback,
        const_str_plain__wrap_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_55c43580106a1e6e54d95041d3a9eb77,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_14__wrap_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e318d411854900096ecb90aa4ea274a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_15_set_passwd_cb( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_15_set_passwd_cb,
        const_str_plain_set_passwd_cb,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5411f7a0e5a468d33cbabda972ebdebe,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_83abd167711a9d69f6fb1ba8bbb40fdb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_16_set_default_verify_paths(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_16_set_default_verify_paths,
        const_str_plain_set_default_verify_paths,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1f9c33e10eab708a76d6954065cc1282,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_7f19e81c824604e95ebb1f01b7f5d7a1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_17__check_env_vars_set(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_17__check_env_vars_set,
        const_str_plain__check_env_vars_set,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1749b0d26efcd1f0dcbb3767913140b7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0f682ae315fc37e97d14dcc920e8b91d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_18__fallback_default_verify_paths(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_18__fallback_default_verify_paths,
        const_str_plain__fallback_default_verify_paths,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_112a0593b8266700f63d535b5382f3e7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c9c6fa40ef38c8d28b115afb17db4e50,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate_chain_file(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_19_use_certificate_chain_file,
        const_str_plain_use_certificate_chain_file,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_655c4c817ba68f8293b5e5f773a9c3b6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6e6e0d8d93df9702d9c8795dc2391090,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_1___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bb92ca164e88d1244448eb99fa29cdfe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_20_use_certificate_file( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_20_use_certificate_file,
        const_str_plain_use_certificate_file,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0f658e91b4d3f853eeaf63330d1f8c09,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e5bdbccc007b5187d287f36f3c9f8130,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_21_use_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_21_use_certificate,
        const_str_plain_use_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_41c71643654412e463e2e01067134703,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_eda9ad2d7932cfc1d1f52f27a3ed06a8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_22_add_extra_chain_cert(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_22_add_extra_chain_cert,
        const_str_plain_add_extra_chain_cert,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6b208ca591bc09f3db3e2b7a669fdf49,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3d1ad7b2c9fa025afe944eacf471d909,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_23__raise_passphrase_exception(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_23__raise_passphrase_exception,
        const_str_plain__raise_passphrase_exception,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_59384c424ee4f4c7331a4d2bae2ebb3f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_24_use_privatekey_file( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_24_use_privatekey_file,
        const_str_plain_use_privatekey_file,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f5158618828ea79b360b2b4d785102df,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_794f687944b90121fa261238090835e1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_25_use_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_25_use_privatekey,
        const_str_plain_use_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_02c1cad644039385b8a3726221761ce2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1f9e090d5f76db9e818dd53fef9b8465,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_26_check_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_26_check_privatekey,
        const_str_plain_check_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_96932aa6f568d4909cbd83290f84e650,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ceaeeee7f342339744c9535ada3c62e3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_27_load_client_ca(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_27_load_client_ca,
        const_str_plain_load_client_ca,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6a517aa52cd15acbda7c46151157c02c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_68d768407778bc3b4c8ffc953440b717,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_28_set_session_id(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_28_set_session_id,
        const_str_plain_set_session_id,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0a78b45fe82072741d967a7116be55e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_df17ae6c88635e3960d7bf94f5e880a4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_session_cache_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_29_set_session_cache_mode,
        const_str_plain_set_session_cache_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_df9b0f7b3f68a04bf8de49673c90bc52,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b65860d01f08f87c7391d19b5cfd9850,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_2_raise_if_problem,
        const_str_plain_raise_if_problem,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8e722a698c7d80a26ae8e7f38e2a9516,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0438f8885bf87c226201350e81ca4f79,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_30_get_session_cache_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_30_get_session_cache_mode,
        const_str_plain_get_session_cache_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1fc2be28988ba2299e0f3db3940125b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_73851dbd1821d646fbb8ad48e937548f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_31_set_verify(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_31_set_verify,
        const_str_plain_set_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3c210d5bc83108fc5f8b8621b4b96e97,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c0087bb531594ec7f6b437fc33f5a397,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_32_set_verify_depth(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_32_set_verify_depth,
        const_str_plain_set_verify_depth,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7594156bee4df5719976741b68595a11,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_c5585513b25f5127855be671a08a1332,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_33_get_verify_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_33_get_verify_mode,
        const_str_plain_get_verify_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f1ff26acd5f4673b85900278fccfa353,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6d088f969ab84bf3d60ab75faa431e51,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_34_get_verify_depth(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_34_get_verify_depth,
        const_str_plain_get_verify_depth,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_32829766e145fc1efe2f877d2ae9b983,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_723fb164f3e133051d00542dd747fe2d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_35_load_tmp_dh(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_35_load_tmp_dh,
        const_str_plain_load_tmp_dh,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fae4a37dc5886e31059db0e90dc6bcda,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8e472bc9049677fa90a9da1a818ea22f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_tmp_ecdh(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_36_set_tmp_ecdh,
        const_str_plain_set_tmp_ecdh,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_80da3cb70b526050748feefac39aa753,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_62f84685dfb1efe6a65f54b5d84154ad,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_37_set_cipher_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_37_set_cipher_list,
        const_str_plain_set_cipher_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f07b4d307d82823816d3b33cd173a678,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0b1af5d020260df564f1f58f9f88daaa,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_client_ca_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_38_set_client_ca_list,
        const_str_plain_set_client_ca_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4595e7f22fd27934c99d0779b3a36d8a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f7bf61568f9564a7aee5354f80d84343,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_39_add_client_ca(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_39_add_client_ca,
        const_str_plain_add_client_ca,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e2e477e47ecef45d6f6b262be274a428,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f5da7ec1228a5c8d32fa9b786affa014,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_3___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_81b26713a856ff526d48f6708e171c70,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_3___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8676d0373d5f8b05f118b297b9bb18ac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_timeout(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_40_set_timeout,
        const_str_plain_set_timeout,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0197cdd72b2974669ab0cb1f129cf2f4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_39dd8800b3995a2e161e8739b1bebc01,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_41_get_timeout(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_41_get_timeout,
        const_str_plain_get_timeout,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_68087fd292b2546ec5a640d5c97808d9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0bb5eb9f5b32c979fadc3e4b702de2f7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_42_set_info_callback,
        const_str_plain_set_info_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2cb565234df87e31bd5093a06c903ab0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e04d236da419e1b15c5c13532be67a91,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_42_set_info_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_990bffb794119d86150b99fa6491e939,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_43_get_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_43_get_app_data,
        const_str_plain_get_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f958b28da4ca6aab9d6b653c2268ae69,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0d994cfb9823ffc5647bea3454d1e646,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_44_set_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_44_set_app_data,
        const_str_plain_set_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_47a8b871086e72be9e62b12178457475,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bae02e8783abd2cb1ef184c4ddb0f45d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_45_get_cert_store(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_45_get_cert_store,
        const_str_plain_get_cert_store,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3601ce3f1589b8f9d54de158108a95af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b55bbb0df6959d47693f7145ead6828a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_options(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_46_set_options,
        const_str_plain_set_options,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_292c28a762938b6a8045d2808b664ec1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3957b1b23f06761ef1844caf450dffd3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_mode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_47_set_mode,
        const_str_plain_set_mode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f7131a7728aa55e97242ea844954e2d3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8d1f7ec402c1b452808eeb662977982b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback,
        const_str_plain_set_tlsext_servername_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4a87892876c4589d9c9a13b1feca9117,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_d84d6f514b61e2d13913a11459387aca,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f026f64ff0ca0abcc464653172e19868,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp,
        const_str_plain_set_tlsext_use_srtp,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_62907623253c538bdf755fd12f970dd3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_447836721d7454a13033957e012d7688,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_4___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_317cb4b84876aa5d1575cb60d91624c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_4___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ff5454a954382e81b4077a213567d6a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_npn_advertise_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_50_set_npn_advertise_callback,
        const_str_plain_set_npn_advertise_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bcacbcc345964cd40d55a8ded45cab48,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5e63447161ff7f7c21b2ac874cc6500c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_51_set_npn_select_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_51_set_npn_select_callback,
        const_str_plain_set_npn_select_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c84e069d6460014d6980972db9133002,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_fe0750f479b57ce782e84a9b40cf000b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_alpn_protos(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_52_set_alpn_protos,
        const_str_plain_set_alpn_protos,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_250a4ae7f401cdf63a568e77d373460c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_cf5a529c83a60eab9bc87caa3430bc5c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_alpn_select_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_53_set_alpn_select_callback,
        const_str_plain_set_alpn_select_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6e82bf48752d997d2ba9c4cb6ca57dc0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_9c76bfc2ff06864d351211fc5c45c351,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_54__set_ocsp_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_54__set_ocsp_callback,
        const_str_plain__set_ocsp_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1fd679ce963858fb95fb0f532483b704,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_e7ed1590d11cbaaaf17420c6bdc13490,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_55_set_ocsp_server_callback( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_55_set_ocsp_server_callback,
        const_str_plain_set_ocsp_server_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_355fcfa300882710f491f60c8724e180,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_77c1b668370aaac8571fd41e2e807543,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_56_set_ocsp_client_callback( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_56_set_ocsp_client_callback,
        const_str_plain_set_ocsp_client_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9c360624a33744b74644bf01d1e328dc,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_7cc8f764b42656b144d56bfbd9df2b48,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_57___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_57___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_118684193660e42e7b532200be083df8,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_149b7c0937a6a666f182d0520ebdf631,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_58___getattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_58___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d66630988e992039e8c615ca57600ec8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_eb75de26d3d89a0b83fc536ac20042b0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_59__raise_ssl_error(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_59__raise_ssl_error,
        const_str_plain__raise_ssl_error,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e64d814c39cb7a48505598e16da6bb25,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_5___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fa7b831ecbe4fb78f1e881fefdd3ba51,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_5___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_162a5a1926e2d87c5196f76de69fc199,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_60_get_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_60_get_context,
        const_str_plain_get_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_abe3e219ee6e1aa4dabcb63168931b9b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_d71143a9aaaa613b59e0c4c3015a7c4a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_61_set_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_61_set_context,
        const_str_plain_set_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_caafd991eb739c67f9b0132a1e25e9b3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_fe9d923dffe7ca07e210d76d45bba668,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_62_get_servername(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_62_get_servername,
        const_str_plain_get_servername,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f32210b1a6041e23f6080980ed862744,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_94e7111e03f9422114930bb75dfc492c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_63_set_tlsext_host_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_63_set_tlsext_host_name,
        const_str_plain_set_tlsext_host_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_84be2e2654ef2638907dd2c10cb860ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b2b544e0252baa92681eeaf8ffa03130,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_64_pending(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_64_pending,
        const_str_plain_pending,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_05cf5483bca2509bcd0b3c906d201953,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1ba1651f4266e42e9b568d28fa131281,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_65_send( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_65_send,
        const_str_plain_send,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5a1358d55560963927bee18bb9d8968e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_2c98e45dae0eb590d01836d5f4b5f54f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_66_sendall( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_66_sendall,
        const_str_plain_sendall,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ce3644339e9eda748037fea603eecb61,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_2eac950a8b26412274fa98ea596054c5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_67_recv( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_67_recv,
        const_str_plain_recv,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b629e495f4ca5d31617df1d720289b76,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ebaec5436a48442094f25464a6eec24c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_68_recv_into( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_68_recv_into,
        const_str_plain_recv_into,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_992b138da987129c02121bdece9bbd42,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6f72f23667e4f49591ed4cf6d6205ca5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_69__handle_bio_errors(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_69__handle_bio_errors,
        const_str_plain__handle_bio_errors,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_69ff2c23544b1c72fc03755bb35fb253,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_6___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cc5d77cb8b65c7f8f33a60eea1cc2796,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_6___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_84469bc26b1b18a7587749a007b2f9d0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_70_bio_read(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_70_bio_read,
        const_str_plain_bio_read,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e2e44a36909f5df8646b2e1f8b0a8741,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f68d1733f2e29d0ad83b903b8f287e14,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_71_bio_write(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_71_bio_write,
        const_str_plain_bio_write,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7a00a7cb18c1f008e8d4f4e6d2d91473,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3c214455d63d6846892932f043ae8dab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_72_renegotiate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_72_renegotiate,
        const_str_plain_renegotiate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_30fbf84052a7d1bcffa3c18a7999cd6f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_91c07271f44b73503e7c77deea91aef1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_73_do_handshake(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_73_do_handshake,
        const_str_plain_do_handshake,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c41b1a3f0450c7a475885eaa3a67dae8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f85e475b3736c6da8cbd8e92af63eba4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_74_renegotiate_pending(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_74_renegotiate_pending,
        const_str_plain_renegotiate_pending,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0c7560e59f4396437ef373315ed7cd5c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bd36e8cd21056831af843bc4658cec96,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_75_total_renegotiations(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_75_total_renegotiations,
        const_str_plain_total_renegotiations,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_05a1faeaf48c61a421aaa55c489d7360,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_61df355efe52f096d5251268bee9ada3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_76_connect(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_76_connect,
        const_str_plain_connect,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e74b0d670d825333142ebe15f0fa8d7c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_060a092ce142509580b5fc6c56b149a1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_77_connect_ex(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_77_connect_ex,
        const_str_plain_connect_ex,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_01faaa9c80c48cd540120e4e857f6ece,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_60759f97a8e448eec2208bd0c353d705,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_78_accept(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_78_accept,
        const_str_plain_accept,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d90925d66d5cf1b0980da015a4674b00,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_592776beca582822ed747da68adba670,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_79_bio_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_79_bio_shutdown,
        const_str_plain_bio_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_85ded3b492f290b648fbd8dbdb475788,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5ecd8d00ee49c82aecc9b4312a6eab51,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_7___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_886a66a4ce2fa5c90a928ff54c46cf35,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_7___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d2ee4bcf609725335171733079f6b33c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_80_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_80_shutdown,
        const_str_plain_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f89df5132055bf6ccda906b72a60bfc3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_9071118ef0006cb5d28d9100761be8e9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_cipher_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_81_get_cipher_list,
        const_str_plain_get_cipher_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a8cab1d99611ab8877a7b8259839e592,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_92d0e5bbbb594d3595c30b16879df5a0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_82_get_client_ca_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_82_get_client_ca_list,
        const_str_plain_get_client_ca_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0bd8f781f5883f7dd44ea21f5d030f6f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_92dae1d5c0e993b1b8bd25bfbbae5039,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_83_makefile(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_83_makefile,
        const_str_plain_makefile,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_72bb665d288c66555372d0602d766fd8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_f45f13437cfffca595693525af90acd6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_84_get_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_84_get_app_data,
        const_str_plain_get_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_32e837ccb250942a0b72b517687f5b19,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_8d7c284f25a4b19db8bcbef7a9895745,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_85_set_app_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_85_set_app_data,
        const_str_plain_set_app_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f362b683cf087e1099fdf014aa93bacd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_240fed82a102b949d0d53c00df42e330,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_86_get_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_86_get_shutdown,
        const_str_plain_get_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_be6cb0488266a27981ef336bc64c1840,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_0bdfe95b50c341a06f9727afb1a762dc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_87_set_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_87_set_shutdown,
        const_str_plain_set_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e718cae76ed96e3a285678549a1a9741,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_655ba65e888ba33199198c92a8e95d70,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_88_get_state_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_88_get_state_string,
        const_str_plain_get_state_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1b54bcdee7de522cee916ad54d2f1ede,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_6e6304d3afc4a993b41c01e5af499f6b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_89_server_random(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_89_server_random,
        const_str_plain_server_random,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f6837856edf570e4bd43a28f747a059d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ad463a4d3fa3baff68f13aea2d205572,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_8___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ef30387d2b22fe29bb41f5ab3b946a84,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_8___init__$$$function_1_wrapper,
        const_str_plain_wrapper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ab7c6851b751f003fc9405d2a2e9ea43,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        2
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_90_client_random(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_90_client_random,
        const_str_plain_client_random,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cad1093edb1e34fb4531b6283b02fe19,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_ce6e46c47189c65d4c33b9ca8d5ba2ad,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_91_master_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_91_master_key,
        const_str_plain_master_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a928f1b20a0225cfbe69803a6f04e72f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_a94ef27b6600318cb26f98532a46ec7d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_92_export_keying_material( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_92_export_keying_material,
        const_str_plain_export_keying_material,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_53861ad8ddc3409044175f205fdf735e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_cbc74855fdd069af46a5197a85921eab,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_93_sock_shutdown(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_93_sock_shutdown,
        const_str_plain_sock_shutdown,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a10c241273a2cfd5b8ca6cac4d75c1bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_159b478f00ae4e4ff337b75b4ff4b73e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_94_get_certificate,
        const_str_plain_get_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_40161c7dc5bd3470776c2c8e35eca36d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_770cbd653c9b65a44061ec243e0b5fd3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_peer_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_95_get_peer_certificate,
        const_str_plain_get_peer_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_408236438062f833e577752ad530c24f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_5f09856be161f8b617a90e11db2ed735,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_96_get_peer_cert_chain(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_96_get_peer_cert_chain,
        const_str_plain_get_peer_cert_chain,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c825b51890ba6e544f0a67ddfa92ae8a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_b6ee2740f619fbeb4f2040d74693ca57,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_read(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_97_want_read,
        const_str_plain_want_read,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_952cfd5b63ecd1dd4f987c147c539d39,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_bcb5a3a78e430302038d88f5e5d88cc5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_98_want_write(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_98_want_write,
        const_str_plain_want_write,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4f2247f2b870626a6f520ab00ca5767f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_1f723e76cd26cf3162ae94f693472dd5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_accept_state(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_99_set_accept_state,
        const_str_plain_set_accept_state,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_04f440036e2b2c35459569a981c6b41b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        const_str_digest_3319904791e7df62e14d88cc362facc1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$SSL$$$function_9__asFileDescriptor(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$SSL$$$function_9__asFileDescriptor,
        const_str_plain__asFileDescriptor,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1560700e571808ac63152799e0da7758,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$SSL,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_OpenSSL$SSL =
{
    PyModuleDef_HEAD_INIT,
    "OpenSSL.SSL",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;

extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( OpenSSL$SSL )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_OpenSSL$SSL );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("OpenSSL.SSL: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.SSL: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.SSL: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initOpenSSL$SSL" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_OpenSSL$SSL = Py_InitModule4(
        "OpenSSL.SSL",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_OpenSSL$SSL = PyModule_Create( &mdef_OpenSSL$SSL );
#endif

    moduledict_OpenSSL$SSL = MODULE_DICT( module_OpenSSL$SSL );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_OpenSSL$SSL,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$SSL,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$SSL,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_OpenSSL$SSL );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9, module_OpenSSL$SSL );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_Context$genexpr_1__$0 = NULL;
    PyObject *tmp_class_creation_10__bases = NULL;
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__bases = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__bases = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__bases = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__bases = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__bases = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__bases = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__bases = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__bases = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__bases = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_import_from_5__module = NULL;
    PyObject *tmp_locals_OpenSSL$SSL_269_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$SSL_269_key_raise_if_problem = NULL;
    PyObject *tmp_select_metaclass_10__base = NULL;
    PyObject *tmp_select_metaclass_11__base = NULL;
    PyObject *tmp_select_metaclass_12__base = NULL;
    PyObject *tmp_select_metaclass_13__base = NULL;
    PyObject *tmp_select_metaclass_14__base = NULL;
    PyObject *tmp_select_metaclass_3__base = NULL;
    PyObject *tmp_select_metaclass_4__base = NULL;
    PyObject *tmp_select_metaclass_5__base = NULL;
    PyObject *tmp_select_metaclass_6__base = NULL;
    PyObject *tmp_select_metaclass_7__base = NULL;
    PyObject *tmp_select_metaclass_9__base = NULL;
    struct Nuitka_FrameObject *frame_cd5d88529d58a411fd9144e06350d5f3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    int tmp_res;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *locals_OpenSSL$SSL_249 = NULL;
    PyObject *tmp_dictset_value;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *locals_OpenSSL$SSL_253 = NULL;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_OpenSSL$SSL_257 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *locals_OpenSSL$SSL_261 = NULL;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *locals_OpenSSL$SSL_265 = NULL;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *locals_OpenSSL$SSL_297 = NULL;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *locals_OpenSSL$SSL_336 = NULL;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *locals_OpenSSL$SSL_377 = NULL;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *locals_OpenSSL$SSL_426 = NULL;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *locals_OpenSSL$SSL_477 = NULL;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *locals_OpenSSL$SSL_544 = NULL;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *locals_OpenSSL$SSL_679 = NULL;
    struct Nuitka_FrameObject *frame_876568a907b5dca527860ce47378562e_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_876568a907b5dca527860ce47378562e_2 = NULL;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *locals_OpenSSL$SSL_1537 = NULL;
    struct Nuitka_FrameObject *frame_2352c5a15d14192c9a7a25a5a1b6a81c_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 = NULL;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_str_digest_3284a0d54b2aa35ff31d3f6e48d74aec;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    // Frame without reuse.
    frame_cd5d88529d58a411fd9144e06350d5f3 = MAKE_MODULE_FRAME( codeobj_cd5d88529d58a411fd9144e06350d5f3, module_OpenSSL$SSL );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_cd5d88529d58a411fd9144e06350d5f3 );
    assert( Py_REFCNT( frame_cd5d88529d58a411fd9144e06350d5f3 ) == 2 );

    // Framed code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_os;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 1;
        tmp_assign_source_3 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_os, tmp_assign_source_3 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        tmp_name_name_2 = const_str_plain_socket;
        tmp_globals_name_2 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 2;
        tmp_assign_source_4 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_socket, tmp_assign_source_4 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        tmp_name_name_3 = const_str_plain_sys;
        tmp_globals_name_3 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = const_tuple_str_plain_platform_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 3;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
        assert( !(tmp_import_name_from_1 == NULL) );
        tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_platform );
        Py_DECREF( tmp_import_name_from_1 );
        assert( !(tmp_assign_source_5 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_platform, tmp_assign_source_5 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        tmp_name_name_4 = const_str_plain_functools;
        tmp_globals_name_4 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = const_tuple_str_plain_wraps_str_plain_partial_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 4;
        tmp_assign_source_6 = IMPORT_MODULE4( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 4;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_1__module == NULL );
        tmp_import_from_1__module = tmp_assign_source_6;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_import_name_from_2;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_2 = tmp_import_from_1__module;
        tmp_assign_source_7 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_wraps );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 4;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_wraps, tmp_assign_source_7 );
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_import_name_from_3;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_3 = tmp_import_from_1__module;
        tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_partial );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 4;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_8 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        tmp_name_name_5 = const_str_plain_itertools;
        tmp_globals_name_5 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = const_tuple_str_plain_count_str_plain_chain_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 5;
        tmp_assign_source_9 = IMPORT_MODULE4( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5 );
        assert( !(tmp_assign_source_9 == NULL) );
        assert( tmp_import_from_2__module == NULL );
        tmp_import_from_2__module = tmp_assign_source_9;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_import_name_from_4;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_4 = tmp_import_from_2__module;
        tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_count );
        assert( !(tmp_assign_source_10 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_count, tmp_assign_source_10 );
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_import_name_from_5;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_5 = tmp_import_from_2__module;
        tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_chain );
        assert( !(tmp_assign_source_11 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_chain, tmp_assign_source_11 );
    }
    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_import_name_from_6;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        tmp_name_name_6 = const_str_plain_weakref;
        tmp_globals_name_6 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = const_tuple_str_plain_WeakValueDictionary_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 6;
        tmp_import_name_from_6 = IMPORT_MODULE4( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6 );
        if ( tmp_import_name_from_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 6;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_WeakValueDictionary );
        Py_DECREF( tmp_import_name_from_6 );
        if ( tmp_assign_source_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 6;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary, tmp_assign_source_12 );
    }
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_import_name_from_7;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        tmp_name_name_7 = const_str_plain_errno;
        tmp_globals_name_7 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = const_tuple_str_plain_errorcode_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 7;
        tmp_import_name_from_7 = IMPORT_MODULE4( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7 );
        assert( !(tmp_import_name_from_7 == NULL) );
        tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_errorcode );
        Py_DECREF( tmp_import_name_from_7 );
        assert( !(tmp_assign_source_13 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_errorcode, tmp_assign_source_13 );
    }
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_import_name_from_8;
        PyObject *tmp_name_name_8;
        PyObject *tmp_globals_name_8;
        PyObject *tmp_locals_name_8;
        PyObject *tmp_fromlist_name_8;
        tmp_name_name_8 = const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
        tmp_globals_name_8 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_8 = Py_None;
        tmp_fromlist_name_8 = const_tuple_str_plain_deprecated_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 9;
        tmp_import_name_from_8 = IMPORT_MODULE4( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8 );
        if ( tmp_import_name_from_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain_deprecated );
        Py_DECREF( tmp_import_name_from_8 );
        if ( tmp_assign_source_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_deprecated, tmp_assign_source_14 );
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_name_name_9;
        PyObject *tmp_globals_name_9;
        PyObject *tmp_locals_name_9;
        PyObject *tmp_fromlist_name_9;
        tmp_name_name_9 = const_str_plain_six;
        tmp_globals_name_9 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_9 = Py_None;
        tmp_fromlist_name_9 = const_tuple_26498c7c65e3c1d61715bb934548919d_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 11;
        tmp_assign_source_15 = IMPORT_MODULE4( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9 );
        if ( tmp_assign_source_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_3__module == NULL );
        tmp_import_from_3__module = tmp_assign_source_15;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_import_name_from_9;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_9 = tmp_import_from_3__module;
        tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_binary_type );
        if ( tmp_assign_source_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__binary_type, tmp_assign_source_16 );
    }
    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_import_name_from_10;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_10 = tmp_import_from_3__module;
        tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_integer_types );
        if ( tmp_assign_source_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_integer_types, tmp_assign_source_17 );
    }
    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_import_name_from_11;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_11 = tmp_import_from_3__module;
        tmp_assign_source_18 = IMPORT_NAME( tmp_import_name_from_11, const_str_plain_int2byte );
        if ( tmp_assign_source_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_int2byte, tmp_assign_source_18 );
    }
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_import_name_from_12;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_12 = tmp_import_from_3__module;
        tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_12, const_str_plain_indexbytes );
        if ( tmp_assign_source_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_indexbytes, tmp_assign_source_19 );
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    {
        PyObject *tmp_assign_source_20;
        PyObject *tmp_name_name_10;
        PyObject *tmp_globals_name_10;
        PyObject *tmp_locals_name_10;
        PyObject *tmp_fromlist_name_10;
        tmp_name_name_10 = const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
        tmp_globals_name_10 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_10 = Py_None;
        tmp_fromlist_name_10 = const_tuple_87f1641fb31961ccfc03a99691482662_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 15;
        tmp_assign_source_20 = IMPORT_MODULE4( tmp_name_name_10, tmp_globals_name_10, tmp_locals_name_10, tmp_fromlist_name_10 );
        if ( tmp_assign_source_20 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_4__module == NULL );
        tmp_import_from_4__module = tmp_assign_source_20;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_import_name_from_13;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_13 = tmp_import_from_4__module;
        tmp_assign_source_21 = IMPORT_NAME( tmp_import_name_from_13, const_str_plain_UNSPECIFIED );
        if ( tmp_assign_source_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED, tmp_assign_source_21 );
    }
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_import_name_from_14;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_14 = tmp_import_from_4__module;
        tmp_assign_source_22 = IMPORT_NAME( tmp_import_name_from_14, const_str_plain_exception_from_error_queue );
        if ( tmp_assign_source_22 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue, tmp_assign_source_22 );
    }
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_import_name_from_15;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_15 = tmp_import_from_4__module;
        tmp_assign_source_23 = IMPORT_NAME( tmp_import_name_from_15, const_str_plain_ffi );
        if ( tmp_assign_source_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ffi, tmp_assign_source_23 );
    }
    {
        PyObject *tmp_assign_source_24;
        PyObject *tmp_import_name_from_16;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_16 = tmp_import_from_4__module;
        tmp_assign_source_24 = IMPORT_NAME( tmp_import_name_from_16, const_str_plain_lib );
        if ( tmp_assign_source_24 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib, tmp_assign_source_24 );
    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_import_name_from_17;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_17 = tmp_import_from_4__module;
        tmp_assign_source_25 = IMPORT_NAME( tmp_import_name_from_17, const_str_plain_make_assert );
        if ( tmp_assign_source_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_assert, tmp_assign_source_25 );
    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_import_name_from_18;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_18 = tmp_import_from_4__module;
        tmp_assign_source_26 = IMPORT_NAME( tmp_import_name_from_18, const_str_plain_native );
        if ( tmp_assign_source_26 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__native, tmp_assign_source_26 );
    }
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_import_name_from_19;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_19 = tmp_import_from_4__module;
        tmp_assign_source_27 = IMPORT_NAME( tmp_import_name_from_19, const_str_plain_path_string );
        if ( tmp_assign_source_27 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__path_string, tmp_assign_source_27 );
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_import_name_from_20;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_20 = tmp_import_from_4__module;
        tmp_assign_source_28 = IMPORT_NAME( tmp_import_name_from_20, const_str_plain_text_to_bytes_and_warn );
        if ( tmp_assign_source_28 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn, tmp_assign_source_28 );
    }
    {
        PyObject *tmp_assign_source_29;
        PyObject *tmp_import_name_from_21;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_21 = tmp_import_from_4__module;
        tmp_assign_source_29 = IMPORT_NAME( tmp_import_name_from_21, const_str_plain_no_zero_allocator );
        if ( tmp_assign_source_29 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 15;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__no_zero_allocator, tmp_assign_source_29 );
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_name_name_11;
        PyObject *tmp_globals_name_11;
        PyObject *tmp_locals_name_11;
        PyObject *tmp_fromlist_name_11;
        tmp_name_name_11 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_globals_name_11 = (PyObject *)moduledict_OpenSSL$SSL;
        tmp_locals_name_11 = Py_None;
        tmp_fromlist_name_11 = const_tuple_c21a4bcc0d9dac830f44bc0c201bf7fd_tuple;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 27;
        tmp_assign_source_30 = IMPORT_MODULE4( tmp_name_name_11, tmp_globals_name_11, tmp_locals_name_11, tmp_fromlist_name_11 );
        if ( tmp_assign_source_30 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 27;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_5__module == NULL );
        tmp_import_from_5__module = tmp_assign_source_30;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_31;
        PyObject *tmp_import_name_from_22;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_22 = tmp_import_from_5__module;
        tmp_assign_source_31 = IMPORT_NAME( tmp_import_name_from_22, const_str_plain_FILETYPE_PEM );
        if ( tmp_assign_source_31 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM, tmp_assign_source_31 );
    }
    {
        PyObject *tmp_assign_source_32;
        PyObject *tmp_import_name_from_23;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_23 = tmp_import_from_5__module;
        tmp_assign_source_32 = IMPORT_NAME( tmp_import_name_from_23, const_str_plain__PassphraseHelper );
        if ( tmp_assign_source_32 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__PassphraseHelper, tmp_assign_source_32 );
    }
    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_import_name_from_24;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_24 = tmp_import_from_5__module;
        tmp_assign_source_33 = IMPORT_NAME( tmp_import_name_from_24, const_str_plain_PKey );
        if ( tmp_assign_source_33 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_PKey, tmp_assign_source_33 );
    }
    {
        PyObject *tmp_assign_source_34;
        PyObject *tmp_import_name_from_25;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_25 = tmp_import_from_5__module;
        tmp_assign_source_34 = IMPORT_NAME( tmp_import_name_from_25, const_str_plain_X509Name );
        if ( tmp_assign_source_34 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Name, tmp_assign_source_34 );
    }
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_import_name_from_26;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_26 = tmp_import_from_5__module;
        tmp_assign_source_35 = IMPORT_NAME( tmp_import_name_from_26, const_str_plain_X509 );
        if ( tmp_assign_source_35 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509, tmp_assign_source_35 );
    }
    {
        PyObject *tmp_assign_source_36;
        PyObject *tmp_import_name_from_27;
        CHECK_OBJECT( tmp_import_from_5__module );
        tmp_import_name_from_27 = tmp_import_from_5__module;
        tmp_assign_source_36 = IMPORT_NAME( tmp_import_name_from_27, const_str_plain_X509Store );
        if ( tmp_assign_source_36 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 27;

            goto try_except_handler_4;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_X509Store, tmp_assign_source_36 );
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_5__module );
    Py_DECREF( tmp_import_from_5__module );
    tmp_import_from_5__module = NULL;

    {
        PyObject *tmp_assign_source_37;
        tmp_assign_source_37 = LIST_COPY( const_list_3507872b18f9d5cd646e67697ec96e56_list );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_37 );
    }
    {
        PyObject *tmp_assign_source_38;
        tmp_assign_source_38 = (PyObject *)&PyBuffer_Type;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__buffer, tmp_assign_source_38 );
    }
    {
        PyObject *tmp_assign_source_39;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 121;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_assign_source_39 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OPENSSL_VERSION_NUMBER );
        if ( tmp_assign_source_39 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 121;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OPENSSL_VERSION_NUMBER, tmp_assign_source_39 );
    }
    {
        PyObject *tmp_assign_source_40;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 122;

            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_assign_source_40 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSLEAY_VERSION );
        if ( tmp_assign_source_40 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 122;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_VERSION, tmp_assign_source_40 );
    }
    {
        PyObject *tmp_assign_source_41;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 123;

            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_assign_source_41 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_SSLEAY_CFLAGS );
        if ( tmp_assign_source_41 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 123;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_CFLAGS, tmp_assign_source_41 );
    }
    {
        PyObject *tmp_assign_source_42;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 124;

            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_assign_source_42 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_SSLEAY_PLATFORM );
        if ( tmp_assign_source_42 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 124;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_PLATFORM, tmp_assign_source_42 );
    }
    {
        PyObject *tmp_assign_source_43;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 125;

            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_assign_source_43 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SSLEAY_DIR );
        if ( tmp_assign_source_43 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 125;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_DIR, tmp_assign_source_43 );
    }
    {
        PyObject *tmp_assign_source_44;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 126;

            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_assign_source_44 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_SSLEAY_BUILT_ON );
        if ( tmp_assign_source_44 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 126;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLEAY_BUILT_ON, tmp_assign_source_44 );
    }
    {
        PyObject *tmp_assign_source_45;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 128;

            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_7;
        tmp_assign_source_45 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_SSL_SENT_SHUTDOWN );
        if ( tmp_assign_source_45 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 128;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SENT_SHUTDOWN, tmp_assign_source_45 );
    }
    {
        PyObject *tmp_assign_source_46;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 129;

            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_8;
        tmp_assign_source_46 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_SSL_RECEIVED_SHUTDOWN );
        if ( tmp_assign_source_46 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_RECEIVED_SHUTDOWN, tmp_assign_source_46 );
    }
    {
        PyObject *tmp_assign_source_47;
        tmp_assign_source_47 = const_int_pos_1;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD, tmp_assign_source_47 );
    }
    {
        PyObject *tmp_assign_source_48;
        tmp_assign_source_48 = const_int_pos_2;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD, tmp_assign_source_48 );
    }
    {
        PyObject *tmp_assign_source_49;
        tmp_assign_source_49 = const_int_pos_3;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD, tmp_assign_source_49 );
    }
    {
        PyObject *tmp_assign_source_50;
        tmp_assign_source_50 = const_int_pos_4;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD, tmp_assign_source_50 );
    }
    {
        PyObject *tmp_assign_source_51;
        tmp_assign_source_51 = const_int_pos_5;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD, tmp_assign_source_51 );
    }
    {
        PyObject *tmp_assign_source_52;
        tmp_assign_source_52 = const_int_pos_6;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD, tmp_assign_source_52 );
    }
    {
        PyObject *tmp_assign_source_53;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 138;

            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_9;
        tmp_assign_source_53 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_SSL_OP_NO_SSLv2 );
        if ( tmp_assign_source_53 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 138;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_SSLv2, tmp_assign_source_53 );
    }
    {
        PyObject *tmp_assign_source_54;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 139;

            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_10;
        tmp_assign_source_54 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_SSL_OP_NO_SSLv3 );
        if ( tmp_assign_source_54 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_SSLv3, tmp_assign_source_54 );
    }
    {
        PyObject *tmp_assign_source_55;
        PyObject *tmp_source_name_11;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 140;

            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = tmp_mvar_value_11;
        tmp_assign_source_55 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_SSL_OP_NO_TLSv1 );
        if ( tmp_assign_source_55 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 140;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1, tmp_assign_source_55 );
    }
    {
        PyObject *tmp_assign_source_56;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 141;

            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_12;
        tmp_assign_source_56 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_SSL_OP_NO_TLSv1_1 );
        if ( tmp_assign_source_56 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1_1, tmp_assign_source_56 );
    }
    {
        PyObject *tmp_assign_source_57;
        PyObject *tmp_source_name_13;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 142;

            goto frame_exception_exit_1;
        }

        tmp_source_name_13 = tmp_mvar_value_13;
        tmp_assign_source_57 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_SSL_OP_NO_TLSv1_2 );
        if ( tmp_assign_source_57 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 142;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TLSv1_2, tmp_assign_source_57 );
    }
    {
        PyObject *tmp_assign_source_58;
        PyObject *tmp_source_name_14;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 144;

            goto frame_exception_exit_1;
        }

        tmp_source_name_14 = tmp_mvar_value_14;
        tmp_assign_source_58 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_SSL_MODE_RELEASE_BUFFERS );
        if ( tmp_assign_source_58 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 144;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_MODE_RELEASE_BUFFERS, tmp_assign_source_58 );
    }
    {
        PyObject *tmp_assign_source_59;
        PyObject *tmp_source_name_15;
        PyObject *tmp_mvar_value_15;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 146;

            goto frame_exception_exit_1;
        }

        tmp_source_name_15 = tmp_mvar_value_15;
        tmp_assign_source_59 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_SSL_OP_SINGLE_DH_USE );
        if ( tmp_assign_source_59 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 146;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SINGLE_DH_USE, tmp_assign_source_59 );
    }
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_source_name_16;
        PyObject *tmp_mvar_value_16;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 147;

            goto frame_exception_exit_1;
        }

        tmp_source_name_16 = tmp_mvar_value_16;
        tmp_assign_source_60 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_SSL_OP_SINGLE_ECDH_USE );
        if ( tmp_assign_source_60 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 147;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SINGLE_ECDH_USE, tmp_assign_source_60 );
    }
    {
        PyObject *tmp_assign_source_61;
        PyObject *tmp_source_name_17;
        PyObject *tmp_mvar_value_17;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_17 == NULL ))
        {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_17 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 148;

            goto frame_exception_exit_1;
        }

        tmp_source_name_17 = tmp_mvar_value_17;
        tmp_assign_source_61 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_SSL_OP_EPHEMERAL_RSA );
        if ( tmp_assign_source_61 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 148;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_EPHEMERAL_RSA, tmp_assign_source_61 );
    }
    {
        PyObject *tmp_assign_source_62;
        PyObject *tmp_source_name_18;
        PyObject *tmp_mvar_value_18;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_18 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 149;

            goto frame_exception_exit_1;
        }

        tmp_source_name_18 = tmp_mvar_value_18;
        tmp_assign_source_62 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_SSL_OP_MICROSOFT_SESS_ID_BUG );
        if ( tmp_assign_source_62 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MICROSOFT_SESS_ID_BUG, tmp_assign_source_62 );
    }
    {
        PyObject *tmp_assign_source_63;
        PyObject *tmp_source_name_19;
        PyObject *tmp_mvar_value_19;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 150;

            goto frame_exception_exit_1;
        }

        tmp_source_name_19 = tmp_mvar_value_19;
        tmp_assign_source_63 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_SSL_OP_NETSCAPE_CHALLENGE_BUG );
        if ( tmp_assign_source_63 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 150;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_CHALLENGE_BUG, tmp_assign_source_63 );
    }
    {
        PyObject *tmp_assign_source_64;
        PyObject *tmp_source_name_20;
        PyObject *tmp_mvar_value_20;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_20 == NULL ))
        {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_20 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 152;

            goto frame_exception_exit_1;
        }

        tmp_source_name_20 = tmp_mvar_value_20;
        tmp_assign_source_64 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG );
        if ( tmp_assign_source_64 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 152;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG, tmp_assign_source_64 );
    }
    {
        PyObject *tmp_assign_source_65;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_21;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_21 == NULL ))
        {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_21 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 154;

            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_21;
        tmp_assign_source_65 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG );
        if ( tmp_assign_source_65 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 154;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SSLREF2_REUSE_CERT_TYPE_BUG, tmp_assign_source_65 );
    }
    {
        PyObject *tmp_assign_source_66;
        PyObject *tmp_source_name_22;
        PyObject *tmp_mvar_value_22;
        tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_22 == NULL ))
        {
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_22 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 155;

            goto frame_exception_exit_1;
        }

        tmp_source_name_22 = tmp_mvar_value_22;
        tmp_assign_source_66 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER );
        if ( tmp_assign_source_66 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 155;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MICROSOFT_BIG_SSLV3_BUFFER, tmp_assign_source_66 );
    }
    {
        PyObject *tmp_assign_source_67;
        PyObject *tmp_source_name_23;
        PyObject *tmp_mvar_value_23;
        tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_23 == NULL ))
        {
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_23 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 156;

            goto frame_exception_exit_1;
        }

        tmp_source_name_23 = tmp_mvar_value_23;
        tmp_assign_source_67 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_SSL_OP_MSIE_SSLV2_RSA_PADDING );
        if ( tmp_assign_source_67 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 156;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_MSIE_SSLV2_RSA_PADDING, tmp_assign_source_67 );
    }
    {
        PyObject *tmp_assign_source_68;
        PyObject *tmp_source_name_24;
        PyObject *tmp_mvar_value_24;
        tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_24 == NULL ))
        {
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_24 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 157;

            goto frame_exception_exit_1;
        }

        tmp_source_name_24 = tmp_mvar_value_24;
        tmp_assign_source_68 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_SSL_OP_SSLEAY_080_CLIENT_DH_BUG );
        if ( tmp_assign_source_68 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 157;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_SSLEAY_080_CLIENT_DH_BUG, tmp_assign_source_68 );
    }
    {
        PyObject *tmp_assign_source_69;
        PyObject *tmp_source_name_25;
        PyObject *tmp_mvar_value_25;
        tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_25 == NULL ))
        {
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_25 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 158;

            goto frame_exception_exit_1;
        }

        tmp_source_name_25 = tmp_mvar_value_25;
        tmp_assign_source_69 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain_SSL_OP_TLS_D5_BUG );
        if ( tmp_assign_source_69 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_D5_BUG, tmp_assign_source_69 );
    }
    {
        PyObject *tmp_assign_source_70;
        PyObject *tmp_source_name_26;
        PyObject *tmp_mvar_value_26;
        tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_26 == NULL ))
        {
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_26 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 159;

            goto frame_exception_exit_1;
        }

        tmp_source_name_26 = tmp_mvar_value_26;
        tmp_assign_source_70 = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain_SSL_OP_TLS_BLOCK_PADDING_BUG );
        if ( tmp_assign_source_70 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 159;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_BLOCK_PADDING_BUG, tmp_assign_source_70 );
    }
    {
        PyObject *tmp_assign_source_71;
        PyObject *tmp_source_name_27;
        PyObject *tmp_mvar_value_27;
        tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_27 == NULL ))
        {
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_27 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 160;

            goto frame_exception_exit_1;
        }

        tmp_source_name_27 = tmp_mvar_value_27;
        tmp_assign_source_71 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain_SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS );
        if ( tmp_assign_source_71 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 160;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_DONT_INSERT_EMPTY_FRAGMENTS, tmp_assign_source_71 );
    }
    {
        PyObject *tmp_assign_source_72;
        PyObject *tmp_source_name_28;
        PyObject *tmp_mvar_value_28;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_28 == NULL ))
        {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_28 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 161;

            goto frame_exception_exit_1;
        }

        tmp_source_name_28 = tmp_mvar_value_28;
        tmp_assign_source_72 = LOOKUP_ATTRIBUTE( tmp_source_name_28, const_str_plain_SSL_OP_CIPHER_SERVER_PREFERENCE );
        if ( tmp_assign_source_72 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 161;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_CIPHER_SERVER_PREFERENCE, tmp_assign_source_72 );
    }
    {
        PyObject *tmp_assign_source_73;
        PyObject *tmp_source_name_29;
        PyObject *tmp_mvar_value_29;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_29 == NULL ))
        {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_29 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 162;

            goto frame_exception_exit_1;
        }

        tmp_source_name_29 = tmp_mvar_value_29;
        tmp_assign_source_73 = LOOKUP_ATTRIBUTE( tmp_source_name_29, const_str_plain_SSL_OP_TLS_ROLLBACK_BUG );
        if ( tmp_assign_source_73 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 162;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_TLS_ROLLBACK_BUG, tmp_assign_source_73 );
    }
    {
        PyObject *tmp_assign_source_74;
        PyObject *tmp_source_name_30;
        PyObject *tmp_mvar_value_30;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_30 == NULL ))
        {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_30 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 163;

            goto frame_exception_exit_1;
        }

        tmp_source_name_30 = tmp_mvar_value_30;
        tmp_assign_source_74 = LOOKUP_ATTRIBUTE( tmp_source_name_30, const_str_plain_SSL_OP_PKCS1_CHECK_1 );
        if ( tmp_assign_source_74 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 163;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_PKCS1_CHECK_1, tmp_assign_source_74 );
    }
    {
        PyObject *tmp_assign_source_75;
        PyObject *tmp_source_name_31;
        PyObject *tmp_mvar_value_31;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_31 == NULL ))
        {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_31 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 164;

            goto frame_exception_exit_1;
        }

        tmp_source_name_31 = tmp_mvar_value_31;
        tmp_assign_source_75 = LOOKUP_ATTRIBUTE( tmp_source_name_31, const_str_plain_SSL_OP_PKCS1_CHECK_2 );
        if ( tmp_assign_source_75 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 164;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_PKCS1_CHECK_2, tmp_assign_source_75 );
    }
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_source_name_32;
        PyObject *tmp_mvar_value_32;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_32 == NULL ))
        {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_32 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 165;

            goto frame_exception_exit_1;
        }

        tmp_source_name_32 = tmp_mvar_value_32;
        tmp_assign_source_76 = LOOKUP_ATTRIBUTE( tmp_source_name_32, const_str_plain_SSL_OP_NETSCAPE_CA_DN_BUG );
        if ( tmp_assign_source_76 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 165;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_CA_DN_BUG, tmp_assign_source_76 );
    }
    {
        PyObject *tmp_assign_source_77;
        PyObject *tmp_source_name_33;
        PyObject *tmp_mvar_value_33;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_33 == NULL ))
        {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_33 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 167;

            goto frame_exception_exit_1;
        }

        tmp_source_name_33 = tmp_mvar_value_33;
        tmp_assign_source_77 = LOOKUP_ATTRIBUTE( tmp_source_name_33, const_str_plain_SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG );
        if ( tmp_assign_source_77 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 167;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG, tmp_assign_source_77 );
    }
    {
        PyObject *tmp_assign_source_78;
        PyObject *tmp_source_name_34;
        PyObject *tmp_mvar_value_34;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_34 == NULL ))
        {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_34 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 169;

            goto frame_exception_exit_1;
        }

        tmp_source_name_34 = tmp_mvar_value_34;
        tmp_assign_source_78 = LOOKUP_ATTRIBUTE( tmp_source_name_34, const_str_plain_SSL_OP_NO_COMPRESSION );
        if ( tmp_assign_source_78 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 169;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_COMPRESSION, tmp_assign_source_78 );
    }
    {
        PyObject *tmp_assign_source_79;
        PyObject *tmp_source_name_35;
        PyObject *tmp_mvar_value_35;
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_35 == NULL ))
        {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_35 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 171;

            goto frame_exception_exit_1;
        }

        tmp_source_name_35 = tmp_mvar_value_35;
        tmp_assign_source_79 = LOOKUP_ATTRIBUTE( tmp_source_name_35, const_str_plain_SSL_OP_NO_QUERY_MTU );
        if ( tmp_assign_source_79 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_QUERY_MTU, tmp_assign_source_79 );
    }
    {
        PyObject *tmp_assign_source_80;
        PyObject *tmp_source_name_36;
        PyObject *tmp_mvar_value_36;
        tmp_mvar_value_36 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_36 == NULL ))
        {
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_36 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 172;

            goto frame_exception_exit_1;
        }

        tmp_source_name_36 = tmp_mvar_value_36;
        tmp_assign_source_80 = LOOKUP_ATTRIBUTE( tmp_source_name_36, const_str_plain_SSL_OP_COOKIE_EXCHANGE );
        if ( tmp_assign_source_80 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 172;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_COOKIE_EXCHANGE, tmp_assign_source_80 );
    }
    {
        PyObject *tmp_assign_source_81;
        PyObject *tmp_source_name_37;
        PyObject *tmp_mvar_value_37;
        tmp_mvar_value_37 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_37 == NULL ))
        {
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_37 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 173;

            goto frame_exception_exit_1;
        }

        tmp_source_name_37 = tmp_mvar_value_37;
        tmp_assign_source_81 = LOOKUP_ATTRIBUTE( tmp_source_name_37, const_str_plain_SSL_OP_NO_TICKET );
        if ( tmp_assign_source_81 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 173;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_NO_TICKET, tmp_assign_source_81 );
    }
    {
        PyObject *tmp_assign_source_82;
        PyObject *tmp_source_name_38;
        PyObject *tmp_mvar_value_38;
        tmp_mvar_value_38 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_38 == NULL ))
        {
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_38 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 175;

            goto frame_exception_exit_1;
        }

        tmp_source_name_38 = tmp_mvar_value_38;
        tmp_assign_source_82 = LOOKUP_ATTRIBUTE( tmp_source_name_38, const_str_plain_SSL_OP_ALL );
        if ( tmp_assign_source_82 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 175;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_OP_ALL, tmp_assign_source_82 );
    }
    {
        PyObject *tmp_assign_source_83;
        PyObject *tmp_source_name_39;
        PyObject *tmp_mvar_value_39;
        tmp_mvar_value_39 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_39 == NULL ))
        {
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_39 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 177;

            goto frame_exception_exit_1;
        }

        tmp_source_name_39 = tmp_mvar_value_39;
        tmp_assign_source_83 = LOOKUP_ATTRIBUTE( tmp_source_name_39, const_str_plain_SSL_VERIFY_PEER );
        if ( tmp_assign_source_83 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 177;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_PEER, tmp_assign_source_83 );
    }
    {
        PyObject *tmp_assign_source_84;
        PyObject *tmp_source_name_40;
        PyObject *tmp_mvar_value_40;
        tmp_mvar_value_40 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_40 == NULL ))
        {
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_40 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 178;

            goto frame_exception_exit_1;
        }

        tmp_source_name_40 = tmp_mvar_value_40;
        tmp_assign_source_84 = LOOKUP_ATTRIBUTE( tmp_source_name_40, const_str_plain_SSL_VERIFY_FAIL_IF_NO_PEER_CERT );
        if ( tmp_assign_source_84 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 178;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_FAIL_IF_NO_PEER_CERT, tmp_assign_source_84 );
    }
    {
        PyObject *tmp_assign_source_85;
        PyObject *tmp_source_name_41;
        PyObject *tmp_mvar_value_41;
        tmp_mvar_value_41 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_41 == NULL ))
        {
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_41 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 179;

            goto frame_exception_exit_1;
        }

        tmp_source_name_41 = tmp_mvar_value_41;
        tmp_assign_source_85 = LOOKUP_ATTRIBUTE( tmp_source_name_41, const_str_plain_SSL_VERIFY_CLIENT_ONCE );
        if ( tmp_assign_source_85 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 179;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_CLIENT_ONCE, tmp_assign_source_85 );
    }
    {
        PyObject *tmp_assign_source_86;
        PyObject *tmp_source_name_42;
        PyObject *tmp_mvar_value_42;
        tmp_mvar_value_42 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_42 == NULL ))
        {
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_42 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 180;

            goto frame_exception_exit_1;
        }

        tmp_source_name_42 = tmp_mvar_value_42;
        tmp_assign_source_86 = LOOKUP_ATTRIBUTE( tmp_source_name_42, const_str_plain_SSL_VERIFY_NONE );
        if ( tmp_assign_source_86 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 180;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_VERIFY_NONE, tmp_assign_source_86 );
    }
    {
        PyObject *tmp_assign_source_87;
        PyObject *tmp_source_name_43;
        PyObject *tmp_mvar_value_43;
        tmp_mvar_value_43 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_43 == NULL ))
        {
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_43 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 182;

            goto frame_exception_exit_1;
        }

        tmp_source_name_43 = tmp_mvar_value_43;
        tmp_assign_source_87 = LOOKUP_ATTRIBUTE( tmp_source_name_43, const_str_plain_SSL_SESS_CACHE_OFF );
        if ( tmp_assign_source_87 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 182;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_OFF, tmp_assign_source_87 );
    }
    {
        PyObject *tmp_assign_source_88;
        PyObject *tmp_source_name_44;
        PyObject *tmp_mvar_value_44;
        tmp_mvar_value_44 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_44 == NULL ))
        {
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_44 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 183;

            goto frame_exception_exit_1;
        }

        tmp_source_name_44 = tmp_mvar_value_44;
        tmp_assign_source_88 = LOOKUP_ATTRIBUTE( tmp_source_name_44, const_str_plain_SSL_SESS_CACHE_CLIENT );
        if ( tmp_assign_source_88 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 183;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_CLIENT, tmp_assign_source_88 );
    }
    {
        PyObject *tmp_assign_source_89;
        PyObject *tmp_source_name_45;
        PyObject *tmp_mvar_value_45;
        tmp_mvar_value_45 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_45 == NULL ))
        {
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_45 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 184;

            goto frame_exception_exit_1;
        }

        tmp_source_name_45 = tmp_mvar_value_45;
        tmp_assign_source_89 = LOOKUP_ATTRIBUTE( tmp_source_name_45, const_str_plain_SSL_SESS_CACHE_SERVER );
        if ( tmp_assign_source_89 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 184;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_SERVER, tmp_assign_source_89 );
    }
    {
        PyObject *tmp_assign_source_90;
        PyObject *tmp_source_name_46;
        PyObject *tmp_mvar_value_46;
        tmp_mvar_value_46 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_46 == NULL ))
        {
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_46 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 185;

            goto frame_exception_exit_1;
        }

        tmp_source_name_46 = tmp_mvar_value_46;
        tmp_assign_source_90 = LOOKUP_ATTRIBUTE( tmp_source_name_46, const_str_plain_SSL_SESS_CACHE_BOTH );
        if ( tmp_assign_source_90 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 185;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_BOTH, tmp_assign_source_90 );
    }
    {
        PyObject *tmp_assign_source_91;
        PyObject *tmp_source_name_47;
        PyObject *tmp_mvar_value_47;
        tmp_mvar_value_47 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_47 == NULL ))
        {
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_47 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 186;

            goto frame_exception_exit_1;
        }

        tmp_source_name_47 = tmp_mvar_value_47;
        tmp_assign_source_91 = LOOKUP_ATTRIBUTE( tmp_source_name_47, const_str_plain_SSL_SESS_CACHE_NO_AUTO_CLEAR );
        if ( tmp_assign_source_91 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 186;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_AUTO_CLEAR, tmp_assign_source_91 );
    }
    {
        PyObject *tmp_assign_source_92;
        PyObject *tmp_source_name_48;
        PyObject *tmp_mvar_value_48;
        tmp_mvar_value_48 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_48 == NULL ))
        {
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_48 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 187;

            goto frame_exception_exit_1;
        }

        tmp_source_name_48 = tmp_mvar_value_48;
        tmp_assign_source_92 = LOOKUP_ATTRIBUTE( tmp_source_name_48, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_LOOKUP );
        if ( tmp_assign_source_92 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 187;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL_LOOKUP, tmp_assign_source_92 );
    }
    {
        PyObject *tmp_assign_source_93;
        PyObject *tmp_source_name_49;
        PyObject *tmp_mvar_value_49;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_49 == NULL ))
        {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_49 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 188;

            goto frame_exception_exit_1;
        }

        tmp_source_name_49 = tmp_mvar_value_49;
        tmp_assign_source_93 = LOOKUP_ATTRIBUTE( tmp_source_name_49, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL_STORE );
        if ( tmp_assign_source_93 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 188;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL_STORE, tmp_assign_source_93 );
    }
    {
        PyObject *tmp_assign_source_94;
        PyObject *tmp_source_name_50;
        PyObject *tmp_mvar_value_50;
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_50 == NULL ))
        {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_50 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 189;

            goto frame_exception_exit_1;
        }

        tmp_source_name_50 = tmp_mvar_value_50;
        tmp_assign_source_94 = LOOKUP_ATTRIBUTE( tmp_source_name_50, const_str_plain_SSL_SESS_CACHE_NO_INTERNAL );
        if ( tmp_assign_source_94 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 189;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SESS_CACHE_NO_INTERNAL, tmp_assign_source_94 );
    }
    {
        PyObject *tmp_assign_source_95;
        PyObject *tmp_source_name_51;
        PyObject *tmp_mvar_value_51;
        tmp_mvar_value_51 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_51 == NULL ))
        {
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_51 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 191;

            goto frame_exception_exit_1;
        }

        tmp_source_name_51 = tmp_mvar_value_51;
        tmp_assign_source_95 = LOOKUP_ATTRIBUTE( tmp_source_name_51, const_str_plain_SSL_ST_CONNECT );
        if ( tmp_assign_source_95 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 191;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_CONNECT, tmp_assign_source_95 );
    }
    {
        PyObject *tmp_assign_source_96;
        PyObject *tmp_source_name_52;
        PyObject *tmp_mvar_value_52;
        tmp_mvar_value_52 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_52 == NULL ))
        {
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_52 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 192;

            goto frame_exception_exit_1;
        }

        tmp_source_name_52 = tmp_mvar_value_52;
        tmp_assign_source_96 = LOOKUP_ATTRIBUTE( tmp_source_name_52, const_str_plain_SSL_ST_ACCEPT );
        if ( tmp_assign_source_96 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 192;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_ACCEPT, tmp_assign_source_96 );
    }
    {
        PyObject *tmp_assign_source_97;
        PyObject *tmp_source_name_53;
        PyObject *tmp_mvar_value_53;
        tmp_mvar_value_53 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_53 == NULL ))
        {
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_53 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 193;

            goto frame_exception_exit_1;
        }

        tmp_source_name_53 = tmp_mvar_value_53;
        tmp_assign_source_97 = LOOKUP_ATTRIBUTE( tmp_source_name_53, const_str_plain_SSL_ST_MASK );
        if ( tmp_assign_source_97 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 193;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_MASK, tmp_assign_source_97 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_54;
        PyObject *tmp_mvar_value_54;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        tmp_mvar_value_54 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_54 == NULL ))
        {
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_54 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 194;

            goto frame_exception_exit_1;
        }

        tmp_source_name_54 = tmp_mvar_value_54;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_54, const_str_plain_Cryptography_HAS_SSL_ST );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 194;

            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 194;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_98;
            PyObject *tmp_source_name_55;
            PyObject *tmp_mvar_value_55;
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_55 == NULL ))
            {
                tmp_mvar_value_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_55 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 195;

                goto frame_exception_exit_1;
            }

            tmp_source_name_55 = tmp_mvar_value_55;
            tmp_assign_source_98 = LOOKUP_ATTRIBUTE( tmp_source_name_55, const_str_plain_SSL_ST_INIT );
            if ( tmp_assign_source_98 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 195;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_INIT, tmp_assign_source_98 );
        }
        {
            PyObject *tmp_assign_source_99;
            PyObject *tmp_source_name_56;
            PyObject *tmp_mvar_value_56;
            tmp_mvar_value_56 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_56 == NULL ))
            {
                tmp_mvar_value_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_56 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 196;

                goto frame_exception_exit_1;
            }

            tmp_source_name_56 = tmp_mvar_value_56;
            tmp_assign_source_99 = LOOKUP_ATTRIBUTE( tmp_source_name_56, const_str_plain_SSL_ST_BEFORE );
            if ( tmp_assign_source_99 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 196;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_BEFORE, tmp_assign_source_99 );
        }
        {
            PyObject *tmp_assign_source_100;
            PyObject *tmp_source_name_57;
            PyObject *tmp_mvar_value_57;
            tmp_mvar_value_57 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_57 == NULL ))
            {
                tmp_mvar_value_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_57 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 197;

                goto frame_exception_exit_1;
            }

            tmp_source_name_57 = tmp_mvar_value_57;
            tmp_assign_source_100 = LOOKUP_ATTRIBUTE( tmp_source_name_57, const_str_plain_SSL_ST_OK );
            if ( tmp_assign_source_100 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 197;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_OK, tmp_assign_source_100 );
        }
        {
            PyObject *tmp_assign_source_101;
            PyObject *tmp_source_name_58;
            PyObject *tmp_mvar_value_58;
            tmp_mvar_value_58 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_58 == NULL ))
            {
                tmp_mvar_value_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_58 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 198;

                goto frame_exception_exit_1;
            }

            tmp_source_name_58 = tmp_mvar_value_58;
            tmp_assign_source_101 = LOOKUP_ATTRIBUTE( tmp_source_name_58, const_str_plain_SSL_ST_RENEGOTIATE );
            if ( tmp_assign_source_101 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 198;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_ST_RENEGOTIATE, tmp_assign_source_101 );
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_59;
            PyObject *tmp_call_result_1;
            PyObject *tmp_call_arg_element_1;
            tmp_mvar_value_59 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___all__ );

            if (unlikely( tmp_mvar_value_59 == NULL ))
            {
                tmp_mvar_value_59 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___all__ );
            }

            if ( tmp_mvar_value_59 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__all__" );
                exception_tb = NULL;

                exception_lineno = 199;

                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_59;
            tmp_call_arg_element_1 = LIST_COPY( const_list_3574eb54ef4ecf6f2c0597b9df34708e_list );
            frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 199;
            {
                PyObject *call_args[] = { tmp_call_arg_element_1 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_extend, call_args );
            }

            Py_DECREF( tmp_call_arg_element_1 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 199;

                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_102;
        PyObject *tmp_source_name_59;
        PyObject *tmp_mvar_value_60;
        tmp_mvar_value_60 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_60 == NULL ))
        {
            tmp_mvar_value_60 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_60 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 206;

            goto frame_exception_exit_1;
        }

        tmp_source_name_59 = tmp_mvar_value_60;
        tmp_assign_source_102 = LOOKUP_ATTRIBUTE( tmp_source_name_59, const_str_plain_SSL_CB_LOOP );
        if ( tmp_assign_source_102 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 206;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_LOOP, tmp_assign_source_102 );
    }
    {
        PyObject *tmp_assign_source_103;
        PyObject *tmp_source_name_60;
        PyObject *tmp_mvar_value_61;
        tmp_mvar_value_61 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_61 == NULL ))
        {
            tmp_mvar_value_61 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_61 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 207;

            goto frame_exception_exit_1;
        }

        tmp_source_name_60 = tmp_mvar_value_61;
        tmp_assign_source_103 = LOOKUP_ATTRIBUTE( tmp_source_name_60, const_str_plain_SSL_CB_EXIT );
        if ( tmp_assign_source_103 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 207;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_EXIT, tmp_assign_source_103 );
    }
    {
        PyObject *tmp_assign_source_104;
        PyObject *tmp_source_name_61;
        PyObject *tmp_mvar_value_62;
        tmp_mvar_value_62 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_62 == NULL ))
        {
            tmp_mvar_value_62 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_62 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 208;

            goto frame_exception_exit_1;
        }

        tmp_source_name_61 = tmp_mvar_value_62;
        tmp_assign_source_104 = LOOKUP_ATTRIBUTE( tmp_source_name_61, const_str_plain_SSL_CB_READ );
        if ( tmp_assign_source_104 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 208;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_READ, tmp_assign_source_104 );
    }
    {
        PyObject *tmp_assign_source_105;
        PyObject *tmp_source_name_62;
        PyObject *tmp_mvar_value_63;
        tmp_mvar_value_63 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_63 == NULL ))
        {
            tmp_mvar_value_63 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_63 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 209;

            goto frame_exception_exit_1;
        }

        tmp_source_name_62 = tmp_mvar_value_63;
        tmp_assign_source_105 = LOOKUP_ATTRIBUTE( tmp_source_name_62, const_str_plain_SSL_CB_WRITE );
        if ( tmp_assign_source_105 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 209;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_WRITE, tmp_assign_source_105 );
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_source_name_63;
        PyObject *tmp_mvar_value_64;
        tmp_mvar_value_64 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_64 == NULL ))
        {
            tmp_mvar_value_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_64 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 210;

            goto frame_exception_exit_1;
        }

        tmp_source_name_63 = tmp_mvar_value_64;
        tmp_assign_source_106 = LOOKUP_ATTRIBUTE( tmp_source_name_63, const_str_plain_SSL_CB_ALERT );
        if ( tmp_assign_source_106 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 210;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ALERT, tmp_assign_source_106 );
    }
    {
        PyObject *tmp_assign_source_107;
        PyObject *tmp_source_name_64;
        PyObject *tmp_mvar_value_65;
        tmp_mvar_value_65 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_65 == NULL ))
        {
            tmp_mvar_value_65 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_65 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 211;

            goto frame_exception_exit_1;
        }

        tmp_source_name_64 = tmp_mvar_value_65;
        tmp_assign_source_107 = LOOKUP_ATTRIBUTE( tmp_source_name_64, const_str_plain_SSL_CB_READ_ALERT );
        if ( tmp_assign_source_107 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 211;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_READ_ALERT, tmp_assign_source_107 );
    }
    {
        PyObject *tmp_assign_source_108;
        PyObject *tmp_source_name_65;
        PyObject *tmp_mvar_value_66;
        tmp_mvar_value_66 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_66 == NULL ))
        {
            tmp_mvar_value_66 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_66 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 212;

            goto frame_exception_exit_1;
        }

        tmp_source_name_65 = tmp_mvar_value_66;
        tmp_assign_source_108 = LOOKUP_ATTRIBUTE( tmp_source_name_65, const_str_plain_SSL_CB_WRITE_ALERT );
        if ( tmp_assign_source_108 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 212;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_WRITE_ALERT, tmp_assign_source_108 );
    }
    {
        PyObject *tmp_assign_source_109;
        PyObject *tmp_source_name_66;
        PyObject *tmp_mvar_value_67;
        tmp_mvar_value_67 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_67 == NULL ))
        {
            tmp_mvar_value_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_67 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 213;

            goto frame_exception_exit_1;
        }

        tmp_source_name_66 = tmp_mvar_value_67;
        tmp_assign_source_109 = LOOKUP_ATTRIBUTE( tmp_source_name_66, const_str_plain_SSL_CB_ACCEPT_LOOP );
        if ( tmp_assign_source_109 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 213;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ACCEPT_LOOP, tmp_assign_source_109 );
    }
    {
        PyObject *tmp_assign_source_110;
        PyObject *tmp_source_name_67;
        PyObject *tmp_mvar_value_68;
        tmp_mvar_value_68 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_68 == NULL ))
        {
            tmp_mvar_value_68 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_68 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 214;

            goto frame_exception_exit_1;
        }

        tmp_source_name_67 = tmp_mvar_value_68;
        tmp_assign_source_110 = LOOKUP_ATTRIBUTE( tmp_source_name_67, const_str_plain_SSL_CB_ACCEPT_EXIT );
        if ( tmp_assign_source_110 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 214;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_ACCEPT_EXIT, tmp_assign_source_110 );
    }
    {
        PyObject *tmp_assign_source_111;
        PyObject *tmp_source_name_68;
        PyObject *tmp_mvar_value_69;
        tmp_mvar_value_69 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_69 == NULL ))
        {
            tmp_mvar_value_69 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_69 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 215;

            goto frame_exception_exit_1;
        }

        tmp_source_name_68 = tmp_mvar_value_69;
        tmp_assign_source_111 = LOOKUP_ATTRIBUTE( tmp_source_name_68, const_str_plain_SSL_CB_CONNECT_LOOP );
        if ( tmp_assign_source_111 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 215;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_CONNECT_LOOP, tmp_assign_source_111 );
    }
    {
        PyObject *tmp_assign_source_112;
        PyObject *tmp_source_name_69;
        PyObject *tmp_mvar_value_70;
        tmp_mvar_value_70 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_70 == NULL ))
        {
            tmp_mvar_value_70 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_70 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 216;

            goto frame_exception_exit_1;
        }

        tmp_source_name_69 = tmp_mvar_value_70;
        tmp_assign_source_112 = LOOKUP_ATTRIBUTE( tmp_source_name_69, const_str_plain_SSL_CB_CONNECT_EXIT );
        if ( tmp_assign_source_112 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 216;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_CONNECT_EXIT, tmp_assign_source_112 );
    }
    {
        PyObject *tmp_assign_source_113;
        PyObject *tmp_source_name_70;
        PyObject *tmp_mvar_value_71;
        tmp_mvar_value_71 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_71 == NULL ))
        {
            tmp_mvar_value_71 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_71 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 217;

            goto frame_exception_exit_1;
        }

        tmp_source_name_70 = tmp_mvar_value_71;
        tmp_assign_source_113 = LOOKUP_ATTRIBUTE( tmp_source_name_70, const_str_plain_SSL_CB_HANDSHAKE_START );
        if ( tmp_assign_source_113 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 217;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_HANDSHAKE_START, tmp_assign_source_113 );
    }
    {
        PyObject *tmp_assign_source_114;
        PyObject *tmp_source_name_71;
        PyObject *tmp_mvar_value_72;
        tmp_mvar_value_72 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_72 == NULL ))
        {
            tmp_mvar_value_72 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_72 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 218;

            goto frame_exception_exit_1;
        }

        tmp_source_name_71 = tmp_mvar_value_72;
        tmp_assign_source_114 = LOOKUP_ATTRIBUTE( tmp_source_name_71, const_str_plain_SSL_CB_HANDSHAKE_DONE );
        if ( tmp_assign_source_114 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 218;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSL_CB_HANDSHAKE_DONE, tmp_assign_source_114 );
    }
    {
        PyObject *tmp_assign_source_115;
        tmp_assign_source_115 = LIST_COPY( const_list_b44af29ad37821285e6b89a520342cf5_list );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_FILE_LOCATIONS, tmp_assign_source_115 );
    }
    {
        PyObject *tmp_assign_source_116;
        tmp_assign_source_116 = LIST_COPY( const_list_str_digest_746ae0014bb266cffee8b7b1473626af_list );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CERTIFICATE_PATH_LOCATIONS, tmp_assign_source_116 );
    }
    {
        PyObject *tmp_assign_source_117;
        tmp_assign_source_117 = const_str_digest_3b38b9684d0a691f727a5c25b49127cb;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_DIR, tmp_assign_source_117 );
    }
    {
        PyObject *tmp_assign_source_118;
        tmp_assign_source_118 = const_str_digest_04211c3d50cdc4f69d9c36018d92c12f;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CRYPTOGRAPHY_MANYLINUX1_CA_FILE, tmp_assign_source_118 );
    }
    {
        PyObject *tmp_assign_source_119;
        tmp_assign_source_119 = PyDict_Copy( const_dict_8204a0d80b2c8b5483fe77928e561739 );
        assert( tmp_class_creation_2__class_dict == NULL );
        tmp_class_creation_2__class_dict = tmp_assign_source_119;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_120;
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_1 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 239;

            goto try_except_handler_5;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_2 = tmp_class_creation_2__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_120 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
        if ( tmp_assign_source_120 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 239;

            goto try_except_handler_5;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_assign_source_120 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_120 );
        condexpr_end_1:;
        assert( tmp_class_creation_2__metaclass == NULL );
        tmp_class_creation_2__metaclass = tmp_assign_source_120;
    }
    {
        PyObject *tmp_assign_source_121;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( tmp_class_creation_2__metaclass );
        tmp_called_name_1 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_1 = const_str_plain_Error;
        tmp_args_element_name_2 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_args_element_name_3 = tmp_class_creation_2__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 239;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_121 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_121 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 239;

            goto try_except_handler_5;
        }
        assert( tmp_class_creation_2__class == NULL );
        tmp_class_creation_2__class = tmp_assign_source_121;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    {
        PyObject *tmp_assign_source_122;
        CHECK_OBJECT( tmp_class_creation_2__class );
        tmp_assign_source_122 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error, tmp_assign_source_122 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    {
        PyObject *tmp_assign_source_123;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_73;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_mvar_value_74;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_mvar_value_75;
        tmp_mvar_value_73 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_partial );

        if (unlikely( tmp_mvar_value_73 == NULL ))
        {
            tmp_mvar_value_73 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
        }

        if ( tmp_mvar_value_73 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "partial" );
            exception_tb = NULL;

            exception_lineno = 245;

            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_73;
        tmp_mvar_value_74 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );

        if (unlikely( tmp_mvar_value_74 == NULL ))
        {
            tmp_mvar_value_74 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );
        }

        if ( tmp_mvar_value_74 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_exception_from_error_queue" );
            exception_tb = NULL;

            exception_lineno = 245;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = tmp_mvar_value_74;
        tmp_mvar_value_75 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_75 == NULL ))
        {
            tmp_mvar_value_75 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_75 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 245;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_5 = tmp_mvar_value_75;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 245;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_123 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_123 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 245;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__raise_current_error, tmp_assign_source_123 );
    }
    {
        PyObject *tmp_assign_source_124;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_76;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_77;
        tmp_mvar_value_76 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_assert );

        if (unlikely( tmp_mvar_value_76 == NULL ))
        {
            tmp_mvar_value_76 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_assert );
        }

        if ( tmp_mvar_value_76 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_assert" );
            exception_tb = NULL;

            exception_lineno = 246;

            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_76;
        tmp_mvar_value_77 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_77 == NULL ))
        {
            tmp_mvar_value_77 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_77 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 246;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_6 = tmp_mvar_value_77;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 246;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_124 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_124 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 246;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__openssl_assert, tmp_assign_source_124 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_125;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_78;
        tmp_mvar_value_78 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_78 == NULL ))
        {
            tmp_mvar_value_78 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_78 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 249;

            goto try_except_handler_6;
        }

        tmp_tuple_element_1 = tmp_mvar_value_78;
        tmp_assign_source_125 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_assign_source_125, 0, tmp_tuple_element_1 );
        assert( tmp_class_creation_3__bases == NULL );
        tmp_class_creation_3__bases = tmp_assign_source_125;
    }
    {
        PyObject *tmp_assign_source_126;
        {
            PyObject *tmp_set_locals_1;
            tmp_set_locals_1 = PyDict_New();
            locals_OpenSSL$SSL_249 = tmp_set_locals_1;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_249, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_126 = locals_OpenSSL$SSL_249;
        Py_INCREF( tmp_assign_source_126 );
        goto try_return_handler_7;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_7:;
        Py_DECREF( locals_OpenSSL$SSL_249 );
        locals_OpenSSL$SSL_249 = NULL;
        goto outline_result_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_1:;
        assert( tmp_class_creation_3__class_dict == NULL );
        tmp_class_creation_3__class_dict = tmp_assign_source_126;
    }
    {
        PyObject *tmp_assign_source_127;
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_key_name_4;
        tmp_key_name_3 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_3 = tmp_class_creation_3__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_3, tmp_key_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 249;

            goto try_except_handler_6;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_2;
        }
        else
        {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_4 = tmp_class_creation_3__class_dict;
        tmp_key_name_4 = const_str_plain___metaclass__;
        tmp_assign_source_127 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
        if ( tmp_assign_source_127 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 249;

            goto try_except_handler_6;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        {
            PyObject *tmp_assign_source_128;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_subscribed_name_1 = tmp_class_creation_3__bases;
            tmp_subscript_name_1 = const_int_0;
            tmp_assign_source_128 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_assign_source_128 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 249;

                goto try_except_handler_6;
            }
            assert( tmp_select_metaclass_3__base == NULL );
            tmp_select_metaclass_3__base = tmp_assign_source_128;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_72;
            CHECK_OBJECT( tmp_select_metaclass_3__base );
            tmp_source_name_72 = tmp_select_metaclass_3__base;
            tmp_assign_source_127 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_72 );
            if ( tmp_assign_source_127 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 249;

                goto try_except_handler_9;
            }
            goto try_return_handler_8;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_1;
            Py_DECREF( exception_keeper_type_6 );
            Py_XDECREF( exception_keeper_value_6 );
            Py_XDECREF( exception_keeper_tb_6 );
            CHECK_OBJECT( tmp_select_metaclass_3__base );
            tmp_type_arg_1 = tmp_select_metaclass_3__base;
            tmp_assign_source_127 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_assign_source_127 == NULL) );
            goto try_return_handler_8;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_8:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_3__base );
        Py_DECREF( tmp_select_metaclass_3__base );
        tmp_select_metaclass_3__base = NULL;

        goto outline_result_2;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_3__base );
        Py_DECREF( tmp_select_metaclass_3__base );
        tmp_select_metaclass_3__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_2:;
        condexpr_end_2:;
        assert( tmp_class_creation_3__metaclass == NULL );
        tmp_class_creation_3__metaclass = tmp_assign_source_127;
    }
    {
        PyObject *tmp_assign_source_129;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT( tmp_class_creation_3__metaclass );
        tmp_called_name_4 = tmp_class_creation_3__metaclass;
        tmp_args_element_name_7 = const_str_plain_WantReadError;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_args_element_name_8 = tmp_class_creation_3__bases;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_args_element_name_9 = tmp_class_creation_3__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 249;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_assign_source_129 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
        }

        if ( tmp_assign_source_129 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 249;

            goto try_except_handler_6;
        }
        assert( tmp_class_creation_3__class == NULL );
        tmp_class_creation_3__class = tmp_assign_source_129;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    Py_XDECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    {
        PyObject *tmp_assign_source_130;
        CHECK_OBJECT( tmp_class_creation_3__class );
        tmp_assign_source_130 = tmp_class_creation_3__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantReadError, tmp_assign_source_130 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases );
    Py_DECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_131;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_79;
        tmp_mvar_value_79 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_79 == NULL ))
        {
            tmp_mvar_value_79 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_79 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 253;

            goto try_except_handler_10;
        }

        tmp_tuple_element_2 = tmp_mvar_value_79;
        tmp_assign_source_131 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_assign_source_131, 0, tmp_tuple_element_2 );
        assert( tmp_class_creation_4__bases == NULL );
        tmp_class_creation_4__bases = tmp_assign_source_131;
    }
    {
        PyObject *tmp_assign_source_132;
        {
            PyObject *tmp_set_locals_2;
            tmp_set_locals_2 = PyDict_New();
            locals_OpenSSL$SSL_253 = tmp_set_locals_2;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_253, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_132 = locals_OpenSSL$SSL_253;
        Py_INCREF( tmp_assign_source_132 );
        goto try_return_handler_11;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_11:;
        Py_DECREF( locals_OpenSSL$SSL_253 );
        locals_OpenSSL$SSL_253 = NULL;
        goto outline_result_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_3:;
        assert( tmp_class_creation_4__class_dict == NULL );
        tmp_class_creation_4__class_dict = tmp_assign_source_132;
    }
    {
        PyObject *tmp_assign_source_133;
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_key_name_5;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_dict_name_6;
        PyObject *tmp_key_name_6;
        tmp_key_name_5 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_5 = tmp_class_creation_4__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_5, tmp_key_name_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 253;

            goto try_except_handler_10;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_3;
        }
        else
        {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_6 = tmp_class_creation_4__class_dict;
        tmp_key_name_6 = const_str_plain___metaclass__;
        tmp_assign_source_133 = DICT_GET_ITEM( tmp_dict_name_6, tmp_key_name_6 );
        if ( tmp_assign_source_133 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 253;

            goto try_except_handler_10;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        {
            PyObject *tmp_assign_source_134;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            CHECK_OBJECT( tmp_class_creation_4__bases );
            tmp_subscribed_name_2 = tmp_class_creation_4__bases;
            tmp_subscript_name_2 = const_int_0;
            tmp_assign_source_134 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
            if ( tmp_assign_source_134 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 253;

                goto try_except_handler_10;
            }
            assert( tmp_select_metaclass_4__base == NULL );
            tmp_select_metaclass_4__base = tmp_assign_source_134;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_73;
            CHECK_OBJECT( tmp_select_metaclass_4__base );
            tmp_source_name_73 = tmp_select_metaclass_4__base;
            tmp_assign_source_133 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_73 );
            if ( tmp_assign_source_133 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 253;

                goto try_except_handler_13;
            }
            goto try_return_handler_12;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_13:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_2;
            Py_DECREF( exception_keeper_type_8 );
            Py_XDECREF( exception_keeper_value_8 );
            Py_XDECREF( exception_keeper_tb_8 );
            CHECK_OBJECT( tmp_select_metaclass_4__base );
            tmp_type_arg_2 = tmp_select_metaclass_4__base;
            tmp_assign_source_133 = BUILTIN_TYPE1( tmp_type_arg_2 );
            assert( !(tmp_assign_source_133 == NULL) );
            goto try_return_handler_12;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_12:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
        Py_DECREF( tmp_select_metaclass_4__base );
        tmp_select_metaclass_4__base = NULL;

        goto outline_result_4;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
        Py_DECREF( tmp_select_metaclass_4__base );
        tmp_select_metaclass_4__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_4:;
        condexpr_end_3:;
        assert( tmp_class_creation_4__metaclass == NULL );
        tmp_class_creation_4__metaclass = tmp_assign_source_133;
    }
    {
        PyObject *tmp_assign_source_135;
        PyObject *tmp_called_name_5;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        CHECK_OBJECT( tmp_class_creation_4__metaclass );
        tmp_called_name_5 = tmp_class_creation_4__metaclass;
        tmp_args_element_name_10 = const_str_plain_WantWriteError;
        CHECK_OBJECT( tmp_class_creation_4__bases );
        tmp_args_element_name_11 = tmp_class_creation_4__bases;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_args_element_name_12 = tmp_class_creation_4__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 253;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_assign_source_135 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
        }

        if ( tmp_assign_source_135 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 253;

            goto try_except_handler_10;
        }
        assert( tmp_class_creation_4__class == NULL );
        tmp_class_creation_4__class = tmp_assign_source_135;
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_136;
        CHECK_OBJECT( tmp_class_creation_4__class );
        tmp_assign_source_136 = tmp_class_creation_4__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantWriteError, tmp_assign_source_136 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases );
    Py_DECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_137;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_mvar_value_80;
        tmp_mvar_value_80 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_80 == NULL ))
        {
            tmp_mvar_value_80 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_80 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 257;

            goto try_except_handler_14;
        }

        tmp_tuple_element_3 = tmp_mvar_value_80;
        tmp_assign_source_137 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_3 );
        PyTuple_SET_ITEM( tmp_assign_source_137, 0, tmp_tuple_element_3 );
        assert( tmp_class_creation_5__bases == NULL );
        tmp_class_creation_5__bases = tmp_assign_source_137;
    }
    {
        PyObject *tmp_assign_source_138;
        {
            PyObject *tmp_set_locals_3;
            tmp_set_locals_3 = PyDict_New();
            locals_OpenSSL$SSL_257 = tmp_set_locals_3;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_257, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_138 = locals_OpenSSL$SSL_257;
        Py_INCREF( tmp_assign_source_138 );
        goto try_return_handler_15;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_15:;
        Py_DECREF( locals_OpenSSL$SSL_257 );
        locals_OpenSSL$SSL_257 = NULL;
        goto outline_result_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_5:;
        assert( tmp_class_creation_5__class_dict == NULL );
        tmp_class_creation_5__class_dict = tmp_assign_source_138;
    }
    {
        PyObject *tmp_assign_source_139;
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        tmp_key_name_7 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_7 = tmp_class_creation_5__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_7, tmp_key_name_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 257;

            goto try_except_handler_14;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_4;
        }
        else
        {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_8 = tmp_class_creation_5__class_dict;
        tmp_key_name_8 = const_str_plain___metaclass__;
        tmp_assign_source_139 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
        if ( tmp_assign_source_139 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 257;

            goto try_except_handler_14;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        {
            PyObject *tmp_assign_source_140;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            CHECK_OBJECT( tmp_class_creation_5__bases );
            tmp_subscribed_name_3 = tmp_class_creation_5__bases;
            tmp_subscript_name_3 = const_int_0;
            tmp_assign_source_140 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
            if ( tmp_assign_source_140 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 257;

                goto try_except_handler_14;
            }
            assert( tmp_select_metaclass_5__base == NULL );
            tmp_select_metaclass_5__base = tmp_assign_source_140;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_74;
            CHECK_OBJECT( tmp_select_metaclass_5__base );
            tmp_source_name_74 = tmp_select_metaclass_5__base;
            tmp_assign_source_139 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_74 );
            if ( tmp_assign_source_139 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 257;

                goto try_except_handler_17;
            }
            goto try_return_handler_16;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_17:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_3;
            Py_DECREF( exception_keeper_type_10 );
            Py_XDECREF( exception_keeper_value_10 );
            Py_XDECREF( exception_keeper_tb_10 );
            CHECK_OBJECT( tmp_select_metaclass_5__base );
            tmp_type_arg_3 = tmp_select_metaclass_5__base;
            tmp_assign_source_139 = BUILTIN_TYPE1( tmp_type_arg_3 );
            assert( !(tmp_assign_source_139 == NULL) );
            goto try_return_handler_16;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_16:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
        Py_DECREF( tmp_select_metaclass_5__base );
        tmp_select_metaclass_5__base = NULL;

        goto outline_result_6;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
        Py_DECREF( tmp_select_metaclass_5__base );
        tmp_select_metaclass_5__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_6:;
        condexpr_end_4:;
        assert( tmp_class_creation_5__metaclass == NULL );
        tmp_class_creation_5__metaclass = tmp_assign_source_139;
    }
    {
        PyObject *tmp_assign_source_141;
        PyObject *tmp_called_name_6;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        CHECK_OBJECT( tmp_class_creation_5__metaclass );
        tmp_called_name_6 = tmp_class_creation_5__metaclass;
        tmp_args_element_name_13 = const_str_plain_WantX509LookupError;
        CHECK_OBJECT( tmp_class_creation_5__bases );
        tmp_args_element_name_14 = tmp_class_creation_5__bases;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_args_element_name_15 = tmp_class_creation_5__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 257;
        {
            PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15 };
            tmp_assign_source_141 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, call_args );
        }

        if ( tmp_assign_source_141 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 257;

            goto try_except_handler_14;
        }
        assert( tmp_class_creation_5__class == NULL );
        tmp_class_creation_5__class = tmp_assign_source_141;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    Py_XDECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    {
        PyObject *tmp_assign_source_142;
        CHECK_OBJECT( tmp_class_creation_5__class );
        tmp_assign_source_142 = tmp_class_creation_5__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WantX509LookupError, tmp_assign_source_142 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class );
    Py_DECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__bases );
    Py_DECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_dict );
    Py_DECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_143;
        PyObject *tmp_tuple_element_4;
        PyObject *tmp_mvar_value_81;
        tmp_mvar_value_81 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_81 == NULL ))
        {
            tmp_mvar_value_81 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_81 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 261;

            goto try_except_handler_18;
        }

        tmp_tuple_element_4 = tmp_mvar_value_81;
        tmp_assign_source_143 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_4 );
        PyTuple_SET_ITEM( tmp_assign_source_143, 0, tmp_tuple_element_4 );
        assert( tmp_class_creation_6__bases == NULL );
        tmp_class_creation_6__bases = tmp_assign_source_143;
    }
    {
        PyObject *tmp_assign_source_144;
        {
            PyObject *tmp_set_locals_4;
            tmp_set_locals_4 = PyDict_New();
            locals_OpenSSL$SSL_261 = tmp_set_locals_4;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_261, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_144 = locals_OpenSSL$SSL_261;
        Py_INCREF( tmp_assign_source_144 );
        goto try_return_handler_19;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_19:;
        Py_DECREF( locals_OpenSSL$SSL_261 );
        locals_OpenSSL$SSL_261 = NULL;
        goto outline_result_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_7:;
        assert( tmp_class_creation_6__class_dict == NULL );
        tmp_class_creation_6__class_dict = tmp_assign_source_144;
    }
    {
        PyObject *tmp_assign_source_145;
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_key_name_10;
        tmp_key_name_9 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_9 = tmp_class_creation_6__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_9, tmp_key_name_9 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 261;

            goto try_except_handler_18;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_5;
        }
        else
        {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_10 = tmp_class_creation_6__class_dict;
        tmp_key_name_10 = const_str_plain___metaclass__;
        tmp_assign_source_145 = DICT_GET_ITEM( tmp_dict_name_10, tmp_key_name_10 );
        if ( tmp_assign_source_145 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 261;

            goto try_except_handler_18;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        {
            PyObject *tmp_assign_source_146;
            PyObject *tmp_subscribed_name_4;
            PyObject *tmp_subscript_name_4;
            CHECK_OBJECT( tmp_class_creation_6__bases );
            tmp_subscribed_name_4 = tmp_class_creation_6__bases;
            tmp_subscript_name_4 = const_int_0;
            tmp_assign_source_146 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 0 );
            if ( tmp_assign_source_146 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 261;

                goto try_except_handler_18;
            }
            assert( tmp_select_metaclass_6__base == NULL );
            tmp_select_metaclass_6__base = tmp_assign_source_146;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_75;
            CHECK_OBJECT( tmp_select_metaclass_6__base );
            tmp_source_name_75 = tmp_select_metaclass_6__base;
            tmp_assign_source_145 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_75 );
            if ( tmp_assign_source_145 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 261;

                goto try_except_handler_21;
            }
            goto try_return_handler_20;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_21:;
        exception_keeper_type_12 = exception_type;
        exception_keeper_value_12 = exception_value;
        exception_keeper_tb_12 = exception_tb;
        exception_keeper_lineno_12 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_4;
            Py_DECREF( exception_keeper_type_12 );
            Py_XDECREF( exception_keeper_value_12 );
            Py_XDECREF( exception_keeper_tb_12 );
            CHECK_OBJECT( tmp_select_metaclass_6__base );
            tmp_type_arg_4 = tmp_select_metaclass_6__base;
            tmp_assign_source_145 = BUILTIN_TYPE1( tmp_type_arg_4 );
            assert( !(tmp_assign_source_145 == NULL) );
            goto try_return_handler_20;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_20:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_6__base );
        Py_DECREF( tmp_select_metaclass_6__base );
        tmp_select_metaclass_6__base = NULL;

        goto outline_result_8;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_6__base );
        Py_DECREF( tmp_select_metaclass_6__base );
        tmp_select_metaclass_6__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_8:;
        condexpr_end_5:;
        assert( tmp_class_creation_6__metaclass == NULL );
        tmp_class_creation_6__metaclass = tmp_assign_source_145;
    }
    {
        PyObject *tmp_assign_source_147;
        PyObject *tmp_called_name_7;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        CHECK_OBJECT( tmp_class_creation_6__metaclass );
        tmp_called_name_7 = tmp_class_creation_6__metaclass;
        tmp_args_element_name_16 = const_str_plain_ZeroReturnError;
        CHECK_OBJECT( tmp_class_creation_6__bases );
        tmp_args_element_name_17 = tmp_class_creation_6__bases;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_args_element_name_18 = tmp_class_creation_6__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 261;
        {
            PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18 };
            tmp_assign_source_147 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, call_args );
        }

        if ( tmp_assign_source_147 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 261;

            goto try_except_handler_18;
        }
        assert( tmp_class_creation_6__class == NULL );
        tmp_class_creation_6__class = tmp_assign_source_147;
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_18:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    Py_XDECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    {
        PyObject *tmp_assign_source_148;
        CHECK_OBJECT( tmp_class_creation_6__class );
        tmp_assign_source_148 = tmp_class_creation_6__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ZeroReturnError, tmp_assign_source_148 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class );
    Py_DECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__bases );
    Py_DECREF( tmp_class_creation_6__bases );
    tmp_class_creation_6__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_149;
        PyObject *tmp_tuple_element_5;
        PyObject *tmp_mvar_value_82;
        tmp_mvar_value_82 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_82 == NULL ))
        {
            tmp_mvar_value_82 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_82 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 265;

            goto try_except_handler_22;
        }

        tmp_tuple_element_5 = tmp_mvar_value_82;
        tmp_assign_source_149 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_5 );
        PyTuple_SET_ITEM( tmp_assign_source_149, 0, tmp_tuple_element_5 );
        assert( tmp_class_creation_7__bases == NULL );
        tmp_class_creation_7__bases = tmp_assign_source_149;
    }
    {
        PyObject *tmp_assign_source_150;
        {
            PyObject *tmp_set_locals_5;
            tmp_set_locals_5 = PyDict_New();
            locals_OpenSSL$SSL_265 = tmp_set_locals_5;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_265, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_150 = locals_OpenSSL$SSL_265;
        Py_INCREF( tmp_assign_source_150 );
        goto try_return_handler_23;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_23:;
        Py_DECREF( locals_OpenSSL$SSL_265 );
        locals_OpenSSL$SSL_265 = NULL;
        goto outline_result_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_9:;
        assert( tmp_class_creation_7__class_dict == NULL );
        tmp_class_creation_7__class_dict = tmp_assign_source_150;
    }
    {
        PyObject *tmp_assign_source_151;
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_key_name_11;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_dict_name_12;
        PyObject *tmp_key_name_12;
        tmp_key_name_11 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_11 = tmp_class_creation_7__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_11, tmp_key_name_11 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 265;

            goto try_except_handler_22;
        }
        tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_6;
        }
        else
        {
            goto condexpr_false_6;
        }
        condexpr_true_6:;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_12 = tmp_class_creation_7__class_dict;
        tmp_key_name_12 = const_str_plain___metaclass__;
        tmp_assign_source_151 = DICT_GET_ITEM( tmp_dict_name_12, tmp_key_name_12 );
        if ( tmp_assign_source_151 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 265;

            goto try_except_handler_22;
        }
        goto condexpr_end_6;
        condexpr_false_6:;
        {
            PyObject *tmp_assign_source_152;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            CHECK_OBJECT( tmp_class_creation_7__bases );
            tmp_subscribed_name_5 = tmp_class_creation_7__bases;
            tmp_subscript_name_5 = const_int_0;
            tmp_assign_source_152 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 0 );
            if ( tmp_assign_source_152 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 265;

                goto try_except_handler_22;
            }
            assert( tmp_select_metaclass_7__base == NULL );
            tmp_select_metaclass_7__base = tmp_assign_source_152;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_76;
            CHECK_OBJECT( tmp_select_metaclass_7__base );
            tmp_source_name_76 = tmp_select_metaclass_7__base;
            tmp_assign_source_151 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_76 );
            if ( tmp_assign_source_151 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 265;

                goto try_except_handler_25;
            }
            goto try_return_handler_24;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_25:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_5;
            Py_DECREF( exception_keeper_type_14 );
            Py_XDECREF( exception_keeper_value_14 );
            Py_XDECREF( exception_keeper_tb_14 );
            CHECK_OBJECT( tmp_select_metaclass_7__base );
            tmp_type_arg_5 = tmp_select_metaclass_7__base;
            tmp_assign_source_151 = BUILTIN_TYPE1( tmp_type_arg_5 );
            assert( !(tmp_assign_source_151 == NULL) );
            goto try_return_handler_24;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_24:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_7__base );
        Py_DECREF( tmp_select_metaclass_7__base );
        tmp_select_metaclass_7__base = NULL;

        goto outline_result_10;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_7__base );
        Py_DECREF( tmp_select_metaclass_7__base );
        tmp_select_metaclass_7__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_10:;
        condexpr_end_6:;
        assert( tmp_class_creation_7__metaclass == NULL );
        tmp_class_creation_7__metaclass = tmp_assign_source_151;
    }
    {
        PyObject *tmp_assign_source_153;
        PyObject *tmp_called_name_8;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        PyObject *tmp_args_element_name_21;
        CHECK_OBJECT( tmp_class_creation_7__metaclass );
        tmp_called_name_8 = tmp_class_creation_7__metaclass;
        tmp_args_element_name_19 = const_str_plain_SysCallError;
        CHECK_OBJECT( tmp_class_creation_7__bases );
        tmp_args_element_name_20 = tmp_class_creation_7__bases;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_args_element_name_21 = tmp_class_creation_7__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 265;
        {
            PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21 };
            tmp_assign_source_153 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
        }

        if ( tmp_assign_source_153 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 265;

            goto try_except_handler_22;
        }
        assert( tmp_class_creation_7__class == NULL );
        tmp_class_creation_7__class = tmp_assign_source_153;
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    Py_XDECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    {
        PyObject *tmp_assign_source_154;
        CHECK_OBJECT( tmp_class_creation_7__class );
        tmp_assign_source_154 = tmp_class_creation_7__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SysCallError, tmp_assign_source_154 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class );
    Py_DECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__bases );
    Py_DECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_dict );
    Py_DECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    {
        PyObject *tmp_assign_source_155;
        {
            PyObject *tmp_assign_source_156;
            tmp_assign_source_156 = MAKE_FUNCTION_OpenSSL$SSL$$$function_1___init__(  );



            assert( tmp_locals_OpenSSL$SSL_269_key___init__ == NULL );
            tmp_locals_OpenSSL$SSL_269_key___init__ = tmp_assign_source_156;
        }
        {
            PyObject *tmp_assign_source_157;
            tmp_assign_source_157 = MAKE_FUNCTION_OpenSSL$SSL$$$function_2_raise_if_problem(  );



            assert( tmp_locals_OpenSSL$SSL_269_key_raise_if_problem == NULL );
            tmp_locals_OpenSSL$SSL_269_key_raise_if_problem = tmp_assign_source_157;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            PyObject *tmp_dict_key_4;
            PyObject *tmp_dict_value_4;
            tmp_dict_value_1 = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_155 = _PyDict_NewPresized( 4 );
            tmp_res = PyDict_SetItem( tmp_assign_source_155, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_2 = const_str_digest_03a9c0f25246f86801453ac49af67056;
            tmp_dict_key_2 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_155, tmp_dict_key_2, tmp_dict_value_2 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$SSL_269_key___init__ );
            tmp_dict_value_3 = tmp_locals_OpenSSL$SSL_269_key___init__;
            tmp_dict_key_3 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_155, tmp_dict_key_3, tmp_dict_value_3 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$SSL_269_key_raise_if_problem );
            tmp_dict_value_4 = tmp_locals_OpenSSL$SSL_269_key_raise_if_problem;
            tmp_dict_key_4 = const_str_plain_raise_if_problem;
            tmp_res = PyDict_SetItem( tmp_assign_source_155, tmp_dict_key_4, tmp_dict_value_4 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_26;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_26:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$SSL_269_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$SSL_269_key___init__ );
        tmp_locals_OpenSSL$SSL_269_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$SSL_269_key_raise_if_problem );
        Py_DECREF( tmp_locals_OpenSSL$SSL_269_key_raise_if_problem );
        tmp_locals_OpenSSL$SSL_269_key_raise_if_problem = NULL;

        goto outline_result_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_11:;
        assert( tmp_class_creation_8__class_dict == NULL );
        tmp_class_creation_8__class_dict = tmp_assign_source_155;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_158;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        tmp_key_name_13 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_13 = tmp_class_creation_8__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_13, tmp_key_name_13 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 269;

            goto try_except_handler_27;
        }
        tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_7;
        }
        else
        {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_14 = tmp_class_creation_8__class_dict;
        tmp_key_name_14 = const_str_plain___metaclass__;
        tmp_assign_source_158 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
        if ( tmp_assign_source_158 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 269;

            goto try_except_handler_27;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        tmp_assign_source_158 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_158 );
        condexpr_end_7:;
        assert( tmp_class_creation_8__metaclass == NULL );
        tmp_class_creation_8__metaclass = tmp_assign_source_158;
    }
    {
        PyObject *tmp_assign_source_159;
        PyObject *tmp_called_name_9;
        PyObject *tmp_args_element_name_22;
        PyObject *tmp_args_element_name_23;
        PyObject *tmp_args_element_name_24;
        CHECK_OBJECT( tmp_class_creation_8__metaclass );
        tmp_called_name_9 = tmp_class_creation_8__metaclass;
        tmp_args_element_name_22 = const_str_plain__CallbackExceptionHelper;
        tmp_args_element_name_23 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_args_element_name_24 = tmp_class_creation_8__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 269;
        {
            PyObject *call_args[] = { tmp_args_element_name_22, tmp_args_element_name_23, tmp_args_element_name_24 };
            tmp_assign_source_159 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
        }

        if ( tmp_assign_source_159 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 269;

            goto try_except_handler_27;
        }
        assert( tmp_class_creation_8__class == NULL );
        tmp_class_creation_8__class = tmp_assign_source_159;
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_27:;
    exception_keeper_type_16 = exception_type;
    exception_keeper_value_16 = exception_value;
    exception_keeper_tb_16 = exception_tb;
    exception_keeper_lineno_16 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_16;
    exception_value = exception_keeper_value_16;
    exception_tb = exception_keeper_tb_16;
    exception_lineno = exception_keeper_lineno_16;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    {
        PyObject *tmp_assign_source_160;
        CHECK_OBJECT( tmp_class_creation_8__class );
        tmp_assign_source_160 = tmp_class_creation_8__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper, tmp_assign_source_160 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class );
    Py_DECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_161;
        PyObject *tmp_tuple_element_6;
        PyObject *tmp_mvar_value_83;
        tmp_mvar_value_83 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_83 == NULL ))
        {
            tmp_mvar_value_83 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_83 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 297;

            goto try_except_handler_28;
        }

        tmp_tuple_element_6 = tmp_mvar_value_83;
        tmp_assign_source_161 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_6 );
        PyTuple_SET_ITEM( tmp_assign_source_161, 0, tmp_tuple_element_6 );
        assert( tmp_class_creation_9__bases == NULL );
        tmp_class_creation_9__bases = tmp_assign_source_161;
    }
    {
        PyObject *tmp_assign_source_162;
        {
            PyObject *tmp_set_locals_6;
            tmp_set_locals_6 = PyDict_New();
            locals_OpenSSL$SSL_297 = tmp_set_locals_6;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_297, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_1494ae1301cb98a828389add570df55f;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_297, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_3___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_297, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_162 = locals_OpenSSL$SSL_297;
        Py_INCREF( tmp_assign_source_162 );
        goto try_return_handler_29;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_29:;
        Py_DECREF( locals_OpenSSL$SSL_297 );
        locals_OpenSSL$SSL_297 = NULL;
        goto outline_result_12;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_12:;
        assert( tmp_class_creation_9__class_dict == NULL );
        tmp_class_creation_9__class_dict = tmp_assign_source_162;
    }
    {
        PyObject *tmp_assign_source_163;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_key_name_16;
        tmp_key_name_15 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_15 = tmp_class_creation_9__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_15, tmp_key_name_15 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 297;

            goto try_except_handler_28;
        }
        tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_8;
        }
        else
        {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_16 = tmp_class_creation_9__class_dict;
        tmp_key_name_16 = const_str_plain___metaclass__;
        tmp_assign_source_163 = DICT_GET_ITEM( tmp_dict_name_16, tmp_key_name_16 );
        if ( tmp_assign_source_163 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 297;

            goto try_except_handler_28;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        {
            PyObject *tmp_assign_source_164;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            CHECK_OBJECT( tmp_class_creation_9__bases );
            tmp_subscribed_name_6 = tmp_class_creation_9__bases;
            tmp_subscript_name_6 = const_int_0;
            tmp_assign_source_164 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 0 );
            if ( tmp_assign_source_164 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 297;

                goto try_except_handler_28;
            }
            assert( tmp_select_metaclass_9__base == NULL );
            tmp_select_metaclass_9__base = tmp_assign_source_164;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_77;
            CHECK_OBJECT( tmp_select_metaclass_9__base );
            tmp_source_name_77 = tmp_select_metaclass_9__base;
            tmp_assign_source_163 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_77 );
            if ( tmp_assign_source_163 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 297;

                goto try_except_handler_31;
            }
            goto try_return_handler_30;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_31:;
        exception_keeper_type_17 = exception_type;
        exception_keeper_value_17 = exception_value;
        exception_keeper_tb_17 = exception_tb;
        exception_keeper_lineno_17 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_6;
            Py_DECREF( exception_keeper_type_17 );
            Py_XDECREF( exception_keeper_value_17 );
            Py_XDECREF( exception_keeper_tb_17 );
            CHECK_OBJECT( tmp_select_metaclass_9__base );
            tmp_type_arg_6 = tmp_select_metaclass_9__base;
            tmp_assign_source_163 = BUILTIN_TYPE1( tmp_type_arg_6 );
            assert( !(tmp_assign_source_163 == NULL) );
            goto try_return_handler_30;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_30:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
        Py_DECREF( tmp_select_metaclass_9__base );
        tmp_select_metaclass_9__base = NULL;

        goto outline_result_13;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
        Py_DECREF( tmp_select_metaclass_9__base );
        tmp_select_metaclass_9__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_13:;
        condexpr_end_8:;
        assert( tmp_class_creation_9__metaclass == NULL );
        tmp_class_creation_9__metaclass = tmp_assign_source_163;
    }
    {
        PyObject *tmp_assign_source_165;
        PyObject *tmp_called_name_10;
        PyObject *tmp_args_element_name_25;
        PyObject *tmp_args_element_name_26;
        PyObject *tmp_args_element_name_27;
        CHECK_OBJECT( tmp_class_creation_9__metaclass );
        tmp_called_name_10 = tmp_class_creation_9__metaclass;
        tmp_args_element_name_25 = const_str_plain__VerifyHelper;
        CHECK_OBJECT( tmp_class_creation_9__bases );
        tmp_args_element_name_26 = tmp_class_creation_9__bases;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_args_element_name_27 = tmp_class_creation_9__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 297;
        {
            PyObject *call_args[] = { tmp_args_element_name_25, tmp_args_element_name_26, tmp_args_element_name_27 };
            tmp_assign_source_165 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, call_args );
        }

        if ( tmp_assign_source_165 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 297;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_9__class == NULL );
        tmp_class_creation_9__class = tmp_assign_source_165;
    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    Py_XDECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    {
        PyObject *tmp_assign_source_166;
        CHECK_OBJECT( tmp_class_creation_9__class );
        tmp_assign_source_166 = tmp_class_creation_9__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__VerifyHelper, tmp_assign_source_166 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class );
    Py_DECREF( tmp_class_creation_9__class );
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__bases );
    Py_DECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_dict );
    Py_DECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_167;
        PyObject *tmp_tuple_element_7;
        PyObject *tmp_mvar_value_84;
        tmp_mvar_value_84 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_84 == NULL ))
        {
            tmp_mvar_value_84 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_84 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 336;

            goto try_except_handler_32;
        }

        tmp_tuple_element_7 = tmp_mvar_value_84;
        tmp_assign_source_167 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_7 );
        PyTuple_SET_ITEM( tmp_assign_source_167, 0, tmp_tuple_element_7 );
        assert( tmp_class_creation_10__bases == NULL );
        tmp_class_creation_10__bases = tmp_assign_source_167;
    }
    {
        PyObject *tmp_assign_source_168;
        {
            PyObject *tmp_set_locals_7;
            tmp_set_locals_7 = PyDict_New();
            locals_OpenSSL$SSL_336 = tmp_set_locals_7;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_336, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_bafb2b633667a6bc76266cfd60bf7f9d;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_336, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_4___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_336, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_168 = locals_OpenSSL$SSL_336;
        Py_INCREF( tmp_assign_source_168 );
        goto try_return_handler_33;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_33:;
        Py_DECREF( locals_OpenSSL$SSL_336 );
        locals_OpenSSL$SSL_336 = NULL;
        goto outline_result_14;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_14:;
        assert( tmp_class_creation_10__class_dict == NULL );
        tmp_class_creation_10__class_dict = tmp_assign_source_168;
    }
    {
        PyObject *tmp_assign_source_169;
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_17;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_dict_name_18;
        PyObject *tmp_key_name_18;
        tmp_key_name_17 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_17 = tmp_class_creation_10__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_17, tmp_key_name_17 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 336;

            goto try_except_handler_32;
        }
        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_9;
        }
        else
        {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_18 = tmp_class_creation_10__class_dict;
        tmp_key_name_18 = const_str_plain___metaclass__;
        tmp_assign_source_169 = DICT_GET_ITEM( tmp_dict_name_18, tmp_key_name_18 );
        if ( tmp_assign_source_169 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 336;

            goto try_except_handler_32;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        {
            PyObject *tmp_assign_source_170;
            PyObject *tmp_subscribed_name_7;
            PyObject *tmp_subscript_name_7;
            CHECK_OBJECT( tmp_class_creation_10__bases );
            tmp_subscribed_name_7 = tmp_class_creation_10__bases;
            tmp_subscript_name_7 = const_int_0;
            tmp_assign_source_170 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 0 );
            if ( tmp_assign_source_170 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 336;

                goto try_except_handler_32;
            }
            assert( tmp_select_metaclass_10__base == NULL );
            tmp_select_metaclass_10__base = tmp_assign_source_170;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_78;
            CHECK_OBJECT( tmp_select_metaclass_10__base );
            tmp_source_name_78 = tmp_select_metaclass_10__base;
            tmp_assign_source_169 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_78 );
            if ( tmp_assign_source_169 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 336;

                goto try_except_handler_35;
            }
            goto try_return_handler_34;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_35:;
        exception_keeper_type_19 = exception_type;
        exception_keeper_value_19 = exception_value;
        exception_keeper_tb_19 = exception_tb;
        exception_keeper_lineno_19 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_7;
            Py_DECREF( exception_keeper_type_19 );
            Py_XDECREF( exception_keeper_value_19 );
            Py_XDECREF( exception_keeper_tb_19 );
            CHECK_OBJECT( tmp_select_metaclass_10__base );
            tmp_type_arg_7 = tmp_select_metaclass_10__base;
            tmp_assign_source_169 = BUILTIN_TYPE1( tmp_type_arg_7 );
            assert( !(tmp_assign_source_169 == NULL) );
            goto try_return_handler_34;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_34:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
        Py_DECREF( tmp_select_metaclass_10__base );
        tmp_select_metaclass_10__base = NULL;

        goto outline_result_15;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
        Py_DECREF( tmp_select_metaclass_10__base );
        tmp_select_metaclass_10__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_15:;
        condexpr_end_9:;
        assert( tmp_class_creation_10__metaclass == NULL );
        tmp_class_creation_10__metaclass = tmp_assign_source_169;
    }
    {
        PyObject *tmp_assign_source_171;
        PyObject *tmp_called_name_11;
        PyObject *tmp_args_element_name_28;
        PyObject *tmp_args_element_name_29;
        PyObject *tmp_args_element_name_30;
        CHECK_OBJECT( tmp_class_creation_10__metaclass );
        tmp_called_name_11 = tmp_class_creation_10__metaclass;
        tmp_args_element_name_28 = const_str_plain__NpnAdvertiseHelper;
        CHECK_OBJECT( tmp_class_creation_10__bases );
        tmp_args_element_name_29 = tmp_class_creation_10__bases;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_args_element_name_30 = tmp_class_creation_10__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 336;
        {
            PyObject *call_args[] = { tmp_args_element_name_28, tmp_args_element_name_29, tmp_args_element_name_30 };
            tmp_assign_source_171 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_11, call_args );
        }

        if ( tmp_assign_source_171 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 336;

            goto try_except_handler_32;
        }
        assert( tmp_class_creation_10__class == NULL );
        tmp_class_creation_10__class = tmp_assign_source_171;
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    Py_XDECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    {
        PyObject *tmp_assign_source_172;
        CHECK_OBJECT( tmp_class_creation_10__class );
        tmp_assign_source_172 = tmp_class_creation_10__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnAdvertiseHelper, tmp_assign_source_172 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class );
    Py_DECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__bases );
    Py_DECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_173;
        PyObject *tmp_tuple_element_8;
        PyObject *tmp_mvar_value_85;
        tmp_mvar_value_85 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_85 == NULL ))
        {
            tmp_mvar_value_85 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_85 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 377;

            goto try_except_handler_36;
        }

        tmp_tuple_element_8 = tmp_mvar_value_85;
        tmp_assign_source_173 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_8 );
        PyTuple_SET_ITEM( tmp_assign_source_173, 0, tmp_tuple_element_8 );
        assert( tmp_class_creation_11__bases == NULL );
        tmp_class_creation_11__bases = tmp_assign_source_173;
    }
    {
        PyObject *tmp_assign_source_174;
        {
            PyObject *tmp_set_locals_8;
            tmp_set_locals_8 = PyDict_New();
            locals_OpenSSL$SSL_377 = tmp_set_locals_8;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_377, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_fded22d63d84a836b130c747fc61664e;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_377, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_5___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_377, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_174 = locals_OpenSSL$SSL_377;
        Py_INCREF( tmp_assign_source_174 );
        goto try_return_handler_37;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_37:;
        Py_DECREF( locals_OpenSSL$SSL_377 );
        locals_OpenSSL$SSL_377 = NULL;
        goto outline_result_16;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_16:;
        assert( tmp_class_creation_11__class_dict == NULL );
        tmp_class_creation_11__class_dict = tmp_assign_source_174;
    }
    {
        PyObject *tmp_assign_source_175;
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        tmp_key_name_19 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_19 = tmp_class_creation_11__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_19, tmp_key_name_19 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 377;

            goto try_except_handler_36;
        }
        tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_10;
        }
        else
        {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_20 = tmp_class_creation_11__class_dict;
        tmp_key_name_20 = const_str_plain___metaclass__;
        tmp_assign_source_175 = DICT_GET_ITEM( tmp_dict_name_20, tmp_key_name_20 );
        if ( tmp_assign_source_175 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 377;

            goto try_except_handler_36;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        {
            PyObject *tmp_assign_source_176;
            PyObject *tmp_subscribed_name_8;
            PyObject *tmp_subscript_name_8;
            CHECK_OBJECT( tmp_class_creation_11__bases );
            tmp_subscribed_name_8 = tmp_class_creation_11__bases;
            tmp_subscript_name_8 = const_int_0;
            tmp_assign_source_176 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_8, tmp_subscript_name_8, 0 );
            if ( tmp_assign_source_176 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 377;

                goto try_except_handler_36;
            }
            assert( tmp_select_metaclass_11__base == NULL );
            tmp_select_metaclass_11__base = tmp_assign_source_176;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_79;
            CHECK_OBJECT( tmp_select_metaclass_11__base );
            tmp_source_name_79 = tmp_select_metaclass_11__base;
            tmp_assign_source_175 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_79 );
            if ( tmp_assign_source_175 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 377;

                goto try_except_handler_39;
            }
            goto try_return_handler_38;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_39:;
        exception_keeper_type_21 = exception_type;
        exception_keeper_value_21 = exception_value;
        exception_keeper_tb_21 = exception_tb;
        exception_keeper_lineno_21 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_8;
            Py_DECREF( exception_keeper_type_21 );
            Py_XDECREF( exception_keeper_value_21 );
            Py_XDECREF( exception_keeper_tb_21 );
            CHECK_OBJECT( tmp_select_metaclass_11__base );
            tmp_type_arg_8 = tmp_select_metaclass_11__base;
            tmp_assign_source_175 = BUILTIN_TYPE1( tmp_type_arg_8 );
            assert( !(tmp_assign_source_175 == NULL) );
            goto try_return_handler_38;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_38:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
        Py_DECREF( tmp_select_metaclass_11__base );
        tmp_select_metaclass_11__base = NULL;

        goto outline_result_17;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
        Py_DECREF( tmp_select_metaclass_11__base );
        tmp_select_metaclass_11__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_17:;
        condexpr_end_10:;
        assert( tmp_class_creation_11__metaclass == NULL );
        tmp_class_creation_11__metaclass = tmp_assign_source_175;
    }
    {
        PyObject *tmp_assign_source_177;
        PyObject *tmp_called_name_12;
        PyObject *tmp_args_element_name_31;
        PyObject *tmp_args_element_name_32;
        PyObject *tmp_args_element_name_33;
        CHECK_OBJECT( tmp_class_creation_11__metaclass );
        tmp_called_name_12 = tmp_class_creation_11__metaclass;
        tmp_args_element_name_31 = const_str_plain__NpnSelectHelper;
        CHECK_OBJECT( tmp_class_creation_11__bases );
        tmp_args_element_name_32 = tmp_class_creation_11__bases;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_args_element_name_33 = tmp_class_creation_11__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 377;
        {
            PyObject *call_args[] = { tmp_args_element_name_31, tmp_args_element_name_32, tmp_args_element_name_33 };
            tmp_assign_source_177 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_12, call_args );
        }

        if ( tmp_assign_source_177 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 377;

            goto try_except_handler_36;
        }
        assert( tmp_class_creation_11__class == NULL );
        tmp_class_creation_11__class = tmp_assign_source_177;
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    Py_XDECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_22;
    exception_value = exception_keeper_value_22;
    exception_tb = exception_keeper_tb_22;
    exception_lineno = exception_keeper_lineno_22;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    {
        PyObject *tmp_assign_source_178;
        CHECK_OBJECT( tmp_class_creation_11__class );
        tmp_assign_source_178 = tmp_class_creation_11__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__NpnSelectHelper, tmp_assign_source_178 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class );
    Py_DECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases );
    Py_DECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_179;
        PyObject *tmp_tuple_element_9;
        PyObject *tmp_mvar_value_86;
        tmp_mvar_value_86 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_86 == NULL ))
        {
            tmp_mvar_value_86 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_86 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 426;

            goto try_except_handler_40;
        }

        tmp_tuple_element_9 = tmp_mvar_value_86;
        tmp_assign_source_179 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_9 );
        PyTuple_SET_ITEM( tmp_assign_source_179, 0, tmp_tuple_element_9 );
        assert( tmp_class_creation_12__bases == NULL );
        tmp_class_creation_12__bases = tmp_assign_source_179;
    }
    {
        PyObject *tmp_assign_source_180;
        {
            PyObject *tmp_set_locals_9;
            tmp_set_locals_9 = PyDict_New();
            locals_OpenSSL$SSL_426 = tmp_set_locals_9;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_426, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_a9a754c6f4c1dd488de35af4ae59537f;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_426, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_6___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_426, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_180 = locals_OpenSSL$SSL_426;
        Py_INCREF( tmp_assign_source_180 );
        goto try_return_handler_41;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_41:;
        Py_DECREF( locals_OpenSSL$SSL_426 );
        locals_OpenSSL$SSL_426 = NULL;
        goto outline_result_18;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_18:;
        assert( tmp_class_creation_12__class_dict == NULL );
        tmp_class_creation_12__class_dict = tmp_assign_source_180;
    }
    {
        PyObject *tmp_assign_source_181;
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_key_name_22;
        tmp_key_name_21 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_21 = tmp_class_creation_12__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_21, tmp_key_name_21 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 426;

            goto try_except_handler_40;
        }
        tmp_condition_result_12 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_11;
        }
        else
        {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_22 = tmp_class_creation_12__class_dict;
        tmp_key_name_22 = const_str_plain___metaclass__;
        tmp_assign_source_181 = DICT_GET_ITEM( tmp_dict_name_22, tmp_key_name_22 );
        if ( tmp_assign_source_181 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 426;

            goto try_except_handler_40;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        {
            PyObject *tmp_assign_source_182;
            PyObject *tmp_subscribed_name_9;
            PyObject *tmp_subscript_name_9;
            CHECK_OBJECT( tmp_class_creation_12__bases );
            tmp_subscribed_name_9 = tmp_class_creation_12__bases;
            tmp_subscript_name_9 = const_int_0;
            tmp_assign_source_182 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_9, tmp_subscript_name_9, 0 );
            if ( tmp_assign_source_182 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 426;

                goto try_except_handler_40;
            }
            assert( tmp_select_metaclass_12__base == NULL );
            tmp_select_metaclass_12__base = tmp_assign_source_182;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_80;
            CHECK_OBJECT( tmp_select_metaclass_12__base );
            tmp_source_name_80 = tmp_select_metaclass_12__base;
            tmp_assign_source_181 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_80 );
            if ( tmp_assign_source_181 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 426;

                goto try_except_handler_43;
            }
            goto try_return_handler_42;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_43:;
        exception_keeper_type_23 = exception_type;
        exception_keeper_value_23 = exception_value;
        exception_keeper_tb_23 = exception_tb;
        exception_keeper_lineno_23 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_9;
            Py_DECREF( exception_keeper_type_23 );
            Py_XDECREF( exception_keeper_value_23 );
            Py_XDECREF( exception_keeper_tb_23 );
            CHECK_OBJECT( tmp_select_metaclass_12__base );
            tmp_type_arg_9 = tmp_select_metaclass_12__base;
            tmp_assign_source_181 = BUILTIN_TYPE1( tmp_type_arg_9 );
            assert( !(tmp_assign_source_181 == NULL) );
            goto try_return_handler_42;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_42:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_12__base );
        Py_DECREF( tmp_select_metaclass_12__base );
        tmp_select_metaclass_12__base = NULL;

        goto outline_result_19;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_12__base );
        Py_DECREF( tmp_select_metaclass_12__base );
        tmp_select_metaclass_12__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_19:;
        condexpr_end_11:;
        assert( tmp_class_creation_12__metaclass == NULL );
        tmp_class_creation_12__metaclass = tmp_assign_source_181;
    }
    {
        PyObject *tmp_assign_source_183;
        PyObject *tmp_called_name_13;
        PyObject *tmp_args_element_name_34;
        PyObject *tmp_args_element_name_35;
        PyObject *tmp_args_element_name_36;
        CHECK_OBJECT( tmp_class_creation_12__metaclass );
        tmp_called_name_13 = tmp_class_creation_12__metaclass;
        tmp_args_element_name_34 = const_str_plain__ALPNSelectHelper;
        CHECK_OBJECT( tmp_class_creation_12__bases );
        tmp_args_element_name_35 = tmp_class_creation_12__bases;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_args_element_name_36 = tmp_class_creation_12__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 426;
        {
            PyObject *call_args[] = { tmp_args_element_name_34, tmp_args_element_name_35, tmp_args_element_name_36 };
            tmp_assign_source_183 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_13, call_args );
        }

        if ( tmp_assign_source_183 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 426;

            goto try_except_handler_40;
        }
        assert( tmp_class_creation_12__class == NULL );
        tmp_class_creation_12__class = tmp_assign_source_183;
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_12__bases );
    tmp_class_creation_12__bases = NULL;

    Py_XDECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_24;
    exception_value = exception_keeper_value_24;
    exception_tb = exception_keeper_tb_24;
    exception_lineno = exception_keeper_lineno_24;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    {
        PyObject *tmp_assign_source_184;
        CHECK_OBJECT( tmp_class_creation_12__class );
        tmp_assign_source_184 = tmp_class_creation_12__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__ALPNSelectHelper, tmp_assign_source_184 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class );
    Py_DECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__bases );
    Py_DECREF( tmp_class_creation_12__bases );
    tmp_class_creation_12__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_185;
        PyObject *tmp_tuple_element_10;
        PyObject *tmp_mvar_value_87;
        tmp_mvar_value_87 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_87 == NULL ))
        {
            tmp_mvar_value_87 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_87 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 477;

            goto try_except_handler_44;
        }

        tmp_tuple_element_10 = tmp_mvar_value_87;
        tmp_assign_source_185 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_10 );
        PyTuple_SET_ITEM( tmp_assign_source_185, 0, tmp_tuple_element_10 );
        assert( tmp_class_creation_13__bases == NULL );
        tmp_class_creation_13__bases = tmp_assign_source_185;
    }
    {
        PyObject *tmp_assign_source_186;
        {
            PyObject *tmp_set_locals_10;
            tmp_set_locals_10 = PyDict_New();
            locals_OpenSSL$SSL_477 = tmp_set_locals_10;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_477, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_ebc06328e68f0dbdd2e23e3f1f581b13;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_477, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_7___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_477, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_186 = locals_OpenSSL$SSL_477;
        Py_INCREF( tmp_assign_source_186 );
        goto try_return_handler_45;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_45:;
        Py_DECREF( locals_OpenSSL$SSL_477 );
        locals_OpenSSL$SSL_477 = NULL;
        goto outline_result_20;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_20:;
        assert( tmp_class_creation_13__class_dict == NULL );
        tmp_class_creation_13__class_dict = tmp_assign_source_186;
    }
    {
        PyObject *tmp_assign_source_187;
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_key_name_23;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_dict_name_24;
        PyObject *tmp_key_name_24;
        tmp_key_name_23 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_23 = tmp_class_creation_13__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_23, tmp_key_name_23 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 477;

            goto try_except_handler_44;
        }
        tmp_condition_result_13 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_12;
        }
        else
        {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_24 = tmp_class_creation_13__class_dict;
        tmp_key_name_24 = const_str_plain___metaclass__;
        tmp_assign_source_187 = DICT_GET_ITEM( tmp_dict_name_24, tmp_key_name_24 );
        if ( tmp_assign_source_187 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 477;

            goto try_except_handler_44;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        {
            PyObject *tmp_assign_source_188;
            PyObject *tmp_subscribed_name_10;
            PyObject *tmp_subscript_name_10;
            CHECK_OBJECT( tmp_class_creation_13__bases );
            tmp_subscribed_name_10 = tmp_class_creation_13__bases;
            tmp_subscript_name_10 = const_int_0;
            tmp_assign_source_188 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_10, tmp_subscript_name_10, 0 );
            if ( tmp_assign_source_188 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 477;

                goto try_except_handler_44;
            }
            assert( tmp_select_metaclass_13__base == NULL );
            tmp_select_metaclass_13__base = tmp_assign_source_188;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_81;
            CHECK_OBJECT( tmp_select_metaclass_13__base );
            tmp_source_name_81 = tmp_select_metaclass_13__base;
            tmp_assign_source_187 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_81 );
            if ( tmp_assign_source_187 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 477;

                goto try_except_handler_47;
            }
            goto try_return_handler_46;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_47:;
        exception_keeper_type_25 = exception_type;
        exception_keeper_value_25 = exception_value;
        exception_keeper_tb_25 = exception_tb;
        exception_keeper_lineno_25 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_10;
            Py_DECREF( exception_keeper_type_25 );
            Py_XDECREF( exception_keeper_value_25 );
            Py_XDECREF( exception_keeper_tb_25 );
            CHECK_OBJECT( tmp_select_metaclass_13__base );
            tmp_type_arg_10 = tmp_select_metaclass_13__base;
            tmp_assign_source_187 = BUILTIN_TYPE1( tmp_type_arg_10 );
            assert( !(tmp_assign_source_187 == NULL) );
            goto try_return_handler_46;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_46:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_13__base );
        Py_DECREF( tmp_select_metaclass_13__base );
        tmp_select_metaclass_13__base = NULL;

        goto outline_result_21;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_13__base );
        Py_DECREF( tmp_select_metaclass_13__base );
        tmp_select_metaclass_13__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_21:;
        condexpr_end_12:;
        assert( tmp_class_creation_13__metaclass == NULL );
        tmp_class_creation_13__metaclass = tmp_assign_source_187;
    }
    {
        PyObject *tmp_assign_source_189;
        PyObject *tmp_called_name_14;
        PyObject *tmp_args_element_name_37;
        PyObject *tmp_args_element_name_38;
        PyObject *tmp_args_element_name_39;
        CHECK_OBJECT( tmp_class_creation_13__metaclass );
        tmp_called_name_14 = tmp_class_creation_13__metaclass;
        tmp_args_element_name_37 = const_str_plain__OCSPServerCallbackHelper;
        CHECK_OBJECT( tmp_class_creation_13__bases );
        tmp_args_element_name_38 = tmp_class_creation_13__bases;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_args_element_name_39 = tmp_class_creation_13__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 477;
        {
            PyObject *call_args[] = { tmp_args_element_name_37, tmp_args_element_name_38, tmp_args_element_name_39 };
            tmp_assign_source_189 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_14, call_args );
        }

        if ( tmp_assign_source_189 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 477;

            goto try_except_handler_44;
        }
        assert( tmp_class_creation_13__class == NULL );
        tmp_class_creation_13__class = tmp_assign_source_189;
    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_44:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    Py_XDECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_26;
    exception_value = exception_keeper_value_26;
    exception_tb = exception_keeper_tb_26;
    exception_lineno = exception_keeper_lineno_26;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    {
        PyObject *tmp_assign_source_190;
        CHECK_OBJECT( tmp_class_creation_13__class );
        tmp_assign_source_190 = tmp_class_creation_13__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPServerCallbackHelper, tmp_assign_source_190 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class );
    Py_DECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__bases );
    Py_DECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_191;
        PyObject *tmp_tuple_element_11;
        PyObject *tmp_mvar_value_88;
        tmp_mvar_value_88 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );

        if (unlikely( tmp_mvar_value_88 == NULL ))
        {
            tmp_mvar_value_88 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CallbackExceptionHelper );
        }

        if ( tmp_mvar_value_88 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_CallbackExceptionHelper" );
            exception_tb = NULL;

            exception_lineno = 544;

            goto try_except_handler_48;
        }

        tmp_tuple_element_11 = tmp_mvar_value_88;
        tmp_assign_source_191 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_11 );
        PyTuple_SET_ITEM( tmp_assign_source_191, 0, tmp_tuple_element_11 );
        assert( tmp_class_creation_14__bases == NULL );
        tmp_class_creation_14__bases = tmp_assign_source_191;
    }
    {
        PyObject *tmp_assign_source_192;
        {
            PyObject *tmp_set_locals_11;
            tmp_set_locals_11 = PyDict_New();
            locals_OpenSSL$SSL_544 = tmp_set_locals_11;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_544, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_fd8757ca246c476601094123086e9a80;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_544, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_8___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_544, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_192 = locals_OpenSSL$SSL_544;
        Py_INCREF( tmp_assign_source_192 );
        goto try_return_handler_49;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_49:;
        Py_DECREF( locals_OpenSSL$SSL_544 );
        locals_OpenSSL$SSL_544 = NULL;
        goto outline_result_22;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_22:;
        assert( tmp_class_creation_14__class_dict == NULL );
        tmp_class_creation_14__class_dict = tmp_assign_source_192;
    }
    {
        PyObject *tmp_assign_source_193;
        nuitka_bool tmp_condition_result_14;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        tmp_key_name_25 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_25 = tmp_class_creation_14__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_25, tmp_key_name_25 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 544;

            goto try_except_handler_48;
        }
        tmp_condition_result_14 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_13;
        }
        else
        {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_26 = tmp_class_creation_14__class_dict;
        tmp_key_name_26 = const_str_plain___metaclass__;
        tmp_assign_source_193 = DICT_GET_ITEM( tmp_dict_name_26, tmp_key_name_26 );
        if ( tmp_assign_source_193 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 544;

            goto try_except_handler_48;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        {
            PyObject *tmp_assign_source_194;
            PyObject *tmp_subscribed_name_11;
            PyObject *tmp_subscript_name_11;
            CHECK_OBJECT( tmp_class_creation_14__bases );
            tmp_subscribed_name_11 = tmp_class_creation_14__bases;
            tmp_subscript_name_11 = const_int_0;
            tmp_assign_source_194 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_11, tmp_subscript_name_11, 0 );
            if ( tmp_assign_source_194 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 544;

                goto try_except_handler_48;
            }
            assert( tmp_select_metaclass_14__base == NULL );
            tmp_select_metaclass_14__base = tmp_assign_source_194;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_82;
            CHECK_OBJECT( tmp_select_metaclass_14__base );
            tmp_source_name_82 = tmp_select_metaclass_14__base;
            tmp_assign_source_193 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_82 );
            if ( tmp_assign_source_193 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 544;

                goto try_except_handler_51;
            }
            goto try_return_handler_50;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_51:;
        exception_keeper_type_27 = exception_type;
        exception_keeper_value_27 = exception_value;
        exception_keeper_tb_27 = exception_tb;
        exception_keeper_lineno_27 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_11;
            Py_DECREF( exception_keeper_type_27 );
            Py_XDECREF( exception_keeper_value_27 );
            Py_XDECREF( exception_keeper_tb_27 );
            CHECK_OBJECT( tmp_select_metaclass_14__base );
            tmp_type_arg_11 = tmp_select_metaclass_14__base;
            tmp_assign_source_193 = BUILTIN_TYPE1( tmp_type_arg_11 );
            assert( !(tmp_assign_source_193 == NULL) );
            goto try_return_handler_50;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_50:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_14__base );
        Py_DECREF( tmp_select_metaclass_14__base );
        tmp_select_metaclass_14__base = NULL;

        goto outline_result_23;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_14__base );
        Py_DECREF( tmp_select_metaclass_14__base );
        tmp_select_metaclass_14__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_result_23:;
        condexpr_end_13:;
        assert( tmp_class_creation_14__metaclass == NULL );
        tmp_class_creation_14__metaclass = tmp_assign_source_193;
    }
    {
        PyObject *tmp_assign_source_195;
        PyObject *tmp_called_name_15;
        PyObject *tmp_args_element_name_40;
        PyObject *tmp_args_element_name_41;
        PyObject *tmp_args_element_name_42;
        CHECK_OBJECT( tmp_class_creation_14__metaclass );
        tmp_called_name_15 = tmp_class_creation_14__metaclass;
        tmp_args_element_name_40 = const_str_plain__OCSPClientCallbackHelper;
        CHECK_OBJECT( tmp_class_creation_14__bases );
        tmp_args_element_name_41 = tmp_class_creation_14__bases;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_args_element_name_42 = tmp_class_creation_14__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 544;
        {
            PyObject *call_args[] = { tmp_args_element_name_40, tmp_args_element_name_41, tmp_args_element_name_42 };
            tmp_assign_source_195 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_15, call_args );
        }

        if ( tmp_assign_source_195 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 544;

            goto try_except_handler_48;
        }
        assert( tmp_class_creation_14__class == NULL );
        tmp_class_creation_14__class = tmp_assign_source_195;
    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_48:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    Py_XDECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    {
        PyObject *tmp_assign_source_196;
        CHECK_OBJECT( tmp_class_creation_14__class );
        tmp_assign_source_196 = tmp_class_creation_14__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__OCSPClientCallbackHelper, tmp_assign_source_196 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class );
    Py_DECREF( tmp_class_creation_14__class );
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__bases );
    Py_DECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_dict );
    Py_DECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    {
        PyObject *tmp_assign_source_197;
        tmp_assign_source_197 = MAKE_FUNCTION_OpenSSL$SSL$$$function_9__asFileDescriptor(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__asFileDescriptor, tmp_assign_source_197 );
    }
    {
        PyObject *tmp_assign_source_198;
        tmp_assign_source_198 = MAKE_FUNCTION_OpenSSL$SSL$$$function_10_SSLeay_version(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLeay_version, tmp_assign_source_198 );
    }
    {
        PyObject *tmp_assign_source_199;
        tmp_assign_source_199 = MAKE_FUNCTION_OpenSSL$SSL$$$function_11__make_requires(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires, tmp_assign_source_199 );
    }
    {
        PyObject *tmp_assign_source_200;
        PyObject *tmp_called_name_16;
        PyObject *tmp_mvar_value_89;
        PyObject *tmp_args_element_name_43;
        PyObject *tmp_source_name_83;
        PyObject *tmp_mvar_value_90;
        PyObject *tmp_args_element_name_44;
        tmp_mvar_value_89 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires );

        if (unlikely( tmp_mvar_value_89 == NULL ))
        {
            tmp_mvar_value_89 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires );
        }

        CHECK_OBJECT( tmp_mvar_value_89 );
        tmp_called_name_16 = tmp_mvar_value_89;
        tmp_mvar_value_90 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_90 == NULL ))
        {
            tmp_mvar_value_90 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_90 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 654;

            goto frame_exception_exit_1;
        }

        tmp_source_name_83 = tmp_mvar_value_90;
        tmp_args_element_name_43 = LOOKUP_ATTRIBUTE( tmp_source_name_83, const_str_plain_Cryptography_HAS_NEXTPROTONEG );
        if ( tmp_args_element_name_43 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 654;

            goto frame_exception_exit_1;
        }
        tmp_args_element_name_44 = const_str_digest_47543c17fa95d5ac5c9bf71145417a30;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 653;
        {
            PyObject *call_args[] = { tmp_args_element_name_43, tmp_args_element_name_44 };
            tmp_assign_source_200 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_16, call_args );
        }

        Py_DECREF( tmp_args_element_name_43 );
        if ( tmp_assign_source_200 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 653;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn, tmp_assign_source_200 );
    }
    {
        PyObject *tmp_assign_source_201;
        PyObject *tmp_called_name_17;
        PyObject *tmp_mvar_value_91;
        PyObject *tmp_args_element_name_45;
        PyObject *tmp_source_name_84;
        PyObject *tmp_mvar_value_92;
        PyObject *tmp_args_element_name_46;
        tmp_mvar_value_91 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires );

        if (unlikely( tmp_mvar_value_91 == NULL ))
        {
            tmp_mvar_value_91 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires );
        }

        if ( tmp_mvar_value_91 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_requires" );
            exception_tb = NULL;

            exception_lineno = 658;

            goto frame_exception_exit_1;
        }

        tmp_called_name_17 = tmp_mvar_value_91;
        tmp_mvar_value_92 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_92 == NULL ))
        {
            tmp_mvar_value_92 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_92 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 659;

            goto frame_exception_exit_1;
        }

        tmp_source_name_84 = tmp_mvar_value_92;
        tmp_args_element_name_45 = LOOKUP_ATTRIBUTE( tmp_source_name_84, const_str_plain_Cryptography_HAS_ALPN );
        if ( tmp_args_element_name_45 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 659;

            goto frame_exception_exit_1;
        }
        tmp_args_element_name_46 = const_str_digest_616719c4a0cde3344203a07484a7fb54;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 658;
        {
            PyObject *call_args[] = { tmp_args_element_name_45, tmp_args_element_name_46 };
            tmp_assign_source_201 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_17, call_args );
        }

        Py_DECREF( tmp_args_element_name_45 );
        if ( tmp_assign_source_201 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 658;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn, tmp_assign_source_201 );
    }
    {
        PyObject *tmp_assign_source_202;
        PyObject *tmp_called_name_18;
        PyObject *tmp_mvar_value_93;
        PyObject *tmp_args_element_name_47;
        PyObject *tmp_source_name_85;
        PyObject *tmp_mvar_value_94;
        PyObject *tmp_args_element_name_48;
        tmp_mvar_value_93 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__make_requires );

        if (unlikely( tmp_mvar_value_93 == NULL ))
        {
            tmp_mvar_value_93 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_requires );
        }

        if ( tmp_mvar_value_93 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_requires" );
            exception_tb = NULL;

            exception_lineno = 663;

            goto frame_exception_exit_1;
        }

        tmp_called_name_18 = tmp_mvar_value_93;
        tmp_mvar_value_94 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_94 == NULL ))
        {
            tmp_mvar_value_94 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_94 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 664;

            goto frame_exception_exit_1;
        }

        tmp_source_name_85 = tmp_mvar_value_94;
        tmp_args_element_name_47 = LOOKUP_ATTRIBUTE( tmp_source_name_85, const_str_plain_Cryptography_HAS_TLSEXT_HOSTNAME );
        if ( tmp_args_element_name_47 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 664;

            goto frame_exception_exit_1;
        }
        tmp_args_element_name_48 = const_str_digest_94c36790285a25f5d9268c8333413cf2;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 663;
        {
            PyObject *call_args[] = { tmp_args_element_name_47, tmp_args_element_name_48 };
            tmp_assign_source_202 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_18, call_args );
        }

        Py_DECREF( tmp_args_element_name_47 );
        if ( tmp_assign_source_202 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 663;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni, tmp_assign_source_202 );
    }
    {
        PyObject *tmp_assign_source_203;
        tmp_assign_source_203 = PyDict_Copy( const_dict_c3a065e676a930b8196978eb12fcba71 );
        assert( tmp_class_creation_15__class_dict == NULL );
        tmp_class_creation_15__class_dict = tmp_assign_source_203;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_204;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_key_name_28;
        tmp_key_name_27 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_27 = tmp_class_creation_15__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_27, tmp_key_name_27 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 668;

            goto try_except_handler_52;
        }
        tmp_condition_result_15 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_14;
        }
        else
        {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_28 = tmp_class_creation_15__class_dict;
        tmp_key_name_28 = const_str_plain___metaclass__;
        tmp_assign_source_204 = DICT_GET_ITEM( tmp_dict_name_28, tmp_key_name_28 );
        if ( tmp_assign_source_204 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 668;

            goto try_except_handler_52;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        tmp_assign_source_204 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_204 );
        condexpr_end_14:;
        assert( tmp_class_creation_15__metaclass == NULL );
        tmp_class_creation_15__metaclass = tmp_assign_source_204;
    }
    {
        PyObject *tmp_assign_source_205;
        PyObject *tmp_called_name_19;
        PyObject *tmp_args_element_name_49;
        PyObject *tmp_args_element_name_50;
        PyObject *tmp_args_element_name_51;
        CHECK_OBJECT( tmp_class_creation_15__metaclass );
        tmp_called_name_19 = tmp_class_creation_15__metaclass;
        tmp_args_element_name_49 = const_str_plain_Session;
        tmp_args_element_name_50 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_args_element_name_51 = tmp_class_creation_15__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 668;
        {
            PyObject *call_args[] = { tmp_args_element_name_49, tmp_args_element_name_50, tmp_args_element_name_51 };
            tmp_assign_source_205 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_19, call_args );
        }

        if ( tmp_assign_source_205 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 668;

            goto try_except_handler_52;
        }
        assert( tmp_class_creation_15__class == NULL );
        tmp_class_creation_15__class = tmp_assign_source_205;
    }
    goto try_end_18;
    // Exception handler code:
    try_except_handler_52:;
    exception_keeper_type_29 = exception_type;
    exception_keeper_value_29 = exception_value;
    exception_keeper_tb_29 = exception_tb;
    exception_keeper_lineno_29 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_29;
    exception_value = exception_keeper_value_29;
    exception_tb = exception_keeper_tb_29;
    exception_lineno = exception_keeper_lineno_29;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    {
        PyObject *tmp_assign_source_206;
        CHECK_OBJECT( tmp_class_creation_15__class );
        tmp_assign_source_206 = tmp_class_creation_15__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Session, tmp_assign_source_206 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class );
    Py_DECREF( tmp_class_creation_15__class );
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_207;
        {
            PyObject *tmp_set_locals_12;
            tmp_set_locals_12 = PyDict_New();
            locals_OpenSSL$SSL_679 = tmp_set_locals_12;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_91220ffd97efb14a503e0ecf9d7ff0d1;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_876568a907b5dca527860ce47378562e_2, codeobj_876568a907b5dca527860ce47378562e, module_OpenSSL$SSL, 0 );
        frame_876568a907b5dca527860ce47378562e_2 = cache_frame_876568a907b5dca527860ce47378562e_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_876568a907b5dca527860ce47378562e_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_876568a907b5dca527860ce47378562e_2 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_mvar_value_95;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_mvar_value_96;
            PyObject *tmp_dict_key_7;
            PyObject *tmp_dict_value_7;
            PyObject *tmp_mvar_value_97;
            PyObject *tmp_dict_key_8;
            PyObject *tmp_dict_value_8;
            PyObject *tmp_mvar_value_98;
            PyObject *tmp_dict_key_9;
            PyObject *tmp_dict_value_9;
            PyObject *tmp_mvar_value_99;
            PyObject *tmp_dict_key_10;
            PyObject *tmp_dict_value_10;
            PyObject *tmp_mvar_value_100;
            tmp_dict_value_5 = const_str_plain_SSLv2_method;
            tmp_mvar_value_95 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD );

            if (unlikely( tmp_mvar_value_95 == NULL ))
            {
                tmp_mvar_value_95 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv2_METHOD );
            }

            if ( tmp_mvar_value_95 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "SSLv2_METHOD" );
                exception_tb = NULL;

                exception_lineno = 688;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_5 = tmp_mvar_value_95;
            tmp_dictset_value = _PyDict_NewPresized( 6 );
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_5, tmp_dict_value_5 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_6 = const_str_plain_SSLv3_method;
            tmp_mvar_value_96 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD );

            if (unlikely( tmp_mvar_value_96 == NULL ))
            {
                tmp_mvar_value_96 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv3_METHOD );
            }

            if ( tmp_mvar_value_96 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "SSLv3_METHOD" );
                exception_tb = NULL;

                exception_lineno = 689;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_6 = tmp_mvar_value_96;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_6, tmp_dict_value_6 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_7 = const_str_plain_SSLv23_method;
            tmp_mvar_value_97 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD );

            if (unlikely( tmp_mvar_value_97 == NULL ))
            {
                tmp_mvar_value_97 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SSLv23_METHOD );
            }

            if ( tmp_mvar_value_97 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "SSLv23_METHOD" );
                exception_tb = NULL;

                exception_lineno = 690;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_7 = tmp_mvar_value_97;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_7, tmp_dict_value_7 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_8 = const_str_plain_TLSv1_method;
            tmp_mvar_value_98 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD );

            if (unlikely( tmp_mvar_value_98 == NULL ))
            {
                tmp_mvar_value_98 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_METHOD );
            }

            if ( tmp_mvar_value_98 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "TLSv1_METHOD" );
                exception_tb = NULL;

                exception_lineno = 691;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_8 = tmp_mvar_value_98;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_8, tmp_dict_value_8 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_9 = const_str_plain_TLSv1_1_method;
            tmp_mvar_value_99 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD );

            if (unlikely( tmp_mvar_value_99 == NULL ))
            {
                tmp_mvar_value_99 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_1_METHOD );
            }

            if ( tmp_mvar_value_99 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "TLSv1_1_METHOD" );
                exception_tb = NULL;

                exception_lineno = 692;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_9 = tmp_mvar_value_99;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_9, tmp_dict_value_9 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_dict_value_10 = const_str_plain_TLSv1_2_method;
            tmp_mvar_value_100 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD );

            if (unlikely( tmp_mvar_value_100 == NULL ))
            {
                tmp_mvar_value_100 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TLSv1_2_METHOD );
            }

            if ( tmp_mvar_value_100 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "TLSv1_2_METHOD" );
                exception_tb = NULL;

                exception_lineno = 693;

                goto frame_exception_exit_2;
            }

            tmp_dict_key_10 = tmp_mvar_value_100;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_10, tmp_dict_value_10 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain__methods, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 687;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_dict_seq_1;
            {
                PyObject *tmp_assign_source_208;
                PyObject *tmp_iter_arg_1;
                PyObject *tmp_called_instance_2;
                tmp_called_instance_2 = PyDict_GetItem( locals_OpenSSL$SSL_679, const_str_plain__methods );

                if ( tmp_called_instance_2 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "name '%s' is not defined", "_methods" );
                    exception_tb = NULL;

                    exception_lineno = 697;

                    goto frame_exception_exit_2;
                }

                if ( tmp_called_instance_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 697;

                    goto frame_exception_exit_2;
                }
                frame_876568a907b5dca527860ce47378562e_2->m_frame.f_lineno = 697;
                tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_items );
                if ( tmp_iter_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 697;

                    goto frame_exception_exit_2;
                }
                tmp_assign_source_208 = MAKE_ITERATOR( tmp_iter_arg_1 );
                Py_DECREF( tmp_iter_arg_1 );
                if ( tmp_assign_source_208 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 696;

                    goto frame_exception_exit_2;
                }
                assert( tmp_Context$genexpr_1__$0 == NULL );
                tmp_Context$genexpr_1__$0 = tmp_assign_source_208;
            }
            // Tried code:
            tmp_dict_seq_1 = OpenSSL$SSL$$$genexpr_1_genexpr_maker();

            ((struct Nuitka_GeneratorObject *)tmp_dict_seq_1)->m_closure[0] = PyCell_NEW0( tmp_Context$genexpr_1__$0 );


            goto try_return_handler_55;
            // tried codes exits in all cases
            NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
            return MOD_RETURN_VALUE( NULL );
            // Return handler code:
            try_return_handler_55:;
            CHECK_OBJECT( (PyObject *)tmp_Context$genexpr_1__$0 );
            Py_DECREF( tmp_Context$genexpr_1__$0 );
            tmp_Context$genexpr_1__$0 = NULL;

            goto outline_result_25;
            // End of try:
            CHECK_OBJECT( (PyObject *)tmp_Context$genexpr_1__$0 );
            Py_DECREF( tmp_Context$genexpr_1__$0 );
            tmp_Context$genexpr_1__$0 = NULL;

            // Return statement must have exited already.
            NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
            return MOD_RETURN_VALUE( NULL );
            outline_result_25:;
            tmp_dictset_value = TO_DICT( tmp_dict_seq_1, NULL );
            Py_DECREF( tmp_dict_seq_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 695;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain__methods, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 695;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_12___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_1;
            tmp_defaults_1 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_1 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_13_load_verify_locations( tmp_defaults_1 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_load_verify_locations, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_14__wrap_callback(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain__wrap_callback, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_2 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_15_set_passwd_cb( tmp_defaults_2 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_passwd_cb, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_16_set_default_verify_paths(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_default_verify_paths, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_17__check_env_vars_set(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain__check_env_vars_set, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_18__fallback_default_verify_paths(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain__fallback_default_verify_paths, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_19_use_certificate_chain_file(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_use_certificate_chain_file, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_3;
            PyObject *tmp_tuple_element_12;
            PyObject *tmp_mvar_value_101;
            tmp_mvar_value_101 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

            if (unlikely( tmp_mvar_value_101 == NULL ))
            {
                tmp_mvar_value_101 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
            }

            if ( tmp_mvar_value_101 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "FILETYPE_PEM" );
                exception_tb = NULL;

                exception_lineno = 910;

                goto frame_exception_exit_2;
            }

            tmp_tuple_element_12 = tmp_mvar_value_101;
            tmp_defaults_3 = PyTuple_New( 1 );
            Py_INCREF( tmp_tuple_element_12 );
            PyTuple_SET_ITEM( tmp_defaults_3, 0, tmp_tuple_element_12 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_20_use_certificate_file( tmp_defaults_3 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_use_certificate_file, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 910;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_21_use_certificate(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_use_certificate, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_22_add_extra_chain_cert(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_add_extra_chain_cert, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_23__raise_passphrase_exception(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain__raise_passphrase_exception, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_4;
            PyObject *tmp_tuple_element_13;
            PyObject *tmp_mvar_value_102;
            tmp_mvar_value_102 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

            if (unlikely( tmp_mvar_value_102 == NULL ))
            {
                tmp_mvar_value_102 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
            }

            if ( tmp_mvar_value_102 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_UNSPECIFIED" );
                exception_tb = NULL;

                exception_lineno = 969;

                goto frame_exception_exit_2;
            }

            tmp_tuple_element_13 = tmp_mvar_value_102;
            tmp_defaults_4 = PyTuple_New( 1 );
            Py_INCREF( tmp_tuple_element_13 );
            PyTuple_SET_ITEM( tmp_defaults_4, 0, tmp_tuple_element_13 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_24_use_privatekey_file( tmp_defaults_4 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_use_privatekey_file, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 969;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_25_use_privatekey(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_use_privatekey, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_26_check_privatekey(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_check_privatekey, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_27_load_client_ca(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_load_client_ca, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_28_set_session_id(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_session_id, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_29_set_session_cache_mode(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_session_cache_mode, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_30_get_session_cache_mode(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_get_session_cache_mode, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_31_set_verify(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_verify, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_32_set_verify_depth(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_verify_depth, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_33_get_verify_mode(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_get_verify_mode, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_34_get_verify_depth(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_get_verify_depth, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_35_load_tmp_dh(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_load_tmp_dh, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_36_set_tmp_ecdh(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_tmp_ecdh, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_37_set_cipher_list(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_cipher_list, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_38_set_client_ca_list(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_client_ca_list, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_39_add_client_ca(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_add_client_ca, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_40_set_timeout(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_timeout, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_41_get_timeout(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_get_timeout, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_42_set_info_callback(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_info_callback, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_43_get_app_data(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_get_app_data, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_44_set_app_data(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_app_data, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_45_get_cert_store(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_get_cert_store, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_46_set_options(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_options, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_47_set_mode(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_mode, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_20;
            PyObject *tmp_mvar_value_103;
            PyObject *tmp_args_element_name_52;
            tmp_mvar_value_103 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni );

            if (unlikely( tmp_mvar_value_103 == NULL ))
            {
                tmp_mvar_value_103 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_sni );
            }

            if ( tmp_mvar_value_103 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_sni" );
                exception_tb = NULL;

                exception_lineno = 1361;

                goto frame_exception_exit_2;
            }

            tmp_called_name_20 = tmp_mvar_value_103;
            tmp_args_element_name_52 = MAKE_FUNCTION_OpenSSL$SSL$$$function_48_set_tlsext_servername_callback(  );



            frame_876568a907b5dca527860ce47378562e_2->m_frame.f_lineno = 1361;
            {
                PyObject *call_args[] = { tmp_args_element_name_52 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
            }

            Py_DECREF( tmp_args_element_name_52 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1361;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_tlsext_servername_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1361;

                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_49_set_tlsext_use_srtp(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_tlsext_use_srtp, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_21;
            PyObject *tmp_mvar_value_104;
            PyObject *tmp_args_element_name_53;
            tmp_mvar_value_104 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn );

            if (unlikely( tmp_mvar_value_104 == NULL ))
            {
                tmp_mvar_value_104 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_npn );
            }

            if ( tmp_mvar_value_104 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_npn" );
                exception_tb = NULL;

                exception_lineno = 1397;

                goto frame_exception_exit_2;
            }

            tmp_called_name_21 = tmp_mvar_value_104;
            tmp_args_element_name_53 = MAKE_FUNCTION_OpenSSL$SSL$$$function_50_set_npn_advertise_callback(  );



            frame_876568a907b5dca527860ce47378562e_2->m_frame.f_lineno = 1397;
            {
                PyObject *call_args[] = { tmp_args_element_name_53 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_21, call_args );
            }

            Py_DECREF( tmp_args_element_name_53 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1397;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_npn_advertise_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1397;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_22;
            PyObject *tmp_mvar_value_105;
            PyObject *tmp_args_element_name_54;
            tmp_mvar_value_105 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn );

            if (unlikely( tmp_mvar_value_105 == NULL ))
            {
                tmp_mvar_value_105 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_npn );
            }

            if ( tmp_mvar_value_105 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_npn" );
                exception_tb = NULL;

                exception_lineno = 1416;

                goto frame_exception_exit_2;
            }

            tmp_called_name_22 = tmp_mvar_value_105;
            tmp_args_element_name_54 = MAKE_FUNCTION_OpenSSL$SSL$$$function_51_set_npn_select_callback(  );



            frame_876568a907b5dca527860ce47378562e_2->m_frame.f_lineno = 1416;
            {
                PyObject *call_args[] = { tmp_args_element_name_54 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
            }

            Py_DECREF( tmp_args_element_name_54 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1416;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_npn_select_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1416;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_23;
            PyObject *tmp_mvar_value_106;
            PyObject *tmp_args_element_name_55;
            tmp_mvar_value_106 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

            if (unlikely( tmp_mvar_value_106 == NULL ))
            {
                tmp_mvar_value_106 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
            }

            if ( tmp_mvar_value_106 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
                exception_tb = NULL;

                exception_lineno = 1434;

                goto frame_exception_exit_2;
            }

            tmp_called_name_23 = tmp_mvar_value_106;
            tmp_args_element_name_55 = MAKE_FUNCTION_OpenSSL$SSL$$$function_52_set_alpn_protos(  );



            frame_876568a907b5dca527860ce47378562e_2->m_frame.f_lineno = 1434;
            {
                PyObject *call_args[] = { tmp_args_element_name_55 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
            }

            Py_DECREF( tmp_args_element_name_55 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1434;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_alpn_protos, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1434;

                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_name_24;
            PyObject *tmp_mvar_value_107;
            PyObject *tmp_args_element_name_56;
            tmp_mvar_value_107 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

            if (unlikely( tmp_mvar_value_107 == NULL ))
            {
                tmp_mvar_value_107 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
            }

            if ( tmp_mvar_value_107 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
                exception_tb = NULL;

                exception_lineno = 1456;

                goto frame_exception_exit_2;
            }

            tmp_called_name_24 = tmp_mvar_value_107;
            tmp_args_element_name_56 = MAKE_FUNCTION_OpenSSL$SSL$$$function_53_set_alpn_select_callback(  );



            frame_876568a907b5dca527860ce47378562e_2->m_frame.f_lineno = 1456;
            {
                PyObject *call_args[] = { tmp_args_element_name_56 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
            }

            Py_DECREF( tmp_args_element_name_56 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1456;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_alpn_select_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1456;

                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_876568a907b5dca527860ce47378562e_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_876568a907b5dca527860ce47378562e_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_876568a907b5dca527860ce47378562e_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_876568a907b5dca527860ce47378562e_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_876568a907b5dca527860ce47378562e_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_876568a907b5dca527860ce47378562e_2,
            type_description_2
        );


        // Release cached frame.
        if ( frame_876568a907b5dca527860ce47378562e_2 == cache_frame_876568a907b5dca527860ce47378562e_2 )
        {
            Py_DECREF( frame_876568a907b5dca527860ce47378562e_2 );
        }
        cache_frame_876568a907b5dca527860ce47378562e_2 = NULL;

        assertFrameObject( frame_876568a907b5dca527860ce47378562e_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_54;
        skip_nested_handling_1:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_54__set_ocsp_callback(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain__set_ocsp_callback, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_5;
            tmp_defaults_5 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_5 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_55_set_ocsp_server_callback( tmp_defaults_5 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_ocsp_server_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_defaults_6;
            tmp_defaults_6 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_6 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_56_set_ocsp_client_callback( tmp_defaults_6 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_679, const_str_plain_set_ocsp_client_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_assign_source_207 = locals_OpenSSL$SSL_679;
        Py_INCREF( tmp_assign_source_207 );
        goto try_return_handler_54;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_54:;
        Py_DECREF( locals_OpenSSL$SSL_679 );
        locals_OpenSSL$SSL_679 = NULL;
        goto outline_result_24;
        // Exception handler code:
        try_except_handler_54:;
        exception_keeper_type_30 = exception_type;
        exception_keeper_value_30 = exception_value;
        exception_keeper_tb_30 = exception_tb;
        exception_keeper_lineno_30 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$SSL_679 );
        locals_OpenSSL$SSL_679 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_30;
        exception_value = exception_keeper_value_30;
        exception_tb = exception_keeper_tb_30;
        exception_lineno = exception_keeper_lineno_30;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_1:;
        exception_lineno = 679;
        goto try_except_handler_53;
        outline_result_24:;
        assert( tmp_class_creation_16__class_dict == NULL );
        tmp_class_creation_16__class_dict = tmp_assign_source_207;
    }
    {
        PyObject *tmp_assign_source_209;
        nuitka_bool tmp_condition_result_16;
        PyObject *tmp_key_name_29;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_dict_name_30;
        PyObject *tmp_key_name_30;
        tmp_key_name_29 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_29 = tmp_class_creation_16__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_29, tmp_key_name_29 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 679;

            goto try_except_handler_53;
        }
        tmp_condition_result_16 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_15;
        }
        else
        {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_30 = tmp_class_creation_16__class_dict;
        tmp_key_name_30 = const_str_plain___metaclass__;
        tmp_assign_source_209 = DICT_GET_ITEM( tmp_dict_name_30, tmp_key_name_30 );
        if ( tmp_assign_source_209 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 679;

            goto try_except_handler_53;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        tmp_assign_source_209 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_209 );
        condexpr_end_15:;
        assert( tmp_class_creation_16__metaclass == NULL );
        tmp_class_creation_16__metaclass = tmp_assign_source_209;
    }
    {
        PyObject *tmp_assign_source_210;
        PyObject *tmp_called_name_25;
        PyObject *tmp_args_element_name_57;
        PyObject *tmp_args_element_name_58;
        PyObject *tmp_args_element_name_59;
        CHECK_OBJECT( tmp_class_creation_16__metaclass );
        tmp_called_name_25 = tmp_class_creation_16__metaclass;
        tmp_args_element_name_57 = const_str_plain_Context;
        tmp_args_element_name_58 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_args_element_name_59 = tmp_class_creation_16__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 679;
        {
            PyObject *call_args[] = { tmp_args_element_name_57, tmp_args_element_name_58, tmp_args_element_name_59 };
            tmp_assign_source_210 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_25, call_args );
        }

        if ( tmp_assign_source_210 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 679;

            goto try_except_handler_53;
        }
        assert( tmp_class_creation_16__class == NULL );
        tmp_class_creation_16__class = tmp_assign_source_210;
    }
    goto try_end_19;
    // Exception handler code:
    try_except_handler_53:;
    exception_keeper_type_31 = exception_type;
    exception_keeper_value_31 = exception_value;
    exception_keeper_tb_31 = exception_tb;
    exception_keeper_lineno_31 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_31;
    exception_value = exception_keeper_value_31;
    exception_tb = exception_keeper_tb_31;
    exception_lineno = exception_keeper_lineno_31;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    {
        PyObject *tmp_assign_source_211;
        CHECK_OBJECT( tmp_class_creation_16__class );
        tmp_assign_source_211 = tmp_class_creation_16__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context, tmp_assign_source_211 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class );
    Py_DECREF( tmp_class_creation_16__class );
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__metaclass );
    Py_DECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    {
        PyObject *tmp_assign_source_212;
        PyObject *tmp_called_name_26;
        PyObject *tmp_mvar_value_108;
        PyObject *tmp_args_element_name_60;
        PyObject *tmp_mvar_value_109;
        PyObject *tmp_args_element_name_61;
        PyObject *tmp_args_element_name_62;
        PyObject *tmp_args_element_name_63;
        PyObject *tmp_mvar_value_110;
        tmp_mvar_value_108 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_108 == NULL ))
        {
            tmp_mvar_value_108 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_108 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 1531;

            goto frame_exception_exit_1;
        }

        tmp_called_name_26 = tmp_mvar_value_108;
        tmp_mvar_value_109 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Context );

        if (unlikely( tmp_mvar_value_109 == NULL ))
        {
            tmp_mvar_value_109 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Context );
        }

        if ( tmp_mvar_value_109 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Context" );
            exception_tb = NULL;

            exception_lineno = 1532;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_60 = tmp_mvar_value_109;
        tmp_args_element_name_61 = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_args_element_name_62 = const_str_digest_b7964fdc1d8df81dacc8b4450db712e3;
        tmp_mvar_value_110 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_110 == NULL ))
        {
            tmp_mvar_value_110 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_110 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 1533;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_63 = tmp_mvar_value_110;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 1531;
        {
            PyObject *call_args[] = { tmp_args_element_name_60, tmp_args_element_name_61, tmp_args_element_name_62, tmp_args_element_name_63 };
            tmp_assign_source_212 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_26, call_args );
        }

        if ( tmp_assign_source_212 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1531;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ContextType, tmp_assign_source_212 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_213;
        {
            PyObject *tmp_set_locals_13;
            tmp_set_locals_13 = PyDict_New();
            locals_OpenSSL$SSL_1537 = tmp_set_locals_13;
        }
        tmp_dictset_value = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_ca4a6d4d96b227b5bd17bc5998515ec3;
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_2352c5a15d14192c9a7a25a5a1b6a81c_3, codeobj_2352c5a15d14192c9a7a25a5a1b6a81c, module_OpenSSL$SSL, 0 );
        frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 = cache_frame_2352c5a15d14192c9a7a25a5a1b6a81c_3;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_27;
            PyObject *tmp_mvar_value_111;
            tmp_mvar_value_111 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary );

            if (unlikely( tmp_mvar_value_111 == NULL ))
            {
                tmp_mvar_value_111 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WeakValueDictionary );
            }

            if ( tmp_mvar_value_111 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "WeakValueDictionary" );
                exception_tb = NULL;

                exception_lineno = 1540;

                goto frame_exception_exit_3;
            }

            tmp_called_name_27 = tmp_mvar_value_111;
            frame_2352c5a15d14192c9a7a25a5a1b6a81c_3->m_frame.f_lineno = 1540;
            tmp_dictset_value = CALL_FUNCTION_NO_ARGS( tmp_called_name_27 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1540;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain__reverse_mapping, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1540;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_defaults_7;
            tmp_defaults_7 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_7 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_57___init__( tmp_defaults_7 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_58___getattr__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain___getattr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_59__raise_ssl_error(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain__raise_ssl_error, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_60_get_context(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_context, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_61_set_context(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_context, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_28;
            PyObject *tmp_mvar_value_112;
            PyObject *tmp_args_element_name_64;
            tmp_mvar_value_112 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni );

            if (unlikely( tmp_mvar_value_112 == NULL ))
            {
                tmp_mvar_value_112 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_sni );
            }

            if ( tmp_mvar_value_112 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_sni" );
                exception_tb = NULL;

                exception_lineno = 1669;

                goto frame_exception_exit_3;
            }

            tmp_called_name_28 = tmp_mvar_value_112;
            tmp_args_element_name_64 = MAKE_FUNCTION_OpenSSL$SSL$$$function_62_get_servername(  );



            frame_2352c5a15d14192c9a7a25a5a1b6a81c_3->m_frame.f_lineno = 1669;
            {
                PyObject *call_args[] = { tmp_args_element_name_64 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_28, call_args );
            }

            Py_DECREF( tmp_args_element_name_64 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1669;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_servername, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1669;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_29;
            PyObject *tmp_mvar_value_113;
            PyObject *tmp_args_element_name_65;
            tmp_mvar_value_113 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_sni );

            if (unlikely( tmp_mvar_value_113 == NULL ))
            {
                tmp_mvar_value_113 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_sni );
            }

            if ( tmp_mvar_value_113 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_sni" );
                exception_tb = NULL;

                exception_lineno = 1687;

                goto frame_exception_exit_3;
            }

            tmp_called_name_29 = tmp_mvar_value_113;
            tmp_args_element_name_65 = MAKE_FUNCTION_OpenSSL$SSL$$$function_63_set_tlsext_host_name(  );



            frame_2352c5a15d14192c9a7a25a5a1b6a81c_3->m_frame.f_lineno = 1687;
            {
                PyObject *call_args[] = { tmp_args_element_name_65 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_29, call_args );
            }

            Py_DECREF( tmp_args_element_name_65 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1687;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_tlsext_host_name, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1687;

                goto frame_exception_exit_3;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_64_pending(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_pending, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_8;
            tmp_defaults_8 = const_tuple_int_0_tuple;
            Py_INCREF( tmp_defaults_8 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_65_send( tmp_defaults_8 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_send, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_OpenSSL$SSL_1537, const_str_plain_send );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "send" );
            exception_tb = NULL;

            exception_lineno = 1739;

            goto frame_exception_exit_3;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1739;

            goto frame_exception_exit_3;
        }
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_write, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_9;
            tmp_defaults_9 = const_tuple_int_0_tuple;
            Py_INCREF( tmp_defaults_9 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_66_sendall( tmp_defaults_9 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_sendall, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_defaults_10;
            tmp_defaults_10 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_10 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_67_recv( tmp_defaults_10 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_recv, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_OpenSSL$SSL_1537, const_str_plain_recv );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "recv" );
            exception_tb = NULL;

            exception_lineno = 1793;

            goto frame_exception_exit_3;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1793;

            goto frame_exception_exit_3;
        }
        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_read, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_11;
            tmp_defaults_11 = const_tuple_none_none_tuple;
            Py_INCREF( tmp_defaults_11 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_68_recv_into( tmp_defaults_11 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_recv_into, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_69__handle_bio_errors(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain__handle_bio_errors, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_70_bio_read(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_bio_read, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_71_bio_write(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_bio_write, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_72_renegotiate(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_renegotiate, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_73_do_handshake(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_do_handshake, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_74_renegotiate_pending(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_renegotiate_pending, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_75_total_renegotiations(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_total_renegotiations, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_76_connect(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_connect, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_77_connect_ex(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_connect_ex, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_78_accept(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_accept, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_79_bio_shutdown(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_bio_shutdown, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_80_shutdown(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_shutdown, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_81_get_cipher_list(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_list, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_82_get_client_ca_list(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_client_ca_list, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_83_makefile(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_makefile, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_84_get_app_data(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_app_data, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_85_set_app_data(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_app_data, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_86_get_shutdown(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_shutdown, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_87_set_shutdown(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_shutdown, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_88_get_state_string(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_state_string, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_89_server_random(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_server_random, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_90_client_random(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_client_random, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_91_master_key(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_master_key, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_12;
            tmp_defaults_12 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_12 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_92_export_keying_material( tmp_defaults_12 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_export_keying_material, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_93_sock_shutdown(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_sock_shutdown, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_94_get_certificate(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_certificate, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_95_get_peer_certificate(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_peer_certificate, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_96_get_peer_cert_chain(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_peer_cert_chain, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_97_want_read(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_want_read, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_98_want_write(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_want_write, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_99_set_accept_state(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_accept_state, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_100_set_connect_state(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_connect_state, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_101_get_session(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_session, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_102_set_session(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_session, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_103__get_finished_message(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain__get_finished_message, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_104_get_finished(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_finished, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_105_get_peer_finished(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_peer_finished, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_106_get_cipher_name(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_name, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_107_get_cipher_bits(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_bits, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_108_get_cipher_version(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_cipher_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_109_get_protocol_version_name(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_protocol_version_name, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_110_get_protocol_version(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_protocol_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_30;
            PyObject *tmp_mvar_value_114;
            PyObject *tmp_args_element_name_66;
            tmp_mvar_value_114 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_npn );

            if (unlikely( tmp_mvar_value_114 == NULL ))
            {
                tmp_mvar_value_114 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_npn );
            }

            if ( tmp_mvar_value_114 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_npn" );
                exception_tb = NULL;

                exception_lineno = 2429;

                goto frame_exception_exit_3;
            }

            tmp_called_name_30 = tmp_mvar_value_114;
            tmp_args_element_name_66 = MAKE_FUNCTION_OpenSSL$SSL$$$function_111_get_next_proto_negotiated(  );



            frame_2352c5a15d14192c9a7a25a5a1b6a81c_3->m_frame.f_lineno = 2429;
            {
                PyObject *call_args[] = { tmp_args_element_name_66 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_30, call_args );
            }

            Py_DECREF( tmp_args_element_name_66 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2429;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_next_proto_negotiated, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2429;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_31;
            PyObject *tmp_mvar_value_115;
            PyObject *tmp_args_element_name_67;
            tmp_mvar_value_115 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

            if (unlikely( tmp_mvar_value_115 == NULL ))
            {
                tmp_mvar_value_115 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
            }

            if ( tmp_mvar_value_115 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
                exception_tb = NULL;

                exception_lineno = 2446;

                goto frame_exception_exit_3;
            }

            tmp_called_name_31 = tmp_mvar_value_115;
            tmp_args_element_name_67 = MAKE_FUNCTION_OpenSSL$SSL$$$function_112_set_alpn_protos(  );



            frame_2352c5a15d14192c9a7a25a5a1b6a81c_3->m_frame.f_lineno = 2446;
            {
                PyObject *call_args[] = { tmp_args_element_name_67 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_31, call_args );
            }

            Py_DECREF( tmp_args_element_name_67 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2446;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_set_alpn_protos, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2446;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_called_name_32;
            PyObject *tmp_mvar_value_116;
            PyObject *tmp_args_element_name_68;
            tmp_mvar_value_116 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__requires_alpn );

            if (unlikely( tmp_mvar_value_116 == NULL ))
            {
                tmp_mvar_value_116 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__requires_alpn );
            }

            if ( tmp_mvar_value_116 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_requires_alpn" );
                exception_tb = NULL;

                exception_lineno = 2468;

                goto frame_exception_exit_3;
            }

            tmp_called_name_32 = tmp_mvar_value_116;
            tmp_args_element_name_68 = MAKE_FUNCTION_OpenSSL$SSL$$$function_113_get_alpn_proto_negotiated(  );



            frame_2352c5a15d14192c9a7a25a5a1b6a81c_3->m_frame.f_lineno = 2468;
            {
                PyObject *call_args[] = { tmp_args_element_name_68 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_32, call_args );
            }

            Py_DECREF( tmp_args_element_name_68 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2468;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_get_alpn_proto_negotiated, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2468;

                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_2352c5a15d14192c9a7a25a5a1b6a81c_3->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_2352c5a15d14192c9a7a25a5a1b6a81c_3, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_2352c5a15d14192c9a7a25a5a1b6a81c_3,
            type_description_2
        );


        // Release cached frame.
        if ( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 == cache_frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 )
        {
            Py_DECREF( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 );
        }
        cache_frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 = NULL;

        assertFrameObject( frame_2352c5a15d14192c9a7a25a5a1b6a81c_3 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_57;
        skip_nested_handling_2:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$SSL$$$function_114_request_ocsp(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$SSL_1537, const_str_plain_request_ocsp, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_213 = locals_OpenSSL$SSL_1537;
        Py_INCREF( tmp_assign_source_213 );
        goto try_return_handler_57;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_57:;
        Py_DECREF( locals_OpenSSL$SSL_1537 );
        locals_OpenSSL$SSL_1537 = NULL;
        goto outline_result_26;
        // Exception handler code:
        try_except_handler_57:;
        exception_keeper_type_32 = exception_type;
        exception_keeper_value_32 = exception_value;
        exception_keeper_tb_32 = exception_tb;
        exception_keeper_lineno_32 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$SSL_1537 );
        locals_OpenSSL$SSL_1537 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_32;
        exception_value = exception_keeper_value_32;
        exception_tb = exception_keeper_tb_32;
        exception_lineno = exception_keeper_lineno_32;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$SSL );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_2:;
        exception_lineno = 1537;
        goto try_except_handler_56;
        outline_result_26:;
        assert( tmp_class_creation_17__class_dict == NULL );
        tmp_class_creation_17__class_dict = tmp_assign_source_213;
    }
    {
        PyObject *tmp_assign_source_214;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        tmp_key_name_31 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_dict_name_31 = tmp_class_creation_17__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_31, tmp_key_name_31 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1537;

            goto try_except_handler_56;
        }
        tmp_condition_result_17 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_16;
        }
        else
        {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_dict_name_32 = tmp_class_creation_17__class_dict;
        tmp_key_name_32 = const_str_plain___metaclass__;
        tmp_assign_source_214 = DICT_GET_ITEM( tmp_dict_name_32, tmp_key_name_32 );
        if ( tmp_assign_source_214 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1537;

            goto try_except_handler_56;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        tmp_assign_source_214 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_214 );
        condexpr_end_16:;
        assert( tmp_class_creation_17__metaclass == NULL );
        tmp_class_creation_17__metaclass = tmp_assign_source_214;
    }
    {
        PyObject *tmp_assign_source_215;
        PyObject *tmp_called_name_33;
        PyObject *tmp_args_element_name_69;
        PyObject *tmp_args_element_name_70;
        PyObject *tmp_args_element_name_71;
        CHECK_OBJECT( tmp_class_creation_17__metaclass );
        tmp_called_name_33 = tmp_class_creation_17__metaclass;
        tmp_args_element_name_69 = const_str_plain_Connection;
        tmp_args_element_name_70 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_args_element_name_71 = tmp_class_creation_17__class_dict;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 1537;
        {
            PyObject *call_args[] = { tmp_args_element_name_69, tmp_args_element_name_70, tmp_args_element_name_71 };
            tmp_assign_source_215 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_33, call_args );
        }

        if ( tmp_assign_source_215 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1537;

            goto try_except_handler_56;
        }
        assert( tmp_class_creation_17__class == NULL );
        tmp_class_creation_17__class = tmp_assign_source_215;
    }
    goto try_end_20;
    // Exception handler code:
    try_except_handler_56:;
    exception_keeper_type_33 = exception_type;
    exception_keeper_value_33 = exception_value;
    exception_keeper_tb_33 = exception_tb;
    exception_keeper_lineno_33 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_33;
    exception_value = exception_keeper_value_33;
    exception_tb = exception_keeper_tb_33;
    exception_lineno = exception_keeper_lineno_33;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    {
        PyObject *tmp_assign_source_216;
        CHECK_OBJECT( tmp_class_creation_17__class );
        tmp_assign_source_216 = tmp_class_creation_17__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection, tmp_assign_source_216 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class );
    Py_DECREF( tmp_class_creation_17__class );
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_dict );
    Py_DECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__metaclass );
    Py_DECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    {
        PyObject *tmp_assign_source_217;
        PyObject *tmp_called_name_34;
        PyObject *tmp_mvar_value_117;
        PyObject *tmp_args_element_name_72;
        PyObject *tmp_mvar_value_118;
        PyObject *tmp_args_element_name_73;
        PyObject *tmp_args_element_name_74;
        PyObject *tmp_args_element_name_75;
        PyObject *tmp_mvar_value_119;
        tmp_mvar_value_117 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_117 == NULL ))
        {
            tmp_mvar_value_117 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_117 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 2499;

            goto frame_exception_exit_1;
        }

        tmp_called_name_34 = tmp_mvar_value_117;
        tmp_mvar_value_118 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_Connection );

        if (unlikely( tmp_mvar_value_118 == NULL ))
        {
            tmp_mvar_value_118 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Connection );
        }

        if ( tmp_mvar_value_118 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Connection" );
            exception_tb = NULL;

            exception_lineno = 2500;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_72 = tmp_mvar_value_118;
        tmp_args_element_name_73 = const_str_digest_36dfc40fd76fef32a3245e24bfe74ea9;
        tmp_args_element_name_74 = const_str_digest_2db82bf07fbb595fa9b0bb5b41c7d7cb;
        tmp_mvar_value_119 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_119 == NULL ))
        {
            tmp_mvar_value_119 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_119 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 2502;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_75 = tmp_mvar_value_119;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 2499;
        {
            PyObject *call_args[] = { tmp_args_element_name_72, tmp_args_element_name_73, tmp_args_element_name_74, tmp_args_element_name_75 };
            tmp_assign_source_217 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_34, call_args );
        }

        if ( tmp_assign_source_217 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2499;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain_ConnectionType, tmp_assign_source_217 );
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_120;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_120 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_120 == NULL ))
        {
            tmp_mvar_value_120 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_120 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2507;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_120;
        frame_cd5d88529d58a411fd9144e06350d5f3->m_frame.f_lineno = 2507;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_SSL_library_init );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2507;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd5d88529d58a411fd9144e06350d5f3 );
#endif
    popFrameStack();

    assertFrameObject( frame_cd5d88529d58a411fd9144e06350d5f3 );

    goto frame_no_exception_3;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd5d88529d58a411fd9144e06350d5f3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cd5d88529d58a411fd9144e06350d5f3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cd5d88529d58a411fd9144e06350d5f3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cd5d88529d58a411fd9144e06350d5f3, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_3:;

#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_OpenSSL$SSL, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_OpenSSL$SSL );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
