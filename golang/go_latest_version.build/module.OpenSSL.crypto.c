/* Generated code for Python module 'OpenSSL.crypto'
 * created by Nuitka version 0.6.1.1
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_OpenSSL$crypto" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_OpenSSL$crypto;
PyDictObject *moduledict_OpenSSL$crypto;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain_set_lastUpdate;
extern PyObject *const_str_plain_EVP_PKEY_id;
static PyObject *const_str_plain_OBJ_nid2ln;
static PyObject *const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f;
static PyObject *const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a;
static PyObject *const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561;
extern PyObject *const_str_plain_data;
static PyObject *const_str_plain__truncate;
static PyObject *const_str_plain_RSA_check_key;
extern PyObject *const_str_plain_X509_CRL_get_nextUpdate;
static PyObject *const_str_plain_X509_NAME_get_index_by_NID;
static PyObject *const_str_plain_issuer_key;
static PyObject *const_str_digest_978cd476d4acffdfb043e6a5e0ebae26;
static PyObject *const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple;
extern PyObject *const_str_plain_PEM_write_bio_X509;
extern PyObject *const_str_plain_EVP_MAX_MD_SIZE;
static PyObject *const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple;
static PyObject *const_str_plain_X509_V_FLAG_POLICY_CHECK;
static PyObject *const_str_digest_b52a484c26b348bfec0a17217a58ad7e;
extern PyObject *const_str_plain_startswith;
static PyObject *const_str_digest_8fda740163dc7d07c78736dc2ebb17b1;
extern PyObject *const_str_plain_X509_set_subject_name;
static PyObject *const_str_plain_all_reasons;
static PyObject *const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple;
static PyObject *const_str_digest_90de967a5219b9210479f7eac5c285c8;
static PyObject *const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143;
static PyObject *const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple;
extern PyObject *const_str_plain_UNSPECIFIED;
static PyObject *const_str_digest_a9bcf1af78e6d912e13685d8a606fe30;
static PyObject *const_str_plain_TYPE_RSA;
static PyObject *const_str_plain_X509_VERIFY_PARAM_free;
static PyObject *const_str_digest_52cbe8d655a10e46907a30970ef9889a;
static PyObject *const_str_plain_sk_X509_EXTENSION_free;
extern PyObject *const_str_plain_PKCS12_free;
static PyObject *const_str_digest_435662c26b2c422edb954b82c85c55d9;
static PyObject *const_str_digest_f737de4a45174195dc1e46101235dc35;
static PyObject *const_str_plain_get_rev_date;
extern PyObject *const_str_plain_pkey;
static PyObject *const_str_digest_3d684470d9353bc1a1e8d63a3aab4679;
static PyObject *const_tuple_str_plain_cls_str_plain_lib_tuple;
static PyObject *const_str_plain_X509StoreContext;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
extern PyObject *const_tuple_str_plain_self_str_plain_version_tuple;
extern PyObject *const_str_plain__CertificateRevocationList;
static PyObject *const_str_plain__get_elliptic_curves;
extern PyObject *const_str_plain__problems;
extern PyObject *const_str_plain_stack;
extern PyObject *const_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9;
extern PyObject *const_str_plain_cipher;
static PyObject *const_str_plain_string_type;
static PyObject *const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple;
extern PyObject *const_str_plain_X509_REVOKED_get0_revocationDate;
static PyObject *const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple;
static PyObject *const_tuple_str_plain_utf8only_tuple;
static PyObject *const_str_digest_aca114104f73a7934675fb06a5336647;
static PyObject *const_str_digest_169aa7f0589e4a3c83203d48f57770af;
static PyObject *const_str_plain_X509_VERIFY_PARAM_new;
extern PyObject *const_str_plain_BIO_new_mem_buf;
static PyObject *const_str_plain__friendlyname;
static PyObject *const_tuple_str_plain_bio_str_plain_ref_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
static PyObject *const_str_digest_1565887baecc678658a50e7d1f245653;
extern PyObject *const_str_plain_X509_set_pubkey;
static PyObject *const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72;
static PyObject *const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple;
static PyObject *const_str_plain_load_pkcs12;
static PyObject *const_str_plain_X509_REVOKED_add1_ext_i2d;
extern PyObject *const_str_plain_int;
static PyObject *const_str_plain_string_result;
extern PyObject *const_str_plain_X509_NAME_get_entry;
extern PyObject *const_str_plain_X509Name;
static PyObject *const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98;
extern PyObject *const_str_plain_sign;
extern PyObject *const_int_neg_1;
static PyObject *const_str_plain_NOTIFY_POLICY;
extern PyObject *const_str_plain_ASN1_STRING_to_UTF8;
static PyObject *const_str_digest_2f350f536232587387680a9435c758f6;
extern PyObject *const_str_plain_timestamp;
extern PyObject *const_str_plain_EVP_PKEY_free;
static PyObject *const_str_digest_670c62a34c6767f6ecd5db6f969b2f34;
static PyObject *const_str_plain_pkcs12;
extern PyObject *const_str_plain_results;
extern PyObject *const_str_plain_X509_CRL_set_issuer_name;
extern PyObject *const_str_plain_X509_new;
static PyObject *const_str_digest_fb60d21f52ae521da77e61851d566364;
extern PyObject *const_str_plain_ERR_clear_error;
extern PyObject *const_str_plain__crl;
static PyObject *const_str_plain_get_short_name;
static PyObject *const_str_plain_digest_obj;
static PyObject *const_str_plain_op;
static PyObject *const_str_plain_type_is_enveloped;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc;
static PyObject *const_str_plain_X509_R_CERT_ALREADY_IN_HASH_TABLE;
static PyObject *const_str_plain_utf8only;
extern PyObject *const_str_plain_X509_STORE_CTX_get_current_cert;
static PyObject *const_str_plain_PKeyType;
extern PyObject *const_str_plain_X509_get_ext_count;
extern PyObject *const_str_plain_X509_free;
extern PyObject *const_str_plain_PEM_read_bio_X509_REQ;
static PyObject *const_str_plain_PKCS12_create;
static PyObject *const_str_plain_dt;
static PyObject *const_str_digest_152d11f8848fac60442a26592ab3da87;
static PyObject *const_str_digest_0632ce6142bf9815370c626f0fb1235a;
extern PyObject *const_str_plain_ia5;
extern PyObject *const_str_plain_Certificate;
extern PyObject *const_str_plain_make_assert;
extern PyObject *const_str_plain_EVP_PKEY_DSA;
static PyObject *const_str_plain_char_result;
static PyObject *const_str_plain_string_timestamp;
static PyObject *const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple;
static PyObject *const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple;
extern PyObject *const_str_plain__from_raw_x509_ptr;
static PyObject *const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple;
static PyObject *const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31;
static PyObject *const_str_plain_X509_STORE_CTX_cleanup;
static PyObject *const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
static PyObject *const_str_digest_44f664275c70041c9ae4bef2565506f3;
extern PyObject *const_str_plain_X509_EXTENSION_get_data;
static PyObject *const_str_plain_sk_X509_push;
static PyObject *const_str_digest_6a19008e8f9a834793cf38dcba68883a;
extern PyObject *const_int_pos_2048;
static PyObject *const_str_plain_CRL_CHECK;
static PyObject *const_str_plain_spki;
static PyObject *const_tuple_str_plain_self_str_plain_ret_tuple;
static PyObject *const_str_plain_pypkcs7;
extern PyObject *const_str_plain_X509_get_serialNumber;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_dsa;
static PyObject *const_str_plain_add_crl;
extern PyObject *const_str_plain_bits;
extern PyObject *const_str_plain_DSAPrivateKey;
static PyObject *const_str_digest_5a3f7f69104a4ed1267a21c950d94463;
extern PyObject *const_tuple_str_plain_self_str_plain_flags_tuple;
static PyObject *const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS;
extern PyObject *const_str_plain_NID_undef;
extern PyObject *const_str_plain_new;
static PyObject *const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79;
static PyObject *const_str_digest_7de17ac920010129977e4280610f275c;
static PyObject *const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
static PyObject *const_str_plain__get_name;
extern PyObject *const_str_plain__Certificate;
static PyObject *const_str_plain_b64_encode;
extern PyObject *const_str_plain_X509_REVOKED_set_serialNumber;
extern PyObject *const_str_plain_store;
static PyObject *const_str_plain_ref;
extern PyObject *const_str_plain_base64;
extern PyObject *const_str_plain_more_args;
static PyObject *const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple;
extern PyObject *const_str_angle_genexpr;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_plain_EVP_VerifyUpdate;
static PyObject *const_str_digest_603c60edaf58a8746faa757f20f3f938;
static PyObject *const_str_digest_32726a73c20427f70712d109be7712b4;
static PyObject *const_str_plain__crl_reasons;
extern PyObject *const_str_plain_X509_set_version;
static PyObject *const_str_plain__passphrase;
extern PyObject *const_str_plain_X509_CRL_set_nextUpdate;
extern PyObject *const_str_plain__raise_current_error;
static PyObject *const_str_plain__revoked;
static PyObject *const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple;
static PyObject *const_str_plain_fname;
extern PyObject *const_str_plain_issuer;
static PyObject *const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24;
static PyObject *const_str_digest_bd5b7ac1c36a2ac4b448366689be109e;
static PyObject *const_str_plain__text_type;
extern PyObject *const_str_plain_der;
static PyObject *const_str_plain_ent_nid;
extern PyObject *const_str_plain_add;
static PyObject *const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113;
extern PyObject *const_tuple_str_plain_partial_tuple;
extern PyObject *const_str_plain_DSA_generate_parameters_ex;
static PyObject *const_str_digest_c384f9f99d5890cd2aae342c30dbaa14;
static PyObject *const_str_plain_load_crl;
static PyObject *const_str_plain_i2d_PKCS12_bio;
static PyObject *const_str_digest_5bd123cbe57a454c8d9d37867b598cb2;
extern PyObject *const_str_plain_X509_set_issuer_name;
static PyObject *const_str_digest_3c7878f9f14c822b0ae6ebb3dbe0804c;
extern PyObject *const_str_plain_res;
extern PyObject *const_str_plain_PEM_read_bio_PrivateKey;
extern PyObject *const_str_plain_req;
static PyObject *const_str_plain_crypto_req;
static PyObject *const_str_plain_CHECK_SS_SIGNATURE;
static PyObject *const_str_plain__nid;
static PyObject *const_str_plain_X509_V_FLAG_NOTIFY_POLICY;
static PyObject *const_str_plain_SSL_FILETYPE_PEM;
static PyObject *const_str_plain_d2i_PKCS7_bio;
extern PyObject *const_str_plain_X509_REVOKED_free;
static PyObject *const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e;
static PyObject *const_str_plain_EVP_PKEY_assign_RSA;
extern PyObject *const_str_plain_sk_X509_EXTENSION_new_null;
extern PyObject *const_str_plain_unspecified;
extern PyObject *const_str_plain_check;
static PyObject *const_str_plain_get_ca_certificates;
extern PyObject *const_str_plain_integer_types;
static PyObject *const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple;
extern PyObject *const_str_plain_asn1_int;
static PyObject *const_str_plain_set_subject;
static PyObject *const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple;
extern PyObject *const_tuple_str_plain_ascii_tuple;
static PyObject *const_str_plain_get_components;
static PyObject *const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple;
static PyObject *const_str_plain_set_privatekey;
static PyObject *const_str_plain_EVP_VerifyFinal;
static PyObject *const_str_digest_26a65c58106d086427e37cb87b0bc3b3;
static PyObject *const_str_digest_8db7448b8246dd51f74c33bda58590bd;
static PyObject *const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple;
extern PyObject *const_str_plain_get_certificate;
static PyObject *const_str_plain_get_notBefore;
static PyObject *const_str_plain_X509V3_set_ctx_nodb;
extern PyObject *const_str_plain__pkey;
extern PyObject *const_str_plain_x509;
extern PyObject *const_str_plain_clear;
static PyObject *const_str_plain_i2d_PrivateKey_bio;
static PyObject *const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf;
static PyObject *const_str_plain_hexstring_serial;
extern PyObject *const_str_plain_False;
static PyObject *const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple;
static PyObject *const_str_digest_1ca413f5b66374db6a573ac0926a99ae;
static PyObject *const_str_plain_exponent;
extern PyObject *const_tuple_str_plain_self_str_plain_subject_tuple;
static PyObject *const_str_plain_X509StoreFlags;
static PyObject *const_str_plain_EVP_SignInit;
static PyObject *const_str_digest_c7bf9684574689f7d764ff6fbd5eab60;
static PyObject *const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339;
static PyObject *const_tuple_str_plain_op_str_plain_f_tuple;
extern PyObject *const_str_digest_c804b213c384a15865e18bf31cfff70e;
static PyObject *const_tuple_str_plain_b16encode_tuple;
static PyObject *const_str_plain_get_serial_number;
static PyObject *const_str_digest_2f591e55cc116ed5223c119e2f7da344;
extern PyObject *const_str_plain_subject;
static PyObject *const_str_plain_vfy_time;
extern PyObject *const_str_plain_userdata;
static PyObject *const_str_plain_sk_X509_EXTENSION_push;
extern PyObject *const_str_plain_critical;
static PyObject *const_str_plain_days;
static PyObject *const_str_digest_3910fdd1c3b683a0988d08f77454ce47;
static PyObject *const_str_plain_get_extension_count;
static PyObject *const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac;
static PyObject *const_tuple_str_plain_self_str_plain_when_tuple;
static PyObject *const_str_plain_X509V3_EXT_print;
static PyObject *const_str_plain_which;
static PyObject *const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple;
extern PyObject *const_str_plain_code;
static PyObject *const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple;
static PyObject *const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple;
static PyObject *const_str_plain_i2a_ASN1_INTEGER;
extern PyObject *const_str_plain__evp_pkey_to_public_key;
static PyObject *const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple;
static PyObject *const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple;
extern PyObject *const_str_plain_X509_REQ_new;
extern PyObject *const_str_plain__native;
extern PyObject *const_str_plain_X509_REQ_free;
extern PyObject *const_str_plain__ffi;
static PyObject *const_str_plain_X509Type;
extern PyObject *const_str_plain_X509_NAME_entry_count;
static PyObject *const_str_plain_not_after;
static PyObject *const_str_digest_5194c46decfddbd64da780c8c0e4faa3;
static PyObject *const_str_plain_X509_NAME_delete_entry;
static PyObject *const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
extern PyObject *const_str_plain_X509_get_subject_name;
extern PyObject *const_str_plain_operator;
static PyObject *const_str_digest_333948d9e51f0e161201a16305959930;
static PyObject *const_str_plain_native_exts_obj;
static PyObject *const_str_digest_9cb57ebafd0926d1746d2e66a6198efe;
static PyObject *const_str_plain_X509_STRICT;
static PyObject *const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple;
static PyObject *const_str_plain_time_string;
static PyObject *const_str_digest_5339fa8ff3df372e54ef7b09078767aa;
static PyObject *const_tuple_86464d9c162f01af99141e0a5b804d71_tuple;
static PyObject *const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple;
extern PyObject *const_str_plain_EVP_PKEY_EC;
extern PyObject *const_str_plain___getattr__;
static PyObject *const_str_plain_NID_subject_alt_name;
static PyObject *const_str_plain_add_cert;
static PyObject *const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple;
static PyObject *const_str_plain_X509V3_EXT_nconf;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error;
extern PyObject *const_str_plain_BIO_get_mem_data;
static PyObject *const_str_digest_5cb0319d0378026eb0ef49838e525520;
extern PyObject *const_str_plain_signature;
static PyObject *const_str_plain_builtin_curves;
static PyObject *const_str_digest_62c9c3f244d467c166be64cd38a755a7;
static PyObject *const_str_digest_f41f911aba33894e1da796354264d96a;
static PyObject *const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6;
extern PyObject *const_str_digest_426349c7e201b358f2086eb3f7fb6f47;
extern PyObject *const_str_plain_ctx;
static PyObject *const_str_plain_subject_cert;
extern PyObject *const_str_plain_encode;
static PyObject *const_str_plain_set_pubkey;
extern PyObject *const_str_plain_X509_NAME_free;
static PyObject *const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac;
static PyObject *const_str_plain_exceptionType;
static PyObject *const_str_digest_61dbd227935e54cb40eecc7de8b8596b;
static PyObject *const_str_digest_1d608c98cc8048d3f7b439059ee29b66;
static PyObject *const_str_digest_79b48b443a4edf88bd64a278e98529d3;
static PyObject *const_str_plain_from_nid;
extern PyObject *const_str_plain_PEM_write_bio_X509_REQ;
static PyObject *const_str_digest_11dbf726734533c622c12e725d15648e;
static PyObject *const_str_plain__spki;
static PyObject *const_str_plain_from_cryptography;
static PyObject *const_str_digest_f56881bccbbc40c6643f9603628e7a5c;
static PyObject *const_str_digest_7a5005a2e44b5258634f5b2837cd8b81;
static PyObject *const_str_plain_set_notBefore;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_load_pkcs7_data;
static PyObject *const_str_plain_pycacerts;
static PyObject *const_str_plain_cacerts;
static PyObject *const_str_digest_95aba6f0be0722dff4a715f251a45159;
static PyObject *const_str_digest_4d148c7b7c1bc2fec101962dc1ce2c2f;
static PyObject *const_str_plain_signature_buffer;
static PyObject *const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple;
extern PyObject *const_str_plain_EC_KEY_new_by_curve_name;
extern PyObject *const_int_0;
static PyObject *const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21;
static PyObject *const_str_digest_9781f115d6516693d922717b11376a73;
extern PyObject *const_str_plain_result;
extern PyObject *const_str_plain_X509_CRL_new;
extern PyObject *const_str_plain_EVP_PKEY_new;
static PyObject *const_str_plain__new_mem_buf;
static PyObject *const_str_plain_X509_verify_cert_error_string;
static PyObject *const_str_plain_CRLType;
static PyObject *const_str_digest_79dac080796da8f8fc9c66ebe460ce2f;
static PyObject *const_str_plain_X509_CRL_print;
extern PyObject *const_str_plain_rsa;
extern PyObject *const_str_plain_X509_sign;
static PyObject *const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple;
extern PyObject *const_str_digest_9abb9f40508debfa3aae6d9135753f7e;
extern PyObject *const_str_plain_e;
static PyObject *const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60;
extern PyObject *const_str_plain_OpenSSL_add_all_algorithms;
static PyObject *const_str_digest_d03be6fc9f3e6729b366e69e0856a450;
extern PyObject *const_tuple_str_plain_self_str_plain_issuer_tuple;
static PyObject *const_str_plain_bignum_ptr;
extern PyObject *const_str_plain_gc;
static PyObject *const_str_digest_11c225ccbab9acffc38107dee9691702;
static PyObject *const_str_plain_OBJ_obj2nid;
static PyObject *const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1;
extern PyObject *const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
extern PyObject *const_str_plain__issuer;
static PyObject *const_str_digest_9ae52cddf69d053d9518f458a81ffa1b;
static PyObject *const_str_digest_68e309761e6d5dc5f5c1e53801284f3a;
static PyObject *const_str_plain_X509_EXTENSION_dup;
static PyObject *const_str_digest_7163953ad9ff69e46167d396f5625cf7;
extern PyObject *const_str_plain___lt__;
static PyObject *const_str_plain_SSL_FILETYPE_ASN1;
extern PyObject *const_str_plain_d2i_PrivateKey_bio;
extern PyObject *const_int_pos_100;
static PyObject *const_tuple_76984bb103279dcce095840ed073cae5_tuple;
static PyObject *const_str_plain_sometime;
extern PyObject *const_tuple_str_plain_where_tuple;
extern PyObject *const_str_plain_X509_REQ_get_pubkey;
static PyObject *const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9;
static PyObject *const_str_plain_callback_args;
extern PyObject *const_str_plain_datetime;
extern PyObject *const_str_plain_digest;
static PyObject *const_str_plain_set_store;
extern PyObject *const_str_plain__UNSPECIFIED;
static PyObject *const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7;
static PyObject *const_str_digest_5f245d1740d80da82563e21c9c4f4fbf;
extern PyObject *const_str_plain_append;
static PyObject *const_str_plain_parse_result;
static PyObject *const_str_plain_reason_code;
static PyObject *const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple;
extern PyObject *const_str_plain_verify;
static PyObject *const_str_plain_set_certificate;
static PyObject *const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple;
static PyObject *const_str_digest_1cf455235163a6978480cc7b12198a27;
static PyObject *const_str_plain_format_result;
extern PyObject *const_str_plain___new__;
extern PyObject *const_str_plain_str;
static PyObject *const_str_digest_11e1356f3459cf012eb88d7288e20e85;
static PyObject *const_str_digest_7338acfc5a3b91c07965b6befadc8c7a;
static PyObject *const_str_plain_get_elliptic_curves;
extern PyObject *const_str_plain_where;
static PyObject *const_str_digest_40e46351c3b918f338d6e675fea0b1ca;
extern PyObject *const_str_plain__make_assert;
static PyObject *const_tuple_str_plain_self_str_plain_exceptionType_tuple;
static PyObject *const_str_plain_RSA_print;
static PyObject *const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple;
extern PyObject *const_str_plain_RSA_free;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_str_plain_result_code;
extern PyObject *const_str_plain_d2i_PUBKEY_bio;
static PyObject *const_int_pos_60;
extern PyObject *const_str_plain_callable;
static PyObject *const_str_plain_X509_subject_name_hash;
extern PyObject *const_str_plain_ERR_GET_REASON;
extern PyObject *const_str_plain_X509_NAME_dup;
static PyObject *const_str_plain_load_certificate_request;
static PyObject *const_str_plain_set_serial;
static PyObject *const_str_plain_X509_NAME_hash;
static PyObject *const_str_digest_1f7559cec53c5da336c35128000e1652;
extern PyObject *const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_plain_bignum_serial;
static PyObject *const_str_digest_39641ea33feffed70915f1c391cc979e;
static PyObject *const_str_digest_a12e23c82fcdd4004653da2260294f18;
extern PyObject *const_str_plain__evp_pkey_to_private_key;
extern PyObject *const_str_plain_X509_EXTENSION_free;
extern PyObject *const_str_plain_replace;
extern PyObject *const_str_plain_DNS;
static PyObject *const_str_plain_from_cryptography_key;
extern PyObject *const_str_digest_e33a7f733650e687efe98e5491512b82;
extern PyObject *const_str_plain_PEM_read_bio_X509;
static PyObject *const_str_digest_14af5bef46557b92b5b6c4d670b7a1b8;
static PyObject *const_str_digest_7db2dd03172a07cae912434bb4ced82e;
static PyObject *const_str_plain__cacerts;
static PyObject *const_str_plain_POLICY_CHECK;
static PyObject *const_str_plain_entry_index;
extern PyObject *const_str_plain__evp_pkey;
static PyObject *const_str_digest_80438074180d95b1a2291874613077b5;
static PyObject *const_str_digest_40ce736ad6e52bc3df10a00233b89318;
extern PyObject *const_str_plain_X509_get_notBefore;
extern PyObject *const_str_plain_revoked;
static PyObject *const_str_plain_sign_result;
static PyObject *const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_cessationOfOperation;
extern PyObject *const_int_pos_512;
static PyObject *const_tuple_str_plain_self_str_plain_spki_tuple;
static PyObject *const_str_digest_141cd36b231fb1bf7caa692f86984b7e;
static PyObject *const_str_plain_NetscapeSPKI;
static PyObject *const_str_digest_866d2e2176ccb47ef7515cbc6c993151;
extern PyObject *const_str_plain__PassphraseHelper;
static PyObject *const_str_plain_export;
static PyObject *const_str_plain_friendlyname_length;
extern PyObject *const_str_plain_name;
static PyObject *const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f;
extern PyObject *const_str_plain_ASN1_TIME_to_generalizedtime;
static PyObject *const_str_plain_NETSCAPE_SPKI_get_pubkey;
static PyObject *const_str_plain_URI;
static PyObject *const_str_plain_ASN1_STRING_set_default_mask_asc;
static PyObject *const_str_plain_octet_result;
extern PyObject *const_tuple_str_plain_deprecated_tuple;
extern PyObject *const_str_plain_PEM_read_bio_X509_CRL;
static PyObject *const_str_digest_463cb3c7dbe7753c6683d3195629dca3;
static PyObject *const_str_digest_75a631b53fc267af68d162051a06411c;
extern PyObject *const_str_empty;
static PyObject *const_str_plain_X509_V_FLAG_CRL_CHECK;
extern PyObject *const_str_plain_param;
extern PyObject *const_str_plain___setattr__;
static PyObject *const_str_plain_X509_NAME_add_entry_by_NID;
extern PyObject *const_tuple_str_space_str_empty_tuple;
static PyObject *const_str_plain_NetscapeSPKIType;
static PyObject *const_str_plain_INHIBIT_MAP;
static PyObject *const_str_digest_a078d66f5fc281c4117a5e5c24749809;
static PyObject *const_str_digest_1691c1bfd96a22cfc48aca410da45814;
extern PyObject *const_str_plain_X509_CRL_set_lastUpdate;
extern PyObject *const_str_plain_DSA_new;
static PyObject *const_str_plain_X509_V_FLAG_IGNORE_CRITICAL;
static PyObject *const_dict_5608fce8424ef5aca22387357d834999;
extern PyObject *const_str_plain_X509_EXTENSION_get_object;
extern PyObject *const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
extern PyObject *const_str_plain_PEM_write_bio_X509_CRL;
extern PyObject *const_int_pos_24;
extern PyObject *const_tuple_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9_int_pos_1_tuple;
static PyObject *const_str_digest_74b73fd54833bfb6b761307c477c0a28;
extern PyObject *const_str_plain_ASN1_TIME_new;
extern PyObject *const_str_plain_RSA_new;
static PyObject *const_list_b8e29824b436479d358fd3771a611e70_list;
static PyObject *const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50;
extern PyObject *const_str_plain_ch;
static PyObject *const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_crl_tuple;
static PyObject *const_str_digest_3121be4a855650e38916196ca238bf2b;
extern PyObject *const_tuple_false_false_tuple;
extern PyObject *const_str_plain_text_type;
static PyObject *const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple;
extern PyObject *const_str_plain_Error;
extern PyObject *const_str_plain__set_asn1_time;
static PyObject *const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple;
extern PyObject *const_str_plain_X509_add_ext;
extern PyObject *const_str_plain_X509_REQ_add_extensions;
static PyObject *const_str_plain_get_type_name;
extern PyObject *const_str_plain__init;
extern PyObject *const_str_plain_sk_X509_EXTENSION_num;
extern PyObject *const_str_plain_boundary;
static PyObject *const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9;
static PyObject *const_str_digest_1f681e9f80c6df652cbc3a085be49171;
extern PyObject *const_str_plain__;
static PyObject *const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple;
static PyObject *const_str_plain_new_reason_ext;
extern PyObject *const_str_plain_BIO_free;
static PyObject *const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK;
static PyObject *const_str_digest_7d6056c968d1eebfab898757e6f3054e;
static PyObject *const_str_digest_721230a42e287d5632d061ff8f0376d6;
extern PyObject *const_str_plain_None;
static PyObject *const_str_digest_f583009b639aad56f3c96c175e595626;
static PyObject *const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple;
static PyObject *const_str_plain__more_args;
extern PyObject *const_str_plain_ffi;
static PyObject *const_str_plain_set_notAfter;
static PyObject *const_str_digest_a7eaace656db47cf2975484b27c818e9;
static PyObject *const_str_plain_friendlyname_buffer;
static PyObject *const_str_plain__initialized;
static PyObject *const_str_plain_RSA_F4;
static PyObject *const_str_plain__read_passphrase;
extern PyObject *const_tuple_str_plain_self_str_plain_cert_tuple;
static PyObject *const_tuple_str_plain___tuple;
static PyObject *const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple;
static PyObject *const_str_plain_maciter;
extern PyObject *const_str_plain_PKey;
static PyObject *const_str_plain__get_backend;
extern PyObject *const_str_plain_ext;
static PyObject *const_str_plain__set_name;
extern PyObject *const_str_plain_ASN1_INTEGER_to_BN;
extern PyObject *const_str_plain_OBJ_txt2nid;
static PyObject *const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38;
extern PyObject *const_str_plain_PY3;
extern PyObject *const_str_plain_pop;
static PyObject *const_str_plain_set_ca_certificates;
static PyObject *const_str_digest_0b708bb28192f1a165c843c47343f35a;
static PyObject *const_tuple_str_plain_dsa_str_plain_rsa_tuple;
extern PyObject *const_str_plain_DSA_free;
extern PyObject *const_str_plain_ASN1_TIME_set_string;
static PyObject *const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55;
extern PyObject *const_str_plain_raise_if_problem;
static PyObject *const_str_plain_get_reason;
static PyObject *const_str_plain_answer;
static PyObject *const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple;
extern PyObject *const_str_plain__lib;
static PyObject *const_str_plain_X509_VERIFY_PARAM_set_time;
static PyObject *const_str_plain_X509_REQ_get_version;
static PyObject *const_str_digest_989a9acfa289de1c2c451525451533c9;
static PyObject *const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4;
static PyObject *const_str_plain_get_version;
static PyObject *const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585;
static PyObject *const_str_plain_X509_REVOKED_delete_ext;
extern PyObject *const_str_plain_generate_key;
extern PyObject *const_tuple_str_plain_self_str_plain_backend_tuple;
extern PyObject *const_str_plain_partial;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_dump_publickey;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_str_plain_FILETYPE_TEXT;
extern PyObject *const_str_plain_EC_KEY_free;
extern PyObject *const_str_plain__exception_from_error_queue;
static PyObject *const_str_plain_PKCS12;
extern PyObject *const_str_plain_dump_certificate;
static PyObject *const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple;
static PyObject *const_str_plain_get_extension;
extern PyObject *const_str_plain_type;
extern PyObject *const_str_plain_ASN1_GENERALIZEDTIME_free;
static PyObject *const_str_digest_d0137950921f709b6c00a3276a078e5f;
static PyObject *const_str_digest_de1d9872d12371b2ead20f3aa79dc834;
extern PyObject *const_str_plain_decode;
static PyObject *const_str_plain_x509req;
extern PyObject *const_str_plain_to_cryptography;
static PyObject *const_str_digest_685b3ded6e482839a3710e6a448d8669;
extern PyObject *const_str_plain_cls;
extern PyObject *const_str_plain_strptime;
static PyObject *const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
extern PyObject *const_str_plain_sk_X509_num;
static PyObject *const_str_plain_get_serial;
static PyObject *const_str_digest_9a71d9e6319c409dff859e67083fc41c;
static PyObject *const_str_digest_3a45faa244ca861d389c340b29a28988;
extern PyObject *const_tuple_str_plain_self_str_plain_revoked_tuple;
static PyObject *const_str_plain_num_curves;
extern PyObject *const_str_plain_i2d_X509_NAME;
static PyObject *const_str_plain_X509_STORE_free;
static PyObject *const_str_digest_ee89bc744832ab3afc27c4e7a4a73b66;
extern PyObject *const_str_plain_message;
static PyObject *const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE;
static PyObject *const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
extern PyObject *const_str_plain__CertificateSigningRequest;
extern PyObject *const_str_plain_backend;
static PyObject *const_str_plain_set_version;
static PyObject *const_str_plain__X509NameInvalidator;
extern PyObject *const_str_plain_key;
extern PyObject *const_str_plain_object;
static PyObject *const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple;
extern PyObject *const_str_plain_cast;
extern PyObject *const_str_plain_curve;
extern PyObject *const_str_plain_size;
static PyObject *const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
extern PyObject *const_str_plain___ne__;
extern PyObject *const_str_plain_d2i_PKCS12_bio;
static PyObject *const_str_plain_pycacert;
static PyObject *const_str_plain_TYPE_DH;
extern PyObject *const_tuple_str_plain_x509_tuple;
extern PyObject *const_str_plain__text_to_bytes_and_warn;
static PyObject *const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple;
static PyObject *const_str_plain_PKCS7_type_is_signed;
extern PyObject *const_str_plain_i2d_X509_CRL_bio;
extern PyObject *const_str_plain_obj;
static PyObject *const_str_plain_X509_V_FLAG_CRL_CHECK_ALL;
static PyObject *const_str_plain__subject_invalidator;
static PyObject *const_str_plain_PKCS7_type_is_signedAndEnveloped;
extern PyObject *const_str_plain__cert;
static PyObject *const_str_digest_f68048107421fed17c8f1bc19be3ec03;
static PyObject *const_str_plain_set_time;
static PyObject *const_str_digest_8e9fba48e24a08144a915d52e31f6d23;
static PyObject *const_str_plain_X509_digest;
extern PyObject *const_str_plain_upper;
static PyObject *const_str_digest_5997506aef8ffc5e12c453030416acc6;
static PyObject *const_str_plain_X509_V_FLAG_X509_STRICT;
static PyObject *const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple;
static PyObject *const_str_plain_passphrase;
static PyObject *const_str_digest_3918253e50729a002fea544312970ff5;
static PyObject *const_str_plain_type_is_data;
extern PyObject *const_str_plain_EVP_PKEY_DH;
static PyObject *const_str_plain_revoked_copy;
static PyObject *const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple;
static PyObject *const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc;
static PyObject *const_str_plain_X509V3_set_ctx;
static PyObject *const_str_plain_get_elliptic_curve;
extern PyObject *const_str_plain_value;
extern PyObject *const_str_plain_store_ctx;
extern PyObject *const_str_plain_extension;
extern PyObject *const_str_plain_certificateHold;
extern PyObject *const_str_plain_X509_CRL_set_version;
static PyObject *const_str_digest_c71c443223c73b253b21961ef3bd7c9e;
static PyObject *const_str_digest_a643e6a1050d6f3782a0d190235d80a7;
extern PyObject *const_str_plain_email;
static PyObject *const_str_digest_35e2a27cee76091329550405e1cb7dc4;
static PyObject *const_str_plain_NETSCAPE_SPKI_free;
extern PyObject *const_str_plain_PEM_write_bio_PUBKEY;
static PyObject *const_str_plain_get_privatekey;
static PyObject *const_str_plain_X509_print_ex;
static PyObject *const_str_digest_b3f225987bb27e065a500d7fe8bd7c70;
extern PyObject *const_str_plain_DeprecationWarning;
extern PyObject *const_str_plain_i2d_X509_REQ_bio;
static PyObject *const_str_plain__extension;
static PyObject *const_str_digest_c0aedec8dc85440d3dace529a9d9050e;
static PyObject *const_str_plain_fval;
static PyObject *const_str_digest_5699814601a04aa972bd2f18de396c39;
static PyObject *const_str_digest_48639cf22fbd4e6b3714265dae0dbed8;
static PyObject *const_str_plain_string_data;
extern PyObject *const_str_plain_serial;
extern PyObject *const_int_pos_16;
static PyObject *const_str_plain_NETSCAPE_SPKI_verify;
static PyObject *const_str_digest_d6b3262f79e4b59cd83ab54699c92117;
static PyObject *const_str_plain_X509ExtensionType;
static PyObject *const_str_digest_1a7a898c4490dd89b305492a40bf2633;
static PyObject *const_str_plain_X509StoreType;
extern PyObject *const_tuple_str_plain__Certificate_tuple;
static PyObject *const_str_digest_016ce3807ea72a262d921fa7d1804717;
extern PyObject *const_str_plain_NULL;
extern PyObject *const_str_plain_X509_CRL_free;
static PyObject *const_str_plain_X509_STORE_CTX_init;
static PyObject *const_str_plain_dump_crl;
static PyObject *const_tuple_str_plain_self_str_plain_x509_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple;
extern PyObject *const_str_plain_errors;
static PyObject *const_str_plain_get_issuer;
static PyObject *const_str_plain_X509_STORE_new;
static PyObject *const_list_298f4a46a008df82aecc87d37443e76b_list;
extern PyObject *const_str_plain_CertificateRevocationList;
static PyObject *const_str_plain_EVP_PKEY_bits;
extern PyObject *const_int_pos_1;
extern PyObject *const_str_plain_EVP_get_cipherbyname;
extern PyObject *const_str_plain_flags;
static PyObject *const_str_plain_set_flags;
static PyObject *const_str_plain__store_ctx;
extern PyObject *const_str_plain_X509_NAME_ENTRY_get_data;
extern PyObject *const_str_plain_RSAPrivateKey;
extern PyObject *const_str_plain_add_result;
static PyObject *const_str_plain_set_reason;
static PyObject *const_str_plain_cipher_obj;
extern PyObject *const_str_plain_X509_set_serialNumber;
extern PyObject *const_str_plain_cert;
static PyObject *const_str_plain_encode_result;
extern PyObject *const_str_plain_iter;
extern PyObject *const_str_plain_RSA_generate_key_ex;
extern PyObject *const_str_plain_X509_REQ_sign;
extern PyObject *const_str_plain_err_reason;
extern PyObject *const_str_plain_copy;
static PyObject *const_tuple_80a9571108770bd34772239ad97225a5_tuple;
static PyObject *const_str_digest_213346f5e36f3faf7ff7a566deec4adb;
extern PyObject *const_str_digest_c561652c58984ec0e9541542aa405594;
extern PyObject *const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple;
static PyObject *const_str_plain_amount;
static PyObject *const_str_plain_set_nextUpdate;
static PyObject *const_str_plain_PKCS7Type;
static PyObject *const_str_plain_CRL;
static PyObject *const_str_plain_md_ctx;
static PyObject *const_str_plain__cleanup;
extern PyObject *const_str_plain_X509_NAME_ENTRY_free;
static PyObject *const_str_digest_6b975dcb77568b31c2312e045b6c638c;
static PyObject *const_str_plain__bio_to_string;
static PyObject *const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b;
extern PyObject *const_str_plain_X509_REQ_get_extensions;
static PyObject *const_str_plain_X509_verify_cert;
extern PyObject *const_str_plain_sk_X509_value;
static PyObject *const_str_plain__get_asn1_time;
static PyObject *const_str_digest_3f7d687efa133ae490fe62a28c3c2584;
extern PyObject *const_str_plain_join;
extern PyObject *const_str_plain_EVP_PKEY_size;
extern PyObject *const_str_plain_ASN1_ENUMERATED_free;
static PyObject *const_str_digest_e4c79524acf8a72de25c6c6491f370a8;
static PyObject *const_str_plain_set_rev_date;
extern PyObject *const_str_plain_hash;
extern PyObject *const_str_digest_499043b9b2da602637f07b1aa101ddfb;
extern PyObject *const_tuple_str_plain_self_str_plain_pkey_tuple;
extern PyObject *const_str_plain_X509_CRL_add0_revoked;
extern PyObject *const_str_plain_Cryptography_EVP_MD_CTX_free;
extern PyObject *const_str_plain_version;
extern PyObject *const_str_plain_GEN_EMAIL;
static PyObject *const_str_plain_load_certificate;
extern PyObject *const_str_plain_X509_REQ_set_version;
static PyObject *const_str_plain_X509_STORE_CTX_free;
static PyObject *const_str_digest_719137938e890576c1050ba31a668078;
static PyObject *const_str_digest_500f278b67471fc0f770fccc80d65d95;
static PyObject *const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd;
static PyObject *const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80;
extern PyObject *const_str_plain___ge__;
static PyObject *const_str_plain_X509Extension;
extern PyObject *const_str_plain_PEM_read_bio_PUBKEY;
extern PyObject *const_str_plain___eq__;
extern PyObject *const_str_plain___le__;
static PyObject *const_str_digest_6ef28169edd3cfe530885f6f9d09c390;
extern PyObject *const_str_plain_EVP_PKEY_RSA;
static PyObject *const_str_digest_b1f5a355e1403668d0044e1a65ec29ce;
static PyObject *const_tuple_13745beac221529fe5d89135e9b648d3_tuple;
extern PyObject *const_str_plain_BN_hex2bn;
static PyObject *const_str_digest_c237653198d1acecae3452511968b22e;
static PyObject *const_str_plain_type_is_signed;
static PyObject *const_str_digest_af63c2663b0a5e83daac69d308dcb1d6;
extern PyObject *const_str_plain_FILETYPE_ASN1;
extern PyObject *const_str_plain_BIO_new;
static PyObject *const_str_plain_get_friendlyname;
extern PyObject *const_str_plain_X509_get_issuer_name;
static PyObject *const_str_plain_set_friendlyname;
static PyObject *const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple;
static PyObject *const_str_plain_IGNORE_CRITICAL;
static PyObject *const_str_plain__untested_error;
static PyObject *const_str_plain_load_publickey;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain__openssl_assert;
extern PyObject *const_str_plain_d;
static PyObject *const_tuple_e0284b4dc341731363d45f065b316e64_tuple;
extern PyObject *const_str_plain_f;
extern PyObject *const_str_plain_crl;
extern PyObject *const_str_plain_hex_str;
static PyObject *const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple;
extern PyObject *const_str_plain_c;
static PyObject *const_str_digest_1dbb147d3e039266688c4d87287eaaad;
static PyObject *const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd;
static PyObject *const_tuple_53b63b794c8b8f328f3f365985abd328_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple;
static PyObject *const_str_plain_X509_STORE_set_flags;
extern PyObject *const_str_plain_buffer;
extern PyObject *const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple;
extern PyObject *const_str_plain_X509_NAME_ENTRY_get_object;
static PyObject *const_tuple_be611311fb5723111b9692ddf834f10b_tuple;
static PyObject *const_str_digest_9c28b2ef32679900c21c54152be8ce03;
extern PyObject *const_str_plain_X509_CRL_sign;
static PyObject *const_str_digest_4097a084fab55cf5c5baa1b785e7c82a;
extern PyObject *const_str_plain_r;
static PyObject *const_str_digest_f35548e1d45f67292233a83f1d0adcce;
static PyObject *const_str_plain_get_extensions;
static PyObject *const_str_plain_algor;
static PyObject *const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8;
static PyObject *const_str_plain_EVP_SignFinal;
extern PyObject *const_str_plain__x509_crl;
extern PyObject *const_str_plain_X509Store;
extern PyObject *const_str_plain_names;
extern PyObject *const_str_plain_write_bio;
extern PyObject *const_str_plain_cryptography;
static PyObject *const_str_plain_get_notAfter;
extern PyObject *const_str_plain_EVP_PKEY_get1_RSA;
static PyObject *const_str_plain__set_boundary_time;
extern PyObject *const_str_plain_DSAPublicKey;
extern PyObject *const_str_plain___repr__;
extern PyObject *const_str_plain_FILETYPE_PEM;
extern PyObject *const_str_plain_superseded;
extern PyObject *const_str_plain_native;
static PyObject *const_str_plain_CB_ISSUER_CHECK;
static PyObject *const_str_plain__issuer_invalidator;
static PyObject *const_str_plain_PKCS7_type_is_enveloped;
extern PyObject *const_str_plain__PY3;
static PyObject *const_str_plain_ASN1_STRING_type;
static PyObject *const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple;
static PyObject *const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple;
extern PyObject *const_str_plain___all__;
static PyObject *const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
static PyObject *const_str_digest_221848055f0a545c7ef1969a37bb78a5;
static PyObject *const_str_plain_EC_get_builtin_curves;
static PyObject *const_str_plain_asn1_serial;
extern PyObject *const_str_plain_six;
extern PyObject *const_str_plain_X509_REVOKED_get_ext_count;
extern PyObject *const_str_plain_GENERAL_NAMES_free;
extern PyObject *const_str_plain_Cryptography_EVP_MD_CTX_new;
static PyObject *const_str_plain__cmp;
extern PyObject *const_str_plain_d2i_X509_bio;
extern PyObject *const_str_plain___debug__;
extern PyObject *const_str_plain_sk_GENERAL_NAME_value;
extern PyObject *const_str_plain_callback;
static PyObject *const_str_digest_0226e12d6e09b849c37787a1a7ec35a4;
static PyObject *const_str_plain_pyrev;
extern PyObject *const_str_plain_sk_X509_REVOKED_value;
static PyObject *const_str_plain_set_serial_number;
static PyObject *const_str_digest_bbde1e297eda38e770b8fce1d06c225b;
static PyObject *const_str_digest_3b5fd85224219fd172d589ec8f98a12a;
static PyObject *const_tuple_8110525d9a52cec647809d72afbc7239_tuple;
static PyObject *const_str_digest_4560cdf69c017b7cd264323295e708cb;
static PyObject *const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple;
static PyObject *const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple;
static PyObject *const_str_digest_5e37d069c5e76ee6d50c7e91b7181934;
extern PyObject *const_str_plain___gt__;
static PyObject *const_str_plain_b16encode;
static PyObject *const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple;
static PyObject *const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7;
static PyObject *const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple;
static PyObject *const_str_plain_EVP_SignUpdate;
static PyObject *const_str_plain_digest_name;
extern PyObject *const_str_plain_X509_get_ext;
static PyObject *const_str_digest_0b9d4db9119537682a1f5302a9cbcc57;
extern PyObject *const_str_plain_X509_REQ_verify;
extern PyObject *const_str_plain_GEN_URI;
static PyObject *const_str_plain_X509_V_FLAG_EXPLICIT_POLICY;
static PyObject *const_str_plain_PKCS7_free;
static PyObject *const_str_digest_1d1fec7c0642196df296efbe43db1801;
static PyObject *const_str_plain_exts;
static PyObject *const_str_plain_TYPE_EC;
static PyObject *const_str_plain_rwflag;
static PyObject *const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple;
static PyObject *const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple;
static PyObject *const_str_plain_CRL_CHECK_ALL;
static PyObject *const_str_digest_d85051204198165c5d51e35c1e5d5077;
static PyObject *const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d;
static PyObject *const_str_plain_TYPE_DSA;
extern PyObject *const_str_plain_pycert;
static PyObject *const_str_plain_M_ASN1_OCTET_STRING_print;
static PyObject *const_str_digest_07697dd6fa4854473fa24b52569d5636;
static PyObject *const_str_plain_has_expired;
static PyObject *const_str_plain_gmtime_adj_notAfter;
extern PyObject *const_str_plain_extensions;
static PyObject *const_str_plain__EllipticCurve;
static PyObject *const_str_digest_007f81c06fa49e709fd9306cc6c26627;
static PyObject *const_str_plain_X509Req;
extern PyObject *const_str_plain_BN_free;
extern PyObject *const_str_plain_CertificateSigningRequest;
static PyObject *const_str_plain_small_serial;
static PyObject *const_str_plain_X509_STORE_add_cert;
static PyObject *const_str_plain_revoked_stack;
extern PyObject *const_str_plain_nid;
extern PyObject *const_str_plain_property;
extern PyObject *const_str_plain_X509_get_notAfter;
static PyObject *const_str_plain_X509_STORE_CTX_new;
extern PyObject *const_str_plain_X509_dup;
static PyObject *const_str_plain_digest_result;
extern PyObject *const_str_plain_BN_new;
static PyObject *const_tuple_str_plain__CertificateRevocationList_tuple;
extern PyObject *const_str_plain_helper;
extern PyObject *const_str_plain_BN_to_ASN1_INTEGER;
extern PyObject *const_str_plain_X509_REVOKED_new;
static PyObject *const_str_plain_issuer_cert;
static PyObject *const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple;
static PyObject *const_str_plain_gmtime_adj_notBefore;
extern PyObject *const_str_digest_9838c39bdf9fdb401c17b0106d8660a3;
extern PyObject *const_str_plain_Cryptography_X509_REVOKED_dup;
extern PyObject *const_str_plain__name;
static PyObject *const_str_plain__exception_from_context;
static PyObject *const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple;
static PyObject *const_str_plain_X509_STORE_set1_param;
static PyObject *const_str_plain_get_critical;
static PyObject *const_str_plain_print_result;
extern PyObject *const_str_plain_length;
static PyObject *const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple;
static PyObject *const_str_plain_encoded;
static PyObject *const_str_plain__req;
static PyObject *const_str_plain_X509_CRL_sort;
extern PyObject *const_str_plain_sk_X509_EXTENSION_value;
static PyObject *const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f;
static PyObject *const_str_plain__prefixes;
static PyObject *const_tuple_5209455ecbb28249752027c3a839ae1c_tuple;
extern PyObject *const_str_plain_OBJ_nid2sn;
extern PyObject *const_str_plain_d2i_X509_REQ_bio;
extern PyObject *const_str_plain_ASN1_INTEGER_free;
static PyObject *const_tuple_str_plain_self_str_plain_req_tuple;
extern PyObject *const_str_plain_lib;
static PyObject *const_str_plain_PEM_write_bio_PrivateKey;
static PyObject *const_str_plain_PEM_read_bio_PKCS7;
static PyObject *const_str_plain_friendlyname;
static PyObject *const_tuple_str_plain_self_str_plain_which_tuple;
static PyObject *const_str_digest_0ba82c04a076f46925a74539c2a8ba40;
extern PyObject *const_str_plain_ERR_peek_error;
static PyObject *const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple;
static PyObject *const_str_plain_to_cryptography_key;
extern PyObject *const_str_plain_algorithm;
static PyObject *const_str_digest_97388c7ddfea4f913fec5c846dd26ef1;
static PyObject *const_tuple_79603f0465bd62773d6ec6c98e743896_tuple;
static PyObject *const_str_digest_e2d15f7f418fdd55a54be9ea476feee3;
static PyObject *const_str_plain_NETSCAPE_SPKI_sign;
static PyObject *const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple;
static PyObject *const_str_digest_61d70cefdce1472400ab8a06d64ef78a;
extern PyObject *const_str_plain_parts;
static PyObject *const_str_plain_load_privatekey;
static PyObject *const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple;
static PyObject *const_str_plain_buffer_length;
static PyObject *const_str_plain_bn_result;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple;
static PyObject *const_str_digest_e19f4eaf61167e65441aca909fe75b36;
static PyObject *const_str_plain_hex_serial;
static PyObject *const_str_plain_MBSTRING_UTF8;
static PyObject *const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple;
static PyObject *const_str_plain_Revoked;
extern PyObject *const_str_plain___str__;
extern PyObject *const_str_plain_PKCS12_parse;
static PyObject *const_str_plain__only_public;
static PyObject *const_tuple_str_plain_self_str_plain_dt_tuple;
extern PyObject *const_str_plain_affiliationChanged;
extern PyObject *const_str_plain_evp_md;
extern PyObject *const_str_plain__store;
extern PyObject *const_str_plain_X509_CRL_get_REVOKED;
static PyObject *const_str_plain_GENERAL_NAME_print;
static PyObject *const_str_plain__names;
static PyObject *const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
static PyObject *const_tuple_str_plain_self_str_plain_store_tuple;
extern PyObject *const_str_plain_ascii;
extern PyObject *const_str_plain_type_name;
static PyObject *const_str_plain_CACompromise;
static PyObject *const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple;
extern PyObject *const_str_plain_X509_REVOKED_get_ext;
static PyObject *const_str_plain_add_extensions;
static PyObject *const_str_plain_EVP_VerifyInit;
static PyObject *const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc;
static PyObject *const_str_plain_NID_crl_reason;
static PyObject *const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_str_plain_generalized_timestamp;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_str_plain_X509StoreContextError;
static PyObject *const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92;
static PyObject *const_str_plain_utcnow;
static PyObject *const_tuple_str_plain_name_str_plain_curve_tuple;
extern PyObject *const_str_plain_X509_get_version;
static PyObject *const_str_plain_notAfter;
static PyObject *const_str_plain_X509_V_FLAG_INHIBIT_MAP;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple;
static PyObject *const_str_digest_fdf1281f34921aa68eda346883bb972d;
static PyObject *const_str_digest_cf86a9123926465ab14a7bd2861326f6;
static PyObject *const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple;
extern PyObject *const_str_plain_sk_X509_free;
static PyObject *const_str_plain_ent_obj;
static PyObject *const_str_plain__owner;
static PyObject *const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple;
extern PyObject *const_str_plain_X509_REQ_get_subject_name;
extern PyObject *const_str_plain_X509_EXTENSION_get_critical;
extern PyObject *const_str_plain___module__;
static PyObject *const_str_plain_ASN1_STRING_data;
static PyObject *const_str_digest_819566a56c114d5ab553db6b3a965184;
static PyObject *const_str_plain_sk_X509_new_null;
extern PyObject *const_str_plain_lower;
static PyObject *const_str_plain_ASN1_STRING_length;
static PyObject *const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple;
static PyObject *const_str_plain_type_is_signedAndEnveloped;
static PyObject *const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple;
static PyObject *const_str_plain_X509_NAME_oneline;
static PyObject *const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea;
extern PyObject *const_str_plain_X509_get_pubkey;
extern PyObject *const_str_plain__x509_req;
static PyObject *const_str_digest_c623dd0c947983ab2cfcbe4c53400720;
static PyObject *const_str_plain_pkcs7;
static PyObject *const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0;
static PyObject *const_str_plain_certificate;
extern PyObject *const_str_plain_exception_from_error_queue;
extern PyObject *const_str_plain_DSA_generate_key;
extern PyObject *const_str_plain_SSL_load_error_strings;
static PyObject *const_str_plain_EVP_PKEY_type;
extern PyObject *const_str_plain__x509;
static PyObject *const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple;
static PyObject *const_str_plain_verify_result;
static PyObject *const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple;
static PyObject *const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9;
extern PyObject *const_str_plain_string;
extern PyObject *const_tuple_str_plain_self_str_plain_key_tuple;
static PyObject *const_str_digest_2cf9e4c7f607857df636a128997ff3fc;
extern PyObject *const_str_plain_p12;
static PyObject *const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple;
static PyObject *const_str_plain_dump_privatekey;
static PyObject *const_str_digest_686e4f9f1c51b7038afe792590c33346;
static PyObject *const_str_digest_0d8911e895179dcd467b4e9de2f411d4;
extern PyObject *const_int_pos_65535;
static PyObject *const_str_plain__load_elliptic_curves;
static PyObject *const_str_plain_pykey;
static PyObject *const_str_plain__pkcs7;
extern PyObject *const_str_plain_EVP_PKEY_set1_DSA;
static PyObject *const_str_plain__get_boundary_time;
extern PyObject *const_str_plain_sk_GENERAL_NAME_num;
static PyObject *const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple;
static PyObject *const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple;
static PyObject *const_str_plain_pem_password_cb;
static PyObject *const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple;
static PyObject *const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple;
static PyObject *const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a;
static PyObject *const_str_plain_X509_STORE_add_crl;
static PyObject *const_str_plain_PKCS7;
static PyObject *const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple;
extern PyObject *const_str_plain_ret;
extern PyObject *const_str_plain_functools;
extern PyObject *const_str_plain_RSAPublicKey;
static PyObject *const_str_plain_final_result;
static PyObject *const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple;
static PyObject *const_str_plain_X509_get0_tbs_sigalg;
static PyObject *const_tuple_d959e8503cbe0fd15122162c0da60661_tuple;
extern PyObject *const_str_plain_byte_string;
static PyObject *const_str_plain_get_data;
static PyObject *const_str_plain_X509_alias_get0;
static PyObject *const_str_plain_notBefore;
static PyObject *const_str_plain_crypto_crl;
static PyObject *const_str_plain_X509_NAME_cmp;
static PyObject *const_str_plain__integer_types;
static PyObject *const_str_plain_PKCS12Type;
extern PyObject *const_str_plain_other;
static PyObject *const_str_plain_EXPLICIT_POLICY;
extern PyObject *const_str_plain_X509_REQ_set_pubkey;
extern PyObject *const_str_plain_label;
static PyObject *const_str_plain_signature_length;
extern PyObject *const_str_plain_i2d_PUBKEY_bio;
static PyObject *const_str_plain_set_issuer;
extern PyObject *const_str_space;
static PyObject *const_str_plain_ASN1_INTEGER_set;
static PyObject *const_str_plain_when;
extern PyObject *const_str_plain_BN_bn2hex;
static PyObject *const_str_digest_08a0d510acdd77f37b666a4668538f96;
static PyObject *const_str_digest_713d8c2afef94db133cda1bff1cb496f;
extern PyObject *const_str_plain_OPENSSL_free;
static PyObject *const_str_digest_2dbcbe3e7da77178b4a9da40244d072a;
extern PyObject *const_str_plain_truncate;
extern PyObject *const_str_plain_strftime;
static PyObject *const_str_digest_0d925750cb36e0c0e5f47f40c47790e6;
extern PyObject *const_str_plain_X509_CRL_get_issuer;
extern PyObject *const_str_plain_deprecated;
static PyObject *const_str_digest_66b2a3b8e35254752e96fbbddc255dfd;
static PyObject *const_str_digest_998fe297d663eb0475d60a56d2b84182;
static PyObject *const_str_digest_859c7c43c5cf3124cdd58374d6e7359e;
static PyObject *const_str_plain_BN_set_word;
extern PyObject *const_str_plain_BIO_s_mem;
extern PyObject *const_str_plain_X509_REVOKED_get0_serialNumber;
static PyObject *const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14;
static PyObject *const_str_digest_bb334a0dc943b8e820be149d2c515af0;
static PyObject *const_tuple_57dca116533b0d6d636b268e7001e41b_tuple;
static PyObject *const_str_plain_crypto_key;
extern PyObject *const_str_plain_bio;
static PyObject *const_str_digest_bb6f5ad807179d7105a669c98779d984;
extern PyObject *const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
static PyObject *const_str_plain_subject_name_hash;
static PyObject *const_tuple_str_plain__CertificateSigningRequest_tuple;
static PyObject *const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
extern PyObject *const_str_plain_text_to_bytes_and_warn;
extern PyObject *const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
static PyObject *const_str_digest_4b3673d04a6e4a628e29457d54d43c0d;
static PyObject *const_str_plain_X509ReqType;
extern PyObject *const_str_plain_set_result;
extern PyObject *const_str_plain_EVP_get_digestbyname;
static PyObject *const_str_plain_V_ASN1_GENERALIZEDTIME;
extern PyObject *const_str_plain__to_EC_KEY;
extern PyObject *const_tuple_str_plain_backend_tuple;
extern PyObject *const_str_plain_sk_X509_REVOKED_num;
extern PyObject *const_str_plain_evp_pkey;
static PyObject *const_str_plain_get_revoked;
static PyObject *const_str_plain_dump_certificate_request;
extern PyObject *const_str_plain_buf;
static PyObject *const_str_plain_data_length;
static PyObject *const_str_plain_X509_gmtime_adj;
extern PyObject *const_str_plain_get_subject;
static PyObject *const_str_plain_NETSCAPE_SPKI_set_pubkey;
static PyObject *const_str_digest_6b6b180b644052fa34c3e81151f6ea0a;
static PyObject *const_str_plain_get_signature_algorithm;
extern PyObject *const_str_chr_58;
extern PyObject *const_str_plain_entry;
static PyObject *const_str_plain_ALLOW_PROXY_CERTS;
static PyObject *const_str_plain_PKCS7_type_is_data;
extern PyObject *const_str_plain_index;
static PyObject *const_str_plain_free;
extern PyObject *const_str_plain_X509V3_EXT_d2i;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_plain__delete_reason;
static PyObject *const_str_plain_X509NameType;
static PyObject *const_str_digest_6674ab14e1178de501dfb968278a50b9;
extern PyObject *const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
static PyObject *const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple;
static PyObject *const_str_plain_verify_certificate;
static PyObject *const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2;
static PyObject *const_tuple_none_int_pos_2048_int_pos_1_tuple;
static PyObject *const_str_plain_result_buffer;
extern PyObject *const_tuple_type_Exception_tuple;
static PyObject *const_str_plain_NETSCAPE_SPKI_b64_encode;
static PyObject *const_tuple_788a505d6e43a02df061e74659415d8f_tuple;
extern PyObject *const_str_plain_GEN_DNS;
static PyObject *const_str_plain_get_pubkey;
static PyObject *const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple;
static PyObject *const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e;
static PyObject *const_str_plain_NETSCAPE_SPKI_new;
static PyObject *const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611;
extern PyObject *const_str_plain_X509_CRL_get_lastUpdate;
static PyObject *const_str_plain_result_length;
static PyObject *const_str_digest_2c2564e59b067260d7d96d252fc73cd1;
static PyObject *const_str_plain_crypto_cert;
static PyObject *const_str_plain__subjectAltNameString;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple;
extern PyObject *const_str_plain_keyCompromise;
static PyObject *const_str_plain__byte_string;
static PyObject *const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple;
static PyObject *const_str_plain__curves;
extern PyObject *const_str_plain_reason;
static PyObject *const_str_digest_9226325aac109a91f8326c1a26ede065;
static PyObject *const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple;
static PyObject *const_str_digest_4357c956c1f3628f437632877b5d8593;
static PyObject *const_str_digest_b16563a844474e8eed4710209909ab32;
static PyObject *const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58;
extern PyObject *const_str_plain_X509_STORE_CTX_get_error_depth;
extern PyObject *const_str_plain_ASN1_ENUMERATED_new;
static PyObject *const_str_plain_X509_REQ_print_ex;
static PyObject *const_str_digest_e2d5c2f473553b6759cc455da987e04a;
static PyObject *const_str_plain_ent;
extern PyObject *const_str_plain_X509;
static PyObject *const_str_plain_add_revoked;
extern PyObject *const_str_plain_i2d_X509_bio;
static PyObject *const_str_digest_290681512f72ca11cbf3e4827987aabb;
extern PyObject *const_str_plain_d2i_X509_CRL_bio;
extern PyObject *const_str_plain_ASN1_ENUMERATED_set;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_str_plain_set_lastUpdate = UNSTREAM_STRING( &constant_bin[ 43023 ], 14, 1 );
    const_str_plain_OBJ_nid2ln = UNSTREAM_STRING( &constant_bin[ 43037 ], 10, 1 );
    const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f = UNSTREAM_STRING( &constant_bin[ 43047 ], 14, 0 );
    const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a = UNSTREAM_STRING( &constant_bin[ 43061 ], 68, 0 );
    const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561 = UNSTREAM_STRING( &constant_bin[ 43129 ], 18, 0 );
    const_str_plain__truncate = UNSTREAM_STRING( &constant_bin[ 43147 ], 9, 1 );
    const_str_plain_RSA_check_key = UNSTREAM_STRING( &constant_bin[ 43156 ], 13, 1 );
    const_str_plain_X509_NAME_get_index_by_NID = UNSTREAM_STRING( &constant_bin[ 43169 ], 26, 1 );
    const_str_plain_issuer_key = UNSTREAM_STRING( &constant_bin[ 43195 ], 10, 1 );
    const_str_digest_978cd476d4acffdfb043e6a5e0ebae26 = UNSTREAM_STRING( &constant_bin[ 43205 ], 258, 0 );
    const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    const_str_plain_builtin_curves = UNSTREAM_STRING( &constant_bin[ 43463 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 2, const_str_plain_builtin_curves ); Py_INCREF( const_str_plain_builtin_curves );
    const_str_plain_num_curves = UNSTREAM_STRING( &constant_bin[ 43477 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 3, const_str_plain_num_curves ); Py_INCREF( const_str_plain_num_curves );
    const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 1, const_str_plain__CertificateRevocationList ); Py_INCREF( const_str_plain__CertificateRevocationList );
    PyTuple_SET_ITEM( const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 2, const_str_plain_backend ); Py_INCREF( const_str_plain_backend );
    const_str_plain_X509_V_FLAG_POLICY_CHECK = UNSTREAM_STRING( &constant_bin[ 43487 ], 24, 1 );
    const_str_digest_b52a484c26b348bfec0a17217a58ad7e = UNSTREAM_STRING( &constant_bin[ 43511 ], 44, 0 );
    const_str_digest_8fda740163dc7d07c78736dc2ebb17b1 = UNSTREAM_STRING( &constant_bin[ 43555 ], 250, 0 );
    const_str_plain_all_reasons = UNSTREAM_STRING( &constant_bin[ 43805 ], 11, 1 );
    const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_which = UNSTREAM_STRING( &constant_bin[ 4704 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_90de967a5219b9210479f7eac5c285c8 = UNSTREAM_STRING( &constant_bin[ 43816 ], 105, 0 );
    const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143 = UNSTREAM_STRING( &constant_bin[ 43921 ], 237, 0 );
    const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    const_str_plain_when = UNSTREAM_STRING( &constant_bin[ 5781 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 2, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    const_str_digest_a9bcf1af78e6d912e13685d8a606fe30 = UNSTREAM_STRING( &constant_bin[ 44158 ], 170, 0 );
    const_str_plain_TYPE_RSA = UNSTREAM_STRING( &constant_bin[ 44328 ], 8, 1 );
    const_str_plain_X509_VERIFY_PARAM_free = UNSTREAM_STRING( &constant_bin[ 44336 ], 22, 1 );
    const_str_digest_52cbe8d655a10e46907a30970ef9889a = UNSTREAM_STRING( &constant_bin[ 44358 ], 215, 0 );
    const_str_plain_sk_X509_EXTENSION_free = UNSTREAM_STRING( &constant_bin[ 44573 ], 22, 1 );
    const_str_digest_435662c26b2c422edb954b82c85c55d9 = UNSTREAM_STRING( &constant_bin[ 44595 ], 288, 0 );
    const_str_digest_f737de4a45174195dc1e46101235dc35 = UNSTREAM_STRING( &constant_bin[ 44883 ], 144, 0 );
    const_str_plain_get_rev_date = UNSTREAM_STRING( &constant_bin[ 45027 ], 12, 1 );
    const_str_digest_3d684470d9353bc1a1e8d63a3aab4679 = UNSTREAM_STRING( &constant_bin[ 45039 ], 15, 0 );
    const_tuple_str_plain_cls_str_plain_lib_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    const_str_plain_X509StoreContext = UNSTREAM_STRING( &constant_bin[ 45054 ], 16, 1 );
    const_str_plain__get_elliptic_curves = UNSTREAM_STRING( &constant_bin[ 45070 ], 20, 1 );
    const_str_plain_string_type = UNSTREAM_STRING( &constant_bin[ 45090 ], 11, 1 );
    const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple = PyTuple_New( 1 );
    const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339 = UNSTREAM_STRING( &constant_bin[ 45101 ], 6, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple, 0, const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339 ); Py_INCREF( const_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339 );
    const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple = PyTuple_New( 1 );
    const_str_digest_8e9fba48e24a08144a915d52e31f6d23 = UNSTREAM_STRING( &constant_bin[ 45107 ], 4, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple, 0, const_str_digest_8e9fba48e24a08144a915d52e31f6d23 ); Py_INCREF( const_str_digest_8e9fba48e24a08144a915d52e31f6d23 );
    const_tuple_str_plain_utf8only_tuple = PyTuple_New( 1 );
    const_str_plain_utf8only = UNSTREAM_STRING( &constant_bin[ 45111 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_utf8only_tuple, 0, const_str_plain_utf8only ); Py_INCREF( const_str_plain_utf8only );
    const_str_digest_aca114104f73a7934675fb06a5336647 = UNSTREAM_STRING( &constant_bin[ 45119 ], 56, 0 );
    const_str_digest_169aa7f0589e4a3c83203d48f57770af = UNSTREAM_STRING( &constant_bin[ 45175 ], 22, 0 );
    const_str_plain_X509_VERIFY_PARAM_new = UNSTREAM_STRING( &constant_bin[ 45197 ], 21, 1 );
    const_str_plain__friendlyname = UNSTREAM_STRING( &constant_bin[ 45218 ], 13, 1 );
    const_tuple_str_plain_bio_str_plain_ref_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_bio_str_plain_ref_tuple, 0, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_ref = UNSTREAM_STRING( &constant_bin[ 9216 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_bio_str_plain_ref_tuple, 1, const_str_plain_ref ); Py_INCREF( const_str_plain_ref );
    const_str_digest_1565887baecc678658a50e7d1f245653 = UNSTREAM_STRING( &constant_bin[ 45231 ], 236, 0 );
    const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72 = UNSTREAM_STRING( &constant_bin[ 45467 ], 48, 0 );
    const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple = PyTuple_New( 1 );
    const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf = UNSTREAM_STRING( &constant_bin[ 31618 ], 2, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple, 0, const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf ); Py_INCREF( const_str_digest_eee7b0934fe224b34ba6722d84ccd2bf );
    const_str_plain_load_pkcs12 = UNSTREAM_STRING( &constant_bin[ 45515 ], 11, 1 );
    const_str_plain_X509_REVOKED_add1_ext_i2d = UNSTREAM_STRING( &constant_bin[ 45526 ], 25, 1 );
    const_str_plain_string_result = UNSTREAM_STRING( &constant_bin[ 45551 ], 13, 1 );
    const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98 = UNSTREAM_STRING( &constant_bin[ 45564 ], 104, 0 );
    const_str_plain_NOTIFY_POLICY = UNSTREAM_STRING( &constant_bin[ 45668 ], 13, 1 );
    const_str_digest_2f350f536232587387680a9435c758f6 = UNSTREAM_STRING( &constant_bin[ 45681 ], 425, 0 );
    const_str_digest_670c62a34c6767f6ecd5db6f969b2f34 = UNSTREAM_STRING( &constant_bin[ 46106 ], 500, 0 );
    const_str_plain_pkcs12 = UNSTREAM_STRING( &constant_bin[ 45520 ], 6, 1 );
    const_str_digest_fb60d21f52ae521da77e61851d566364 = UNSTREAM_STRING( &constant_bin[ 46606 ], 19, 0 );
    const_str_plain_get_short_name = UNSTREAM_STRING( &constant_bin[ 46625 ], 14, 1 );
    const_str_plain_digest_obj = UNSTREAM_STRING( &constant_bin[ 46639 ], 10, 1 );
    const_str_plain_op = UNSTREAM_STRING( &constant_bin[ 6306 ], 2, 1 );
    const_str_plain_type_is_enveloped = UNSTREAM_STRING( &constant_bin[ 46649 ], 17, 1 );
    const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc = UNSTREAM_STRING( &constant_bin[ 46666 ], 107, 0 );
    const_str_plain_X509_R_CERT_ALREADY_IN_HASH_TABLE = UNSTREAM_STRING( &constant_bin[ 46773 ], 33, 1 );
    const_str_plain_PKeyType = UNSTREAM_STRING( &constant_bin[ 46806 ], 8, 1 );
    const_str_plain_PKCS12_create = UNSTREAM_STRING( &constant_bin[ 46814 ], 13, 1 );
    const_str_plain_dt = UNSTREAM_STRING( &constant_bin[ 46827 ], 2, 1 );
    const_str_digest_152d11f8848fac60442a26592ab3da87 = UNSTREAM_STRING( &constant_bin[ 46829 ], 688, 0 );
    const_str_digest_0632ce6142bf9815370c626f0fb1235a = UNSTREAM_STRING( &constant_bin[ 47517 ], 26, 0 );
    const_str_plain_char_result = UNSTREAM_STRING( &constant_bin[ 47543 ], 11, 1 );
    const_str_plain_string_timestamp = UNSTREAM_STRING( &constant_bin[ 47554 ], 16, 1 );
    const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 1, const_str_plain_extensions ); Py_INCREF( const_str_plain_extensions );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 3, const_str_plain_stack ); Py_INCREF( const_str_plain_stack );
    PyTuple_SET_ITEM( const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 4, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_pypkcs7 = UNSTREAM_STRING( &constant_bin[ 47570 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 3, const_str_plain_pypkcs7 ); Py_INCREF( const_str_plain_pypkcs7 );
    const_str_plain_pkcs7 = UNSTREAM_STRING( &constant_bin[ 43843 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 4, const_str_plain_pkcs7 ); Py_INCREF( const_str_plain_pkcs7 );
    const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_not_after = UNSTREAM_STRING( &constant_bin[ 47577 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 1, const_str_plain_not_after ); Py_INCREF( const_str_plain_not_after );
    const_str_plain_time_string = UNSTREAM_STRING( &constant_bin[ 47586 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 2, const_str_plain_time_string ); Py_INCREF( const_str_plain_time_string );
    const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31 = UNSTREAM_STRING( &constant_bin[ 47597 ], 9, 0 );
    const_str_plain_X509_STORE_CTX_cleanup = UNSTREAM_STRING( &constant_bin[ 47606 ], 22, 1 );
    const_str_digest_50f07d7dbc7dc060eb5685744b92c007 = UNSTREAM_STRING( &constant_bin[ 18741 ], 23, 0 );
    const_str_digest_44f664275c70041c9ae4bef2565506f3 = UNSTREAM_STRING( &constant_bin[ 47628 ], 640, 0 );
    const_str_plain_sk_X509_push = UNSTREAM_STRING( &constant_bin[ 48268 ], 12, 1 );
    const_str_digest_6a19008e8f9a834793cf38dcba68883a = UNSTREAM_STRING( &constant_bin[ 48280 ], 442, 0 );
    const_str_plain_CRL_CHECK = UNSTREAM_STRING( &constant_bin[ 48722 ], 9, 1 );
    const_str_plain_spki = UNSTREAM_STRING( &constant_bin[ 48731 ], 4, 1 );
    const_tuple_str_plain_self_str_plain_ret_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ret_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ret_tuple, 1, const_str_plain_ret ); Py_INCREF( const_str_plain_ret );
    const_str_plain_add_crl = UNSTREAM_STRING( &constant_bin[ 48735 ], 7, 1 );
    const_str_digest_5a3f7f69104a4ed1267a21c950d94463 = UNSTREAM_STRING( &constant_bin[ 48742 ], 773, 0 );
    const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS = UNSTREAM_STRING( &constant_bin[ 49515 ], 29, 1 );
    const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79 = UNSTREAM_STRING( &constant_bin[ 49544 ], 188, 0 );
    const_str_digest_7de17ac920010129977e4280610f275c = UNSTREAM_STRING( &constant_bin[ 49732 ], 271, 0 );
    const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC = UNSTREAM_STRING( &constant_bin[ 50003 ], 38, 1 );
    const_str_plain__get_name = UNSTREAM_STRING( &constant_bin[ 20825 ], 9, 1 );
    const_str_plain_b64_encode = UNSTREAM_STRING( &constant_bin[ 50041 ], 10, 1 );
    const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 1, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 3, const_str_plain_ret ); Py_INCREF( const_str_plain_ret );
    const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 3, const_str_plain_op ); Py_INCREF( const_str_plain_op );
    const_str_plain_EVP_VerifyUpdate = UNSTREAM_STRING( &constant_bin[ 50051 ], 16, 1 );
    const_str_digest_603c60edaf58a8746faa757f20f3f938 = UNSTREAM_STRING( &constant_bin[ 50067 ], 265, 0 );
    const_str_digest_32726a73c20427f70712d109be7712b4 = UNSTREAM_STRING( &constant_bin[ 50332 ], 192, 0 );
    const_str_plain__crl_reasons = UNSTREAM_STRING( &constant_bin[ 50524 ], 12, 1 );
    const_str_plain__passphrase = UNSTREAM_STRING( &constant_bin[ 31277 ], 11, 1 );
    const_str_plain__revoked = UNSTREAM_STRING( &constant_bin[ 50536 ], 8, 1 );
    const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 0, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 1, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    const_str_plain_final_result = UNSTREAM_STRING( &constant_bin[ 50544 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 3, const_str_plain_final_result ); Py_INCREF( const_str_plain_final_result );
    const_str_plain_signature_length = UNSTREAM_STRING( &constant_bin[ 50556 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 4, const_str_plain_signature_length ); Py_INCREF( const_str_plain_signature_length );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 5, const_str_plain_length ); Py_INCREF( const_str_plain_length );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 6, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    const_str_plain_signature_buffer = UNSTREAM_STRING( &constant_bin[ 50572 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 7, const_str_plain_signature_buffer ); Py_INCREF( const_str_plain_signature_buffer );
    const_str_plain_md_ctx = UNSTREAM_STRING( &constant_bin[ 50588 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 8, const_str_plain_md_ctx ); Py_INCREF( const_str_plain_md_ctx );
    const_str_plain_fname = UNSTREAM_STRING( &constant_bin[ 50594 ], 5, 1 );
    const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24 = UNSTREAM_STRING( &constant_bin[ 50599 ], 266, 0 );
    const_str_digest_bd5b7ac1c36a2ac4b448366689be109e = UNSTREAM_STRING( &constant_bin[ 50865 ], 686, 0 );
    const_str_plain__text_type = UNSTREAM_STRING( &constant_bin[ 51551 ], 10, 1 );
    const_str_plain_ent_nid = UNSTREAM_STRING( &constant_bin[ 51561 ], 7, 1 );
    const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113 = UNSTREAM_STRING( &constant_bin[ 51568 ], 249, 0 );
    const_str_digest_c384f9f99d5890cd2aae342c30dbaa14 = UNSTREAM_STRING( &constant_bin[ 51817 ], 109, 0 );
    const_str_plain_load_crl = UNSTREAM_STRING( &constant_bin[ 51926 ], 8, 1 );
    const_str_plain_i2d_PKCS12_bio = UNSTREAM_STRING( &constant_bin[ 51934 ], 14, 1 );
    const_str_digest_5bd123cbe57a454c8d9d37867b598cb2 = UNSTREAM_STRING( &constant_bin[ 51948 ], 70, 0 );
    const_str_digest_3c7878f9f14c822b0ae6ebb3dbe0804c = UNSTREAM_STRING( &constant_bin[ 52018 ], 50, 0 );
    const_str_plain_crypto_req = UNSTREAM_STRING( &constant_bin[ 52068 ], 10, 1 );
    const_str_plain_CHECK_SS_SIGNATURE = UNSTREAM_STRING( &constant_bin[ 52078 ], 18, 1 );
    const_str_plain__nid = UNSTREAM_STRING( &constant_bin[ 43040 ], 4, 1 );
    const_str_plain_X509_V_FLAG_NOTIFY_POLICY = UNSTREAM_STRING( &constant_bin[ 52096 ], 25, 1 );
    const_str_plain_SSL_FILETYPE_PEM = UNSTREAM_STRING( &constant_bin[ 52121 ], 16, 1 );
    const_str_plain_d2i_PKCS7_bio = UNSTREAM_STRING( &constant_bin[ 52137 ], 13, 1 );
    const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e = UNSTREAM_STRING( &constant_bin[ 52150 ], 189, 0 );
    const_str_plain_EVP_PKEY_assign_RSA = UNSTREAM_STRING( &constant_bin[ 52339 ], 19, 1 );
    const_str_plain_get_ca_certificates = UNSTREAM_STRING( &constant_bin[ 52358 ], 19, 1 );
    const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple = PyTuple_New( 18 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 0, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    const_str_plain_passphrase = UNSTREAM_STRING( &constant_bin[ 9958 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 1, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_pykey = UNSTREAM_STRING( &constant_bin[ 52377 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 3, const_str_plain_pykey ); Py_INCREF( const_str_plain_pykey );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 4, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    const_str_plain_friendlyname_buffer = UNSTREAM_STRING( &constant_bin[ 52382 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 5, const_str_plain_friendlyname_buffer ); Py_INCREF( const_str_plain_friendlyname_buffer );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 6, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 7, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 8, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    const_str_plain_cacerts = UNSTREAM_STRING( &constant_bin[ 52401 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 9, const_str_plain_cacerts ); Py_INCREF( const_str_plain_cacerts );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 10, const_str_plain_pycert ); Py_INCREF( const_str_plain_pycert );
    const_str_plain_friendlyname_length = UNSTREAM_STRING( &constant_bin[ 52408 ], 19, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 11, const_str_plain_friendlyname_length ); Py_INCREF( const_str_plain_friendlyname_length );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 12, const_str_plain_p12 ); Py_INCREF( const_str_plain_p12 );
    const_str_plain_pycacert = UNSTREAM_STRING( &constant_bin[ 52427 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 13, const_str_plain_pycacert ); Py_INCREF( const_str_plain_pycacert );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 14, const_str_plain_pkcs12 ); Py_INCREF( const_str_plain_pkcs12 );
    const_str_plain_friendlyname = UNSTREAM_STRING( &constant_bin[ 45219 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 15, const_str_plain_friendlyname ); Py_INCREF( const_str_plain_friendlyname );
    const_str_plain_pycacerts = UNSTREAM_STRING( &constant_bin[ 52435 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 16, const_str_plain_pycacerts ); Py_INCREF( const_str_plain_pycacerts );
    const_str_plain_parse_result = UNSTREAM_STRING( &constant_bin[ 52444 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 17, const_str_plain_parse_result ); Py_INCREF( const_str_plain_parse_result );
    const_str_plain_set_subject = UNSTREAM_STRING( &constant_bin[ 52456 ], 11, 1 );
    const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 3, const_str_plain_asn1_int ); Py_INCREF( const_str_plain_asn1_int );
    const_str_plain_get_components = UNSTREAM_STRING( &constant_bin[ 52467 ], 14, 1 );
    const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 0, const_str_plain_ffi ); Py_INCREF( const_str_plain_ffi );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 2, const_str_plain_exception_from_error_queue ); Py_INCREF( const_str_plain_exception_from_error_queue );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 3, const_str_plain_byte_string ); Py_INCREF( const_str_plain_byte_string );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 4, const_str_plain_native ); Py_INCREF( const_str_plain_native );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 5, const_str_plain_UNSPECIFIED ); Py_INCREF( const_str_plain_UNSPECIFIED );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 6, const_str_plain_text_to_bytes_and_warn ); Py_INCREF( const_str_plain_text_to_bytes_and_warn );
    PyTuple_SET_ITEM( const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple, 7, const_str_plain_make_assert ); Py_INCREF( const_str_plain_make_assert );
    const_str_plain_set_privatekey = UNSTREAM_STRING( &constant_bin[ 52481 ], 14, 1 );
    const_str_plain_EVP_VerifyFinal = UNSTREAM_STRING( &constant_bin[ 52495 ], 15, 1 );
    const_str_digest_26a65c58106d086427e37cb87b0bc3b3 = UNSTREAM_STRING( &constant_bin[ 52510 ], 271, 0 );
    const_str_digest_8db7448b8246dd51f74c33bda58590bd = UNSTREAM_STRING( &constant_bin[ 52781 ], 376, 0 );
    const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 1, const_str_plain__Certificate ); Py_INCREF( const_str_plain__Certificate );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 2, const_str_plain_backend ); Py_INCREF( const_str_plain_backend );
    const_str_plain_get_notBefore = UNSTREAM_STRING( &constant_bin[ 53157 ], 13, 1 );
    const_str_plain_X509V3_set_ctx_nodb = UNSTREAM_STRING( &constant_bin[ 53170 ], 19, 1 );
    const_str_plain_i2d_PrivateKey_bio = UNSTREAM_STRING( &constant_bin[ 53189 ], 18, 1 );
    const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf = UNSTREAM_STRING( &constant_bin[ 53207 ], 270, 0 );
    const_str_plain_hexstring_serial = UNSTREAM_STRING( &constant_bin[ 53477 ], 16, 1 );
    const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple, 0, const_str_plain_integer_types ); Py_INCREF( const_str_plain_integer_types );
    PyTuple_SET_ITEM( const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple, 1, const_str_plain_text_type ); Py_INCREF( const_str_plain_text_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple, 2, const_str_plain_PY3 ); Py_INCREF( const_str_plain_PY3 );
    const_str_digest_1ca413f5b66374db6a573ac0926a99ae = UNSTREAM_STRING( &constant_bin[ 53493 ], 135, 0 );
    const_str_plain_exponent = UNSTREAM_STRING( &constant_bin[ 53628 ], 8, 1 );
    const_str_plain_X509StoreFlags = UNSTREAM_STRING( &constant_bin[ 53636 ], 14, 1 );
    const_str_plain_EVP_SignInit = UNSTREAM_STRING( &constant_bin[ 53650 ], 12, 1 );
    const_str_digest_c7bf9684574689f7d764ff6fbd5eab60 = UNSTREAM_STRING( &constant_bin[ 53662 ], 266, 0 );
    const_tuple_str_plain_op_str_plain_f_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_op_str_plain_f_tuple, 0, const_str_plain_op ); Py_INCREF( const_str_plain_op );
    PyTuple_SET_ITEM( const_tuple_str_plain_op_str_plain_f_tuple, 1, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    const_tuple_str_plain_b16encode_tuple = PyTuple_New( 1 );
    const_str_plain_b16encode = UNSTREAM_STRING( &constant_bin[ 53928 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_b16encode_tuple, 0, const_str_plain_b16encode ); Py_INCREF( const_str_plain_b16encode );
    const_str_plain_get_serial_number = UNSTREAM_STRING( &constant_bin[ 53937 ], 17, 1 );
    const_str_digest_2f591e55cc116ed5223c119e2f7da344 = UNSTREAM_STRING( &constant_bin[ 53954 ], 150, 0 );
    const_str_plain_vfy_time = UNSTREAM_STRING( &constant_bin[ 54104 ], 8, 1 );
    const_str_plain_sk_X509_EXTENSION_push = UNSTREAM_STRING( &constant_bin[ 54112 ], 22, 1 );
    const_str_plain_days = UNSTREAM_STRING( &constant_bin[ 54134 ], 4, 1 );
    const_str_digest_3910fdd1c3b683a0988d08f77454ce47 = UNSTREAM_STRING( &constant_bin[ 54138 ], 23, 0 );
    const_str_plain_get_extension_count = UNSTREAM_STRING( &constant_bin[ 54161 ], 19, 1 );
    const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac = UNSTREAM_STRING( &constant_bin[ 54180 ], 158, 0 );
    const_tuple_str_plain_self_str_plain_when_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_tuple, 1, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    const_str_plain_X509V3_EXT_print = UNSTREAM_STRING( &constant_bin[ 54338 ], 16, 1 );
    const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 1, const_str_plain_type_name ); Py_INCREF( const_str_plain_type_name );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 2, const_str_plain_critical ); Py_INCREF( const_str_plain_critical );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 3, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 4, const_str_plain_subject ); Py_INCREF( const_str_plain_subject );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 5, const_str_plain_issuer ); Py_INCREF( const_str_plain_issuer );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 6, const_str_plain_extension ); Py_INCREF( const_str_plain_extension );
    PyTuple_SET_ITEM( const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 7, const_str_plain_ctx ); Py_INCREF( const_str_plain_ctx );
    const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 1, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_result_code = UNSTREAM_STRING( &constant_bin[ 54354 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 3, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 1, const_str_plain_version ); Py_INCREF( const_str_plain_version );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_i2a_ASN1_INTEGER = UNSTREAM_STRING( &constant_bin[ 54365 ], 16, 1 );
    const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_algor = UNSTREAM_STRING( &constant_bin[ 54381 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 1, const_str_plain_algor ); Py_INCREF( const_str_plain_algor );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 0, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_buffer_length = UNSTREAM_STRING( &constant_bin[ 54386 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 1, const_str_plain_buffer_length ); Py_INCREF( const_str_plain_buffer_length );
    const_str_plain_result_buffer = UNSTREAM_STRING( &constant_bin[ 54399 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 2, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    const_str_plain_X509Type = UNSTREAM_STRING( &constant_bin[ 54412 ], 8, 1 );
    const_str_digest_5194c46decfddbd64da780c8c0e4faa3 = UNSTREAM_STRING( &constant_bin[ 54420 ], 46, 0 );
    const_str_plain_X509_NAME_delete_entry = UNSTREAM_STRING( &constant_bin[ 54466 ], 22, 1 );
    const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13 = UNSTREAM_STRING( &constant_bin[ 54488 ], 24, 0 );
    const_str_digest_333948d9e51f0e161201a16305959930 = UNSTREAM_STRING( &constant_bin[ 54512 ], 244, 0 );
    const_str_plain_native_exts_obj = UNSTREAM_STRING( &constant_bin[ 54756 ], 15, 1 );
    const_str_digest_9cb57ebafd0926d1746d2e66a6198efe = UNSTREAM_STRING( &constant_bin[ 54771 ], 43, 0 );
    const_str_plain_X509_STRICT = UNSTREAM_STRING( &constant_bin[ 54814 ], 11, 1 );
    const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple = PyTuple_New( 1 );
    const_str_digest_e2d15f7f418fdd55a54be9ea476feee3 = UNSTREAM_STRING( &constant_bin[ 54825 ], 16, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple, 0, const_str_digest_e2d15f7f418fdd55a54be9ea476feee3 ); Py_INCREF( const_str_digest_e2d15f7f418fdd55a54be9ea476feee3 );
    const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_crypto_cert = UNSTREAM_STRING( &constant_bin[ 54841 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 1, const_str_plain_crypto_cert ); Py_INCREF( const_str_plain_crypto_cert );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 2, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    const_str_digest_5339fa8ff3df372e54ef7b09078767aa = UNSTREAM_STRING( &constant_bin[ 54852 ], 15, 0 );
    const_tuple_86464d9c162f01af99141e0a5b804d71_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 2, const_str_plain_write_bio ); Py_INCREF( const_str_plain_write_bio );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 3, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    PyTuple_SET_ITEM( const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 4, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 2, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    const_str_plain_print_result = UNSTREAM_STRING( &constant_bin[ 54867 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 3, const_str_plain_print_result ); Py_INCREF( const_str_plain_print_result );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 4, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 5, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    const_str_plain_NID_subject_alt_name = UNSTREAM_STRING( &constant_bin[ 54879 ], 20, 1 );
    const_str_plain_add_cert = UNSTREAM_STRING( &constant_bin[ 54899 ], 8, 1 );
    const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple = PyTuple_New( 1 );
    const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21 = UNSTREAM_STRING( &constant_bin[ 54861 ], 6, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple, 0, const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21 ); Py_INCREF( const_str_digest_70b987f75825a6c2ffe2c8fe53d85a21 );
    const_str_plain_X509V3_EXT_nconf = UNSTREAM_STRING( &constant_bin[ 54907 ], 16, 1 );
    const_str_digest_5cb0319d0378026eb0ef49838e525520 = UNSTREAM_STRING( &constant_bin[ 54923 ], 311, 0 );
    const_str_digest_62c9c3f244d467c166be64cd38a755a7 = UNSTREAM_STRING( &constant_bin[ 55234 ], 224, 0 );
    const_str_digest_f41f911aba33894e1da796354264d96a = UNSTREAM_STRING( &constant_bin[ 55458 ], 435, 0 );
    const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6 = UNSTREAM_STRING( &constant_bin[ 55893 ], 24, 0 );
    const_str_plain_subject_cert = UNSTREAM_STRING( &constant_bin[ 55917 ], 12, 1 );
    const_str_plain_set_pubkey = UNSTREAM_STRING( &constant_bin[ 55929 ], 10, 1 );
    const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac = UNSTREAM_STRING( &constant_bin[ 55939 ], 131, 0 );
    const_str_plain_exceptionType = UNSTREAM_STRING( &constant_bin[ 56070 ], 13, 1 );
    const_str_digest_61dbd227935e54cb40eecc7de8b8596b = UNSTREAM_STRING( &constant_bin[ 56083 ], 137, 0 );
    const_str_digest_1d608c98cc8048d3f7b439059ee29b66 = UNSTREAM_STRING( &constant_bin[ 56220 ], 420, 0 );
    const_str_digest_79b48b443a4edf88bd64a278e98529d3 = UNSTREAM_STRING( &constant_bin[ 56640 ], 254, 0 );
    const_str_plain_from_nid = UNSTREAM_STRING( &constant_bin[ 56894 ], 8, 1 );
    const_str_digest_11dbf726734533c622c12e725d15648e = UNSTREAM_STRING( &constant_bin[ 56902 ], 123, 0 );
    const_str_plain__spki = UNSTREAM_STRING( &constant_bin[ 57025 ], 5, 1 );
    const_str_plain_from_cryptography = UNSTREAM_STRING( &constant_bin[ 57030 ], 17, 1 );
    const_str_digest_f56881bccbbc40c6643f9603628e7a5c = UNSTREAM_STRING( &constant_bin[ 57047 ], 273, 0 );
    const_str_digest_7a5005a2e44b5258634f5b2837cd8b81 = UNSTREAM_STRING( &constant_bin[ 57320 ], 29, 0 );
    const_str_plain_set_notBefore = UNSTREAM_STRING( &constant_bin[ 57349 ], 13, 1 );
    const_str_plain_load_pkcs7_data = UNSTREAM_STRING( &constant_bin[ 57362 ], 15, 1 );
    const_str_digest_95aba6f0be0722dff4a715f251a45159 = UNSTREAM_STRING( &constant_bin[ 57377 ], 18, 0 );
    const_str_digest_4d148c7b7c1bc2fec101962dc1ce2c2f = UNSTREAM_STRING( &constant_bin[ 57395 ], 52, 0 );
    const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 3, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_9781f115d6516693d922717b11376a73 = UNSTREAM_STRING( &constant_bin[ 57447 ], 277, 0 );
    const_str_plain__new_mem_buf = UNSTREAM_STRING( &constant_bin[ 57724 ], 12, 1 );
    const_str_plain_X509_verify_cert_error_string = UNSTREAM_STRING( &constant_bin[ 57736 ], 29, 1 );
    const_str_plain_CRLType = UNSTREAM_STRING( &constant_bin[ 57765 ], 7, 1 );
    const_str_digest_79dac080796da8f8fc9c66ebe460ce2f = UNSTREAM_STRING( &constant_bin[ 57772 ], 29, 0 );
    const_str_plain_X509_CRL_print = UNSTREAM_STRING( &constant_bin[ 57801 ], 14, 1 );
    const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 1, const_str_plain_errors ); Py_INCREF( const_str_plain_errors );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 2, const_str_plain__cert ); Py_INCREF( const_str_plain__cert );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 3, const_str_plain_pycert ); Py_INCREF( const_str_plain_pycert );
    PyTuple_SET_ITEM( const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 4, const_str_plain__x509 ); Py_INCREF( const_str_plain__x509 );
    const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60 = UNSTREAM_STRING( &constant_bin[ 57815 ], 316, 0 );
    const_str_digest_d03be6fc9f3e6729b366e69e0856a450 = UNSTREAM_STRING( &constant_bin[ 58131 ], 368, 0 );
    const_str_plain_bignum_ptr = UNSTREAM_STRING( &constant_bin[ 58499 ], 10, 1 );
    const_str_digest_11c225ccbab9acffc38107dee9691702 = UNSTREAM_STRING( &constant_bin[ 58509 ], 67, 0 );
    const_str_plain_OBJ_obj2nid = UNSTREAM_STRING( &constant_bin[ 58576 ], 11, 1 );
    const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1 = UNSTREAM_STRING( &constant_bin[ 58587 ], 22, 0 );
    const_str_digest_9ae52cddf69d053d9518f458a81ffa1b = UNSTREAM_STRING( &constant_bin[ 58609 ], 36, 0 );
    const_str_digest_68e309761e6d5dc5f5c1e53801284f3a = UNSTREAM_STRING( &constant_bin[ 58645 ], 55, 0 );
    const_str_plain_X509_EXTENSION_dup = UNSTREAM_STRING( &constant_bin[ 58700 ], 18, 1 );
    const_str_digest_7163953ad9ff69e46167d396f5625cf7 = UNSTREAM_STRING( &constant_bin[ 58718 ], 31, 0 );
    const_str_plain_SSL_FILETYPE_ASN1 = UNSTREAM_STRING( &constant_bin[ 58749 ], 17, 1 );
    const_tuple_76984bb103279dcce095840ed073cae5_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 2, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 3, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 4, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 5, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_76984bb103279dcce095840ed073cae5_tuple, 6, const_str_plain_evp_pkey ); Py_INCREF( const_str_plain_evp_pkey );
    const_str_plain_sometime = UNSTREAM_STRING( &constant_bin[ 58766 ], 8, 1 );
    const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9 = UNSTREAM_STRING( &constant_bin[ 58774 ], 259, 0 );
    const_str_plain_callback_args = UNSTREAM_STRING( &constant_bin[ 21793 ], 13, 1 );
    const_str_plain_set_store = UNSTREAM_STRING( &constant_bin[ 59033 ], 9, 1 );
    const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7 = UNSTREAM_STRING( &constant_bin[ 59042 ], 284, 0 );
    const_str_digest_5f245d1740d80da82563e21c9c4f4fbf = UNSTREAM_STRING( &constant_bin[ 59326 ], 107, 0 );
    const_str_plain_reason_code = UNSTREAM_STRING( &constant_bin[ 59433 ], 11, 1 );
    const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 0, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 1, const_str_plain_signature ); Py_INCREF( const_str_plain_signature );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 3, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 4, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 5, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    const_str_plain_verify_result = UNSTREAM_STRING( &constant_bin[ 59444 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 6, const_str_plain_verify_result ); Py_INCREF( const_str_plain_verify_result );
    PyTuple_SET_ITEM( const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 7, const_str_plain_md_ctx ); Py_INCREF( const_str_plain_md_ctx );
    const_str_plain_set_certificate = UNSTREAM_STRING( &constant_bin[ 59457 ], 15, 1 );
    const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 1, const_str_plain_revoked ); Py_INCREF( const_str_plain_revoked );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 2, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_str_plain_pyrev = UNSTREAM_STRING( &constant_bin[ 59472 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 3, const_str_plain_pyrev ); Py_INCREF( const_str_plain_pyrev );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 4, const_str_plain_results ); Py_INCREF( const_str_plain_results );
    const_str_plain_revoked_stack = UNSTREAM_STRING( &constant_bin[ 59477 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 5, const_str_plain_revoked_stack ); Py_INCREF( const_str_plain_revoked_stack );
    const_str_plain_revoked_copy = UNSTREAM_STRING( &constant_bin[ 59490 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 6, const_str_plain_revoked_copy ); Py_INCREF( const_str_plain_revoked_copy );
    const_str_digest_1cf455235163a6978480cc7b12198a27 = UNSTREAM_STRING( &constant_bin[ 59502 ], 48, 0 );
    const_str_plain_format_result = UNSTREAM_STRING( &constant_bin[ 59550 ], 13, 1 );
    const_str_digest_11e1356f3459cf012eb88d7288e20e85 = UNSTREAM_STRING( &constant_bin[ 59563 ], 161, 0 );
    const_str_digest_7338acfc5a3b91c07965b6befadc8c7a = UNSTREAM_STRING( &constant_bin[ 59724 ], 15, 0 );
    const_str_plain_get_elliptic_curves = UNSTREAM_STRING( &constant_bin[ 13669 ], 19, 1 );
    const_str_digest_40e46351c3b918f338d6e675fea0b1ca = UNSTREAM_STRING( &constant_bin[ 59739 ], 421, 0 );
    const_tuple_str_plain_self_str_plain_exceptionType_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exceptionType_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exceptionType_tuple, 1, const_str_plain_exceptionType ); Py_INCREF( const_str_plain_exceptionType );
    const_str_plain_RSA_print = UNSTREAM_STRING( &constant_bin[ 60160 ], 9, 1 );
    const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 1, const_str_plain_hex_str ); Py_INCREF( const_str_plain_hex_str );
    const_str_plain_bignum_serial = UNSTREAM_STRING( &constant_bin[ 60169 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 2, const_str_plain_bignum_serial ); Py_INCREF( const_str_plain_bignum_serial );
    const_str_plain_asn1_serial = UNSTREAM_STRING( &constant_bin[ 60182 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 3, const_str_plain_asn1_serial ); Py_INCREF( const_str_plain_asn1_serial );
    const_str_plain_bn_result = UNSTREAM_STRING( &constant_bin[ 60193 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 4, const_str_plain_bn_result ); Py_INCREF( const_str_plain_bn_result );
    PyTuple_SET_ITEM( const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 5, const_str_plain_bignum_ptr ); Py_INCREF( const_str_plain_bignum_ptr );
    const_int_pos_60 = PyInt_FromLong( 60l );
    const_str_plain_X509_subject_name_hash = UNSTREAM_STRING( &constant_bin[ 60202 ], 22, 1 );
    const_str_plain_load_certificate_request = UNSTREAM_STRING( &constant_bin[ 60224 ], 24, 1 );
    const_str_plain_set_serial = UNSTREAM_STRING( &constant_bin[ 60248 ], 10, 1 );
    const_str_plain_X509_NAME_hash = UNSTREAM_STRING( &constant_bin[ 60258 ], 14, 1 );
    const_str_digest_1f7559cec53c5da336c35128000e1652 = UNSTREAM_STRING( &constant_bin[ 60272 ], 23, 0 );
    const_str_digest_39641ea33feffed70915f1c391cc979e = UNSTREAM_STRING( &constant_bin[ 60295 ], 37, 0 );
    const_str_digest_a12e23c82fcdd4004653da2260294f18 = UNSTREAM_STRING( &constant_bin[ 60332 ], 400, 0 );
    const_str_plain_from_cryptography_key = UNSTREAM_STRING( &constant_bin[ 60732 ], 21, 1 );
    const_str_digest_14af5bef46557b92b5b6c4d670b7a1b8 = UNSTREAM_STRING( &constant_bin[ 60753 ], 500, 0 );
    const_str_digest_7db2dd03172a07cae912434bb4ced82e = UNSTREAM_STRING( &constant_bin[ 61253 ], 50, 0 );
    const_str_plain__cacerts = UNSTREAM_STRING( &constant_bin[ 61303 ], 8, 1 );
    const_str_plain_POLICY_CHECK = UNSTREAM_STRING( &constant_bin[ 43499 ], 12, 1 );
    const_str_plain_entry_index = UNSTREAM_STRING( &constant_bin[ 61311 ], 11, 1 );
    const_str_digest_80438074180d95b1a2291874613077b5 = UNSTREAM_STRING( &constant_bin[ 61322 ], 8, 0 );
    const_str_digest_40ce736ad6e52bc3df10a00233b89318 = UNSTREAM_STRING( &constant_bin[ 61330 ], 116, 0 );
    const_str_plain_sign_result = UNSTREAM_STRING( &constant_bin[ 61446 ], 11, 1 );
    const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_amount = UNSTREAM_STRING( &constant_bin[ 52241 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 1, const_str_plain_amount ); Py_INCREF( const_str_plain_amount );
    const_str_plain_notAfter = UNSTREAM_STRING( &constant_bin[ 61457 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 2, const_str_plain_notAfter ); Py_INCREF( const_str_plain_notAfter );
    const_tuple_str_plain_self_str_plain_spki_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_spki_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_spki_tuple, 1, const_str_plain_spki ); Py_INCREF( const_str_plain_spki );
    const_str_digest_141cd36b231fb1bf7caa692f86984b7e = UNSTREAM_STRING( &constant_bin[ 61465 ], 205, 0 );
    const_str_plain_NetscapeSPKI = UNSTREAM_STRING( &constant_bin[ 61670 ], 12, 1 );
    const_str_digest_866d2e2176ccb47ef7515cbc6c993151 = UNSTREAM_STRING( &constant_bin[ 61682 ], 468, 0 );
    const_str_plain_export = UNSTREAM_STRING( &constant_bin[ 5373 ], 6, 1 );
    const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f = UNSTREAM_STRING( &constant_bin[ 62150 ], 152, 0 );
    const_str_plain_NETSCAPE_SPKI_get_pubkey = UNSTREAM_STRING( &constant_bin[ 62302 ], 24, 1 );
    const_str_plain_URI = UNSTREAM_STRING( &constant_bin[ 62326 ], 3, 1 );
    const_str_plain_ASN1_STRING_set_default_mask_asc = UNSTREAM_STRING( &constant_bin[ 62329 ], 32, 1 );
    const_str_plain_octet_result = UNSTREAM_STRING( &constant_bin[ 62361 ], 12, 1 );
    const_str_digest_463cb3c7dbe7753c6683d3195629dca3 = UNSTREAM_STRING( &constant_bin[ 62373 ], 54, 0 );
    const_str_digest_75a631b53fc267af68d162051a06411c = UNSTREAM_STRING( &constant_bin[ 62427 ], 414, 0 );
    const_str_plain_X509_V_FLAG_CRL_CHECK = UNSTREAM_STRING( &constant_bin[ 62841 ], 21, 1 );
    const_str_plain_X509_NAME_add_entry_by_NID = UNSTREAM_STRING( &constant_bin[ 62862 ], 26, 1 );
    const_str_plain_NetscapeSPKIType = UNSTREAM_STRING( &constant_bin[ 62888 ], 16, 1 );
    const_str_plain_INHIBIT_MAP = UNSTREAM_STRING( &constant_bin[ 62904 ], 11, 1 );
    const_str_digest_a078d66f5fc281c4117a5e5c24749809 = UNSTREAM_STRING( &constant_bin[ 62915 ], 134, 0 );
    const_str_digest_1691c1bfd96a22cfc48aca410da45814 = UNSTREAM_STRING( &constant_bin[ 63049 ], 41, 0 );
    const_str_plain_X509_V_FLAG_IGNORE_CRITICAL = UNSTREAM_STRING( &constant_bin[ 63090 ], 27, 1 );
    const_dict_5608fce8424ef5aca22387357d834999 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_5608fce8424ef5aca22387357d834999, const_str_plain___module__, const_str_digest_6d237a1253b74549ee18fb0e488e3cf9 );
    PyDict_SetItem( const_dict_5608fce8424ef5aca22387357d834999, const_str_plain___doc__, const_str_digest_68e309761e6d5dc5f5c1e53801284f3a );
    assert( PyDict_Size( const_dict_5608fce8424ef5aca22387357d834999 ) == 2 );
    const_str_digest_74b73fd54833bfb6b761307c477c0a28 = UNSTREAM_STRING( &constant_bin[ 63117 ], 252, 0 );
    const_list_b8e29824b436479d358fd3771a611e70_list = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 63369 ], 600 );
    const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50 = UNSTREAM_STRING( &constant_bin[ 63969 ], 191, 0 );
    const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 0, const_str_digest_c561652c58984ec0e9541542aa405594 ); Py_INCREF( const_str_digest_c561652c58984ec0e9541542aa405594 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 1, const_int_pos_512 ); Py_INCREF( const_int_pos_512 );
    const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 1, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 2, const_str_plain_dt ); Py_INCREF( const_str_plain_dt );
    const_tuple_str_plain_self_str_plain_crl_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_crl_tuple, 1, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    const_str_digest_3121be4a855650e38916196ca238bf2b = UNSTREAM_STRING( &constant_bin[ 64160 ], 403, 0 );
    const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 3, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 4, const_str_plain_evp_pkey ); Py_INCREF( const_str_plain_evp_pkey );
    const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 1, const_str_plain__CertificateSigningRequest ); Py_INCREF( const_str_plain__CertificateSigningRequest );
    PyTuple_SET_ITEM( const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 2, const_str_plain_backend ); Py_INCREF( const_str_plain_backend );
    const_str_plain_get_type_name = UNSTREAM_STRING( &constant_bin[ 64563 ], 13, 1 );
    const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9 = UNSTREAM_STRING( &constant_bin[ 64576 ], 43, 0 );
    const_str_digest_1f681e9f80c6df652cbc3a085be49171 = UNSTREAM_STRING( &constant_bin[ 64619 ], 252, 0 );
    const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 0, const_str_plain___eq__ ); Py_INCREF( const_str_plain___eq__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 1, const_str_plain___ne__ ); Py_INCREF( const_str_plain___ne__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 2, const_str_plain___lt__ ); Py_INCREF( const_str_plain___lt__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 3, const_str_plain___le__ ); Py_INCREF( const_str_plain___le__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 4, const_str_plain___gt__ ); Py_INCREF( const_str_plain___gt__ );
    PyTuple_SET_ITEM( const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple, 5, const_str_plain___ge__ ); Py_INCREF( const_str_plain___ge__ );
    const_str_plain_new_reason_ext = UNSTREAM_STRING( &constant_bin[ 64871 ], 14, 1 );
    const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK = UNSTREAM_STRING( &constant_bin[ 64885 ], 27, 1 );
    const_str_digest_7d6056c968d1eebfab898757e6f3054e = UNSTREAM_STRING( &constant_bin[ 64912 ], 120, 0 );
    const_str_digest_721230a42e287d5632d061ff8f0376d6 = UNSTREAM_STRING( &constant_bin[ 65032 ], 259, 0 );
    const_str_digest_f583009b639aad56f3c96c175e595626 = UNSTREAM_STRING( &constant_bin[ 65291 ], 340, 0 );
    const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 3, const_str_plain_sign_result ); Py_INCREF( const_str_plain_sign_result );
    PyTuple_SET_ITEM( const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 4, const_str_plain_evp_md ); Py_INCREF( const_str_plain_evp_md );
    const_str_plain__more_args = UNSTREAM_STRING( &constant_bin[ 65631 ], 10, 1 );
    const_str_plain_set_notAfter = UNSTREAM_STRING( &constant_bin[ 65641 ], 12, 1 );
    const_str_digest_a7eaace656db47cf2975484b27c818e9 = UNSTREAM_STRING( &constant_bin[ 65653 ], 165, 0 );
    const_str_plain__initialized = UNSTREAM_STRING( &constant_bin[ 65818 ], 12, 1 );
    const_str_plain_RSA_F4 = UNSTREAM_STRING( &constant_bin[ 65830 ], 6, 1 );
    const_str_plain__read_passphrase = UNSTREAM_STRING( &constant_bin[ 65836 ], 16, 1 );
    const_tuple_str_plain___tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain___tuple, 0, const_str_plain__ ); Py_INCREF( const_str_plain__ );
    const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 1, const_str_plain_message ); Py_INCREF( const_str_plain_message );
    const_str_plain_certificate = UNSTREAM_STRING( &constant_bin[ 2624 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 2, const_str_plain_certificate ); Py_INCREF( const_str_plain_certificate );
    const_str_plain_maciter = UNSTREAM_STRING( &constant_bin[ 48086 ], 7, 1 );
    const_str_plain__get_backend = UNSTREAM_STRING( &constant_bin[ 58471 ], 12, 1 );
    const_str_plain__set_name = UNSTREAM_STRING( &constant_bin[ 65852 ], 9, 1 );
    const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38 = UNSTREAM_STRING( &constant_bin[ 65861 ], 197, 0 );
    const_str_plain_set_ca_certificates = UNSTREAM_STRING( &constant_bin[ 66058 ], 19, 1 );
    const_str_digest_0b708bb28192f1a165c843c47343f35a = UNSTREAM_STRING( &constant_bin[ 66077 ], 151, 0 );
    const_tuple_str_plain_dsa_str_plain_rsa_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dsa_str_plain_rsa_tuple, 0, const_str_plain_dsa ); Py_INCREF( const_str_plain_dsa );
    PyTuple_SET_ITEM( const_tuple_str_plain_dsa_str_plain_rsa_tuple, 1, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55 = UNSTREAM_STRING( &constant_bin[ 66228 ], 248, 0 );
    const_str_plain_get_reason = UNSTREAM_STRING( &constant_bin[ 66476 ], 10, 1 );
    const_str_plain_answer = UNSTREAM_STRING( &constant_bin[ 66486 ], 6, 1 );
    const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_encoded = UNSTREAM_STRING( &constant_bin[ 20999 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 1, const_str_plain_encoded ); Py_INCREF( const_str_plain_encoded );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_X509_VERIFY_PARAM_set_time = UNSTREAM_STRING( &constant_bin[ 66492 ], 26, 1 );
    const_str_plain_X509_REQ_get_version = UNSTREAM_STRING( &constant_bin[ 66518 ], 20, 1 );
    const_str_digest_989a9acfa289de1c2c451525451533c9 = UNSTREAM_STRING( &constant_bin[ 66538 ], 46, 0 );
    const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4 = UNSTREAM_STRING( &constant_bin[ 66584 ], 11, 0 );
    const_str_plain_get_version = UNSTREAM_STRING( &constant_bin[ 6538 ], 11, 1 );
    const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585 = UNSTREAM_STRING( &constant_bin[ 66595 ], 233, 0 );
    const_str_plain_X509_REVOKED_delete_ext = UNSTREAM_STRING( &constant_bin[ 66828 ], 23, 1 );
    const_str_plain_dump_publickey = UNSTREAM_STRING( &constant_bin[ 63698 ], 14, 1 );
    const_str_plain_FILETYPE_TEXT = UNSTREAM_STRING( &constant_bin[ 58563 ], 13, 1 );
    const_str_plain_PKCS12 = UNSTREAM_STRING( &constant_bin[ 46814 ], 6, 1 );
    const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 2, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 3, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    const_str_plain_get_extension = UNSTREAM_STRING( &constant_bin[ 54161 ], 13, 1 );
    const_str_digest_d0137950921f709b6c00a3276a078e5f = UNSTREAM_STRING( &constant_bin[ 66851 ], 463, 0 );
    const_str_digest_de1d9872d12371b2ead20f3aa79dc834 = UNSTREAM_STRING( &constant_bin[ 67314 ], 208, 0 );
    const_str_plain_x509req = UNSTREAM_STRING( &constant_bin[ 67522 ], 7, 1 );
    const_str_digest_685b3ded6e482839a3710e6a448d8669 = UNSTREAM_STRING( &constant_bin[ 67529 ], 287, 0 );
    const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9 = UNSTREAM_STRING( &constant_bin[ 67816 ], 12, 0 );
    const_str_plain_get_serial = UNSTREAM_STRING( &constant_bin[ 53937 ], 10, 1 );
    const_str_digest_9a71d9e6319c409dff859e67083fc41c = UNSTREAM_STRING( &constant_bin[ 67828 ], 563, 0 );
    const_str_digest_3a45faa244ca861d389c340b29a28988 = UNSTREAM_STRING( &constant_bin[ 68391 ], 45, 0 );
    const_str_plain_X509_STORE_free = UNSTREAM_STRING( &constant_bin[ 68436 ], 15, 1 );
    const_str_digest_ee89bc744832ab3afc27c4e7a4a73b66 = UNSTREAM_STRING( &constant_bin[ 68451 ], 54, 0 );
    const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE = UNSTREAM_STRING( &constant_bin[ 68505 ], 30, 1 );
    const_str_digest_f019d8c1ebbf58631ace92b4423b3aad = UNSTREAM_STRING( &constant_bin[ 68535 ], 51, 0 );
    const_str_plain_set_version = UNSTREAM_STRING( &constant_bin[ 68586 ], 11, 1 );
    const_str_plain__X509NameInvalidator = UNSTREAM_STRING( &constant_bin[ 68597 ], 20, 1 );
    const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 1, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    PyTuple_SET_ITEM( const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 2, const_str_plain_format_result ); Py_INCREF( const_str_plain_format_result );
    const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e = UNSTREAM_STRING( &constant_bin[ 68617 ], 20, 0 );
    const_str_plain_TYPE_DH = UNSTREAM_STRING( &constant_bin[ 68637 ], 7, 1 );
    const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 2, const_str_plain_cipher ); Py_INCREF( const_str_plain_cipher );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 3, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 4, const_str_plain_helper ); Py_INCREF( const_str_plain_helper );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 5, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    const_str_plain_cipher_obj = UNSTREAM_STRING( &constant_bin[ 68644 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 6, const_str_plain_cipher_obj ); Py_INCREF( const_str_plain_cipher_obj );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 7, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    PyTuple_SET_ITEM( const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 8, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    const_str_plain_PKCS7_type_is_signed = UNSTREAM_STRING( &constant_bin[ 68654 ], 20, 1 );
    const_str_plain_X509_V_FLAG_CRL_CHECK_ALL = UNSTREAM_STRING( &constant_bin[ 68674 ], 25, 1 );
    const_str_plain__subject_invalidator = UNSTREAM_STRING( &constant_bin[ 68699 ], 20, 1 );
    const_str_plain_PKCS7_type_is_signedAndEnveloped = UNSTREAM_STRING( &constant_bin[ 68719 ], 32, 1 );
    const_str_digest_f68048107421fed17c8f1bc19be3ec03 = UNSTREAM_STRING( &constant_bin[ 68751 ], 190, 0 );
    const_str_plain_set_time = UNSTREAM_STRING( &constant_bin[ 5052 ], 8, 1 );
    const_str_plain_X509_digest = UNSTREAM_STRING( &constant_bin[ 68941 ], 11, 1 );
    const_str_digest_5997506aef8ffc5e12c453030416acc6 = UNSTREAM_STRING( &constant_bin[ 68952 ], 68, 0 );
    const_str_plain_X509_V_FLAG_X509_STRICT = UNSTREAM_STRING( &constant_bin[ 69020 ], 23, 1 );
    const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 1, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 3, const_str_plain_result_code ); Py_INCREF( const_str_plain_result_code );
    const_str_digest_3918253e50729a002fea544312970ff5 = UNSTREAM_STRING( &constant_bin[ 69043 ], 64, 0 );
    const_str_plain_type_is_data = UNSTREAM_STRING( &constant_bin[ 69107 ], 12, 1 );
    const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 1, const_str_plain_index ); Py_INCREF( const_str_plain_index );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 3, const_str_plain_extension ); Py_INCREF( const_str_plain_extension );
    const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc = UNSTREAM_STRING( &constant_bin[ 69119 ], 17, 0 );
    const_str_plain_X509V3_set_ctx = UNSTREAM_STRING( &constant_bin[ 53170 ], 14, 1 );
    const_str_plain_get_elliptic_curve = UNSTREAM_STRING( &constant_bin[ 13612 ], 18, 1 );
    const_str_digest_c71c443223c73b253b21961ef3bd7c9e = UNSTREAM_STRING( &constant_bin[ 69136 ], 645, 0 );
    const_str_digest_a643e6a1050d6f3782a0d190235d80a7 = UNSTREAM_STRING( &constant_bin[ 69781 ], 205, 0 );
    const_str_digest_35e2a27cee76091329550405e1cb7dc4 = UNSTREAM_STRING( &constant_bin[ 69986 ], 265, 0 );
    const_str_plain_NETSCAPE_SPKI_free = UNSTREAM_STRING( &constant_bin[ 70251 ], 18, 1 );
    const_str_plain_get_privatekey = UNSTREAM_STRING( &constant_bin[ 70269 ], 14, 1 );
    const_str_plain_X509_print_ex = UNSTREAM_STRING( &constant_bin[ 70283 ], 13, 1 );
    const_str_digest_b3f225987bb27e065a500d7fe8bd7c70 = UNSTREAM_STRING( &constant_bin[ 70296 ], 24, 0 );
    const_str_plain__extension = UNSTREAM_STRING( &constant_bin[ 47401 ], 10, 1 );
    const_str_digest_c0aedec8dc85440d3dace529a9d9050e = UNSTREAM_STRING( &constant_bin[ 70320 ], 349, 0 );
    const_str_plain_fval = UNSTREAM_STRING( &constant_bin[ 70669 ], 4, 1 );
    const_str_digest_5699814601a04aa972bd2f18de396c39 = UNSTREAM_STRING( &constant_bin[ 70673 ], 345, 0 );
    const_str_digest_48639cf22fbd4e6b3714265dae0dbed8 = UNSTREAM_STRING( &constant_bin[ 71018 ], 99, 0 );
    const_str_plain_string_data = UNSTREAM_STRING( &constant_bin[ 71117 ], 11, 1 );
    const_str_plain_NETSCAPE_SPKI_verify = UNSTREAM_STRING( &constant_bin[ 71128 ], 20, 1 );
    const_str_digest_d6b3262f79e4b59cd83ab54699c92117 = UNSTREAM_STRING( &constant_bin[ 71148 ], 231, 0 );
    const_str_plain_X509ExtensionType = UNSTREAM_STRING( &constant_bin[ 69043 ], 17, 1 );
    const_str_digest_1a7a898c4490dd89b305492a40bf2633 = UNSTREAM_STRING( &constant_bin[ 71379 ], 217, 0 );
    const_str_plain_X509StoreType = UNSTREAM_STRING( &constant_bin[ 45119 ], 13, 1 );
    const_str_digest_016ce3807ea72a262d921fa7d1804717 = UNSTREAM_STRING( &constant_bin[ 71596 ], 10, 0 );
    const_str_plain_X509_STORE_CTX_init = UNSTREAM_STRING( &constant_bin[ 71606 ], 19, 1 );
    const_str_plain_dump_crl = UNSTREAM_STRING( &constant_bin[ 63912 ], 8, 1 );
    const_tuple_str_plain_self_str_plain_x509_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_x509_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_x509_tuple, 1, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 1, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 2, const_str_plain_answer ); Py_INCREF( const_str_plain_answer );
    const_str_plain_get_issuer = UNSTREAM_STRING( &constant_bin[ 71625 ], 10, 1 );
    const_str_plain_X509_STORE_new = UNSTREAM_STRING( &constant_bin[ 71635 ], 14, 1 );
    const_list_298f4a46a008df82aecc87d37443e76b_list = PyList_New( 7 );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 0, const_str_plain_unspecified ); Py_INCREF( const_str_plain_unspecified );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 1, const_str_plain_keyCompromise ); Py_INCREF( const_str_plain_keyCompromise );
    const_str_plain_CACompromise = UNSTREAM_STRING( &constant_bin[ 71649 ], 12, 1 );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 2, const_str_plain_CACompromise ); Py_INCREF( const_str_plain_CACompromise );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 3, const_str_plain_affiliationChanged ); Py_INCREF( const_str_plain_affiliationChanged );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 4, const_str_plain_superseded ); Py_INCREF( const_str_plain_superseded );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 5, const_str_plain_cessationOfOperation ); Py_INCREF( const_str_plain_cessationOfOperation );
    PyList_SET_ITEM( const_list_298f4a46a008df82aecc87d37443e76b_list, 6, const_str_plain_certificateHold ); Py_INCREF( const_str_plain_certificateHold );
    const_str_plain_EVP_PKEY_bits = UNSTREAM_STRING( &constant_bin[ 71661 ], 13, 1 );
    const_str_plain_set_flags = UNSTREAM_STRING( &constant_bin[ 71674 ], 9, 1 );
    const_str_plain__store_ctx = UNSTREAM_STRING( &constant_bin[ 51090 ], 10, 1 );
    const_str_plain_set_reason = UNSTREAM_STRING( &constant_bin[ 71683 ], 10, 1 );
    const_str_plain_encode_result = UNSTREAM_STRING( &constant_bin[ 71693 ], 13, 1 );
    const_tuple_80a9571108770bd34772239ad97225a5_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 1, const_str_plain_extensions ); Py_INCREF( const_str_plain_extensions );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_80a9571108770bd34772239ad97225a5_tuple, 3, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_digest_213346f5e36f3faf7ff7a566deec4adb = UNSTREAM_STRING( &constant_bin[ 71706 ], 252, 0 );
    const_str_plain_set_nextUpdate = UNSTREAM_STRING( &constant_bin[ 71958 ], 14, 1 );
    const_str_plain_PKCS7Type = UNSTREAM_STRING( &constant_bin[ 59502 ], 9, 1 );
    const_str_plain_CRL = UNSTREAM_STRING( &constant_bin[ 48722 ], 3, 1 );
    const_str_plain__cleanup = UNSTREAM_STRING( &constant_bin[ 47620 ], 8, 1 );
    const_str_digest_6b975dcb77568b31c2312e045b6c638c = UNSTREAM_STRING( &constant_bin[ 71972 ], 35, 0 );
    const_str_plain__bio_to_string = UNSTREAM_STRING( &constant_bin[ 72007 ], 14, 1 );
    const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b = UNSTREAM_STRING( &constant_bin[ 72021 ], 477, 0 );
    const_str_plain_X509_verify_cert = UNSTREAM_STRING( &constant_bin[ 43684 ], 16, 1 );
    const_str_plain__get_asn1_time = UNSTREAM_STRING( &constant_bin[ 72498 ], 14, 1 );
    const_str_digest_3f7d687efa133ae490fe62a28c3c2584 = UNSTREAM_STRING( &constant_bin[ 72512 ], 175, 0 );
    const_str_digest_e4c79524acf8a72de25c6c6491f370a8 = UNSTREAM_STRING( &constant_bin[ 72687 ], 294, 0 );
    const_str_plain_set_rev_date = UNSTREAM_STRING( &constant_bin[ 72981 ], 12, 1 );
    const_str_plain_load_certificate = UNSTREAM_STRING( &constant_bin[ 60224 ], 16, 1 );
    const_str_plain_X509_STORE_CTX_free = UNSTREAM_STRING( &constant_bin[ 72993 ], 19, 1 );
    const_str_digest_719137938e890576c1050ba31a668078 = UNSTREAM_STRING( &constant_bin[ 73012 ], 205, 0 );
    const_str_digest_500f278b67471fc0f770fccc80d65d95 = UNSTREAM_STRING( &constant_bin[ 73217 ], 21, 0 );
    const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd = UNSTREAM_STRING( &constant_bin[ 73238 ], 283, 0 );
    const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80 = UNSTREAM_STRING( &constant_bin[ 73521 ], 181, 0 );
    const_str_plain_X509Extension = UNSTREAM_STRING( &constant_bin[ 44524 ], 13, 1 );
    const_str_digest_6ef28169edd3cfe530885f6f9d09c390 = UNSTREAM_STRING( &constant_bin[ 73702 ], 267, 0 );
    const_str_digest_b1f5a355e1403668d0044e1a65ec29ce = UNSTREAM_STRING( &constant_bin[ 73969 ], 25, 0 );
    const_tuple_13745beac221529fe5d89135e9b648d3_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 2, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 3, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 4, const_str_plain_days ); Py_INCREF( const_str_plain_days );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 5, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 6, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 7, const_str_plain_sometime ); Py_INCREF( const_str_plain_sometime );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 8, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    PyTuple_SET_ITEM( const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 9, const_str_plain_sign_result ); Py_INCREF( const_str_plain_sign_result );
    const_str_digest_c237653198d1acecae3452511968b22e = UNSTREAM_STRING( &constant_bin[ 73994 ], 84, 0 );
    const_str_plain_type_is_signed = UNSTREAM_STRING( &constant_bin[ 68660 ], 14, 1 );
    const_str_digest_af63c2663b0a5e83daac69d308dcb1d6 = UNSTREAM_STRING( &constant_bin[ 74078 ], 158, 0 );
    const_str_plain_get_friendlyname = UNSTREAM_STRING( &constant_bin[ 74236 ], 16, 1 );
    const_str_plain_set_friendlyname = UNSTREAM_STRING( &constant_bin[ 74252 ], 16, 1 );
    const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 2, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    PyTuple_SET_ITEM( const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 4, const_str_plain_sign_result ); Py_INCREF( const_str_plain_sign_result );
    const_str_plain_IGNORE_CRITICAL = UNSTREAM_STRING( &constant_bin[ 63102 ], 15, 1 );
    const_str_plain__untested_error = UNSTREAM_STRING( &constant_bin[ 74268 ], 15, 1 );
    const_str_plain_load_publickey = UNSTREAM_STRING( &constant_bin[ 63795 ], 14, 1 );
    const_tuple_e0284b4dc341731363d45f065b316e64_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 2, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 3, const_str_plain_more_args ); Py_INCREF( const_str_plain_more_args );
    PyTuple_SET_ITEM( const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 4, const_str_plain_truncate ); Py_INCREF( const_str_plain_truncate );
    const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 1, const_str_plain_passphrase ); Py_INCREF( const_str_plain_passphrase );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 2, const_str_plain_iter ); Py_INCREF( const_str_plain_iter );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 3, const_str_plain_maciter ); Py_INCREF( const_str_plain_maciter );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 4, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 5, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 6, const_str_plain_cacerts ); Py_INCREF( const_str_plain_cacerts );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 7, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 8, const_str_plain_friendlyname ); Py_INCREF( const_str_plain_friendlyname );
    PyTuple_SET_ITEM( const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 9, const_str_plain_pkcs12 ); Py_INCREF( const_str_plain_pkcs12 );
    const_str_digest_1dbb147d3e039266688c4d87287eaaad = UNSTREAM_STRING( &constant_bin[ 74283 ], 14, 0 );
    const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd = UNSTREAM_STRING( &constant_bin[ 74297 ], 320, 0 );
    const_tuple_53b63b794c8b8f328f3f365985abd328_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 4, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 1, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_X509_STORE_set_flags = UNSTREAM_STRING( &constant_bin[ 74617 ], 20, 1 );
    const_tuple_be611311fb5723111b9692ddf834f10b_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 1, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    PyTuple_SET_ITEM( const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 2, const_str_plain_code ); Py_INCREF( const_str_plain_code );
    PyTuple_SET_ITEM( const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 3, const_str_plain_err_reason ); Py_INCREF( const_str_plain_err_reason );
    const_str_digest_9c28b2ef32679900c21c54152be8ce03 = UNSTREAM_STRING( &constant_bin[ 74637 ], 226, 0 );
    const_str_digest_4097a084fab55cf5c5baa1b785e7c82a = UNSTREAM_STRING( &constant_bin[ 74863 ], 257, 0 );
    const_str_digest_f35548e1d45f67292233a83f1d0adcce = UNSTREAM_STRING( &constant_bin[ 75120 ], 238, 0 );
    const_str_plain_get_extensions = UNSTREAM_STRING( &constant_bin[ 75358 ], 14, 1 );
    const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8 = UNSTREAM_STRING( &constant_bin[ 75372 ], 159, 0 );
    const_str_plain_EVP_SignFinal = UNSTREAM_STRING( &constant_bin[ 75531 ], 13, 1 );
    const_str_plain_get_notAfter = UNSTREAM_STRING( &constant_bin[ 75544 ], 12, 1 );
    const_str_plain__set_boundary_time = UNSTREAM_STRING( &constant_bin[ 75556 ], 18, 1 );
    const_str_plain_CB_ISSUER_CHECK = UNSTREAM_STRING( &constant_bin[ 64897 ], 15, 1 );
    const_str_plain__issuer_invalidator = UNSTREAM_STRING( &constant_bin[ 75574 ], 19, 1 );
    const_str_plain_PKCS7_type_is_enveloped = UNSTREAM_STRING( &constant_bin[ 75593 ], 23, 1 );
    const_str_plain_ASN1_STRING_type = UNSTREAM_STRING( &constant_bin[ 75616 ], 16, 1 );
    const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 1, const_str_plain_string_type ); Py_INCREF( const_str_plain_string_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 1, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 2, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    const_str_digest_117006b03ff8e10f330ac900a6cd41e8 = UNSTREAM_STRING( &constant_bin[ 75632 ], 25, 0 );
    const_str_digest_221848055f0a545c7ef1969a37bb78a5 = UNSTREAM_STRING( &constant_bin[ 75657 ], 10, 0 );
    const_str_plain_EC_get_builtin_curves = UNSTREAM_STRING( &constant_bin[ 75667 ], 21, 1 );
    const_str_plain__cmp = UNSTREAM_STRING( &constant_bin[ 75688 ], 4, 1 );
    const_str_digest_0226e12d6e09b849c37787a1a7ec35a4 = UNSTREAM_STRING( &constant_bin[ 75692 ], 27, 0 );
    const_str_plain_set_serial_number = UNSTREAM_STRING( &constant_bin[ 75719 ], 17, 1 );
    const_str_digest_bbde1e297eda38e770b8fce1d06c225b = UNSTREAM_STRING( &constant_bin[ 75736 ], 43, 0 );
    const_str_digest_3b5fd85224219fd172d589ec8f98a12a = UNSTREAM_STRING( &constant_bin[ 75779 ], 124, 0 );
    const_tuple_8110525d9a52cec647809d72afbc7239_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 1, const_str_plain_c ); Py_INCREF( const_str_plain_c );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 2, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 3, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_digest_4560cdf69c017b7cd264323295e708cb = UNSTREAM_STRING( &constant_bin[ 75903 ], 28, 0 );
    const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 1, const_str_plain_serial ); Py_INCREF( const_str_plain_serial );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 2, const_str_plain_asn1_serial ); Py_INCREF( const_str_plain_asn1_serial );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 3, const_str_plain_bignum_serial ); Py_INCREF( const_str_plain_bignum_serial );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 4, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_small_serial = UNSTREAM_STRING( &constant_bin[ 75931 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 5, const_str_plain_small_serial ); Py_INCREF( const_str_plain_small_serial );
    const_str_plain_hex_serial = UNSTREAM_STRING( &constant_bin[ 75943 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 6, const_str_plain_hex_serial ); Py_INCREF( const_str_plain_hex_serial );
    const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 1, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 4, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 5, const_str_plain_fval ); Py_INCREF( const_str_plain_fval );
    const_str_plain_ent = UNSTREAM_STRING( &constant_bin[ 2658 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 6, const_str_plain_ent ); Py_INCREF( const_str_plain_ent );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 7, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 8, const_str_plain_fname ); Py_INCREF( const_str_plain_fname );
    const_str_digest_5e37d069c5e76ee6d50c7e91b7181934 = UNSTREAM_STRING( &constant_bin[ 75953 ], 232, 0 );
    const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 2, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    const_str_plain_data_length = UNSTREAM_STRING( &constant_bin[ 13445 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 3, const_str_plain_data_length ); Py_INCREF( const_str_plain_data_length );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 4, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 6, const_str_plain_entry_index ); Py_INCREF( const_str_plain_entry_index );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 7, const_str_plain_entry ); Py_INCREF( const_str_plain_entry );
    PyTuple_SET_ITEM( const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 8, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7 = UNSTREAM_STRING( &constant_bin[ 76185 ], 20, 0 );
    const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_issuer_cert = UNSTREAM_STRING( &constant_bin[ 76205 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 1, const_str_plain_issuer_cert ); Py_INCREF( const_str_plain_issuer_cert );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 2, const_str_plain_issuer_key ); Py_INCREF( const_str_plain_issuer_key );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 3, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 4, const_str_plain_digest_obj ); Py_INCREF( const_str_plain_digest_obj );
    PyTuple_SET_ITEM( const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_EVP_SignUpdate = UNSTREAM_STRING( &constant_bin[ 76216 ], 14, 1 );
    const_str_plain_digest_name = UNSTREAM_STRING( &constant_bin[ 54986 ], 11, 1 );
    const_str_digest_0b9d4db9119537682a1f5302a9cbcc57 = UNSTREAM_STRING( &constant_bin[ 76230 ], 321, 0 );
    const_str_plain_X509_V_FLAG_EXPLICIT_POLICY = UNSTREAM_STRING( &constant_bin[ 76551 ], 27, 1 );
    const_str_plain_PKCS7_free = UNSTREAM_STRING( &constant_bin[ 76578 ], 10, 1 );
    const_str_digest_1d1fec7c0642196df296efbe43db1801 = UNSTREAM_STRING( &constant_bin[ 76588 ], 722, 0 );
    const_str_plain_exts = UNSTREAM_STRING( &constant_bin[ 2550 ], 4, 1 );
    const_str_plain_TYPE_EC = UNSTREAM_STRING( &constant_bin[ 77310 ], 7, 1 );
    const_str_plain_rwflag = UNSTREAM_STRING( &constant_bin[ 77317 ], 6, 1 );
    const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 3, const_str_plain_x509 ); Py_INCREF( const_str_plain_x509 );
    const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple, 0, const_str_digest_4560cdf69c017b7cd264323295e708cb ); Py_INCREF( const_str_digest_4560cdf69c017b7cd264323295e708cb );
    const_str_plain_CRL_CHECK_ALL = UNSTREAM_STRING( &constant_bin[ 68686 ], 13, 1 );
    const_str_digest_d85051204198165c5d51e35c1e5d5077 = UNSTREAM_STRING( &constant_bin[ 77323 ], 214, 0 );
    const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d = UNSTREAM_STRING( &constant_bin[ 77537 ], 290, 0 );
    const_str_plain_TYPE_DSA = UNSTREAM_STRING( &constant_bin[ 63445 ], 8, 1 );
    const_str_plain_M_ASN1_OCTET_STRING_print = UNSTREAM_STRING( &constant_bin[ 77827 ], 25, 1 );
    const_str_digest_07697dd6fa4854473fa24b52569d5636 = UNSTREAM_STRING( &constant_bin[ 77852 ], 139, 0 );
    const_str_plain_has_expired = UNSTREAM_STRING( &constant_bin[ 77991 ], 11, 1 );
    const_str_plain_gmtime_adj_notAfter = UNSTREAM_STRING( &constant_bin[ 78002 ], 19, 1 );
    const_str_plain__EllipticCurve = UNSTREAM_STRING( &constant_bin[ 78021 ], 14, 1 );
    const_str_digest_007f81c06fa49e709fd9306cc6c26627 = UNSTREAM_STRING( &constant_bin[ 78035 ], 189, 0 );
    const_str_plain_X509Req = UNSTREAM_STRING( &constant_bin[ 57395 ], 7, 1 );
    const_str_plain_X509_STORE_add_cert = UNSTREAM_STRING( &constant_bin[ 78224 ], 19, 1 );
    const_str_plain_X509_STORE_CTX_new = UNSTREAM_STRING( &constant_bin[ 78243 ], 18, 1 );
    const_str_plain_digest_result = UNSTREAM_STRING( &constant_bin[ 78261 ], 13, 1 );
    const_tuple_str_plain__CertificateRevocationList_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__CertificateRevocationList_tuple, 0, const_str_plain__CertificateRevocationList ); Py_INCREF( const_str_plain__CertificateRevocationList );
    const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 1, const_str_plain__issuer ); Py_INCREF( const_str_plain__issuer );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 2, const_str_plain_issuer ); Py_INCREF( const_str_plain_issuer );
    const_str_plain_gmtime_adj_notBefore = UNSTREAM_STRING( &constant_bin[ 78274 ], 20, 1 );
    const_str_plain__exception_from_context = UNSTREAM_STRING( &constant_bin[ 78294 ], 23, 1 );
    const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 1, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_X509_STORE_set1_param = UNSTREAM_STRING( &constant_bin[ 78317 ], 21, 1 );
    const_str_plain_get_critical = UNSTREAM_STRING( &constant_bin[ 78338 ], 12, 1 );
    const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 1, const_str_plain_lib ); Py_INCREF( const_str_plain_lib );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 2, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    const_str_plain__req = UNSTREAM_STRING( &constant_bin[ 7423 ], 4, 1 );
    const_str_plain_X509_CRL_sort = UNSTREAM_STRING( &constant_bin[ 78350 ], 13, 1 );
    const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f = UNSTREAM_STRING( &constant_bin[ 78363 ], 199, 0 );
    const_str_plain__prefixes = UNSTREAM_STRING( &constant_bin[ 78562 ], 9, 1 );
    const_tuple_5209455ecbb28249752027c3a839ae1c_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 1, const_str_plain_buf ); Py_INCREF( const_str_plain_buf );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 2, const_str_plain_size ); Py_INCREF( const_str_plain_size );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 3, const_str_plain_rwflag ); Py_INCREF( const_str_plain_rwflag );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 4, const_str_plain_userdata ); Py_INCREF( const_str_plain_userdata );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 5, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 6, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 7, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_tuple_str_plain_self_str_plain_req_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_req_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_req_tuple, 1, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    const_str_plain_PEM_write_bio_PrivateKey = UNSTREAM_STRING( &constant_bin[ 78571 ], 24, 1 );
    const_str_plain_PEM_read_bio_PKCS7 = UNSTREAM_STRING( &constant_bin[ 78595 ], 18, 1 );
    const_tuple_str_plain_self_str_plain_which_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_which_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    const_str_digest_0ba82c04a076f46925a74539c2a8ba40 = UNSTREAM_STRING( &constant_bin[ 78613 ], 459, 0 );
    const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 1, const_str_plain_amount ); Py_INCREF( const_str_plain_amount );
    const_str_plain_notBefore = UNSTREAM_STRING( &constant_bin[ 53161 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 2, const_str_plain_notBefore ); Py_INCREF( const_str_plain_notBefore );
    const_str_plain_to_cryptography_key = UNSTREAM_STRING( &constant_bin[ 79072 ], 19, 1 );
    const_str_digest_97388c7ddfea4f913fec5c846dd26ef1 = UNSTREAM_STRING( &constant_bin[ 79091 ], 279, 0 );
    const_tuple_79603f0465bd62773d6ec6c98e743896_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 1, const_str_plain_reason ); Py_INCREF( const_str_plain_reason );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 2, const_str_plain_reason_code ); Py_INCREF( const_str_plain_reason_code );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 3, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 4, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 5, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    PyTuple_SET_ITEM( const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 6, const_str_plain_new_reason_ext ); Py_INCREF( const_str_plain_new_reason_ext );
    const_str_plain_NETSCAPE_SPKI_sign = UNSTREAM_STRING( &constant_bin[ 79370 ], 18, 1 );
    const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 2, const_str_plain_print_result ); Py_INCREF( const_str_plain_print_result );
    const_str_digest_61d70cefdce1472400ab8a06d64ef78a = UNSTREAM_STRING( &constant_bin[ 79388 ], 142, 0 );
    const_str_plain_load_privatekey = UNSTREAM_STRING( &constant_bin[ 63814 ], 15, 1 );
    const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple, 0, const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4 ); Py_INCREF( const_str_digest_f3b04f8993b30e664e4afacb3d64cdc4 );
    const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 1, const_str_plain_crypto_req ); Py_INCREF( const_str_plain_crypto_req );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 2, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    const_str_digest_e19f4eaf61167e65441aca909fe75b36 = UNSTREAM_STRING( &constant_bin[ 79530 ], 23, 0 );
    const_str_plain_MBSTRING_UTF8 = UNSTREAM_STRING( &constant_bin[ 79553 ], 13, 1 );
    const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 1, const_str_plain_cacerts ); Py_INCREF( const_str_plain_cacerts );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 2, const_str_plain_cert ); Py_INCREF( const_str_plain_cert );
    const_str_plain_Revoked = UNSTREAM_STRING( &constant_bin[ 63737 ], 7, 1 );
    const_str_plain__only_public = UNSTREAM_STRING( &constant_bin[ 79566 ], 12, 1 );
    const_tuple_str_plain_self_str_plain_dt_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dt_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_dt_tuple, 1, const_str_plain_dt ); Py_INCREF( const_str_plain_dt );
    const_str_plain_GENERAL_NAME_print = UNSTREAM_STRING( &constant_bin[ 79578 ], 18, 1 );
    const_str_plain__names = UNSTREAM_STRING( &constant_bin[ 3081 ], 6, 1 );
    const_str_digest_c57795fb6a9ac3d47e928f9a8b608571 = UNSTREAM_STRING( &constant_bin[ 79596 ], 43, 0 );
    const_tuple_str_plain_self_str_plain_store_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_store_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_store_tuple, 1, const_str_plain_store ); Py_INCREF( const_str_plain_store );
    const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 1, const_str_plain_vfy_time ); Py_INCREF( const_str_plain_vfy_time );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 2, const_str_plain_param ); Py_INCREF( const_str_plain_param );
    const_str_plain_add_extensions = UNSTREAM_STRING( &constant_bin[ 79639 ], 14, 1 );
    const_str_plain_EVP_VerifyInit = UNSTREAM_STRING( &constant_bin[ 79653 ], 14, 1 );
    const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc = UNSTREAM_STRING( &constant_bin[ 79667 ], 313, 0 );
    const_str_plain_NID_crl_reason = UNSTREAM_STRING( &constant_bin[ 79980 ], 14, 1 );
    const_str_plain_generalized_timestamp = UNSTREAM_STRING( &constant_bin[ 79994 ], 21, 1 );
    const_str_plain_X509StoreContextError = UNSTREAM_STRING( &constant_bin[ 63609 ], 21, 1 );
    const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92 = UNSTREAM_STRING( &constant_bin[ 80015 ], 181, 0 );
    const_str_plain_utcnow = UNSTREAM_STRING( &constant_bin[ 80196 ], 6, 1 );
    const_tuple_str_plain_name_str_plain_curve_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_name_str_plain_curve_tuple, 0, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_str_plain_name_str_plain_curve_tuple, 1, const_str_plain_curve ); Py_INCREF( const_str_plain_curve );
    const_str_plain_X509_V_FLAG_INHIBIT_MAP = UNSTREAM_STRING( &constant_bin[ 80202 ], 23, 1 );
    const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_crypto_key = UNSTREAM_STRING( &constant_bin[ 64697 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 1, const_str_plain_crypto_key ); Py_INCREF( const_str_plain_crypto_key );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 2, const_str_plain_pkey ); Py_INCREF( const_str_plain_pkey );
    const_str_digest_fdf1281f34921aa68eda346883bb972d = UNSTREAM_STRING( &constant_bin[ 80225 ], 62, 0 );
    const_str_digest_cf86a9123926465ab14a7bd2861326f6 = UNSTREAM_STRING( &constant_bin[ 80287 ], 571, 0 );
    const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 0, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 2, const_str_plain_data ); Py_INCREF( const_str_plain_data );
    const_str_plain_free = UNSTREAM_STRING( &constant_bin[ 22931 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 3, const_str_plain_free ); Py_INCREF( const_str_plain_free );
    const_str_plain_ent_obj = UNSTREAM_STRING( &constant_bin[ 80858 ], 7, 1 );
    const_str_plain__owner = UNSTREAM_STRING( &constant_bin[ 80865 ], 6, 1 );
    const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 0, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 1, const_str_plain_buffer ); Py_INCREF( const_str_plain_buffer );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 2, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 3, const_str_plain_req ); Py_INCREF( const_str_plain_req );
    PyTuple_SET_ITEM( const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 4, const_str_plain_x509req ); Py_INCREF( const_str_plain_x509req );
    const_str_plain_ASN1_STRING_data = UNSTREAM_STRING( &constant_bin[ 80871 ], 16, 1 );
    const_str_digest_819566a56c114d5ab553db6b3a965184 = UNSTREAM_STRING( &constant_bin[ 80887 ], 18, 0 );
    const_str_plain_sk_X509_new_null = UNSTREAM_STRING( &constant_bin[ 80905 ], 16, 1 );
    const_str_plain_ASN1_STRING_length = UNSTREAM_STRING( &constant_bin[ 80921 ], 18, 1 );
    const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple, 0, const_str_digest_016ce3807ea72a262d921fa7d1804717 ); Py_INCREF( const_str_digest_016ce3807ea72a262d921fa7d1804717 );
    const_str_plain_type_is_signedAndEnveloped = UNSTREAM_STRING( &constant_bin[ 68725 ], 26, 1 );
    const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 1, const_str_plain_store ); Py_INCREF( const_str_plain_store );
    PyTuple_SET_ITEM( const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 2, const_str_plain_certificate ); Py_INCREF( const_str_plain_certificate );
    PyTuple_SET_ITEM( const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 3, const_str_plain_store_ctx ); Py_INCREF( const_str_plain_store_ctx );
    const_str_plain_X509_NAME_oneline = UNSTREAM_STRING( &constant_bin[ 80939 ], 17, 1 );
    const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea = UNSTREAM_STRING( &constant_bin[ 80956 ], 37, 0 );
    const_str_digest_c623dd0c947983ab2cfcbe4c53400720 = UNSTREAM_STRING( &constant_bin[ 80993 ], 14, 0 );
    const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0 = UNSTREAM_STRING( &constant_bin[ 81007 ], 415, 0 );
    const_str_plain_EVP_PKEY_type = UNSTREAM_STRING( &constant_bin[ 81422 ], 13, 1 );
    const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 1, const_str_plain_char_result ); Py_INCREF( const_str_plain_char_result );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 2, const_str_plain_octet_result ); Py_INCREF( const_str_plain_octet_result );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 3, const_str_plain_string_result ); Py_INCREF( const_str_plain_string_result );
    const_str_plain_result_length = UNSTREAM_STRING( &constant_bin[ 81435 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 4, const_str_plain_result_length ); Py_INCREF( const_str_plain_result_length );
    const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 1, const_str_plain_bio ); Py_INCREF( const_str_plain_bio );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 4, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 5, const_str_plain_label ); Py_INCREF( const_str_plain_label );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 6, const_str_plain_parts ); Py_INCREF( const_str_plain_parts );
    PyTuple_SET_ITEM( const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 7, const_str_plain_names ); Py_INCREF( const_str_plain_names );
    const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9 = UNSTREAM_STRING( &constant_bin[ 81448 ], 393, 0 );
    const_str_digest_2cf9e4c7f607857df636a128997ff3fc = UNSTREAM_STRING( &constant_bin[ 81841 ], 31, 0 );
    const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 1, const_str_plain_which ); Py_INCREF( const_str_plain_which );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 3, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain_dump_privatekey = UNSTREAM_STRING( &constant_bin[ 63717 ], 15, 1 );
    const_str_digest_686e4f9f1c51b7038afe792590c33346 = UNSTREAM_STRING( &constant_bin[ 81872 ], 118, 0 );
    const_str_digest_0d8911e895179dcd467b4e9de2f411d4 = UNSTREAM_STRING( &constant_bin[ 81990 ], 250, 0 );
    const_str_plain__load_elliptic_curves = UNSTREAM_STRING( &constant_bin[ 82240 ], 21, 1 );
    const_str_plain__pkcs7 = UNSTREAM_STRING( &constant_bin[ 43842 ], 6, 1 );
    const_str_plain__get_boundary_time = UNSTREAM_STRING( &constant_bin[ 82261 ], 18, 1 );
    const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 1, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 2, const_str_plain_string_result ); Py_INCREF( const_str_plain_string_result );
    PyTuple_SET_ITEM( const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 3, const_str_plain_encode_result ); Py_INCREF( const_str_plain_encode_result );
    const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple, 0, const_str_plain_ASN1_TIME_to_generalizedtime ); Py_INCREF( const_str_plain_ASN1_TIME_to_generalizedtime );
    const_str_plain_pem_password_cb = UNSTREAM_STRING( &constant_bin[ 82279 ], 15, 1 );
    const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 1, const_str_plain_bignum_serial ); Py_INCREF( const_str_plain_bignum_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 2, const_str_plain_hexstring_serial ); Py_INCREF( const_str_plain_hexstring_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 3, const_str_plain_asn1_serial ); Py_INCREF( const_str_plain_asn1_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 4, const_str_plain_hex_serial ); Py_INCREF( const_str_plain_hex_serial );
    PyTuple_SET_ITEM( const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 5, const_str_plain_serial ); Py_INCREF( const_str_plain_serial );
    const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 2, const_str_plain_ext ); Py_INCREF( const_str_plain_ext );
    PyTuple_SET_ITEM( const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 3, const_str_plain_exts ); Py_INCREF( const_str_plain_exts );
    PyTuple_SET_ITEM( const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 4, const_str_plain_native_exts_obj ); Py_INCREF( const_str_plain_native_exts_obj );
    const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a = UNSTREAM_STRING( &constant_bin[ 82294 ], 346, 0 );
    const_str_plain_X509_STORE_add_crl = UNSTREAM_STRING( &constant_bin[ 82640 ], 18, 1 );
    const_str_plain_PKCS7 = UNSTREAM_STRING( &constant_bin[ 43891 ], 5, 1 );
    const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_crypto_crl = UNSTREAM_STRING( &constant_bin[ 57095 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 1, const_str_plain_crypto_crl ); Py_INCREF( const_str_plain_crypto_crl );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 2, const_str_plain_crl ); Py_INCREF( const_str_plain_crl );
    const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0, const_str_digest_80438074180d95b1a2291874613077b5 ); Py_INCREF( const_str_digest_80438074180d95b1a2291874613077b5 );
    const_str_plain_X509_get0_tbs_sigalg = UNSTREAM_STRING( &constant_bin[ 82658 ], 20, 1 );
    const_tuple_d959e8503cbe0fd15122162c0da60661_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 0, const_str_plain_timestamp ); Py_INCREF( const_str_plain_timestamp );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 1, const_str_plain_generalized_timestamp ); Py_INCREF( const_str_plain_generalized_timestamp );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 2, const_str_plain_string_result ); Py_INCREF( const_str_plain_string_result );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 3, const_str_plain_string_data ); Py_INCREF( const_str_plain_string_data );
    PyTuple_SET_ITEM( const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 4, const_str_plain_string_timestamp ); Py_INCREF( const_str_plain_string_timestamp );
    const_str_plain_get_data = UNSTREAM_STRING( &constant_bin[ 82678 ], 8, 1 );
    const_str_plain_X509_alias_get0 = UNSTREAM_STRING( &constant_bin[ 82686 ], 15, 1 );
    const_str_plain_X509_NAME_cmp = UNSTREAM_STRING( &constant_bin[ 82701 ], 13, 1 );
    const_str_plain__integer_types = UNSTREAM_STRING( &constant_bin[ 82714 ], 14, 1 );
    const_str_plain_PKCS12Type = UNSTREAM_STRING( &constant_bin[ 52018 ], 10, 1 );
    const_str_plain_EXPLICIT_POLICY = UNSTREAM_STRING( &constant_bin[ 76563 ], 15, 1 );
    const_str_plain_set_issuer = UNSTREAM_STRING( &constant_bin[ 82728 ], 10, 1 );
    const_str_plain_ASN1_INTEGER_set = UNSTREAM_STRING( &constant_bin[ 82738 ], 16, 1 );
    const_str_digest_08a0d510acdd77f37b666a4668538f96 = UNSTREAM_STRING( &constant_bin[ 82754 ], 44, 0 );
    const_str_digest_713d8c2afef94db133cda1bff1cb496f = UNSTREAM_STRING( &constant_bin[ 82798 ], 33, 0 );
    const_str_digest_2dbcbe3e7da77178b4a9da40244d072a = UNSTREAM_STRING( &constant_bin[ 82831 ], 26, 0 );
    const_str_digest_0d925750cb36e0c0e5f47f40c47790e6 = UNSTREAM_STRING( &constant_bin[ 82857 ], 22, 0 );
    const_str_digest_66b2a3b8e35254752e96fbbddc255dfd = UNSTREAM_STRING( &constant_bin[ 82879 ], 174, 0 );
    const_str_digest_998fe297d663eb0475d60a56d2b84182 = UNSTREAM_STRING( &constant_bin[ 83053 ], 447, 0 );
    const_str_digest_859c7c43c5cf3124cdd58374d6e7359e = UNSTREAM_STRING( &constant_bin[ 83500 ], 79, 0 );
    const_str_plain_BN_set_word = UNSTREAM_STRING( &constant_bin[ 83579 ], 11, 1 );
    const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14 = UNSTREAM_STRING( &constant_bin[ 83590 ], 32, 0 );
    const_str_digest_bb334a0dc943b8e820be149d2c515af0 = UNSTREAM_STRING( &constant_bin[ 75691 ], 19, 0 );
    const_tuple_57dca116533b0d6d636b268e7001e41b_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 1, const_str_plain_digest_name ); Py_INCREF( const_str_plain_digest_name );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 2, const_str_plain_digest_result ); Py_INCREF( const_str_plain_digest_result );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 3, const_str_plain_ch ); Py_INCREF( const_str_plain_ch );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 4, const_str_plain_result_length ); Py_INCREF( const_str_plain_result_length );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 5, const_str_plain_result_buffer ); Py_INCREF( const_str_plain_result_buffer );
    PyTuple_SET_ITEM( const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 6, const_str_plain_digest ); Py_INCREF( const_str_plain_digest );
    const_str_digest_bb6f5ad807179d7105a669c98779d984 = UNSTREAM_STRING( &constant_bin[ 83622 ], 50, 0 );
    const_str_plain_subject_name_hash = UNSTREAM_STRING( &constant_bin[ 60207 ], 17, 1 );
    const_tuple_str_plain__CertificateSigningRequest_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__CertificateSigningRequest_tuple, 0, const_str_plain__CertificateSigningRequest ); Py_INCREF( const_str_plain__CertificateSigningRequest );
    const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d = UNSTREAM_STRING( &constant_bin[ 83672 ], 177, 0 );
    const_str_digest_4b3673d04a6e4a628e29457d54d43c0d = UNSTREAM_STRING( &constant_bin[ 83849 ], 29, 0 );
    const_str_plain_X509ReqType = UNSTREAM_STRING( &constant_bin[ 57395 ], 11, 1 );
    const_str_plain_V_ASN1_GENERALIZEDTIME = UNSTREAM_STRING( &constant_bin[ 83878 ], 22, 1 );
    const_str_plain_get_revoked = UNSTREAM_STRING( &constant_bin[ 83900 ], 11, 1 );
    const_str_plain_dump_certificate_request = UNSTREAM_STRING( &constant_bin[ 63834 ], 24, 1 );
    const_str_plain_X509_gmtime_adj = UNSTREAM_STRING( &constant_bin[ 83911 ], 15, 1 );
    const_str_plain_NETSCAPE_SPKI_set_pubkey = UNSTREAM_STRING( &constant_bin[ 83926 ], 24, 1 );
    const_str_digest_6b6b180b644052fa34c3e81151f6ea0a = UNSTREAM_STRING( &constant_bin[ 83950 ], 40, 0 );
    const_str_plain_get_signature_algorithm = UNSTREAM_STRING( &constant_bin[ 83990 ], 23, 1 );
    const_str_plain_ALLOW_PROXY_CERTS = UNSTREAM_STRING( &constant_bin[ 49527 ], 17, 1 );
    const_str_plain_PKCS7_type_is_data = UNSTREAM_STRING( &constant_bin[ 84013 ], 18, 1 );
    const_str_plain__delete_reason = UNSTREAM_STRING( &constant_bin[ 84031 ], 14, 1 );
    const_str_plain_X509NameType = UNSTREAM_STRING( &constant_bin[ 68451 ], 12, 1 );
    const_str_digest_6674ab14e1178de501dfb968278a50b9 = UNSTREAM_STRING( &constant_bin[ 60295 ], 21, 0 );
    const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 1, const_str_plain_revoked ); Py_INCREF( const_str_plain_revoked );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 2, const_str_plain_copy ); Py_INCREF( const_str_plain_copy );
    PyTuple_SET_ITEM( const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 3, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_plain_verify_certificate = UNSTREAM_STRING( &constant_bin[ 51682 ], 18, 1 );
    const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2 = UNSTREAM_STRING( &constant_bin[ 84045 ], 161, 0 );
    const_tuple_none_int_pos_2048_int_pos_1_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2048_int_pos_1_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2048_int_pos_1_tuple, 1, const_int_pos_2048 ); Py_INCREF( const_int_pos_2048 );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2048_int_pos_1_tuple, 2, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    const_str_plain_NETSCAPE_SPKI_b64_encode = UNSTREAM_STRING( &constant_bin[ 84206 ], 24, 1 );
    const_tuple_788a505d6e43a02df061e74659415d8f_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 2, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 4, const_str_plain_nid ); Py_INCREF( const_str_plain_nid );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 5, const_str_plain_ent_obj ); Py_INCREF( const_str_plain_ent_obj );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 6, const_str_plain_ent ); Py_INCREF( const_str_plain_ent );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 7, const_str_plain_ent_nid ); Py_INCREF( const_str_plain_ent_nid );
    PyTuple_SET_ITEM( const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 8, const_str_plain_add_result ); Py_INCREF( const_str_plain_add_result );
    const_str_plain_get_pubkey = UNSTREAM_STRING( &constant_bin[ 62316 ], 10, 1 );
    const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0, const_str_digest_5339fa8ff3df372e54ef7b09078767aa ); Py_INCREF( const_str_digest_5339fa8ff3df372e54ef7b09078767aa );
    const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e = UNSTREAM_STRING( &constant_bin[ 84230 ], 356, 0 );
    const_str_plain_NETSCAPE_SPKI_new = UNSTREAM_STRING( &constant_bin[ 84586 ], 17, 1 );
    const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611 = UNSTREAM_STRING( &constant_bin[ 84603 ], 273, 0 );
    const_str_digest_2c2564e59b067260d7d96d252fc73cd1 = UNSTREAM_STRING( &constant_bin[ 84876 ], 248, 0 );
    const_str_plain__subjectAltNameString = UNSTREAM_STRING( &constant_bin[ 85124 ], 21, 1 );
    const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 2, const_str_plain_bits ); Py_INCREF( const_str_plain_bits );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 3, const_str_plain_exponent ); Py_INCREF( const_str_plain_exponent );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 4, const_str_plain_rsa ); Py_INCREF( const_str_plain_rsa );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 6, const_str_plain_res ); Py_INCREF( const_str_plain_res );
    PyTuple_SET_ITEM( const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 7, const_str_plain_dsa ); Py_INCREF( const_str_plain_dsa );
    const_str_plain__byte_string = UNSTREAM_STRING( &constant_bin[ 85145 ], 12, 1 );
    const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 0, const_str_plain_boundary ); Py_INCREF( const_str_plain_boundary );
    PyTuple_SET_ITEM( const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 1, const_str_plain_when ); Py_INCREF( const_str_plain_when );
    PyTuple_SET_ITEM( const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 2, const_str_plain_set_result ); Py_INCREF( const_str_plain_set_result );
    const_str_plain__curves = UNSTREAM_STRING( &constant_bin[ 13681 ], 7, 1 );
    const_str_digest_9226325aac109a91f8326c1a26ede065 = UNSTREAM_STRING( &constant_bin[ 85157 ], 48, 0 );
    const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple, 0, const_str_digest_0d925750cb36e0c0e5f47f40c47790e6 ); Py_INCREF( const_str_digest_0d925750cb36e0c0e5f47f40c47790e6 );
    const_str_digest_4357c956c1f3628f437632877b5d8593 = UNSTREAM_STRING( &constant_bin[ 85205 ], 197, 0 );
    const_str_digest_b16563a844474e8eed4710209909ab32 = UNSTREAM_STRING( &constant_bin[ 85402 ], 283, 0 );
    const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58 = UNSTREAM_STRING( &constant_bin[ 85685 ], 211, 0 );
    const_str_plain_X509_REQ_print_ex = UNSTREAM_STRING( &constant_bin[ 85896 ], 17, 1 );
    const_str_digest_e2d5c2f473553b6759cc455da987e04a = UNSTREAM_STRING( &constant_bin[ 85913 ], 163, 0 );
    const_str_plain_add_revoked = UNSTREAM_STRING( &constant_bin[ 86076 ], 11, 1 );
    const_str_digest_290681512f72ca11cbf3e4827987aabb = UNSTREAM_STRING( &constant_bin[ 86087 ], 20, 0 );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_OpenSSL$crypto( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_673f2b0b42693996557bb3ee4e55f969;
static PyCodeObject *codeobj_57aaabf758aa7c8c4a6e68a7dcea7c0c;
static PyCodeObject *codeobj_762cff70b659b0b1614f9749662cbdb5;
static PyCodeObject *codeobj_746bb3fa3035767ed3cd36b6784141e9;
static PyCodeObject *codeobj_053b533781a7f6d764fff943a8c7efe9;
static PyCodeObject *codeobj_e115d65213e4a52485ea15b6051b88e9;
static PyCodeObject *codeobj_282c2f71fc2cfcb78842aae5c1418e1a;
static PyCodeObject *codeobj_1642adfffc73b068bfa3ff06f1921759;
static PyCodeObject *codeobj_f18fafe32e9e502bfe9ab12ad38f5cd3;
static PyCodeObject *codeobj_815faf1bae776438a2806f882aa20cdb;
static PyCodeObject *codeobj_cf6295d0383197dc8a74dbef60884f33;
static PyCodeObject *codeobj_d860a737664a16683e8d212dd9ae54eb;
static PyCodeObject *codeobj_10b38ed4f0743b3bdeee62d537a0c90a;
static PyCodeObject *codeobj_1e9a0d222889b318a7dbd80de8f45303;
static PyCodeObject *codeobj_50fc6fa6c0ba7d87e3e63c2bfa99b0ec;
static PyCodeObject *codeobj_b3eeb60a67b100f9108e6a5c3cf04ffc;
static PyCodeObject *codeobj_9ff3a88728c4c3ad3cab48c082dc7fb8;
static PyCodeObject *codeobj_507773a59fe1a3d6025f2d54e3fa4c0b;
static PyCodeObject *codeobj_a0582cf67145aa1223c5c2d1c9e689f4;
static PyCodeObject *codeobj_87626e6c1de4d18891ada0519a066a50;
static PyCodeObject *codeobj_5b8fb2eb4576f5266e57e0af3d70a55b;
static PyCodeObject *codeobj_01b9cb7c90c52be647b05193f717878b;
static PyCodeObject *codeobj_338fb2696ad7e2b451292dd99118ec51;
static PyCodeObject *codeobj_ee9f0393ec340507f2d7d8df847a43a2;
static PyCodeObject *codeobj_a2c62897603cb5a7fc5a6b08caea1638;
static PyCodeObject *codeobj_9b9fe3cd704764cfc5a24bfccdf88473;
static PyCodeObject *codeobj_d964ee3167a18a9a588e49cbd6499968;
static PyCodeObject *codeobj_34cc9897f64823e467bbb021110e428b;
static PyCodeObject *codeobj_d0de697e0ff0841e276f18046e633c8c;
static PyCodeObject *codeobj_78f117206d8a841a588d9bb177b70ecd;
static PyCodeObject *codeobj_d7b026a4f1f66fd2b9e84f2cfbc64af8;
static PyCodeObject *codeobj_8f3d95c9a6254aa6ef78af56f493d9f8;
static PyCodeObject *codeobj_8baf017b3c354fe764f7b750d89261a3;
static PyCodeObject *codeobj_0b3107fda7e0aa194200a083196e49c5;
static PyCodeObject *codeobj_4e2b2ba154ff2752acf2cd9a9d89cc43;
static PyCodeObject *codeobj_3c27bf579b7f947bd398a69e11f418fa;
static PyCodeObject *codeobj_064c50c5cfb37771136fe7d568d247de;
static PyCodeObject *codeobj_0589830efba91376579341caa89dd6a4;
static PyCodeObject *codeobj_729446125c4d798b28cb589d422e8d78;
static PyCodeObject *codeobj_475e786458065e1c4a97a0ef87abac1c;
static PyCodeObject *codeobj_0d1f0497dba37a9b164ae4b60dcd4d90;
static PyCodeObject *codeobj_f1b4064961f0e278b8e11fc39e19cd03;
static PyCodeObject *codeobj_87faf2505fcb253335d3ffaa0e318e59;
static PyCodeObject *codeobj_e290698928eff63f6a91ddfadc9c203c;
static PyCodeObject *codeobj_3f35dc87711e3416ee84ceaf5ce82fc4;
static PyCodeObject *codeobj_82c4e32bfec555b110886c6016f6efba;
static PyCodeObject *codeobj_78e8acd21cb941da83b042ef8579466b;
static PyCodeObject *codeobj_3ee8a1e08a2e2b1ed44dccfa5075f32a;
static PyCodeObject *codeobj_b2f2763c19dc9c314be26f15048c5fd6;
static PyCodeObject *codeobj_3127dbe27680f0c65ac42a57d59c9b15;
static PyCodeObject *codeobj_50e52f8de0f444400c5e7caf8a75aef0;
static PyCodeObject *codeobj_a6726744ebe17f9af48cee0d79422468;
static PyCodeObject *codeobj_c99ce10f3d0860a31e6597cc2063e968;
static PyCodeObject *codeobj_751e01039a709a9872d0145d6873cd38;
static PyCodeObject *codeobj_6f027376d854b905b5ee53119d46201b;
static PyCodeObject *codeobj_a07fd4d8b0764d77370791e3c0281e5f;
static PyCodeObject *codeobj_dbc361cccf29968e2e8df96cd0cf2935;
static PyCodeObject *codeobj_bbd2a92a2023b917b723ee2bdc574a0b;
static PyCodeObject *codeobj_0d0a6cfa23df0134bf276c6438f2ab9f;
static PyCodeObject *codeobj_eaea0b733ecd041102dac535c4e48296;
static PyCodeObject *codeobj_c544d0701ee1c350826d019a78afa8e0;
static PyCodeObject *codeobj_f29a38d7c45651595cf6aedace7de9aa;
static PyCodeObject *codeobj_36498b0149329ae65dad35a28b8821d9;
static PyCodeObject *codeobj_457291e3f25809c88b1764bd146b0304;
static PyCodeObject *codeobj_174bb49227fddc62e7f6e6dd1564c881;
static PyCodeObject *codeobj_2c29d90d26933595e91a312e32e549af;
static PyCodeObject *codeobj_021a09f6ae6938555af0896436365d60;
static PyCodeObject *codeobj_5379defb662177ec26632ddbc4192577;
static PyCodeObject *codeobj_459e5c608fc9cc34bd5565608d5b7717;
static PyCodeObject *codeobj_83351a66f26ebd1513f374fe4435cbc6;
static PyCodeObject *codeobj_14e959ce713a9ebb06e99f8e969e2b76;
static PyCodeObject *codeobj_713cab84aff1c754e3062c3169ef4209;
static PyCodeObject *codeobj_c1d3d7e0cb19e2d22f67d229f398e65f;
static PyCodeObject *codeobj_1ac471aeb3398883ade56d46d3bdeb44;
static PyCodeObject *codeobj_0259a49d9dc1def6fc738b9fed343645;
static PyCodeObject *codeobj_301abfeda8d0b6cd2206b5e57a81b467;
static PyCodeObject *codeobj_8a10d3a4b3ce5d07432c2f893bb983ea;
static PyCodeObject *codeobj_1772a6013264994a984e605cd7a40693;
static PyCodeObject *codeobj_0e95773403f38cc930f5b88f7ea092a0;
static PyCodeObject *codeobj_e73694d63eb3a283fa48580107273fb0;
static PyCodeObject *codeobj_1e309d622f57f1df6afb5655a5cbc12f;
static PyCodeObject *codeobj_04292aa6779241fb95227d0370adeed4;
static PyCodeObject *codeobj_71fdf953dd46d53e76e9fdeae2b36d1e;
static PyCodeObject *codeobj_61d8a1f2a778a009244666e966ebfedc;
static PyCodeObject *codeobj_b4af7bab50c450318505ff73850146b0;
static PyCodeObject *codeobj_8c372eaf0ec75aac95b57337ae37f3da;
static PyCodeObject *codeobj_b54bdbd0210e46dca8f052dcb4a34ee3;
static PyCodeObject *codeobj_d8c8cfa251a7ea6bd085c75d033cb23e;
static PyCodeObject *codeobj_07e8a0b0547d18c5e7adbf11c5000bd2;
static PyCodeObject *codeobj_95f4633cd0b82a09b30e9e453fe96c0e;
static PyCodeObject *codeobj_c02f074eb4c422487aa6b3df9c1e1e4d;
static PyCodeObject *codeobj_598b2e7282a2c0052171ad54e31c80cc;
static PyCodeObject *codeobj_36dd5b9a4d1d6a7dc1fc5a680c728521;
static PyCodeObject *codeobj_4c8ce226b675a3a62920440c65572b34;
static PyCodeObject *codeobj_5a0f6d45c706c470bc2bce1f1d87be1f;
static PyCodeObject *codeobj_b1465cc56b7c48e5a832bb947da5804f;
static PyCodeObject *codeobj_fd58d0714ce26a74bd1e7f490fd4c5d4;
static PyCodeObject *codeobj_a622427fd2cf1844f047e5dc915ecd01;
static PyCodeObject *codeobj_9c55547d55b45e1f2119700eb745837a;
static PyCodeObject *codeobj_d4151e0f9a9e8aa47862a42aa12c8f43;
static PyCodeObject *codeobj_d2db5d6448098f1cdeaafc369e0dd5e1;
static PyCodeObject *codeobj_8c37e52f9e85331b386989d0fa841a7d;
static PyCodeObject *codeobj_856ed1c292c994af7bfce0923beed35a;
static PyCodeObject *codeobj_8b83c9708fea4b878e013c45136fd234;
static PyCodeObject *codeobj_112f2bcd9e9fd44144e9a47985cb3c6d;
static PyCodeObject *codeobj_647ba6ed33a4f2ae30ef81b1cc6e4aa6;
static PyCodeObject *codeobj_0bd74d7e47065b77cbb33b10a13c07c3;
static PyCodeObject *codeobj_0dec7b6420a8d454a6e5ea62e48a57d6;
static PyCodeObject *codeobj_de4c7e237ff7a4f38726d637549766fd;
static PyCodeObject *codeobj_cf6f76fdcb2c9248257e81564c818063;
static PyCodeObject *codeobj_3e38fc9f9c9ed1ca78f0a360ad365d63;
static PyCodeObject *codeobj_c707a22aafaa65d7b3d974108e264db4;
static PyCodeObject *codeobj_ebc8c731c4308b3df5f2999eec8135b7;
static PyCodeObject *codeobj_96e0f2ade3ce600a5c007e498e0f3fcd;
static PyCodeObject *codeobj_417f224a16eb9c304a2c9c356d7916aa;
static PyCodeObject *codeobj_5143552858fa1f886627571bace5fd5b;
static PyCodeObject *codeobj_3fc7b9425fa546666c4ea6616c19376d;
static PyCodeObject *codeobj_6f4b7a8a0a555afc1990275873d5d9ae;
static PyCodeObject *codeobj_da38dadd4eb8df9253df88a35a690ea3;
static PyCodeObject *codeobj_f108fefac443a30560644004e534a6dd;
static PyCodeObject *codeobj_84b1e7e21b5757c80ed4f13ea2afff02;
static PyCodeObject *codeobj_67f4c23d4eea6c453c888d6f47275f62;
static PyCodeObject *codeobj_b149ec0eb89f519088e871e4ad91a2cc;
static PyCodeObject *codeobj_0428bad59ec7b5a66149d8e2c88e0cb2;
static PyCodeObject *codeobj_206aa892821ceb22b8152788bccc5cec;
static PyCodeObject *codeobj_3cc7e9e47e498ec30d4ee192b216714d;
static PyCodeObject *codeobj_0dfc2596049ebde55e199985efd3a197;
static PyCodeObject *codeobj_7b59db8d8529b0892574d3e63b0668e4;
static PyCodeObject *codeobj_5d7ca7a86f1a69e3c52554fdf475aba9;
static PyCodeObject *codeobj_9e5962b9332e672b73dffe75490da895;
static PyCodeObject *codeobj_e2e9d6475353a0461a1bce66bbc0f03f;
static PyCodeObject *codeobj_43c017e77c6895e242ea62099ae753ac;
static PyCodeObject *codeobj_8871586b9593b7dcfe1a8959b4852b60;
static PyCodeObject *codeobj_3cf211d19041a0548596ace3209e1f70;
static PyCodeObject *codeobj_5a01e627c9af2bcd87343071c673f76b;
static PyCodeObject *codeobj_f8c39137ff00684bc5503c4fb8f68575;
static PyCodeObject *codeobj_dbe86b73598b46271e67f0b9f613c00a;
static PyCodeObject *codeobj_06feef7fc51c36afe8e827ad79ecfbd2;
static PyCodeObject *codeobj_68a36fb583f00099fdddf6bbbc375aee;
static PyCodeObject *codeobj_5cb75a6ba9401b5ee9f8f9fd264c5f1e;
static PyCodeObject *codeobj_a433b20a090f9b3cd7a05e3cc8726b20;
static PyCodeObject *codeobj_a1652d3a4f682aed85a3fb220e328368;
static PyCodeObject *codeobj_c110c2c8fcfc71619c84f105eb89bce4;
static PyCodeObject *codeobj_72a795899dc57920294fb3185d7828f7;
static PyCodeObject *codeobj_0c71584586f74ec422d71fb95ed763aa;
static PyCodeObject *codeobj_eabc0b3b7063d9f47931e06c3b6106e5;
static PyCodeObject *codeobj_ae1f066821a09f20b88eb8608a297549;
static PyCodeObject *codeobj_3fea67ca1b07373944ae6c41f77a4858;
static PyCodeObject *codeobj_8e211ad8a1c8e21a1a72dcaf0e373537;
static PyCodeObject *codeobj_10bd3e802582e0d9c677ad46e3411b69;
static PyCodeObject *codeobj_9cbe3542cb01bdd5c50f6b4b4e305557;
static PyCodeObject *codeobj_587512bae47cea562886e765c3184c29;
static PyCodeObject *codeobj_ff3315c115fcc0322838af618aa26d9c;
static PyCodeObject *codeobj_e01ada03e6cb97935670c2ece19dcde1;
static PyCodeObject *codeobj_f6c90cffa233150a81ae6bcf5966b415;
static PyCodeObject *codeobj_7b18b41aa1a7fb07c2565ad2e80412f3;
static PyCodeObject *codeobj_c474aed261102d3b5e4f6b3f98e8fe00;
static PyCodeObject *codeobj_209bfbe606aa2e251590784a110971a9;
static PyCodeObject *codeobj_ac5cf5ddb389d171d9f49512989a34d2;
static PyCodeObject *codeobj_ac9f6b5c97ade7871513f9832183e591;
static PyCodeObject *codeobj_412e6657a113f901d16d6c82c1c25936;
static PyCodeObject *codeobj_dbc23fd6b5a9b4b62f8f2245725b8cc9;
static PyCodeObject *codeobj_6488d3c4867ccfec75048bca1c93e024;
static PyCodeObject *codeobj_bb28aa15be6d6ac10ac98d4bd673db31;
static PyCodeObject *codeobj_298c62d2e62c4e7e7c771a8483b79517;
static PyCodeObject *codeobj_572d929a0f50dfeb4faf9840be0cf071;
static PyCodeObject *codeobj_d05172d050310e43eef8f47311a18aa3;
static PyCodeObject *codeobj_bcef8ad01db68d820609cb6453b5f512;
static PyCodeObject *codeobj_d973aa6ad6702c4cbe398efc4bf93b64;
static PyCodeObject *codeobj_8f0dacae7ab4b4acc4d0b5ce81fc6ce2;

static void createModuleCodeObjects(void)
{
    module_filename_obj = const_str_digest_bb6f5ad807179d7105a669c98779d984;
    codeobj_673f2b0b42693996557bb3ee4e55f969 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 418, const_tuple_8110525d9a52cec647809d72afbc7239_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_57aaabf758aa7c8c4a6e68a7dcea7c0c = MAKE_CODEOBJ( module_filename_obj, const_str_digest_1f7559cec53c5da336c35128000e1652, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_762cff70b659b0b1614f9749662cbdb5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CRL, 2123, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_746bb3fa3035767ed3cd36b6784141e9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PKey, 219, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_053b533781a7f6d764fff943a8c7efe9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509, 1080, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_e115d65213e4a52485ea15b6051b88e9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509Extension, 716, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_282c2f71fc2cfcb78842aae5c1418e1a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509Name, 516, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_1642adfffc73b068bfa3ff06f1921759 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509Req, 874, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_f18fafe32e9e502bfe9ab12ad38f5cd3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_X509StoreFlags, 1553, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_815faf1bae776438a2806f882aa20cdb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__EllipticCurve, 377, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_cf6295d0383197dc8a74dbef60884f33 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__PassphraseHelper, 2677, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_d860a737664a16683e8d212dd9ae54eb = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getattr__, 587, const_tuple_f6b86765c5a5e2cb7660564ebdcec2d7_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_10b38ed4f0743b3bdeee62d537a0c90a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 207, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1e9a0d222889b318a7dbd80de8f45303 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 226, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_50fc6fa6c0ba7d87e3e63c2bfa99b0ec = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 452, const_tuple_str_plain_self_str_plain_lib_str_plain_nid_str_plain_name_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b3eeb60a67b100f9108e6a5c3cf04ffc = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 541, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9ff3a88728c4c3ad3cab48c082dc7fb8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 721, const_tuple_f55bc3086b9449b7c24969f5e02af09b_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_507773a59fe1a3d6025f2d54e3fa4c0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 879, const_tuple_str_plain_self_str_plain_req_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a0582cf67145aa1223c5c2d1c9e689f4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1084, const_tuple_str_plain_self_str_plain_x509_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_87626e6c1de4d18891ada0519a066a50 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1590, const_tuple_str_plain_self_str_plain_store_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5b8fb2eb4576f5266e57e0af3d70a55b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1703, const_tuple_str_plain_self_str_plain_message_str_plain_certificate_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_01b9cb7c90c52be647b05193f717878b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1726, const_tuple_c1e1b7e48a4d24180e53a91b4e9e45ad_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_338fb2696ad7e2b451292dd99118ec51 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1972, const_tuple_str_plain_self_str_plain_revoked_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ee9f0393ec340507f2d7d8df847a43a2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2128, const_tuple_str_plain_self_str_plain_crl_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a2c62897603cb5a7fc5a6b08caea1638 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2404, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9b9fe3cd704764cfc5a24bfccdf88473 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2585, const_tuple_str_plain_self_str_plain_spki_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d964ee3167a18a9a588e49cbd6499968 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 2678, const_tuple_e0284b4dc341731363d45f065b316e64_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_34cc9897f64823e467bbb021110e428b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 390, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d0de697e0ff0841e276f18046e633c8c = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 469, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_78f117206d8a841a588d9bb177b70ecd = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 644, const_tuple_3feaf484c2a2250f0d395be4b333fb30_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d7b026a4f1f66fd2b9e84f2cfbc64af8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___setattr__, 551, const_tuple_788a505d6e43a02df061e74659415d8f_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8f3d95c9a6254aa6ef78af56f493d9f8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 815, const_tuple_str_plain_self_str_plain_bio_str_plain_print_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8baf017b3c354fe764f7b750d89261a3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__bio_to_string, 135, const_tuple_6821d02066babb1885e247bdbf40c8ec_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0b3107fda7e0aa194200a083196e49c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__cleanup, 1749, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4e2b2ba154ff2752acf2cd9a9d89cc43 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__cmp, 627, const_tuple_str_plain_op_str_plain_f_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3c27bf579b7f947bd398a69e11f418fa = MAKE_CODEOBJ( module_filename_obj, const_str_plain__delete_reason, 2017, const_tuple_str_plain_self_str_plain_i_str_plain_obj_str_plain_ext_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_064c50c5cfb37771136fe7d568d247de = MAKE_CODEOBJ( module_filename_obj, const_str_plain__exception_from_context, 1757, const_tuple_fe55f23347ee1ca3dc14a1930b416eaa_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0589830efba91376579341caa89dd6a4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__from_raw_x509_ptr, 1092, const_tuple_str_plain_cls_str_plain_x509_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_729446125c4d798b28cb589d422e8d78 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_asn1_time, 166, const_tuple_d959e8503cbe0fd15122162c0da60661_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_475e786458065e1c4a97a0ef87abac1c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_backend, 88, const_tuple_str_plain_backend_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0d1f0497dba37a9b164ae4b60dcd4d90 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_boundary_time, 1364, const_tuple_str_plain_self_str_plain_which_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f1b4064961f0e278b8e11fc39e19cd03 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_elliptic_curves, 421, const_tuple_str_plain_cls_str_plain_lib_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_87faf2505fcb253335d3ffaa0e318e59 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_name, 1422, const_tuple_str_plain_self_str_plain_which_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e290698928eff63f6a91ddfadc9c203c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__init, 1736, const_tuple_str_plain_self_str_plain_ret_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3f35dc87711e3416ee84ceaf5ce82fc4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__load_elliptic_curves, 401, const_tuple_349fb4cb1ce06b9a51a79a6cd36ef36b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_82c4e32bfec555b110886c6016f6efba = MAKE_CODEOBJ( module_filename_obj, const_str_plain__new_mem_buf, 109, const_tuple_str_plain_buffer_str_plain_bio_str_plain_data_str_plain_free_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_78e8acd21cb941da83b042ef8579466b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__nid, 782, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3ee8a1e08a2e2b1ed44dccfa5075f32a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__read_passphrase, 2725, const_tuple_5209455ecbb28249752027c3a839ae1c_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b2f2763c19dc9c314be26f15048c5fd6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_asn1_time, 144, const_tuple_str_plain_boundary_str_plain_when_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3127dbe27680f0c65ac42a57d59c9b15 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_boundary_time, 1380, const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_50e52f8de0f444400c5e7caf8a75aef0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_boundary_time, 2229, const_tuple_str_plain_self_str_plain_which_str_plain_when_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a6726744ebe17f9af48cee0d79422468 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__set_name, 1433, const_tuple_d23f6dfb17b5708d3504cb59648ebed0_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c99ce10f3d0860a31e6597cc2063e968 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__subjectAltNameString, 794, const_tuple_48783f9f765e1ca05b39b42cba82d1fc_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_751e01039a709a9872d0145d6873cd38 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__to_EC_KEY, 472, const_tuple_str_plain_self_str_plain_key_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6f027376d854b905b5ee53119d46201b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__untested_error, 100, const_tuple_str_plain_where_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a07fd4d8b0764d77370791e3c0281e5f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add, 210, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dbc361cccf29968e2e8df96cd0cf2935 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_cert, 1594, const_tuple_be611311fb5723111b9692ddf834f10b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bbd2a92a2023b917b723ee2bdc574a0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_crl, 1624, const_tuple_str_plain_self_str_plain_crl_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0d0a6cfa23df0134bf276c6438f2ab9f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_extensions, 987, const_tuple_7ffc84c231c6d64baeef42ad62a1270d_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eaea0b733ecd041102dac535c4e48296 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_extensions, 1506, const_tuple_80a9571108770bd34772239ad97225a5_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c544d0701ee1c350826d019a78afa8e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add_revoked, 2186, const_tuple_aacd84e9abfa73a83f6f088507b53506_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f29a38d7c45651595cf6aedace7de9aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_all_reasons, 2089, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_36498b0149329ae65dad35a28b8821d9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_b64_encode, 2633, const_tuple_str_plain_self_str_plain_encoded_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_457291e3f25809c88b1764bd146b0304 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_bits, 361, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_174bb49227fddc62e7f6e6dd1564c881 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_callback, 2688, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2c29d90d26933595e91a312e32e549af = MAKE_CODEOBJ( module_filename_obj, const_str_plain_callback_args, 2701, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_021a09f6ae6938555af0896436365d60 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_check, 327, const_tuple_str_plain_self_str_plain_rsa_str_plain_result_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5379defb662177ec26632ddbc4192577 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_clear, 213, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_459e5c608fc9cc34bd5565608d5b7717 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_der, 668, const_tuple_7fda6bda0dce687e350e407f685c57f6_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_83351a66f26ebd1513f374fe4435cbc6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_digest, 1230, const_tuple_57dca116533b0d6d636b268e7001e41b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_14e959ce713a9ebb06e99f8e969e2b76 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_certificate, 1842, const_tuple_4cf00dd32a506e6f9e6721c83bedbfad_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_713cab84aff1c754e3062c3169ef4209 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_certificate_request, 2817, const_tuple_71acb4312fb0ef6e4480ea2334a6a994_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c1d3d7e0cb19e2d22f67d229f398e65f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_crl, 2943, const_tuple_str_plain_type_str_plain_crl_str_plain_bio_str_plain_ret_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1ac471aeb3398883ade56d46d3bdeb44 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_privatekey, 1894, const_tuple_5f27e2d018bfbbfa2690b5943a091bcc_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0259a49d9dc1def6fc738b9fed343645 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_dump_publickey, 1869, const_tuple_86464d9c162f01af99141e0a5b804d71_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_301abfeda8d0b6cd2206b5e57a81b467 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_export, 2287, const_tuple_13745beac221529fe5d89135e9b648d3_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8a10d3a4b3ce5d07432c2f893bb983ea = MAKE_CODEOBJ( module_filename_obj, const_str_plain_export, 2512, const_tuple_f62306bb1360dfa87574f464cff0b6db_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1772a6013264994a984e605cd7a40693 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_f, 628, const_tuple_str_plain_self_str_plain_other_str_plain_result_str_plain_op_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_0e95773403f38cc930f5b88f7ea092a0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_free, 126, const_tuple_str_plain_bio_str_plain_ref_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e73694d63eb3a283fa48580107273fb0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography, 899, const_tuple_str_plain_cls_str_plain_crypto_req_str_plain_req_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1e309d622f57f1df6afb5655a5cbc12f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography, 1112, const_tuple_str_plain_cls_str_plain_crypto_cert_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_04292aa6779241fb95227d0370adeed4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography, 2146, const_tuple_str_plain_cls_str_plain_crypto_crl_str_plain_crl_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_71fdf953dd46d53e76e9fdeae2b36d1e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_cryptography_key, 248, const_tuple_str_plain_cls_str_plain_crypto_key_str_plain_pkey_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_61d8a1f2a778a009244666e966ebfedc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_from_nid, 435, const_tuple_str_plain_cls_str_plain_lib_str_plain_nid_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b4af7bab50c450318505ff73850146b0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_generate_key, 271, const_tuple_270cfc7fce9aafdf0c3eb9f2164206f4_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8c372eaf0ec75aac95b57337ae37f3da = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_ca_certificates, 2454, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b54bdbd0210e46dca8f052dcb4a34ee3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_certificate, 2410, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d8c8cfa251a7ea6bd085c75d033cb23e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_components, 683, const_tuple_1598e2e44a7cbbc56ff6b01a61982114_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_07e8a0b0547d18c5e7adbf11c5000bd2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_critical, 828, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_95f4633cd0b82a09b30e9e453fe96c0e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_data, 851, const_tuple_aa595f479ccfd6af3a4dde57a871f8ed_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c02f074eb4c422487aa6b3df9c1e1e4d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_elliptic_curve, 498, const_tuple_str_plain_name_str_plain_curve_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_598b2e7282a2c0052171ad54e31c80cc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_elliptic_curves, 483, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_36dd5b9a4d1d6a7dc1fc5a680c728521 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extension, 1522, const_tuple_28746fdd1a6563b63939e82f1814a7ff_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4c8ce226b675a3a62920440c65572b34 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extension_count, 1495, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5a0f6d45c706c470bc2bce1f1d87be1f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_extensions, 1010, const_tuple_c5e29833751f21ea567c72bd68a6420e_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b1465cc56b7c48e5a832bb947da5804f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_friendlyname, 2503, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fd58d0714ce26a74bd1e7f490fd4c5d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_issuer, 1439, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a622427fd2cf1844f047e5dc915ecd01 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_issuer, 2203, const_tuple_str_plain_self_str_plain__issuer_str_plain_issuer_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9c55547d55b45e1f2119700eb745837a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_notAfter, 1396, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d4151e0f9a9e8aa47862a42aa12c8f43 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_notBefore, 1367, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d2db5d6448098f1cdeaafc369e0dd5e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_privatekey, 2432, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8c37e52f9e85331b386989d0fa841a7d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_pubkey, 930, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_856ed1c292c994af7bfce0923beed35a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_pubkey, 1155, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8b83c9708fea4b878e013c45136fd234 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_pubkey, 2645, const_tuple_str_plain_self_str_plain_pkey_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_112f2bcd9e9fd44144e9a47985cb3c6d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_reason, 2062, const_tuple_5ef57f6035eba9ead62528f8493f508e_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_647ba6ed33a4f2ae30ef81b1cc6e4aa6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_rev_date, 2112, const_tuple_str_plain_self_str_plain_dt_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0bd74d7e47065b77cbb33b10a13c07c3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_revoked, 2165, const_tuple_f442a9e9eba2c7bd96e443ed0b5afd06_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0dec7b6420a8d454a6e5ea62e48a57d6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_serial, 1999, const_tuple_2abd4adfc3fb4c61eb6347c1066336bb_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_de4c7e237ff7a4f38726d637549766fd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_serial_number, 1305, const_tuple_64996e5d3f2714cc368d8bf48665c67a_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cf6f76fdcb2c9248257e81564c818063 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_short_name, 836, const_tuple_str_plain_self_str_plain_obj_str_plain_nid_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3e38fc9f9c9ed1ca78f0a360ad365d63 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_signature_algorithm, 1213, const_tuple_str_plain_self_str_plain_algor_str_plain_nid_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c707a22aafaa65d7b3d974108e264db4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_subject, 965, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ebc8c731c4308b3df5f2999eec8135b7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_subject, 1467, const_tuple_str_plain_self_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_96e0f2ade3ce600a5c007e498e0f3fcd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_type_name, 2381, const_tuple_str_plain_self_str_plain_string_type_str_plain_nid_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_417f224a16eb9c304a2c9c356d7916aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_version, 955, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5143552858fa1f886627571bace5fd5b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_version, 1146, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3fc7b9425fa546666c4ea6616c19376d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_gmtime_adj_notAfter, 1325, const_tuple_str_plain_self_str_plain_amount_str_plain_notAfter_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6f4b7a8a0a555afc1990275873d5d9ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_gmtime_adj_notBefore, 1339, const_tuple_str_plain_self_str_plain_amount_str_plain_notBefore_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_da38dadd4eb8df9253df88a35a690ea3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_has_expired, 1352, const_tuple_str_plain_self_str_plain_not_after_str_plain_time_string_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f108fefac443a30560644004e534a6dd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hash, 656, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_84b1e7e21b5757c80ed4f13ea2afff02 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_certificate, 1812, const_tuple_str_plain_type_str_plain_buffer_str_plain_bio_str_plain_x509_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_67f4c23d4eea6c453c888d6f47275f62 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_certificate_request, 2845, const_tuple_21bd89dfe3a1dd3e39e03972a01f5a89_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b149ec0eb89f519088e871e4ad91a2cc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_crl, 2971, const_tuple_53b63b794c8b8f328f3f365985abd328_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0428bad59ec7b5a66149d8e2c88e0cb2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_pkcs12, 3030, const_tuple_fc5a926ee67d9170a63704460f298cf2_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_206aa892821ceb22b8152788bccc5cec = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_pkcs7_data, 3001, const_tuple_516125a1d64dba4bb10b7a1d5054cba1_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3cc7e9e47e498ec30d4ee192b216714d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_privatekey, 2781, const_tuple_76984bb103279dcce095840ed073cae5_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0dfc2596049ebde55e199985efd3a197 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_load_publickey, 2748, const_tuple_34a51bbef25f1a50174cde73cf717c0e_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7b59db8d8529b0892574d3e63b0668e4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_raise_if_problem, 2714, const_tuple_str_plain_self_str_plain_exceptionType_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5d7ca7a86f1a69e3c52554fdf475aba9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_ca_certificates, 2465, const_tuple_str_plain_self_str_plain_cacerts_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9e5962b9332e672b73dffe75490da895 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_certificate, 2419, const_tuple_str_plain_self_str_plain_cert_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e2e9d6475353a0461a1bce66bbc0f03f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_flags, 1640, const_tuple_str_plain_self_str_plain_flags_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_43c017e77c6895e242ea62099ae753ac = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_friendlyname, 2486, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8871586b9593b7dcfe1a8959b4852b60 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_issuer, 1455, const_tuple_str_plain_self_str_plain_issuer_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3cf211d19041a0548596ace3209e1f70 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_lastUpdate, 2232, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5a01e627c9af2bcd87343071c673f76b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_nextUpdate, 2247, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f8c39137ff00684bc5503c4fb8f68575 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_notAfter, 1409, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dbe86b73598b46271e67f0b9f613c00a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_notBefore, 1383, const_tuple_str_plain_self_str_plain_when_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_06feef7fc51c36afe8e827ad79ecfbd2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_privatekey, 2441, const_tuple_str_plain_self_str_plain_pkey_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_68a36fb583f00099fdddf6bbbc375aee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_pubkey, 918, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5cb75a6ba9401b5ee9f8f9fd264c5f1e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_pubkey, 1170, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a433b20a090f9b3cd7a05e3cc8726b20 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_pubkey, 2659, const_tuple_str_plain_self_str_plain_pkey_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a1652d3a4f682aed85a3fb220e328368 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_reason, 2026, const_tuple_79603f0465bd62773d6ec6c98e743896_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c110c2c8fcfc71619c84f105eb89bce4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_rev_date, 2101, const_tuple_str_plain_self_str_plain_when_str_plain_dt_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_72a795899dc57920294fb3185d7828f7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_serial, 1976, const_tuple_a2a87d1d5695ca90897866b205aec3ce_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0c71584586f74ec422d71fb95ed763aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_serial_number, 1266, const_tuple_13d990c39f45e826db58a38b07f9cd95_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eabc0b3b7063d9f47931e06c3b6106e5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_store, 1778, const_tuple_str_plain_self_str_plain_store_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ae1f066821a09f20b88eb8608a297549 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_subject, 1483, const_tuple_str_plain_self_str_plain_subject_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3fea67ca1b07373944ae6c41f77a4858 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_time, 1664, const_tuple_str_plain_self_str_plain_vfy_time_str_plain_param_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8e211ad8a1c8e21a1a72dcaf0e373537 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_version, 944, const_tuple_str_plain_self_str_plain_version_str_plain_set_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_10bd3e802582e0d9c677ad46e3411b69 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_version, 1131, const_tuple_str_plain_self_str_plain_version_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9cbe3542cb01bdd5c50f6b4b4e305557 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_set_version, 2218, const_tuple_str_plain_self_str_plain_version_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_587512bae47cea562886e765c3184c29 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 1027, const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ff3315c115fcc0322838af618aa26d9c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 1185, const_tuple_10f3f1cb3df7aac52b98dbb720bf50d1_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e01ada03e6cb97935670c2ece19dcde1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 2262, const_tuple_4415e41d2d925845f2ba634f8c71f0dc_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f6c90cffa233150a81ae6bcf5966b415 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 2589, const_tuple_7df0279ef5fffac2c0a66ea7c472ab4b_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7b18b41aa1a7fb07c2565ad2e80412f3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sign, 2873, const_tuple_51ff74c45307e7d0bccc36be86c10b54_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c474aed261102d3b5e4f6b3f98e8fe00 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_subject_name_hash, 1257, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_209bfbe606aa2e251590784a110971a9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography, 885, const_tuple_7eb0e743d38af9e33bf64e78c0ab103c_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ac5cf5ddb389d171d9f49512989a34d2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography, 1100, const_tuple_str_plain_self_str_plain__Certificate_str_plain_backend_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ac9f6b5c97ade7871513f9832183e591 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography, 2132, const_tuple_0c127564cb8e0f10a9444ae3c25de3f1_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_412e6657a113f901d16d6c82c1c25936 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_to_cryptography_key, 231, const_tuple_str_plain_self_str_plain_backend_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dbc23fd6b5a9b4b62f8f2245725b8cc9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type, 353, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6488d3c4867ccfec75048bca1c93e024 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_data, 2373, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bb28aa15be6d6ac10ac98d4bd673db31 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_enveloped, 2357, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_298c62d2e62c4e7e7c771a8483b79517 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_signed, 2349, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_572d929a0f50dfeb4faf9840be0cf071 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_type_is_signedAndEnveloped, 2365, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d05172d050310e43eef8f47311a18aa3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify, 1051, const_tuple_str_plain_self_str_plain_pkey_str_plain_result_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bcef8ad01db68d820609cb6453b5f512 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify, 2616, const_tuple_str_plain_self_str_plain_key_str_plain_answer_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d973aa6ad6702c4cbe398efc4bf93b64 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify, 2907, const_tuple_5903b88f37d1077b2f3871dbc2944417_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_verify_certificate, 1789, const_tuple_str_plain_self_str_plain_ret_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_maker( void );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_100_dump_privatekey( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_101___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_102_set_serial(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_103_get_serial(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_104__delete_reason(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_reason(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_reason(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_107_all_reasons(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_rev_date(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_rev_date(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_110___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_111_to_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_112_from_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_113_get_revoked(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_114_add_revoked(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_115_get_issuer(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_116_set_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_117__set_boundary_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_118_set_lastUpdate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_nextUpdate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_120_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_121_export( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_122_type_is_signed(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_123_type_is_enveloped(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_126_get_type_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_127___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_128_get_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_129_set_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_130_get_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_131_set_privatekey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_132_get_ca_certificates(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_133_set_ca_certificates(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_friendlyname(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_friendlyname(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_136_export( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_137___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_138_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_139_verify(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_140_b64_encode(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_141_get_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_142_set_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_143___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_144_callback(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_145_callback_args(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_146_raise_if_problem( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_147__read_passphrase(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_148_load_publickey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_149_load_privatekey( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_150_dump_certificate_request(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_certificate_request(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_152_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_153_verify(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_154_dump_crl(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_155_load_crl(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_156_load_pkcs7_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_157_load_pkcs12( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( PyObject *defaults );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_90___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_92__init(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__cleanup(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_94__exception_from_context(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_95_set_store(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_96_verify_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_97_load_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_98_dump_certificate(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_99_dump_publickey(  );


static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear(  );


// The module function definitions.
static PyObject *impl_OpenSSL$crypto$$$function_1__get_backend( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_475e786458065e1c4a97a0ef87abac1c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_475e786458065e1c4a97a0ef87abac1c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_475e786458065e1c4a97a0ef87abac1c, codeobj_475e786458065e1c4a97a0ef87abac1c, module_OpenSSL$crypto, sizeof(void *) );
    frame_475e786458065e1c4a97a0ef87abac1c = cache_frame_475e786458065e1c4a97a0ef87abac1c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_475e786458065e1c4a97a0ef87abac1c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_475e786458065e1c4a97a0ef87abac1c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_9abb9f40508debfa3aae6d9135753f7e;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_backend_tuple;
        frame_475e786458065e1c4a97a0ef87abac1c->m_frame.f_lineno = 96;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 96;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_backend );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 96;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        assert( var_backend == NULL );
        var_backend = tmp_assign_source_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_475e786458065e1c4a97a0ef87abac1c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_475e786458065e1c4a97a0ef87abac1c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_475e786458065e1c4a97a0ef87abac1c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_475e786458065e1c4a97a0ef87abac1c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_475e786458065e1c4a97a0ef87abac1c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_475e786458065e1c4a97a0ef87abac1c,
        type_description_1,
        var_backend
    );


    // Release cached frame.
    if ( frame_475e786458065e1c4a97a0ef87abac1c == cache_frame_475e786458065e1c4a97a0ef87abac1c )
    {
        Py_DECREF( frame_475e786458065e1c4a97a0ef87abac1c );
    }
    cache_frame_475e786458065e1c4a97a0ef87abac1c = NULL;

    assertFrameObject( frame_475e786458065e1c4a97a0ef87abac1c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_backend );
    tmp_return_value = var_backend;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_1__get_backend );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_1__get_backend );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_2__untested_error( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_where = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6f027376d854b905b5ee53119d46201b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6f027376d854b905b5ee53119d46201b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6f027376d854b905b5ee53119d46201b, codeobj_6f027376d854b905b5ee53119d46201b, module_OpenSSL$crypto, sizeof(void *) );
    frame_6f027376d854b905b5ee53119d46201b = cache_frame_6f027376d854b905b5ee53119d46201b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f027376d854b905b5ee53119d46201b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f027376d854b905b5ee53119d46201b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        tmp_left_name_1 = const_str_digest_819566a56c114d5ab553db6b3a965184;
        CHECK_OBJECT( par_where );
        tmp_tuple_element_1 = par_where;
        tmp_right_name_1 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 106;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_6f027376d854b905b5ee53119d46201b->m_frame.f_lineno = 106;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 106;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f027376d854b905b5ee53119d46201b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f027376d854b905b5ee53119d46201b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f027376d854b905b5ee53119d46201b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f027376d854b905b5ee53119d46201b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f027376d854b905b5ee53119d46201b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f027376d854b905b5ee53119d46201b,
        type_description_1,
        par_where
    );


    // Release cached frame.
    if ( frame_6f027376d854b905b5ee53119d46201b == cache_frame_6f027376d854b905b5ee53119d46201b )
    {
        Py_DECREF( frame_6f027376d854b905b5ee53119d46201b );
    }
    cache_frame_6f027376d854b905b5ee53119d46201b = NULL;

    assertFrameObject( frame_6f027376d854b905b5ee53119d46201b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_2__untested_error );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_where );
    Py_DECREF( par_where );
    par_where = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_2__untested_error );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_OpenSSL$crypto$$$function_3__new_mem_buf( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_buffer = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_data = NULL;
    PyObject *var_free = NULL;
    struct Nuitka_FrameObject *frame_82c4e32bfec555b110886c6016f6efba;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_82c4e32bfec555b110886c6016f6efba = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_82c4e32bfec555b110886c6016f6efba, codeobj_82c4e32bfec555b110886c6016f6efba, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_82c4e32bfec555b110886c6016f6efba = cache_frame_82c4e32bfec555b110886c6016f6efba;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_82c4e32bfec555b110886c6016f6efba );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_82c4e32bfec555b110886c6016f6efba ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_buffer );
        tmp_compexpr_left_1 = par_buffer;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_1;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_BIO_new );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_2 == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            frame_82c4e32bfec555b110886c6016f6efba->m_frame.f_lineno = 119;
            tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BIO_s_mem );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_82c4e32bfec555b110886c6016f6efba->m_frame.f_lineno = 119;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_bio == NULL );
            var_bio = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 120;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_3;
            tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_free );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 120;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_free == NULL );
            var_free = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 122;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_4;
            tmp_args_element_name_2 = const_str_digest_c561652c58984ec0e9541542aa405594;
            CHECK_OBJECT( par_buffer );
            tmp_args_element_name_3 = par_buffer;
            frame_82c4e32bfec555b110886c6016f6efba->m_frame.f_lineno = 122;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_new, call_args );
            }

            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 122;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_data == NULL );
            var_data = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_len_arg_1;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_5;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_BIO_new_mem_buf );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_data );
            tmp_args_element_name_4 = var_data;
            CHECK_OBJECT( par_buffer );
            tmp_len_arg_1 = par_buffer;
            tmp_args_element_name_5 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_82c4e32bfec555b110886c6016f6efba->m_frame.f_lineno = 123;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 123;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_bio == NULL );
            var_bio = tmp_assign_source_4;
        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_defaults_1;
            PyObject *tmp_tuple_element_1;
            CHECK_OBJECT( var_data );
            tmp_tuple_element_1 = var_data;
            tmp_defaults_1 = PyTuple_New( 1 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_defaults_1, 0, tmp_tuple_element_1 );
            tmp_assign_source_5 = MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( tmp_defaults_1 );



            assert( var_free == NULL );
            var_free = tmp_assign_source_5;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_6;
        CHECK_OBJECT( var_bio );
        tmp_compexpr_left_2 = var_bio;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_6 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_82c4e32bfec555b110886c6016f6efba->m_frame.f_lineno = 129;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 131;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_8;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_7 = var_bio;
        CHECK_OBJECT( var_free );
        tmp_args_element_name_8 = var_free;
        frame_82c4e32bfec555b110886c6016f6efba->m_frame.f_lineno = 131;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_gc, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 131;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_bio;
            assert( old != NULL );
            var_bio = tmp_assign_source_6;
            Py_DECREF( old );
        }

    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_82c4e32bfec555b110886c6016f6efba );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_82c4e32bfec555b110886c6016f6efba );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_82c4e32bfec555b110886c6016f6efba, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_82c4e32bfec555b110886c6016f6efba->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_82c4e32bfec555b110886c6016f6efba, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_82c4e32bfec555b110886c6016f6efba,
        type_description_1,
        par_buffer,
        var_bio,
        var_data,
        var_free
    );


    // Release cached frame.
    if ( frame_82c4e32bfec555b110886c6016f6efba == cache_frame_82c4e32bfec555b110886c6016f6efba )
    {
        Py_DECREF( frame_82c4e32bfec555b110886c6016f6efba );
    }
    cache_frame_82c4e32bfec555b110886c6016f6efba = NULL;

    assertFrameObject( frame_82c4e32bfec555b110886c6016f6efba );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_bio );
    tmp_return_value = var_bio;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    CHECK_OBJECT( (PyObject *)var_free );
    Py_DECREF( var_free );
    var_free = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    Py_XDECREF( var_free );
    var_free = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_bio = python_pars[ 0 ];
    PyObject *par_ref = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0e95773403f38cc930f5b88f7ea092a0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0e95773403f38cc930f5b88f7ea092a0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0e95773403f38cc930f5b88f7ea092a0, codeobj_0e95773403f38cc930f5b88f7ea092a0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_0e95773403f38cc930f5b88f7ea092a0 = cache_frame_0e95773403f38cc930f5b88f7ea092a0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0e95773403f38cc930f5b88f7ea092a0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0e95773403f38cc930f5b88f7ea092a0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 127;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_bio );
        tmp_args_element_name_1 = par_bio;
        frame_0e95773403f38cc930f5b88f7ea092a0->m_frame.f_lineno = 127;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_BIO_free, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 127;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0e95773403f38cc930f5b88f7ea092a0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0e95773403f38cc930f5b88f7ea092a0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0e95773403f38cc930f5b88f7ea092a0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0e95773403f38cc930f5b88f7ea092a0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0e95773403f38cc930f5b88f7ea092a0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0e95773403f38cc930f5b88f7ea092a0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0e95773403f38cc930f5b88f7ea092a0,
        type_description_1,
        par_bio,
        par_ref
    );


    // Release cached frame.
    if ( frame_0e95773403f38cc930f5b88f7ea092a0 == cache_frame_0e95773403f38cc930f5b88f7ea092a0 )
    {
        Py_DECREF( frame_0e95773403f38cc930f5b88f7ea092a0 );
    }
    cache_frame_0e95773403f38cc930f5b88f7ea092a0 = NULL;

    assertFrameObject( frame_0e95773403f38cc930f5b88f7ea092a0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_ref );
    Py_DECREF( par_ref );
    par_ref = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_ref );
    Py_DECREF( par_ref );
    par_ref = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_4__bio_to_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_bio = python_pars[ 0 ];
    PyObject *var_buffer_length = NULL;
    PyObject *var_result_buffer = NULL;
    struct Nuitka_FrameObject *frame_8baf017b3c354fe764f7b750d89261a3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8baf017b3c354fe764f7b750d89261a3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8baf017b3c354fe764f7b750d89261a3, codeobj_8baf017b3c354fe764f7b750d89261a3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8baf017b3c354fe764f7b750d89261a3 = cache_frame_8baf017b3c354fe764f7b750d89261a3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8baf017b3c354fe764f7b750d89261a3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8baf017b3c354fe764f7b750d89261a3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 139;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_8baf017b3c354fe764f7b750d89261a3->m_frame.f_lineno = 139;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_70b987f75825a6c2ffe2c8fe53d85a21_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_buffer == NULL );
        var_result_buffer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_bio );
        tmp_args_element_name_1 = par_bio;
        CHECK_OBJECT( var_result_buffer );
        tmp_args_element_name_2 = var_result_buffer;
        frame_8baf017b3c354fe764f7b750d89261a3->m_frame.f_lineno = 140;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_BIO_get_mem_data, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_buffer_length == NULL );
        var_buffer_length = tmp_assign_source_2;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_4;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_buffer );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_subscribed_name_1 = var_result_buffer;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_buffer_length );
        tmp_args_element_name_4 = var_buffer_length;
        frame_8baf017b3c354fe764f7b750d89261a3->m_frame.f_lineno = 141;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8baf017b3c354fe764f7b750d89261a3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8baf017b3c354fe764f7b750d89261a3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8baf017b3c354fe764f7b750d89261a3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8baf017b3c354fe764f7b750d89261a3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8baf017b3c354fe764f7b750d89261a3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8baf017b3c354fe764f7b750d89261a3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8baf017b3c354fe764f7b750d89261a3,
        type_description_1,
        par_bio,
        var_buffer_length,
        var_result_buffer
    );


    // Release cached frame.
    if ( frame_8baf017b3c354fe764f7b750d89261a3 == cache_frame_8baf017b3c354fe764f7b750d89261a3 )
    {
        Py_DECREF( frame_8baf017b3c354fe764f7b750d89261a3 );
    }
    cache_frame_8baf017b3c354fe764f7b750d89261a3 = NULL;

    assertFrameObject( frame_8baf017b3c354fe764f7b750d89261a3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_4__bio_to_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_buffer_length );
    Py_DECREF( var_buffer_length );
    var_buffer_length = NULL;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_buffer_length );
    var_buffer_length = NULL;

    CHECK_OBJECT( (PyObject *)par_bio );
    Py_DECREF( par_bio );
    par_bio = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_4__bio_to_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_5__set_asn1_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_boundary = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_b2f2763c19dc9c314be26f15048c5fd6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b2f2763c19dc9c314be26f15048c5fd6 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b2f2763c19dc9c314be26f15048c5fd6, codeobj_b2f2763c19dc9c314be26f15048c5fd6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b2f2763c19dc9c314be26f15048c5fd6 = cache_frame_b2f2763c19dc9c314be26f15048c5fd6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b2f2763c19dc9c314be26f15048c5fd6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b2f2763c19dc9c314be26f15048c5fd6 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_when );
        tmp_isinstance_inst_1 = par_when;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_0632ce6142bf9815370c626f0fb1235a;
            frame_b2f2763c19dc9c314be26f15048c5fd6->m_frame.f_lineno = 159;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 159;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 161;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_boundary );
        tmp_args_element_name_1 = par_boundary;
        CHECK_OBJECT( par_when );
        tmp_args_element_name_2 = par_when;
        frame_b2f2763c19dc9c314be26f15048c5fd6->m_frame.f_lineno = 161;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_ASN1_TIME_set_string, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 161;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_set_result == NULL );
        var_set_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_set_result );
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 162;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_c623dd0c947983ab2cfcbe4c53400720;
            frame_b2f2763c19dc9c314be26f15048c5fd6->m_frame.f_lineno = 163;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 163;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b2f2763c19dc9c314be26f15048c5fd6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b2f2763c19dc9c314be26f15048c5fd6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b2f2763c19dc9c314be26f15048c5fd6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b2f2763c19dc9c314be26f15048c5fd6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b2f2763c19dc9c314be26f15048c5fd6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2f2763c19dc9c314be26f15048c5fd6,
        type_description_1,
        par_boundary,
        par_when,
        var_set_result
    );


    // Release cached frame.
    if ( frame_b2f2763c19dc9c314be26f15048c5fd6 == cache_frame_b2f2763c19dc9c314be26f15048c5fd6 )
    {
        Py_DECREF( frame_b2f2763c19dc9c314be26f15048c5fd6 );
    }
    cache_frame_b2f2763c19dc9c314be26f15048c5fd6 = NULL;

    assertFrameObject( frame_b2f2763c19dc9c314be26f15048c5fd6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_5__set_asn1_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_boundary );
    Py_DECREF( par_boundary );
    par_boundary = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_boundary );
    Py_DECREF( par_boundary );
    par_boundary = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_5__set_asn1_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_6__get_asn1_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_timestamp = python_pars[ 0 ];
    PyObject *var_generalized_timestamp = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_string_data = NULL;
    PyObject *var_string_timestamp = NULL;
    struct Nuitka_FrameObject *frame_729446125c4d798b28cb589d422e8d78;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_729446125c4d798b28cb589d422e8d78 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_729446125c4d798b28cb589d422e8d78, codeobj_729446125c4d798b28cb589d422e8d78, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_729446125c4d798b28cb589d422e8d78 = cache_frame_729446125c4d798b28cb589d422e8d78;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_729446125c4d798b28cb589d422e8d78 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_729446125c4d798b28cb589d422e8d78 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 176;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
        CHECK_OBJECT( par_timestamp );
        tmp_args_element_name_2 = par_timestamp;
        frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 176;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_cast, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 176;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_string_timestamp == NULL );
        var_string_timestamp = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 177;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_string_timestamp );
        tmp_args_element_name_3 = var_string_timestamp;
        frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 177;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_ASN1_STRING_length, call_args );
        }

        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 177;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 177;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_3 = tmp_mvar_value_3;
            CHECK_OBJECT( var_string_timestamp );
            tmp_args_element_name_4 = var_string_timestamp;
            frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 180;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_compexpr_left_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_ASN1_STRING_type, call_args );
            }

            if ( tmp_compexpr_left_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {
                Py_DECREF( tmp_compexpr_left_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_V_ASN1_GENERALIZEDTIME );
            if ( tmp_compexpr_right_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_compexpr_left_2 );

                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_left_2 );
            Py_DECREF( tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 180;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_source_name_2;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_mvar_value_6;
                PyObject *tmp_args_element_name_6;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_2 = tmp_mvar_value_5;
                tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_string );
                if ( tmp_called_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_6 == NULL )
                {
                    Py_DECREF( tmp_called_name_1 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_4 = tmp_mvar_value_6;
                CHECK_OBJECT( var_string_timestamp );
                tmp_args_element_name_6 = var_string_timestamp;
                frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 182;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6 };
                    tmp_args_element_name_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_ASN1_STRING_data, call_args );
                }

                if ( tmp_args_element_name_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );

                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 182;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5 };
                    tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_args_element_name_5 );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 182;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_5;
                PyObject *tmp_mvar_value_7;
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_7 == NULL ))
                {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_7 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 184;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_5 = tmp_mvar_value_7;
                frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 184;
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_0d925750cb36e0c0e5f47f40c47790e6_tuple, 0 ) );

                if ( tmp_assign_source_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 184;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_generalized_timestamp == NULL );
                var_generalized_timestamp = tmp_assign_source_2;
            }
            {
                PyObject *tmp_called_instance_6;
                PyObject *tmp_mvar_value_8;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_args_element_name_8;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_8 == NULL ))
                {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_8 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 185;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_6 = tmp_mvar_value_8;
                CHECK_OBJECT( par_timestamp );
                tmp_args_element_name_7 = par_timestamp;
                CHECK_OBJECT( var_generalized_timestamp );
                tmp_args_element_name_8 = var_generalized_timestamp;
                frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 185;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_6, const_str_plain_ASN1_TIME_to_generalizedtime, call_args );
                }

                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 185;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_subscribed_name_1;
                PyObject *tmp_subscript_name_1;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_9;
                CHECK_OBJECT( var_generalized_timestamp );
                tmp_subscribed_name_1 = var_generalized_timestamp;
                tmp_subscript_name_1 = const_int_0;
                tmp_compexpr_left_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
                if ( tmp_compexpr_left_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_9 == NULL )
                {
                    Py_DECREF( tmp_compexpr_left_3 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_9;
                tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
                if ( tmp_compexpr_right_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_compexpr_left_3 );

                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
                Py_DECREF( tmp_compexpr_left_3 );
                Py_DECREF( tmp_compexpr_right_3 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 186;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_mvar_value_10;
                    PyObject *tmp_call_result_2;
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__untested_error );

                    if (unlikely( tmp_mvar_value_10 == NULL ))
                    {
                        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__untested_error );
                    }

                    if ( tmp_mvar_value_10 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_untested_error" );
                        exception_tb = NULL;

                        exception_lineno = 196;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_2 = tmp_mvar_value_10;
                    frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 196;
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_str_plain_ASN1_TIME_to_generalizedtime_tuple, 0 ) );

                    if ( tmp_call_result_2 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 196;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    Py_DECREF( tmp_call_result_2 );
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_assign_source_3;
                    PyObject *tmp_called_name_3;
                    PyObject *tmp_source_name_4;
                    PyObject *tmp_mvar_value_11;
                    PyObject *tmp_args_element_name_9;
                    PyObject *tmp_args_element_name_10;
                    PyObject *tmp_subscribed_name_2;
                    PyObject *tmp_subscript_name_2;
                    tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                    if (unlikely( tmp_mvar_value_11 == NULL ))
                    {
                        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                    }

                    if ( tmp_mvar_value_11 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                        exception_tb = NULL;

                        exception_lineno = 198;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_4 = tmp_mvar_value_11;
                    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_cast );
                    if ( tmp_called_name_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 198;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_9 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
                    CHECK_OBJECT( var_generalized_timestamp );
                    tmp_subscribed_name_2 = var_generalized_timestamp;
                    tmp_subscript_name_2 = const_int_0;
                    tmp_args_element_name_10 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
                    if ( tmp_args_element_name_10 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_3 );

                        exception_lineno = 199;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 198;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
                        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                    }

                    Py_DECREF( tmp_called_name_3 );
                    Py_DECREF( tmp_args_element_name_10 );
                    if ( tmp_assign_source_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 198;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    {
                        PyObject *old = var_string_timestamp;
                        assert( old != NULL );
                        var_string_timestamp = tmp_assign_source_3;
                        Py_DECREF( old );
                    }

                }
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_instance_7;
                    PyObject *tmp_mvar_value_12;
                    PyObject *tmp_args_element_name_11;
                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_12 == NULL ))
                    {
                        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_12 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 200;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_7 = tmp_mvar_value_12;
                    CHECK_OBJECT( var_string_timestamp );
                    tmp_args_element_name_11 = var_string_timestamp;
                    frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 200;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_11 };
                        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_ASN1_STRING_data, call_args );
                    }

                    if ( tmp_assign_source_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 200;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_string_data == NULL );
                    var_string_data = tmp_assign_source_4;
                }
                {
                    PyObject *tmp_assign_source_5;
                    PyObject *tmp_called_instance_8;
                    PyObject *tmp_mvar_value_13;
                    PyObject *tmp_args_element_name_12;
                    tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                    if (unlikely( tmp_mvar_value_13 == NULL ))
                    {
                        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                    }

                    if ( tmp_mvar_value_13 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                        exception_tb = NULL;

                        exception_lineno = 201;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_8 = tmp_mvar_value_13;
                    CHECK_OBJECT( var_string_data );
                    tmp_args_element_name_12 = var_string_data;
                    frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 201;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_12 };
                        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_string, call_args );
                    }

                    if ( tmp_assign_source_5 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 201;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_string_result == NULL );
                    var_string_result = tmp_assign_source_5;
                }
                {
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_14;
                    PyObject *tmp_call_result_3;
                    PyObject *tmp_args_element_name_13;
                    PyObject *tmp_subscribed_name_3;
                    PyObject *tmp_subscript_name_3;
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_14 == NULL ))
                    {
                        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_14 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_14;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_ASN1_GENERALIZEDTIME_free );
                    if ( tmp_called_name_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( var_generalized_timestamp );
                    tmp_subscribed_name_3 = var_generalized_timestamp;
                    tmp_subscript_name_3 = const_int_0;
                    tmp_args_element_name_13 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
                    if ( tmp_args_element_name_13 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_4 );

                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_729446125c4d798b28cb589d422e8d78->m_frame.f_lineno = 202;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_13 };
                        tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
                    }

                    Py_DECREF( tmp_called_name_4 );
                    Py_DECREF( tmp_args_element_name_13 );
                    if ( tmp_call_result_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 202;
                        type_description_1 = "ooooo";
                        goto frame_exception_exit_1;
                    }
                    Py_DECREF( tmp_call_result_3 );
                }
                CHECK_OBJECT( var_string_result );
                tmp_return_value = var_string_result;
                Py_INCREF( tmp_return_value );
                goto frame_return_exit_1;
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_729446125c4d798b28cb589d422e8d78 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_729446125c4d798b28cb589d422e8d78 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_729446125c4d798b28cb589d422e8d78 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_729446125c4d798b28cb589d422e8d78, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_729446125c4d798b28cb589d422e8d78->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_729446125c4d798b28cb589d422e8d78, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_729446125c4d798b28cb589d422e8d78,
        type_description_1,
        par_timestamp,
        var_generalized_timestamp,
        var_string_result,
        var_string_data,
        var_string_timestamp
    );


    // Release cached frame.
    if ( frame_729446125c4d798b28cb589d422e8d78 == cache_frame_729446125c4d798b28cb589d422e8d78 )
    {
        Py_DECREF( frame_729446125c4d798b28cb589d422e8d78 );
    }
    cache_frame_729446125c4d798b28cb589d422e8d78 = NULL;

    assertFrameObject( frame_729446125c4d798b28cb589d422e8d78 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_6__get_asn1_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_timestamp );
    Py_DECREF( par_timestamp );
    par_timestamp = NULL;

    Py_XDECREF( var_generalized_timestamp );
    var_generalized_timestamp = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_string_data );
    var_string_data = NULL;

    CHECK_OBJECT( (PyObject *)var_string_timestamp );
    Py_DECREF( var_string_timestamp );
    var_string_timestamp = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_timestamp );
    Py_DECREF( par_timestamp );
    par_timestamp = NULL;

    Py_XDECREF( var_generalized_timestamp );
    var_generalized_timestamp = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_string_data );
    var_string_data = NULL;

    Py_XDECREF( var_string_timestamp );
    var_string_timestamp = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_6__get_asn1_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_7___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_10b38ed4f0743b3bdeee62d537a0c90a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_10b38ed4f0743b3bdeee62d537a0c90a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_10b38ed4f0743b3bdeee62d537a0c90a, codeobj_10b38ed4f0743b3bdeee62d537a0c90a, module_OpenSSL$crypto, sizeof(void *) );
    frame_10b38ed4f0743b3bdeee62d537a0c90a = cache_frame_10b38ed4f0743b3bdeee62d537a0c90a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_10b38ed4f0743b3bdeee62d537a0c90a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_10b38ed4f0743b3bdeee62d537a0c90a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = PyList_New( 0 );
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__names, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 208;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10b38ed4f0743b3bdeee62d537a0c90a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10b38ed4f0743b3bdeee62d537a0c90a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_10b38ed4f0743b3bdeee62d537a0c90a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_10b38ed4f0743b3bdeee62d537a0c90a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_10b38ed4f0743b3bdeee62d537a0c90a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_10b38ed4f0743b3bdeee62d537a0c90a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_10b38ed4f0743b3bdeee62d537a0c90a == cache_frame_10b38ed4f0743b3bdeee62d537a0c90a )
    {
        Py_DECREF( frame_10b38ed4f0743b3bdeee62d537a0c90a );
    }
    cache_frame_10b38ed4f0743b3bdeee62d537a0c90a = NULL;

    assertFrameObject( frame_10b38ed4f0743b3bdeee62d537a0c90a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_7___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_7___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_8_add( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_a07fd4d8b0764d77370791e3c0281e5f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a07fd4d8b0764d77370791e3c0281e5f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a07fd4d8b0764d77370791e3c0281e5f, codeobj_a07fd4d8b0764d77370791e3c0281e5f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_a07fd4d8b0764d77370791e3c0281e5f = cache_frame_a07fd4d8b0764d77370791e3c0281e5f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a07fd4d8b0764d77370791e3c0281e5f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a07fd4d8b0764d77370791e3c0281e5f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__names );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 211;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_args_element_name_1 = par_name;
        frame_a07fd4d8b0764d77370791e3c0281e5f->m_frame.f_lineno = 211;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 211;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a07fd4d8b0764d77370791e3c0281e5f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a07fd4d8b0764d77370791e3c0281e5f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a07fd4d8b0764d77370791e3c0281e5f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a07fd4d8b0764d77370791e3c0281e5f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a07fd4d8b0764d77370791e3c0281e5f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a07fd4d8b0764d77370791e3c0281e5f,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_a07fd4d8b0764d77370791e3c0281e5f == cache_frame_a07fd4d8b0764d77370791e3c0281e5f )
    {
        Py_DECREF( frame_a07fd4d8b0764d77370791e3c0281e5f );
    }
    cache_frame_a07fd4d8b0764d77370791e3c0281e5f = NULL;

    assertFrameObject( frame_a07fd4d8b0764d77370791e3c0281e5f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_8_add );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_8_add );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_9_clear( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_5379defb662177ec26632ddbc4192577;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_5379defb662177ec26632ddbc4192577 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5379defb662177ec26632ddbc4192577, codeobj_5379defb662177ec26632ddbc4192577, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_5379defb662177ec26632ddbc4192577 = cache_frame_5379defb662177ec26632ddbc4192577;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5379defb662177ec26632ddbc4192577 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5379defb662177ec26632ddbc4192577 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__names );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 214;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 214;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                exception_lineno = 214;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_3;
            Py_INCREF( var_name );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_attrdel_target_1;
        CHECK_OBJECT( var_name );
        tmp_attrdel_target_1 = var_name;
        tmp_res = PyObject_DelAttr( tmp_attrdel_target_1, const_str_plain__name );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 216;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 214;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5379defb662177ec26632ddbc4192577 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5379defb662177ec26632ddbc4192577 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5379defb662177ec26632ddbc4192577, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5379defb662177ec26632ddbc4192577->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5379defb662177ec26632ddbc4192577, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5379defb662177ec26632ddbc4192577,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_5379defb662177ec26632ddbc4192577 == cache_frame_5379defb662177ec26632ddbc4192577 )
    {
        Py_DECREF( frame_5379defb662177ec26632ddbc4192577 );
    }
    cache_frame_5379defb662177ec26632ddbc4192577 = NULL;

    assertFrameObject( frame_5379defb662177ec26632ddbc4192577 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_9_clear );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_9_clear );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_10___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_1e9a0d222889b318a7dbd80de8f45303;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_1e9a0d222889b318a7dbd80de8f45303 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1e9a0d222889b318a7dbd80de8f45303, codeobj_1e9a0d222889b318a7dbd80de8f45303, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_1e9a0d222889b318a7dbd80de8f45303 = cache_frame_1e9a0d222889b318a7dbd80de8f45303;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1e9a0d222889b318a7dbd80de8f45303 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1e9a0d222889b318a7dbd80de8f45303 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_1e9a0d222889b318a7dbd80de8f45303->m_frame.f_lineno = 227;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_EVP_PKEY_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_args_element_name_1 = var_pkey;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_EVP_PKEY_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_1e9a0d222889b318a7dbd80de8f45303->m_frame.f_lineno = 228;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 228;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_False;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__initialized, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 229;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e9a0d222889b318a7dbd80de8f45303 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e9a0d222889b318a7dbd80de8f45303 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1e9a0d222889b318a7dbd80de8f45303, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1e9a0d222889b318a7dbd80de8f45303->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1e9a0d222889b318a7dbd80de8f45303, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1e9a0d222889b318a7dbd80de8f45303,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_1e9a0d222889b318a7dbd80de8f45303 == cache_frame_1e9a0d222889b318a7dbd80de8f45303 )
    {
        Py_DECREF( frame_1e9a0d222889b318a7dbd80de8f45303 );
    }
    cache_frame_1e9a0d222889b318a7dbd80de8f45303 = NULL;

    assertFrameObject( frame_1e9a0d222889b318a7dbd80de8f45303 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_10___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_10___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_11_to_cryptography_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_412e6657a113f901d16d6c82c1c25936;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_412e6657a113f901d16d6c82c1c25936 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_412e6657a113f901d16d6c82c1c25936, codeobj_412e6657a113f901d16d6c82c1c25936, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_412e6657a113f901d16d6c82c1c25936 = cache_frame_412e6657a113f901d16d6c82c1c25936;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_412e6657a113f901d16d6c82c1c25936 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_412e6657a113f901d16d6c82c1c25936 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
            exception_tb = NULL;

            exception_lineno = 242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_412e6657a113f901d16d6c82c1c25936->m_frame.f_lineno = 242;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_backend == NULL );
        var_backend = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 243;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 243;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( var_backend );
            tmp_source_name_2 = var_backend;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__evp_pkey_to_public_key );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 244;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 244;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_412e6657a113f901d16d6c82c1c25936->m_frame.f_lineno = 244;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 244;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( var_backend );
            tmp_source_name_4 = var_backend;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__evp_pkey_to_private_key );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 246;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__pkey );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 246;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_412e6657a113f901d16d6c82c1c25936->m_frame.f_lineno = 246;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 246;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_412e6657a113f901d16d6c82c1c25936 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_412e6657a113f901d16d6c82c1c25936 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_412e6657a113f901d16d6c82c1c25936 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_412e6657a113f901d16d6c82c1c25936, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_412e6657a113f901d16d6c82c1c25936->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_412e6657a113f901d16d6c82c1c25936, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_412e6657a113f901d16d6c82c1c25936,
        type_description_1,
        par_self,
        var_backend
    );


    // Release cached frame.
    if ( frame_412e6657a113f901d16d6c82c1c25936 == cache_frame_412e6657a113f901d16d6c82c1c25936 )
    {
        Py_DECREF( frame_412e6657a113f901d16d6c82c1c25936 );
    }
    cache_frame_412e6657a113f901d16d6c82c1c25936 = NULL;

    assertFrameObject( frame_412e6657a113f901d16d6c82c1c25936 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_11_to_cryptography_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_11_to_cryptography_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_12_from_cryptography_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_key = python_pars[ 1 ];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_71fdf953dd46d53e76e9fdeae2b36d1e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_71fdf953dd46d53e76e9fdeae2b36d1e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_71fdf953dd46d53e76e9fdeae2b36d1e, codeobj_71fdf953dd46d53e76e9fdeae2b36d1e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_71fdf953dd46d53e76e9fdeae2b36d1e = cache_frame_71fdf953dd46d53e76e9fdeae2b36d1e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_71fdf953dd46d53e76e9fdeae2b36d1e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_71fdf953dd46d53e76e9fdeae2b36d1e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_name_1 = par_cls;
        frame_71fdf953dd46d53e76e9fdeae2b36d1e->m_frame.f_lineno = 260;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 260;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( par_crypto_key );
        tmp_isinstance_inst_1 = par_crypto_key;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "rsa" );
            exception_tb = NULL;

            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_RSAPublicKey );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_isinstance_cls_1 = PyTuple_New( 4 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "rsa" );
            exception_tb = NULL;

            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_RSAPrivateKey );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_isinstance_cls_1 );

            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "dsa" );
            exception_tb = NULL;

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_DSAPublicKey );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_isinstance_cls_1 );

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 2, tmp_tuple_element_1 );
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "dsa" );
            exception_tb = NULL;

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_DSAPrivateKey );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_isinstance_cls_1 );

            exception_lineno = 262;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 3, tmp_tuple_element_1 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 261;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_290681512f72ca11cbf3e4827987aabb;
            frame_71fdf953dd46d53e76e9fdeae2b36d1e->m_frame.f_lineno = 263;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 263;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_5;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_crypto_key );
        tmp_source_name_5 = par_crypto_key;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__evp_pkey );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 265;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 265;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        CHECK_OBJECT( par_crypto_key );
        tmp_isinstance_inst_2 = par_crypto_key;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_rsa );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "rsa" );
            exception_tb = NULL;

            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_RSAPublicKey );
        if ( tmp_tuple_element_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_isinstance_cls_2 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_2, 0, tmp_tuple_element_2 );
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dsa );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_isinstance_cls_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "dsa" );
            exception_tb = NULL;

            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_DSAPublicKey );
        if ( tmp_tuple_element_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_isinstance_cls_2 );

            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_isinstance_cls_2, 1, tmp_tuple_element_2 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        Py_DECREF( tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 266;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            tmp_assattr_name_2 = Py_True;
            CHECK_OBJECT( var_pkey );
            tmp_assattr_target_2 = var_pkey;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__only_public, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 267;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__initialized, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 268;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_71fdf953dd46d53e76e9fdeae2b36d1e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_71fdf953dd46d53e76e9fdeae2b36d1e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_71fdf953dd46d53e76e9fdeae2b36d1e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_71fdf953dd46d53e76e9fdeae2b36d1e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_71fdf953dd46d53e76e9fdeae2b36d1e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_71fdf953dd46d53e76e9fdeae2b36d1e,
        type_description_1,
        par_cls,
        par_crypto_key,
        var_pkey
    );


    // Release cached frame.
    if ( frame_71fdf953dd46d53e76e9fdeae2b36d1e == cache_frame_71fdf953dd46d53e76e9fdeae2b36d1e )
    {
        Py_DECREF( frame_71fdf953dd46d53e76e9fdeae2b36d1e );
    }
    cache_frame_71fdf953dd46d53e76e9fdeae2b36d1e = NULL;

    assertFrameObject( frame_71fdf953dd46d53e76e9fdeae2b36d1e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pkey );
    tmp_return_value = var_pkey;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_12_from_cryptography_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_crypto_key );
    Py_DECREF( par_crypto_key );
    par_crypto_key = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_crypto_key );
    Py_DECREF( par_crypto_key );
    par_crypto_key = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_12_from_cryptography_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_13_generate_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *par_bits = python_pars[ 2 ];
    PyObject *var_exponent = NULL;
    PyObject *var_rsa = NULL;
    PyObject *var_result = NULL;
    PyObject *var_res = NULL;
    PyObject *var_dsa = NULL;
    struct Nuitka_FrameObject *frame_b4af7bab50c450318505ff73850146b0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b4af7bab50c450318505ff73850146b0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b4af7bab50c450318505ff73850146b0, codeobj_b4af7bab50c450318505ff73850146b0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b4af7bab50c450318505ff73850146b0 = cache_frame_b4af7bab50c450318505ff73850146b0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b4af7bab50c450318505ff73850146b0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b4af7bab50c450318505ff73850146b0 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_type );
        tmp_isinstance_inst_1 = par_type;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 287;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 287;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 288;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 288;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_bits );
        tmp_isinstance_inst_2 = par_bits;
        tmp_isinstance_cls_2 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 290;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 290;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_3910fdd1c3b683a0988d08f77454ce47;
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 291;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 291;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_RSA );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TYPE_RSA );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "TYPE_RSA" );
            exception_tb = NULL;

            exception_lineno = 293;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 293;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_bits );
            tmp_compexpr_left_2 = par_bits;
            tmp_compexpr_right_2 = const_int_0;
            tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 294;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_make_exception_arg_3;
                tmp_make_exception_arg_3 = const_str_digest_4fd5a0c1d1fb7366c52acc7b3ac0b5b1;
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 295;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_3 };
                    tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_3 == NULL) );
                exception_type = tmp_raise_type_3;
                exception_lineno = 295;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 298;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_2;
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 298;
            tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BN_new );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 298;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_exponent == NULL );
            var_exponent = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_exponent );
            tmp_args_element_name_1 = var_exponent;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_4;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BN_free );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 299;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 299;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_exponent;
                assert( old != NULL );
                var_exponent = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_5;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_BN_set_word );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_exponent );
            tmp_args_element_name_3 = var_exponent;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_RSA_F4 );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 300;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 300;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_7;
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 302;
            tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_RSA_new );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 302;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_rsa == NULL );
            var_rsa = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_8;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_RSA_generate_key_ex );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_rsa );
            tmp_args_element_name_5 = var_rsa;
            CHECK_OBJECT( par_bits );
            tmp_args_element_name_6 = par_bits;
            CHECK_OBJECT( var_exponent );
            tmp_args_element_name_7 = var_exponent;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_9 == NULL )
            {
                Py_DECREF( tmp_called_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_9;
            tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 304;
            {
                PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 304;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_result == NULL );
            var_result = tmp_assign_source_4;
        }
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_10 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 305;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_10;
            CHECK_OBJECT( var_result );
            tmp_compexpr_left_3 = var_result;
            tmp_compexpr_right_3 = const_int_pos_1;
            tmp_args_element_name_9 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_args_element_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 305;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 305;
            {
                PyObject *call_args[] = { tmp_args_element_name_9 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_args_element_name_9 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 305;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_7;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_8;
            PyObject *tmp_args_element_name_11;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_7 = tmp_mvar_value_11;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_EVP_PKEY_assign_RSA );
            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__pkey );
            if ( tmp_args_element_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_rsa );
            tmp_args_element_name_11 = var_rsa;
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 307;
            {
                PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_10 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 307;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_result;
                assert( old != NULL );
                var_result = tmp_assign_source_5;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 308;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_6 = tmp_mvar_value_12;
            CHECK_OBJECT( var_result );
            tmp_compexpr_left_4 = var_result;
            tmp_compexpr_right_4 = const_int_pos_1;
            tmp_args_element_name_12 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            if ( tmp_args_element_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 308;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 308;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 308;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        goto branch_end_3;
        branch_no_3:;
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_mvar_value_13;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_5 = par_type;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DSA );

            if (unlikely( tmp_mvar_value_13 == NULL ))
            {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TYPE_DSA );
            }

            if ( tmp_mvar_value_13 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "TYPE_DSA" );
                exception_tb = NULL;

                exception_lineno = 310;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_5 = tmp_mvar_value_13;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 310;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_assign_source_6;
                PyObject *tmp_called_instance_3;
                PyObject *tmp_mvar_value_14;
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_14 == NULL ))
                {
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_14 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 311;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_3 = tmp_mvar_value_14;
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 311;
                tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_DSA_new );
                if ( tmp_assign_source_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 311;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_dsa == NULL );
                var_dsa = tmp_assign_source_6;
            }
            {
                PyObject *tmp_called_name_7;
                PyObject *tmp_mvar_value_15;
                PyObject *tmp_call_result_4;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                PyObject *tmp_source_name_9;
                PyObject *tmp_mvar_value_16;
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_15 == NULL ))
                {
                    tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_15 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_7 = tmp_mvar_value_15;
                CHECK_OBJECT( var_dsa );
                tmp_compexpr_left_6 = var_dsa;
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_16 == NULL ))
                {
                    tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_16 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_9 = tmp_mvar_value_16;
                tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_NULL );
                if ( tmp_compexpr_right_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_13 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
                Py_DECREF( tmp_compexpr_right_6 );
                if ( tmp_args_element_name_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 312;
                {
                    PyObject *call_args[] = { tmp_args_element_name_13 };
                    tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
                }

                Py_DECREF( tmp_args_element_name_13 );
                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 312;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_4 );
            }
            {
                PyObject *tmp_assign_source_7;
                PyObject *tmp_called_name_8;
                PyObject *tmp_source_name_10;
                PyObject *tmp_mvar_value_17;
                PyObject *tmp_args_element_name_14;
                PyObject *tmp_args_element_name_15;
                PyObject *tmp_source_name_11;
                PyObject *tmp_mvar_value_18;
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_17 == NULL ))
                {
                    tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_17 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_10 = tmp_mvar_value_17;
                tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_gc );
                if ( tmp_called_name_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_dsa );
                tmp_args_element_name_14 = var_dsa;
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_18 == NULL ))
                {
                    tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_18 == NULL )
                {
                    Py_DECREF( tmp_called_name_8 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_11 = tmp_mvar_value_18;
                tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_DSA_free );
                if ( tmp_args_element_name_15 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_8 );

                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 314;
                {
                    PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
                    tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
                }

                Py_DECREF( tmp_called_name_8 );
                Py_DECREF( tmp_args_element_name_15 );
                if ( tmp_assign_source_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 314;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = var_dsa;
                    assert( old != NULL );
                    var_dsa = tmp_assign_source_7;
                    Py_DECREF( old );
                }

            }
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_name_9;
                PyObject *tmp_source_name_12;
                PyObject *tmp_mvar_value_19;
                PyObject *tmp_args_element_name_16;
                PyObject *tmp_args_element_name_17;
                PyObject *tmp_args_element_name_18;
                PyObject *tmp_source_name_13;
                PyObject *tmp_mvar_value_20;
                PyObject *tmp_args_element_name_19;
                PyObject *tmp_args_element_name_20;
                PyObject *tmp_source_name_14;
                PyObject *tmp_mvar_value_21;
                PyObject *tmp_args_element_name_21;
                PyObject *tmp_source_name_15;
                PyObject *tmp_mvar_value_22;
                PyObject *tmp_args_element_name_22;
                PyObject *tmp_source_name_16;
                PyObject *tmp_mvar_value_23;
                tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_19 == NULL ))
                {
                    tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_19 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 315;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_12 = tmp_mvar_value_19;
                tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_DSA_generate_parameters_ex );
                if ( tmp_called_name_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 315;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_dsa );
                tmp_args_element_name_16 = var_dsa;
                CHECK_OBJECT( par_bits );
                tmp_args_element_name_17 = par_bits;
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_20 == NULL ))
                {
                    tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_20 == NULL )
                {
                    Py_DECREF( tmp_called_name_9 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_13 = tmp_mvar_value_20;
                tmp_args_element_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_NULL );
                if ( tmp_args_element_name_18 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_9 );

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_19 = const_int_0;
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_21 == NULL ))
                {
                    tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_21 == NULL )
                {
                    Py_DECREF( tmp_called_name_9 );
                    Py_DECREF( tmp_args_element_name_18 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_14 = tmp_mvar_value_21;
                tmp_args_element_name_20 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_NULL );
                if ( tmp_args_element_name_20 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_9 );
                    Py_DECREF( tmp_args_element_name_18 );

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_22 == NULL ))
                {
                    tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_22 == NULL )
                {
                    Py_DECREF( tmp_called_name_9 );
                    Py_DECREF( tmp_args_element_name_18 );
                    Py_DECREF( tmp_args_element_name_20 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_15 = tmp_mvar_value_22;
                tmp_args_element_name_21 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_NULL );
                if ( tmp_args_element_name_21 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_9 );
                    Py_DECREF( tmp_args_element_name_18 );
                    Py_DECREF( tmp_args_element_name_20 );

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_23 == NULL ))
                {
                    tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_23 == NULL )
                {
                    Py_DECREF( tmp_called_name_9 );
                    Py_DECREF( tmp_args_element_name_18 );
                    Py_DECREF( tmp_args_element_name_20 );
                    Py_DECREF( tmp_args_element_name_21 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_16 = tmp_mvar_value_23;
                tmp_args_element_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_NULL );
                if ( tmp_args_element_name_22 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_9 );
                    Py_DECREF( tmp_args_element_name_18 );
                    Py_DECREF( tmp_args_element_name_20 );
                    Py_DECREF( tmp_args_element_name_21 );

                    exception_lineno = 316;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 315;
                {
                    PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21, tmp_args_element_name_22 };
                    tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_9, call_args );
                }

                Py_DECREF( tmp_called_name_9 );
                Py_DECREF( tmp_args_element_name_18 );
                Py_DECREF( tmp_args_element_name_20 );
                Py_DECREF( tmp_args_element_name_21 );
                Py_DECREF( tmp_args_element_name_22 );
                if ( tmp_assign_source_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 315;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_res == NULL );
                var_res = tmp_assign_source_8;
            }
            {
                PyObject *tmp_called_name_10;
                PyObject *tmp_mvar_value_24;
                PyObject *tmp_call_result_5;
                PyObject *tmp_args_element_name_23;
                PyObject *tmp_compexpr_left_7;
                PyObject *tmp_compexpr_right_7;
                tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_24 == NULL ))
                {
                    tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_24 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 318;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_10 = tmp_mvar_value_24;
                CHECK_OBJECT( var_res );
                tmp_compexpr_left_7 = var_res;
                tmp_compexpr_right_7 = const_int_pos_1;
                tmp_args_element_name_23 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
                if ( tmp_args_element_name_23 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 318;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 318;
                {
                    PyObject *call_args[] = { tmp_args_element_name_23 };
                    tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
                }

                Py_DECREF( tmp_args_element_name_23 );
                if ( tmp_call_result_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 318;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_5 );
            }
            {
                PyObject *tmp_called_name_11;
                PyObject *tmp_mvar_value_25;
                PyObject *tmp_call_result_6;
                PyObject *tmp_args_element_name_24;
                PyObject *tmp_compexpr_left_8;
                PyObject *tmp_compexpr_right_8;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_mvar_value_26;
                PyObject *tmp_args_element_name_25;
                tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_25 == NULL ))
                {
                    tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_25 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_11 = tmp_mvar_value_25;
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_26 == NULL ))
                {
                    tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_26 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_4 = tmp_mvar_value_26;
                CHECK_OBJECT( var_dsa );
                tmp_args_element_name_25 = var_dsa;
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 320;
                {
                    PyObject *call_args[] = { tmp_args_element_name_25 };
                    tmp_compexpr_left_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_DSA_generate_key, call_args );
                }

                if ( tmp_compexpr_left_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_compexpr_right_8 = const_int_pos_1;
                tmp_args_element_name_24 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
                Py_DECREF( tmp_compexpr_left_8 );
                if ( tmp_args_element_name_24 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 320;
                {
                    PyObject *call_args[] = { tmp_args_element_name_24 };
                    tmp_call_result_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
                }

                Py_DECREF( tmp_args_element_name_24 );
                if ( tmp_call_result_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 320;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_6 );
            }
            {
                PyObject *tmp_called_name_12;
                PyObject *tmp_mvar_value_27;
                PyObject *tmp_call_result_7;
                PyObject *tmp_args_element_name_26;
                PyObject *tmp_compexpr_left_9;
                PyObject *tmp_compexpr_right_9;
                PyObject *tmp_called_name_13;
                PyObject *tmp_source_name_17;
                PyObject *tmp_mvar_value_28;
                PyObject *tmp_args_element_name_27;
                PyObject *tmp_source_name_18;
                PyObject *tmp_args_element_name_28;
                tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_27 == NULL ))
                {
                    tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_27 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_12 = tmp_mvar_value_27;
                tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_28 == NULL ))
                {
                    tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_28 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_17 = tmp_mvar_value_28;
                tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_EVP_PKEY_set1_DSA );
                if ( tmp_called_name_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_self );
                tmp_source_name_18 = par_self;
                tmp_args_element_name_27 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain__pkey );
                if ( tmp_args_element_name_27 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_13 );

                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_dsa );
                tmp_args_element_name_28 = var_dsa;
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 321;
                {
                    PyObject *call_args[] = { tmp_args_element_name_27, tmp_args_element_name_28 };
                    tmp_compexpr_left_9 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_13, call_args );
                }

                Py_DECREF( tmp_called_name_13 );
                Py_DECREF( tmp_args_element_name_27 );
                if ( tmp_compexpr_left_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_compexpr_right_9 = const_int_pos_1;
                tmp_args_element_name_26 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_9, tmp_compexpr_right_9 );
                Py_DECREF( tmp_compexpr_left_9 );
                if ( tmp_args_element_name_26 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 321;
                {
                    PyObject *call_args[] = { tmp_args_element_name_26 };
                    tmp_call_result_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
                }

                Py_DECREF( tmp_args_element_name_26 );
                if ( tmp_call_result_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 321;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_7 );
            }
            goto branch_end_5;
            branch_no_5:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_called_name_14;
                PyObject *tmp_mvar_value_29;
                tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

                if (unlikely( tmp_mvar_value_29 == NULL ))
                {
                    tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
                }

                if ( tmp_mvar_value_29 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
                    exception_tb = NULL;

                    exception_lineno = 323;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_14 = tmp_mvar_value_29;
                frame_b4af7bab50c450318505ff73850146b0->m_frame.f_lineno = 323;
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, &PyTuple_GET_ITEM( const_tuple_str_digest_e2d15f7f418fdd55a54be9ea476feee3_tuple, 0 ) );

                if ( tmp_raise_type_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 323;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                exception_type = tmp_raise_type_4;
                exception_lineno = 323;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_end_5:;
        }
        branch_end_3:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = Py_True;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__initialized, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 325;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4af7bab50c450318505ff73850146b0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4af7bab50c450318505ff73850146b0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b4af7bab50c450318505ff73850146b0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b4af7bab50c450318505ff73850146b0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b4af7bab50c450318505ff73850146b0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b4af7bab50c450318505ff73850146b0,
        type_description_1,
        par_self,
        par_type,
        par_bits,
        var_exponent,
        var_rsa,
        var_result,
        var_res,
        var_dsa
    );


    // Release cached frame.
    if ( frame_b4af7bab50c450318505ff73850146b0 == cache_frame_b4af7bab50c450318505ff73850146b0 )
    {
        Py_DECREF( frame_b4af7bab50c450318505ff73850146b0 );
    }
    cache_frame_b4af7bab50c450318505ff73850146b0 = NULL;

    assertFrameObject( frame_b4af7bab50c450318505ff73850146b0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_13_generate_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_exponent );
    var_exponent = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_bits );
    Py_DECREF( par_bits );
    par_bits = NULL;

    Py_XDECREF( var_dsa );
    var_dsa = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_exponent );
    var_exponent = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_res );
    var_res = NULL;

    CHECK_OBJECT( (PyObject *)par_bits );
    Py_DECREF( par_bits );
    par_bits = NULL;

    Py_XDECREF( var_dsa );
    var_dsa = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_13_generate_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_14_check( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_rsa = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_021a09f6ae6938555af0896436365d60;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_021a09f6ae6938555af0896436365d60 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_021a09f6ae6938555af0896436365d60, codeobj_021a09f6ae6938555af0896436365d60, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_021a09f6ae6938555af0896436365d60 = cache_frame_021a09f6ae6938555af0896436365d60;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_021a09f6ae6938555af0896436365d60 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_021a09f6ae6938555af0896436365d60 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_3d684470d9353bc1a1e8d63a3aab4679;
            frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 341;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 341;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_EVP_PKEY_type );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 343;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_type );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 343;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_PKEY_RSA );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_c85d62bfc2af2f3c2202464fd6374ea7;
            frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 344;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 344;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_EVP_PKEY_get1_RSA );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 346;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_rsa == NULL );
        var_rsa = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_rsa );
        tmp_args_element_name_3 = var_rsa;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_5;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_RSA_free );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 347;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 347;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_rsa;
            assert( old != NULL );
            var_rsa = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 348;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_6;
        CHECK_OBJECT( var_rsa );
        tmp_args_element_name_5 = var_rsa;
        frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 348;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_RSA_check_key, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 348;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_2;
        CHECK_OBJECT( var_result );
        tmp_truth_name_2 = CHECK_IF_TRUE( var_result );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = Py_True;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
            exception_tb = NULL;

            exception_lineno = 351;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        frame_021a09f6ae6938555af0896436365d60->m_frame.f_lineno = 351;
        tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 351;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_021a09f6ae6938555af0896436365d60 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_021a09f6ae6938555af0896436365d60 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_021a09f6ae6938555af0896436365d60 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_021a09f6ae6938555af0896436365d60, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_021a09f6ae6938555af0896436365d60->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_021a09f6ae6938555af0896436365d60, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_021a09f6ae6938555af0896436365d60,
        type_description_1,
        par_self,
        var_rsa,
        var_result
    );


    // Release cached frame.
    if ( frame_021a09f6ae6938555af0896436365d60 == cache_frame_021a09f6ae6938555af0896436365d60 )
    {
        Py_DECREF( frame_021a09f6ae6938555af0896436365d60 );
    }
    cache_frame_021a09f6ae6938555af0896436365d60 = NULL;

    assertFrameObject( frame_021a09f6ae6938555af0896436365d60 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_14_check );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_rsa );
    Py_DECREF( var_rsa );
    var_rsa = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_14_check );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_15_type( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_dbc23fd6b5a9b4b62f8f2245725b8cc9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dbc23fd6b5a9b4b62f8f2245725b8cc9, codeobj_dbc23fd6b5a9b4b62f8f2245725b8cc9, module_OpenSSL$crypto, sizeof(void *) );
    frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 = cache_frame_dbc23fd6b5a9b4b62f8f2245725b8cc9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_PKEY_id );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkey );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_dbc23fd6b5a9b4b62f8f2245725b8cc9->m_frame.f_lineno = 359;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 359;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dbc23fd6b5a9b4b62f8f2245725b8cc9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dbc23fd6b5a9b4b62f8f2245725b8cc9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dbc23fd6b5a9b4b62f8f2245725b8cc9,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 == cache_frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 )
    {
        Py_DECREF( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 );
    }
    cache_frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 = NULL;

    assertFrameObject( frame_dbc23fd6b5a9b4b62f8f2245725b8cc9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_15_type );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_15_type );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_16_bits( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_457291e3f25809c88b1764bd146b0304;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_457291e3f25809c88b1764bd146b0304 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_457291e3f25809c88b1764bd146b0304, codeobj_457291e3f25809c88b1764bd146b0304, module_OpenSSL$crypto, sizeof(void *) );
    frame_457291e3f25809c88b1764bd146b0304 = cache_frame_457291e3f25809c88b1764bd146b0304;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_457291e3f25809c88b1764bd146b0304 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_457291e3f25809c88b1764bd146b0304 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_PKEY_bits );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkey );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_457291e3f25809c88b1764bd146b0304->m_frame.f_lineno = 367;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 367;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_457291e3f25809c88b1764bd146b0304 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_457291e3f25809c88b1764bd146b0304 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_457291e3f25809c88b1764bd146b0304 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_457291e3f25809c88b1764bd146b0304, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_457291e3f25809c88b1764bd146b0304->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_457291e3f25809c88b1764bd146b0304, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_457291e3f25809c88b1764bd146b0304,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_457291e3f25809c88b1764bd146b0304 == cache_frame_457291e3f25809c88b1764bd146b0304 )
    {
        Py_DECREF( frame_457291e3f25809c88b1764bd146b0304 );
    }
    cache_frame_457291e3f25809c88b1764bd146b0304 = NULL;

    assertFrameObject( frame_457291e3f25809c88b1764bd146b0304 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_16_bits );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_16_bits );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_17___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_34cc9897f64823e467bbb021110e428b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_34cc9897f64823e467bbb021110e428b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_34cc9897f64823e467bbb021110e428b, codeobj_34cc9897f64823e467bbb021110e428b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_34cc9897f64823e467bbb021110e428b = cache_frame_34cc9897f64823e467bbb021110e428b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_34cc9897f64823e467bbb021110e428b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_34cc9897f64823e467bbb021110e428b ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_EllipticCurve" );
            exception_tb = NULL;

            exception_lineno = 397;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 397;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_type_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_EllipticCurve" );
                exception_tb = NULL;

                exception_lineno = 398;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 398;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_other );
            tmp_args_element_name_1 = par_other;
            frame_34cc9897f64823e467bbb021110e428b->m_frame.f_lineno = 398;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___ne__, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 398;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34cc9897f64823e467bbb021110e428b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_34cc9897f64823e467bbb021110e428b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34cc9897f64823e467bbb021110e428b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_34cc9897f64823e467bbb021110e428b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_34cc9897f64823e467bbb021110e428b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_34cc9897f64823e467bbb021110e428b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_34cc9897f64823e467bbb021110e428b,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_34cc9897f64823e467bbb021110e428b == cache_frame_34cc9897f64823e467bbb021110e428b )
    {
        Py_DECREF( frame_34cc9897f64823e467bbb021110e428b );
    }
    cache_frame_34cc9897f64823e467bbb021110e428b = NULL;

    assertFrameObject( frame_34cc9897f64823e467bbb021110e428b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_NotImplemented;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_17___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_17___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_18__load_elliptic_curves( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_cls = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_lib = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_builtin_curves = NULL;
    PyObject *var_num_curves = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_3f35dc87711e3416ee84ceaf5ce82fc4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3f35dc87711e3416ee84ceaf5ce82fc4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3f35dc87711e3416ee84ceaf5ce82fc4, codeobj_3f35dc87711e3416ee84ceaf5ce82fc4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3f35dc87711e3416ee84ceaf5ce82fc4 = cache_frame_3f35dc87711e3416ee84ceaf5ce82fc4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3f35dc87711e3416ee84ceaf5ce82fc4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3f35dc87711e3416ee84ceaf5ce82fc4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( PyCell_GET( par_lib ) );
        tmp_source_name_1 = PyCell_GET( par_lib );
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EC_get_builtin_curves );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = const_int_0;
        frame_3f35dc87711e3416ee84ceaf5ce82fc4->m_frame.f_lineno = 411;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 411;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        assert( var_num_curves == NULL );
        var_num_curves = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 412;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_3 = const_str_digest_73f7a7ef7b02ca8c5d7fdfe1049be561;
        CHECK_OBJECT( var_num_curves );
        tmp_args_element_name_4 = var_num_curves;
        frame_3f35dc87711e3416ee84ceaf5ce82fc4->m_frame.f_lineno = 412;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 412;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        assert( var_builtin_curves == NULL );
        var_builtin_curves = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT( PyCell_GET( par_lib ) );
        tmp_called_instance_2 = PyCell_GET( par_lib );
        CHECK_OBJECT( var_builtin_curves );
        tmp_args_element_name_5 = var_builtin_curves;
        CHECK_OBJECT( var_num_curves );
        tmp_args_element_name_6 = var_num_curves;
        frame_3f35dc87711e3416ee84ceaf5ce82fc4->m_frame.f_lineno = 416;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_EC_get_builtin_curves, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 416;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_set_arg_1;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( var_builtin_curves );
            tmp_iter_arg_1 = var_builtin_curves;
            tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 418;
                type_description_1 = "ccoo";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_3;
        }
        // Tried code:
        tmp_set_arg_1 = OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[0] = par_cls;
        Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[0] );
        ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[1] = PyCell_NEW0( tmp_genexpr_1__$0 );
        ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[2] = par_lib;
        Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_set_arg_1)->m_closure[2] );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
        return NULL;
        outline_result_1:;
        tmp_return_value = PySet_New( tmp_set_arg_1 );
        Py_DECREF( tmp_set_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 417;
            type_description_1 = "ccoo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f35dc87711e3416ee84ceaf5ce82fc4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f35dc87711e3416ee84ceaf5ce82fc4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f35dc87711e3416ee84ceaf5ce82fc4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3f35dc87711e3416ee84ceaf5ce82fc4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3f35dc87711e3416ee84ceaf5ce82fc4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3f35dc87711e3416ee84ceaf5ce82fc4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3f35dc87711e3416ee84ceaf5ce82fc4,
        type_description_1,
        par_cls,
        par_lib,
        var_builtin_curves,
        var_num_curves
    );


    // Release cached frame.
    if ( frame_3f35dc87711e3416ee84ceaf5ce82fc4 == cache_frame_3f35dc87711e3416ee84ceaf5ce82fc4 )
    {
        Py_DECREF( frame_3f35dc87711e3416ee84ceaf5ce82fc4 );
    }
    cache_frame_3f35dc87711e3416ee84ceaf5ce82fc4 = NULL;

    assertFrameObject( frame_3f35dc87711e3416ee84ceaf5ce82fc4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_builtin_curves );
    Py_DECREF( var_builtin_curves );
    var_builtin_curves = NULL;

    CHECK_OBJECT( (PyObject *)var_num_curves );
    Py_DECREF( var_num_curves );
    var_num_curves = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_builtin_curves );
    var_builtin_curves = NULL;

    Py_XDECREF( var_num_curves );
    var_num_curves = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_18__load_elliptic_curves );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals {
    PyObject *var_c;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals *generator_heap = (struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_c = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_673f2b0b42693996557bb3ee4e55f969, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[1] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[1] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Nocc";
                generator_heap->exception_lineno = 418;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_c;
            generator_heap->var_c = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_c );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "cls" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_from_nid );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "lib" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }

        tmp_args_element_name_1 = PyCell_GET( generator->m_closure[2] );
        CHECK_OBJECT( generator_heap->var_c );
        tmp_source_name_2 = generator_heap->var_c;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_nid );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
            Py_DECREF( tmp_called_name_1 );

            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        generator->m_frame->m_frame.f_lineno = 418;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_expression_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_expression_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_called_name_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_called_name_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_args_element_name_1, sizeof(PyObject *), &tmp_args_element_name_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 418;
            generator_heap->type_description_1 = "Nocc";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 418;
        generator_heap->type_description_1 = "Nocc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_c,
            generator->m_closure[2],
            generator->m_closure[0]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_c );
    generator_heap->var_c = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_c );
    generator_heap->var_c = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_context,
        module_OpenSSL$crypto,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_673f2b0b42693996557bb3ee4e55f969,
        3,
        sizeof(struct OpenSSL$crypto$$$function_18__load_elliptic_curves$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_OpenSSL$crypto$$$function_19__get_elliptic_curves( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_lib = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_f1b4064961f0e278b8e11fc39e19cd03;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f1b4064961f0e278b8e11fc39e19cd03 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f1b4064961f0e278b8e11fc39e19cd03, codeobj_f1b4064961f0e278b8e11fc39e19cd03, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_f1b4064961f0e278b8e11fc39e19cd03 = cache_frame_f1b4064961f0e278b8e11fc39e19cd03;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f1b4064961f0e278b8e11fc39e19cd03 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f1b4064961f0e278b8e11fc39e19cd03 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__curves );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 431;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT( par_cls );
            tmp_called_instance_1 = par_cls;
            CHECK_OBJECT( par_lib );
            tmp_args_element_name_1 = par_lib;
            frame_f1b4064961f0e278b8e11fc39e19cd03->m_frame.f_lineno = 432;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__load_elliptic_curves, call_args );
            }

            if ( tmp_assattr_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 432;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_cls );
            tmp_assattr_target_1 = par_cls;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__curves, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 432;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_cls );
        tmp_source_name_2 = par_cls;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__curves );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 433;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1b4064961f0e278b8e11fc39e19cd03 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1b4064961f0e278b8e11fc39e19cd03 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1b4064961f0e278b8e11fc39e19cd03 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f1b4064961f0e278b8e11fc39e19cd03, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f1b4064961f0e278b8e11fc39e19cd03->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f1b4064961f0e278b8e11fc39e19cd03, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f1b4064961f0e278b8e11fc39e19cd03,
        type_description_1,
        par_cls,
        par_lib
    );


    // Release cached frame.
    if ( frame_f1b4064961f0e278b8e11fc39e19cd03 == cache_frame_f1b4064961f0e278b8e11fc39e19cd03 )
    {
        Py_DECREF( frame_f1b4064961f0e278b8e11fc39e19cd03 );
    }
    cache_frame_f1b4064961f0e278b8e11fc39e19cd03 = NULL;

    assertFrameObject( frame_f1b4064961f0e278b8e11fc39e19cd03 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_19__get_elliptic_curves );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_19__get_elliptic_curves );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_20_from_nid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_lib = python_pars[ 1 ];
    PyObject *par_nid = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_61d8a1f2a778a009244666e966ebfedc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_61d8a1f2a778a009244666e966ebfedc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_61d8a1f2a778a009244666e966ebfedc, codeobj_61d8a1f2a778a009244666e966ebfedc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_61d8a1f2a778a009244666e966ebfedc = cache_frame_61d8a1f2a778a009244666e966ebfedc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_61d8a1f2a778a009244666e966ebfedc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_61d8a1f2a778a009244666e966ebfedc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT( par_cls );
        tmp_called_name_1 = par_cls;
        CHECK_OBJECT( par_lib );
        tmp_args_element_name_1 = par_lib;
        CHECK_OBJECT( par_nid );
        tmp_args_element_name_2 = par_nid;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_string );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_lib );
        tmp_called_instance_2 = par_lib;
        CHECK_OBJECT( par_nid );
        tmp_args_element_name_5 = par_nid;
        frame_61d8a1f2a778a009244666e966ebfedc->m_frame.f_lineno = 450;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_nid2sn, call_args );
        }

        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_61d8a1f2a778a009244666e966ebfedc->m_frame.f_lineno = 450;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_called_instance_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_61d8a1f2a778a009244666e966ebfedc->m_frame.f_lineno = 450;
        tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_61d8a1f2a778a009244666e966ebfedc->m_frame.f_lineno = 450;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 450;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_61d8a1f2a778a009244666e966ebfedc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_61d8a1f2a778a009244666e966ebfedc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_61d8a1f2a778a009244666e966ebfedc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_61d8a1f2a778a009244666e966ebfedc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_61d8a1f2a778a009244666e966ebfedc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_61d8a1f2a778a009244666e966ebfedc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_61d8a1f2a778a009244666e966ebfedc,
        type_description_1,
        par_cls,
        par_lib,
        par_nid
    );


    // Release cached frame.
    if ( frame_61d8a1f2a778a009244666e966ebfedc == cache_frame_61d8a1f2a778a009244666e966ebfedc )
    {
        Py_DECREF( frame_61d8a1f2a778a009244666e966ebfedc );
    }
    cache_frame_61d8a1f2a778a009244666e966ebfedc = NULL;

    assertFrameObject( frame_61d8a1f2a778a009244666e966ebfedc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_20_from_nid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_20_from_nid );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_21___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_lib = python_pars[ 1 ];
    PyObject *par_nid = python_pars[ 2 ];
    PyObject *par_name = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec, codeobj_50fc6fa6c0ba7d87e3e63c2bfa99b0ec, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec = cache_frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_lib );
        tmp_assattr_name_1 = par_lib;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__lib, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 465;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_nid );
        tmp_assattr_name_2 = par_nid;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__nid, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 466;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_name );
        tmp_assattr_name_3 = par_name;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_name, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 467;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec,
        type_description_1,
        par_self,
        par_lib,
        par_nid,
        par_name
    );


    // Release cached frame.
    if ( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec == cache_frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec )
    {
        Py_DECREF( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec );
    }
    cache_frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec = NULL;

    assertFrameObject( frame_50fc6fa6c0ba7d87e3e63c2bfa99b0ec );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_21___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_nid );
    Py_DECREF( par_nid );
    par_nid = NULL;

    CHECK_OBJECT( (PyObject *)par_lib );
    Py_DECREF( par_lib );
    par_lib = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_21___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_22___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d0de697e0ff0841e276f18046e633c8c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d0de697e0ff0841e276f18046e633c8c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d0de697e0ff0841e276f18046e633c8c, codeobj_d0de697e0ff0841e276f18046e633c8c, module_OpenSSL$crypto, sizeof(void *) );
    frame_d0de697e0ff0841e276f18046e633c8c = cache_frame_d0de697e0ff0841e276f18046e633c8c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d0de697e0ff0841e276f18046e633c8c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d0de697e0ff0841e276f18046e633c8c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        tmp_left_name_1 = const_str_digest_221848055f0a545c7ef1969a37bb78a5;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 470;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 470;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0de697e0ff0841e276f18046e633c8c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0de697e0ff0841e276f18046e633c8c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0de697e0ff0841e276f18046e633c8c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d0de697e0ff0841e276f18046e633c8c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d0de697e0ff0841e276f18046e633c8c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d0de697e0ff0841e276f18046e633c8c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d0de697e0ff0841e276f18046e633c8c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d0de697e0ff0841e276f18046e633c8c == cache_frame_d0de697e0ff0841e276f18046e633c8c )
    {
        Py_DECREF( frame_d0de697e0ff0841e276f18046e633c8c );
    }
    cache_frame_d0de697e0ff0841e276f18046e633c8c = NULL;

    assertFrameObject( frame_d0de697e0ff0841e276f18046e633c8c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_22___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_22___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_23__to_EC_KEY( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_key = NULL;
    struct Nuitka_FrameObject *frame_751e01039a709a9872d0145d6873cd38;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_751e01039a709a9872d0145d6873cd38 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_751e01039a709a9872d0145d6873cd38, codeobj_751e01039a709a9872d0145d6873cd38, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_751e01039a709a9872d0145d6873cd38 = cache_frame_751e01039a709a9872d0145d6873cd38;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_751e01039a709a9872d0145d6873cd38 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_751e01039a709a9872d0145d6873cd38 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__lib );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EC_KEY_new_by_curve_name );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__nid );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_751e01039a709a9872d0145d6873cd38->m_frame.f_lineno = 479;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_key == NULL );
        var_key = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_1;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_key );
        tmp_args_element_name_2 = var_key;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_2;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_EC_KEY_free );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_751e01039a709a9872d0145d6873cd38->m_frame.f_lineno = 480;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_751e01039a709a9872d0145d6873cd38 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_751e01039a709a9872d0145d6873cd38 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_751e01039a709a9872d0145d6873cd38 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_751e01039a709a9872d0145d6873cd38, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_751e01039a709a9872d0145d6873cd38->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_751e01039a709a9872d0145d6873cd38, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_751e01039a709a9872d0145d6873cd38,
        type_description_1,
        par_self,
        var_key
    );


    // Release cached frame.
    if ( frame_751e01039a709a9872d0145d6873cd38 == cache_frame_751e01039a709a9872d0145d6873cd38 )
    {
        Py_DECREF( frame_751e01039a709a9872d0145d6873cd38 );
    }
    cache_frame_751e01039a709a9872d0145d6873cd38 = NULL;

    assertFrameObject( frame_751e01039a709a9872d0145d6873cd38 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_23__to_EC_KEY );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_key );
    Py_DECREF( var_key );
    var_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_23__to_EC_KEY );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_24_get_elliptic_curves( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_598b2e7282a2c0052171ad54e31c80cc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_598b2e7282a2c0052171ad54e31c80cc = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME( cache_frame_598b2e7282a2c0052171ad54e31c80cc, codeobj_598b2e7282a2c0052171ad54e31c80cc, module_OpenSSL$crypto, 0 );
    frame_598b2e7282a2c0052171ad54e31c80cc = cache_frame_598b2e7282a2c0052171ad54e31c80cc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_598b2e7282a2c0052171ad54e31c80cc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_598b2e7282a2c0052171ad54e31c80cc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__EllipticCurve );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_EllipticCurve" );
            exception_tb = NULL;

            exception_lineno = 495;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_elliptic_curves );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 495;

            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 495;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_598b2e7282a2c0052171ad54e31c80cc->m_frame.f_lineno = 495;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 495;

            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_598b2e7282a2c0052171ad54e31c80cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_598b2e7282a2c0052171ad54e31c80cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_598b2e7282a2c0052171ad54e31c80cc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_598b2e7282a2c0052171ad54e31c80cc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_598b2e7282a2c0052171ad54e31c80cc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_598b2e7282a2c0052171ad54e31c80cc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_598b2e7282a2c0052171ad54e31c80cc,
        type_description_1
    );


    // Release cached frame.
    if ( frame_598b2e7282a2c0052171ad54e31c80cc == cache_frame_598b2e7282a2c0052171ad54e31c80cc )
    {
        Py_DECREF( frame_598b2e7282a2c0052171ad54e31c80cc );
    }
    cache_frame_598b2e7282a2c0052171ad54e31c80cc = NULL;

    assertFrameObject( frame_598b2e7282a2c0052171ad54e31c80cc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_24_get_elliptic_curves );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_25_get_elliptic_curve( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_name = python_pars[ 0 ];
    PyObject *var_curve = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_c02f074eb4c422487aa6b3df9c1e1e4d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_c02f074eb4c422487aa6b3df9c1e1e4d = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c02f074eb4c422487aa6b3df9c1e1e4d, codeobj_c02f074eb4c422487aa6b3df9c1e1e4d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_c02f074eb4c422487aa6b3df9c1e1e4d = cache_frame_c02f074eb4c422487aa6b3df9c1e1e4d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c02f074eb4c422487aa6b3df9c1e1e4d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c02f074eb4c422487aa6b3df9c1e1e4d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "get_elliptic_curves" );
            exception_tb = NULL;

            exception_lineno = 510;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_c02f074eb4c422487aa6b3df9c1e1e4d->m_frame.f_lineno = 510;
        tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 510;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 510;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                exception_lineno = 510;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_curve;
            var_curve = tmp_assign_source_3;
            Py_INCREF( var_curve );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var_curve );
        tmp_source_name_1 = var_curve;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 511;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_name );
        tmp_compexpr_right_1 = par_name;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 511;
            type_description_1 = "oo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( var_curve );
        tmp_return_value = var_curve;
        Py_INCREF( tmp_return_value );
        goto try_return_handler_2;
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 510;
        type_description_1 = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_make_exception_arg_2;
        tmp_make_exception_arg_1 = const_str_digest_95aba6f0be0722dff4a715f251a45159;
        CHECK_OBJECT( par_name );
        tmp_make_exception_arg_2 = par_name;
        frame_c02f074eb4c422487aa6b3df9c1e1e4d->m_frame.f_lineno = 513;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1, tmp_make_exception_arg_2 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS2( PyExc_ValueError, call_args );
        }

        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 513;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c02f074eb4c422487aa6b3df9c1e1e4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c02f074eb4c422487aa6b3df9c1e1e4d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c02f074eb4c422487aa6b3df9c1e1e4d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c02f074eb4c422487aa6b3df9c1e1e4d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c02f074eb4c422487aa6b3df9c1e1e4d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c02f074eb4c422487aa6b3df9c1e1e4d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c02f074eb4c422487aa6b3df9c1e1e4d,
        type_description_1,
        par_name,
        var_curve
    );


    // Release cached frame.
    if ( frame_c02f074eb4c422487aa6b3df9c1e1e4d == cache_frame_c02f074eb4c422487aa6b3df9c1e1e4d )
    {
        Py_DECREF( frame_c02f074eb4c422487aa6b3df9c1e1e4d );
    }
    cache_frame_c02f074eb4c422487aa6b3df9c1e1e4d = NULL;

    assertFrameObject( frame_c02f074eb4c422487aa6b3df9c1e1e4d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_25_get_elliptic_curve );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_curve );
    Py_DECREF( var_curve );
    var_curve = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_curve );
    var_curve = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_25_get_elliptic_curve );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_26___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_b3eeb60a67b100f9108e6a5c3cf04ffc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b3eeb60a67b100f9108e6a5c3cf04ffc = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b3eeb60a67b100f9108e6a5c3cf04ffc, codeobj_b3eeb60a67b100f9108e6a5c3cf04ffc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_b3eeb60a67b100f9108e6a5c3cf04ffc = cache_frame_b3eeb60a67b100f9108e6a5c3cf04ffc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b3eeb60a67b100f9108e6a5c3cf04ffc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b3eeb60a67b100f9108e6a5c3cf04ffc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_dup );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_source_name_2 = par_name;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b3eeb60a67b100f9108e6a5c3cf04ffc->m_frame.f_lineno = 548;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 548;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_name;
            assert( old != NULL );
            par_name = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_args_element_name_2 = par_name;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_NAME_free );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_b3eeb60a67b100f9108e6a5c3cf04ffc->m_frame.f_lineno = 549;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 549;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b3eeb60a67b100f9108e6a5c3cf04ffc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b3eeb60a67b100f9108e6a5c3cf04ffc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b3eeb60a67b100f9108e6a5c3cf04ffc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b3eeb60a67b100f9108e6a5c3cf04ffc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b3eeb60a67b100f9108e6a5c3cf04ffc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b3eeb60a67b100f9108e6a5c3cf04ffc,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_b3eeb60a67b100f9108e6a5c3cf04ffc == cache_frame_b3eeb60a67b100f9108e6a5c3cf04ffc )
    {
        Py_DECREF( frame_b3eeb60a67b100f9108e6a5c3cf04ffc );
    }
    cache_frame_b3eeb60a67b100f9108e6a5c3cf04ffc = NULL;

    assertFrameObject( frame_b3eeb60a67b100f9108e6a5c3cf04ffc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_26___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_26___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_27___setattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_value = python_pars[ 2 ];
    PyObject *var_i = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_ent_obj = NULL;
    PyObject *var_ent = NULL;
    PyObject *var_ent_nid = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_d7b026a4f1f66fd2b9e84f2cfbc64af8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d7b026a4f1f66fd2b9e84f2cfbc64af8, codeobj_d7b026a4f1f66fd2b9e84f2cfbc64af8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 = cache_frame_d7b026a4f1f66fd2b9e84f2cfbc64af8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_name );
        tmp_called_instance_1 = par_name;
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 552;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain___tuple, 0 ) );

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 552;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 552;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_type_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
                exception_tb = NULL;

                exception_lineno = 553;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = tmp_mvar_value_1;
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_2 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 553;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_name );
            tmp_args_element_name_1 = par_name;
            CHECK_OBJECT( par_value );
            tmp_args_element_name_2 = par_value;
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 553;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain___setattr__, call_args );
            }

            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 553;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_type_arg_1;
        CHECK_OBJECT( par_name );
        tmp_type_arg_1 = par_name;
        tmp_compexpr_left_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_compexpr_left_1 == NULL) );
        tmp_compexpr_right_1 = (PyObject *)&PyString_Type;
        tmp_condition_result_2 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_type_arg_2;
            tmp_left_name_1 = const_str_digest_bbde1e297eda38e770b8fce1d06c225b;
            CHECK_OBJECT( par_value );
            tmp_type_arg_2 = par_value;
            tmp_source_name_1 = BUILTIN_TYPE1( tmp_type_arg_2 );
            assert( !(tmp_source_name_1 == NULL) );
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 559;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyTuple_New( 1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 558;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 558;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 558;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_OBJ_txt2nid );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( par_name );
        tmp_args_element_name_4 = par_name;
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 561;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 561;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 561;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_nid == NULL );
        var_nid = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_nid );
        tmp_compexpr_left_2 = var_nid;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 562;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NID_undef );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 562;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 562;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        // Tried code:
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 564;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 564;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 564;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 );
        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_d7b026a4f1f66fd2b9e84f2cfbc64af8, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_6;
            tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
                exception_tb = NULL;

                exception_lineno = 565;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_6;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 565;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 565;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 563;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame) frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
            branch_no_4:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_27___setattr__ );
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_7b5d428ebb9708d902c18ce8ddfb3cbc;
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 567;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 567;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_NAME_entry_count );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__name );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 570;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 570;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooooo";
                exception_lineno = 570;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_4;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_6 = tmp_mvar_value_8;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_NAME_get_entry );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__name );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_i );
        tmp_args_element_name_7 = var_i;
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 571;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 571;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_ent;
            var_ent = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 572;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_3 = tmp_mvar_value_9;
        CHECK_OBJECT( var_ent );
        tmp_args_element_name_8 = var_ent;
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 572;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_NAME_ENTRY_get_object, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 572;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_ent_obj;
            var_ent_obj = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 573;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_4 = tmp_mvar_value_10;
        CHECK_OBJECT( var_ent_obj );
        tmp_args_element_name_9 = var_ent_obj;
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 573;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_OBJ_obj2nid, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 573;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_ent_nid;
            var_ent_nid = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT( var_nid );
        tmp_compexpr_left_4 = var_nid;
        CHECK_OBJECT( var_ent_nid );
        tmp_compexpr_right_4 = var_ent_nid;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 574;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_called_name_6;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_9;
            PyObject *tmp_args_element_name_11;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }

            tmp_source_name_8 = tmp_mvar_value_11;
            tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509_NAME_delete_entry );
            if ( tmp_called_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_9 = par_self;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__name );
            if ( tmp_args_element_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_6 );

                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT( var_i );
            tmp_args_element_name_11 = var_i;
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 575;
            {
                PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
                tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_called_name_6 );
            Py_DECREF( tmp_args_element_name_10 );
            if ( tmp_assign_source_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 575;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            {
                PyObject *old = var_ent;
                assert( old != NULL );
                var_ent = tmp_assign_source_8;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_12;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 576;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }

            tmp_called_instance_5 = tmp_mvar_value_12;
            CHECK_OBJECT( var_ent );
            tmp_args_element_name_12 = var_ent;
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 576;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_X509_NAME_ENTRY_free, call_args );
            }

            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 576;
                type_description_1 = "ooooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        goto loop_end_1;
        branch_no_5:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 570;
        type_description_1 = "ooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_13;
        CHECK_OBJECT( par_value );
        tmp_isinstance_inst_1 = par_value;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 579;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_13;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 579;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_called_instance_6;
            CHECK_OBJECT( par_value );
            tmp_called_instance_6 = par_value;
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 580;
            tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

            if ( tmp_assign_source_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 580;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_value;
                assert( old != NULL );
                par_value = tmp_assign_source_9;
                Py_DECREF( old );
            }

        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_11;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 582;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_14;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_NAME_add_entry_by_NID );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 582;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_11 = par_self;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__name );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 583;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_nid );
        tmp_args_element_name_14 = var_nid;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_15 == NULL )
        {
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 583;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_15;
        tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_MBSTRING_UTF8 );
        if ( tmp_args_element_name_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );

            exception_lineno = 583;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_value );
        tmp_args_element_name_16 = par_value;
        tmp_args_element_name_17 = const_int_neg_1;
        tmp_args_element_name_18 = const_int_neg_1;
        tmp_args_element_name_19 = const_int_0;
        frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 582;
        {
            PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
            tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        Py_DECREF( tmp_args_element_name_15 );
        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 582;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_add_result == NULL );
        var_add_result = tmp_assign_source_10;
    }
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_add_result );
        tmp_operand_name_2 = var_add_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 584;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_call_result_4;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_16 == NULL ))
            {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_16 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 585;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_8 = tmp_mvar_value_16;
            frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame.f_lineno = 585;
            tmp_call_result_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 585;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        branch_no_7:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d7b026a4f1f66fd2b9e84f2cfbc64af8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d7b026a4f1f66fd2b9e84f2cfbc64af8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d7b026a4f1f66fd2b9e84f2cfbc64af8,
        type_description_1,
        par_self,
        par_name,
        par_value,
        var_i,
        var_nid,
        var_ent_obj,
        var_ent,
        var_ent_nid,
        var_add_result
    );


    // Release cached frame.
    if ( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 == cache_frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 )
    {
        Py_DECREF( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 );
    }
    cache_frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 = NULL;

    assertFrameObject( frame_d7b026a4f1f66fd2b9e84f2cfbc64af8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_27___setattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_ent_obj );
    var_ent_obj = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_ent_nid );
    var_ent_nid = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_ent_obj );
    var_ent_obj = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_ent_nid );
    var_ent_nid = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_27___setattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_28___getattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *var_result_buffer = NULL;
    PyObject *var_data_length = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_result = NULL;
    PyObject *var_entry_index = NULL;
    PyObject *var_entry = NULL;
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_d860a737664a16683e8d212dd9ae54eb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_d860a737664a16683e8d212dd9ae54eb = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d860a737664a16683e8d212dd9ae54eb, codeobj_d860a737664a16683e8d212dd9ae54eb, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d860a737664a16683e8d212dd9ae54eb = cache_frame_d860a737664a16683e8d212dd9ae54eb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d860a737664a16683e8d212dd9ae54eb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d860a737664a16683e8d212dd9ae54eb ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OBJ_txt2nid );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_name );
        tmp_args_element_name_2 = par_name;
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 594;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 594;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 594;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_nid == NULL );
        var_nid = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_nid );
        tmp_compexpr_left_1 = var_nid;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 595;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NID_undef );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 595;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 595;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 602;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 602;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 602;
                type_description_1 = "ooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION( frame_d860a737664a16683e8d212dd9ae54eb );
        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_d860a737664a16683e8d212dd9ae54eb, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_d860a737664a16683e8d212dd9ae54eb, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_5;
            tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
                exception_tb = NULL;

                exception_lineno = 603;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_5;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 603;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 603;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 601;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_d860a737664a16683e8d212dd9ae54eb->m_frame) frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
            branch_no_2:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_28___getattr__ );
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_type_name_1;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_object_name_1;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
                exception_tb = NULL;

                exception_lineno = 605;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_type_name_1 = tmp_mvar_value_6;
            CHECK_OBJECT( par_self );
            tmp_object_name_1 = par_self;
            tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 605;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_name );
            tmp_args_element_name_3 = par_name;
            frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 605;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___getattr__, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 605;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_NAME_get_index_by_NID );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_nid );
        tmp_args_element_name_5 = var_nid;
        tmp_args_element_name_6 = const_int_neg_1;
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 607;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 607;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_entry_index == NULL );
        var_entry_index = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( var_entry_index );
        tmp_compexpr_left_3 = var_entry_index;
        tmp_compexpr_right_3 = const_int_neg_1;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 608;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_NAME_get_entry );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__name );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_entry_index );
        tmp_args_element_name_8 = var_entry_index;
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 611;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 611;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_entry == NULL );
        var_entry = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 612;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_9;
        CHECK_OBJECT( var_entry );
        tmp_args_element_name_9 = var_entry;
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 612;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509_NAME_ENTRY_get_data, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 612;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_data == NULL );
        var_data = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 614;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_10;
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 614;
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0 ) );

        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 614;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_buffer == NULL );
        var_result_buffer = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 615;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_11;
        CHECK_OBJECT( var_result_buffer );
        tmp_args_element_name_10 = var_result_buffer;
        CHECK_OBJECT( var_data );
        tmp_args_element_name_11 = var_data;
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 615;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_ASN1_STRING_to_UTF8, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 615;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_data_length == NULL );
        var_data_length = tmp_assign_source_6;
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 616;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_12;
        CHECK_OBJECT( var_data_length );
        tmp_compexpr_left_4 = var_data_length;
        tmp_compexpr_right_4 = const_int_0;
        tmp_args_element_name_12 = RICH_COMPARE_GTE_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_args_element_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 616;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 616;
        {
            PyObject *call_args[] = { tmp_args_element_name_12 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_args_element_name_12 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 616;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_5;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_14;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }

        tmp_source_name_7 = tmp_mvar_value_13;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_buffer );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_subscribed_name_1 = var_result_buffer;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_13 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 620;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_data_length );
        tmp_args_element_name_14 = var_data_length;
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 619;
        {
            PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        tmp_called_instance_5 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_called_instance_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 619;
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_digest_c075052d723d6707083e869a0e3659bb_tuple, 0 ) );

        Py_DECREF( tmp_called_instance_5 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 619;
            type_description_1 = "ooooooooo";
            goto try_except_handler_3;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_7;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            Py_DECREF( exception_keeper_type_2 );
            Py_XDECREF( exception_keeper_value_2 );
            Py_XDECREF( exception_keeper_tb_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_14;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_OPENSSL_free );
        if ( tmp_called_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            Py_DECREF( exception_keeper_type_2 );
            Py_XDECREF( exception_keeper_value_2 );
            Py_XDECREF( exception_keeper_tb_2 );

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_subscribed_name_2 = var_result_buffer;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_15 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
        if ( tmp_args_element_name_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_8 );
            Py_DECREF( exception_keeper_type_2 );
            Py_XDECREF( exception_keeper_value_2 );
            Py_XDECREF( exception_keeper_tb_2 );

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 624;
        {
            PyObject *call_args[] = { tmp_args_element_name_15 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
        }

        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_15 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            Py_DECREF( exception_keeper_type_2 );
            Py_XDECREF( exception_keeper_value_2 );
            Py_XDECREF( exception_keeper_tb_2 );

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_called_name_9;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_OPENSSL_free );
        if ( tmp_called_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_subscribed_name_3 = var_result_buffer;
        tmp_subscript_name_3 = const_int_0;
        tmp_args_element_name_16 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
        if ( tmp_args_element_name_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_9 );

            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_d860a737664a16683e8d212dd9ae54eb->m_frame.f_lineno = 624;
        {
            PyObject *call_args[] = { tmp_args_element_name_16 };
            tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
        }

        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_16 );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 624;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d860a737664a16683e8d212dd9ae54eb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_d860a737664a16683e8d212dd9ae54eb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_d860a737664a16683e8d212dd9ae54eb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d860a737664a16683e8d212dd9ae54eb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d860a737664a16683e8d212dd9ae54eb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d860a737664a16683e8d212dd9ae54eb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d860a737664a16683e8d212dd9ae54eb,
        type_description_1,
        par_self,
        par_name,
        var_result_buffer,
        var_data_length,
        var_nid,
        var_result,
        var_entry_index,
        var_entry,
        var_data
    );


    // Release cached frame.
    if ( frame_d860a737664a16683e8d212dd9ae54eb == cache_frame_d860a737664a16683e8d212dd9ae54eb )
    {
        Py_DECREF( frame_d860a737664a16683e8d212dd9ae54eb );
    }
    cache_frame_d860a737664a16683e8d212dd9ae54eb = NULL;

    assertFrameObject( frame_d860a737664a16683e8d212dd9ae54eb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_28___getattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data_length );
    var_data_length = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_entry_index );
    var_entry_index = NULL;

    Py_XDECREF( var_entry );
    var_entry = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_data_length );
    var_data_length = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_entry_index );
    var_entry_index = NULL;

    Py_XDECREF( var_entry );
    var_entry = NULL;

    Py_XDECREF( var_data );
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_28___getattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_29__cmp( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_op = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_f = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_op;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );


        assert( var_f == NULL );
        var_f = tmp_assign_source_1;
    }
    // Tried code:
    CHECK_OBJECT( var_f );
    tmp_return_value = var_f;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_f );
    Py_DECREF( var_f );
    var_f = NULL;

    CHECK_OBJECT( (PyObject *)par_op );
    Py_DECREF( par_op );
    par_op = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_29__cmp$$$function_1_f( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_1772a6013264994a984e605cd7a40693;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_1772a6013264994a984e605cd7a40693 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1772a6013264994a984e605cd7a40693, codeobj_1772a6013264994a984e605cd7a40693, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1772a6013264994a984e605cd7a40693 = cache_frame_1772a6013264994a984e605cd7a40693;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1772a6013264994a984e605cd7a40693 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1772a6013264994a984e605cd7a40693 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_other );
        tmp_isinstance_inst_1 = par_other;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 629;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 629;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 629;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_NotImplemented;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_cmp );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_3 = par_other;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__name );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        frame_1772a6013264994a984e605cd7a40693->m_frame.f_lineno = 631;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 631;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "op" );
            exception_tb = NULL;

            exception_lineno = 632;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = PyCell_GET( self->m_closure[0] );
        CHECK_OBJECT( var_result );
        tmp_args_element_name_3 = var_result;
        tmp_args_element_name_4 = const_int_0;
        frame_1772a6013264994a984e605cd7a40693->m_frame.f_lineno = 632;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 632;
            type_description_1 = "oooc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1772a6013264994a984e605cd7a40693 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1772a6013264994a984e605cd7a40693 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1772a6013264994a984e605cd7a40693 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1772a6013264994a984e605cd7a40693, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1772a6013264994a984e605cd7a40693->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1772a6013264994a984e605cd7a40693, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1772a6013264994a984e605cd7a40693,
        type_description_1,
        par_self,
        par_other,
        var_result,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_1772a6013264994a984e605cd7a40693 == cache_frame_1772a6013264994a984e605cd7a40693 )
    {
        Py_DECREF( frame_1772a6013264994a984e605cd7a40693 );
    }
    cache_frame_1772a6013264994a984e605cd7a40693 = NULL;

    assertFrameObject( frame_1772a6013264994a984e605cd7a40693 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp$$$function_1_f );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_29__cmp$$$function_1_f );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_30___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result_buffer = NULL;
    PyObject *var_format_result = NULL;
    struct Nuitka_FrameObject *frame_78f117206d8a841a588d9bb177b70ecd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_78f117206d8a841a588d9bb177b70ecd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_78f117206d8a841a588d9bb177b70ecd, codeobj_78f117206d8a841a588d9bb177b70ecd, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_78f117206d8a841a588d9bb177b70ecd = cache_frame_78f117206d8a841a588d9bb177b70ecd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_78f117206d8a841a588d9bb177b70ecd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_78f117206d8a841a588d9bb177b70ecd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_78f117206d8a841a588d9bb177b70ecd->m_frame.f_lineno = 648;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_c561652c58984ec0e9541542aa405594_int_pos_512_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 648;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_buffer == NULL );
        var_result_buffer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 649;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_oneline );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 649;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 650;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_args_element_name_2 = var_result_buffer;
        CHECK_OBJECT( var_result_buffer );
        tmp_len_arg_1 = var_result_buffer;
        tmp_args_element_name_3 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 650;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_78f117206d8a841a588d9bb177b70ecd->m_frame.f_lineno = 649;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 649;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_format_result == NULL );
        var_format_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_format_result );
        tmp_compexpr_left_1 = var_format_result;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_78f117206d8a841a588d9bb177b70ecd->m_frame.f_lineno = 651;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 651;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_left_name_1 = const_str_digest_169aa7f0589e4a3c83203d48f57770af;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
            exception_tb = NULL;

            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_6;
        CHECK_OBJECT( var_result_buffer );
        tmp_args_element_name_6 = var_result_buffer;
        frame_78f117206d8a841a588d9bb177b70ecd->m_frame.f_lineno = 654;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_args_element_name_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_string, call_args );
        }

        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_78f117206d8a841a588d9bb177b70ecd->m_frame.f_lineno = 654;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 654;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_1 = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
        tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 653;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78f117206d8a841a588d9bb177b70ecd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_78f117206d8a841a588d9bb177b70ecd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78f117206d8a841a588d9bb177b70ecd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_78f117206d8a841a588d9bb177b70ecd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_78f117206d8a841a588d9bb177b70ecd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_78f117206d8a841a588d9bb177b70ecd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_78f117206d8a841a588d9bb177b70ecd,
        type_description_1,
        par_self,
        var_result_buffer,
        var_format_result
    );


    // Release cached frame.
    if ( frame_78f117206d8a841a588d9bb177b70ecd == cache_frame_78f117206d8a841a588d9bb177b70ecd )
    {
        Py_DECREF( frame_78f117206d8a841a588d9bb177b70ecd );
    }
    cache_frame_78f117206d8a841a588d9bb177b70ecd = NULL;

    assertFrameObject( frame_78f117206d8a841a588d9bb177b70ecd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_30___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_format_result );
    Py_DECREF( var_format_result );
    var_format_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_format_result );
    var_format_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_30___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_31_hash( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f108fefac443a30560644004e534a6dd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f108fefac443a30560644004e534a6dd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f108fefac443a30560644004e534a6dd, codeobj_f108fefac443a30560644004e534a6dd, module_OpenSSL$crypto, sizeof(void *) );
    frame_f108fefac443a30560644004e534a6dd = cache_frame_f108fefac443a30560644004e534a6dd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f108fefac443a30560644004e534a6dd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f108fefac443a30560644004e534a6dd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_hash );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_f108fefac443a30560644004e534a6dd->m_frame.f_lineno = 666;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 666;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f108fefac443a30560644004e534a6dd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f108fefac443a30560644004e534a6dd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f108fefac443a30560644004e534a6dd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f108fefac443a30560644004e534a6dd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f108fefac443a30560644004e534a6dd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f108fefac443a30560644004e534a6dd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f108fefac443a30560644004e534a6dd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f108fefac443a30560644004e534a6dd == cache_frame_f108fefac443a30560644004e534a6dd )
    {
        Py_DECREF( frame_f108fefac443a30560644004e534a6dd );
    }
    cache_frame_f108fefac443a30560644004e534a6dd = NULL;

    assertFrameObject( frame_f108fefac443a30560644004e534a6dd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_31_hash );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_31_hash );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_32_der( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_result_buffer = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_encode_result = NULL;
    struct Nuitka_FrameObject *frame_459e5c608fc9cc34bd5565608d5b7717;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_459e5c608fc9cc34bd5565608d5b7717 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_459e5c608fc9cc34bd5565608d5b7717, codeobj_459e5c608fc9cc34bd5565608d5b7717, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_459e5c608fc9cc34bd5565608d5b7717 = cache_frame_459e5c608fc9cc34bd5565608d5b7717;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_459e5c608fc9cc34bd5565608d5b7717 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_459e5c608fc9cc34bd5565608d5b7717 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 675;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_459e5c608fc9cc34bd5565608d5b7717->m_frame.f_lineno = 675;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_5339fa8ff3df372e54ef7b09078767aa_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 675;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_buffer == NULL );
        var_result_buffer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_i2d_X509_NAME );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_args_element_name_2 = var_result_buffer;
        frame_459e5c608fc9cc34bd5565608d5b7717->m_frame.f_lineno = 676;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 676;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_encode_result == NULL );
        var_encode_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 677;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_encode_result );
        tmp_compexpr_left_1 = var_encode_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_3 = RICH_COMPARE_GTE_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 677;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_459e5c608fc9cc34bd5565608d5b7717->m_frame.f_lineno = 677;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 677;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_3;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_5;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_buffer );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_subscribed_name_1 = var_result_buffer;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_encode_result );
        tmp_args_element_name_5 = var_encode_result;
        frame_459e5c608fc9cc34bd5565608d5b7717->m_frame.f_lineno = 679;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 679;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_string_result == NULL );
        var_string_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_OPENSSL_free );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_buffer );
        tmp_subscribed_name_2 = var_result_buffer;
        tmp_subscript_name_2 = const_int_0;
        tmp_args_element_name_6 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_459e5c608fc9cc34bd5565608d5b7717->m_frame.f_lineno = 680;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 680;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_459e5c608fc9cc34bd5565608d5b7717 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_459e5c608fc9cc34bd5565608d5b7717 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_459e5c608fc9cc34bd5565608d5b7717, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_459e5c608fc9cc34bd5565608d5b7717->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_459e5c608fc9cc34bd5565608d5b7717, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_459e5c608fc9cc34bd5565608d5b7717,
        type_description_1,
        par_self,
        var_result_buffer,
        var_string_result,
        var_encode_result
    );


    // Release cached frame.
    if ( frame_459e5c608fc9cc34bd5565608d5b7717 == cache_frame_459e5c608fc9cc34bd5565608d5b7717 )
    {
        Py_DECREF( frame_459e5c608fc9cc34bd5565608d5b7717 );
    }
    cache_frame_459e5c608fc9cc34bd5565608d5b7717 = NULL;

    assertFrameObject( frame_459e5c608fc9cc34bd5565608d5b7717 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_string_result );
    tmp_return_value = var_string_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_32_der );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_string_result );
    Py_DECREF( var_string_result );
    var_string_result = NULL;

    CHECK_OBJECT( (PyObject *)var_encode_result );
    Py_DECREF( var_encode_result );
    var_encode_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_encode_result );
    var_encode_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_32_der );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_33_get_components( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_value = NULL;
    PyObject *var_name = NULL;
    PyObject *var_i = NULL;
    PyObject *var_nid = NULL;
    PyObject *var_fval = NULL;
    PyObject *var_ent = NULL;
    PyObject *var_result = NULL;
    PyObject *var_fname = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_d8c8cfa251a7ea6bd085c75d033cb23e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_d8c8cfa251a7ea6bd085c75d033cb23e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New( 0 );
        assert( var_result == NULL );
        var_result = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d8c8cfa251a7ea6bd085c75d033cb23e, codeobj_d8c8cfa251a7ea6bd085c75d033cb23e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d8c8cfa251a7ea6bd085c75d033cb23e = cache_frame_d8c8cfa251a7ea6bd085c75d033cb23e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d8c8cfa251a7ea6bd085c75d033cb23e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d8c8cfa251a7ea6bd085c75d033cb23e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_entry_count );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 691;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 691;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooooo";
                exception_lineno = 691;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_4;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_NAME_get_entry );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_i );
        tmp_args_element_name_3 = var_i;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 692;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 692;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ent;
            var_ent = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 694;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_ent );
        tmp_args_element_name_4 = var_ent;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 694;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_NAME_ENTRY_get_object, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 694;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_fname;
            var_fname = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 695;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT( var_ent );
        tmp_args_element_name_5 = var_ent;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 695;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509_NAME_ENTRY_get_data, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 695;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_fval;
            var_fval = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 697;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT( var_fname );
        tmp_args_element_name_6 = var_fname;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 697;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_OBJ_obj2nid, call_args );
        }

        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 697;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_nid;
            var_nid = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 698;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_4 = tmp_mvar_value_6;
        CHECK_OBJECT( var_nid );
        tmp_args_element_name_7 = var_nid;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 698;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_OBJ_nid2sn, call_args );
        }

        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 698;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_9;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_10;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_11;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_buffer );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_5 = tmp_mvar_value_8;
        CHECK_OBJECT( var_fval );
        tmp_args_element_name_9 = var_fval;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 702;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_args_element_name_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_ASN1_STRING_data, call_args );
        }

        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_8 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 703;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_6 = tmp_mvar_value_9;
        CHECK_OBJECT( var_fval );
        tmp_args_element_name_11 = var_fval;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 703;
        {
            PyObject *call_args[] = { tmp_args_element_name_11 };
            tmp_args_element_name_10 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_ASN1_STRING_length, call_args );
        }

        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_8 );

            exception_lineno = 703;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 702;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_10 };
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_8 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_10 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 702;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_value;
            var_value = tmp_assign_source_10;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_13;
        CHECK_OBJECT( var_result );
        tmp_source_name_6 = var_result;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_append );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_10 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_7 = tmp_mvar_value_10;
        CHECK_OBJECT( var_name );
        tmp_args_element_name_13 = var_name;
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 704;
        {
            PyObject *call_args[] = { tmp_args_element_name_13 };
            tmp_tuple_element_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_string, call_args );
        }

        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_12 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_args_element_name_12, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( var_value );
        tmp_tuple_element_1 = var_value;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_element_name_12, 1, tmp_tuple_element_1 );
        frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame.f_lineno = 704;
        {
            PyObject *call_args[] = { tmp_args_element_name_12 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_12 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 704;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 691;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8c8cfa251a7ea6bd085c75d033cb23e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d8c8cfa251a7ea6bd085c75d033cb23e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d8c8cfa251a7ea6bd085c75d033cb23e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d8c8cfa251a7ea6bd085c75d033cb23e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d8c8cfa251a7ea6bd085c75d033cb23e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d8c8cfa251a7ea6bd085c75d033cb23e,
        type_description_1,
        par_self,
        var_value,
        var_name,
        var_i,
        var_nid,
        var_fval,
        var_ent,
        var_result,
        var_fname
    );


    // Release cached frame.
    if ( frame_d8c8cfa251a7ea6bd085c75d033cb23e == cache_frame_d8c8cfa251a7ea6bd085c75d033cb23e )
    {
        Py_DECREF( frame_d8c8cfa251a7ea6bd085c75d033cb23e );
    }
    cache_frame_d8c8cfa251a7ea6bd085c75d033cb23e = NULL;

    assertFrameObject( frame_d8c8cfa251a7ea6bd085c75d033cb23e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_33_get_components );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_fval );
    var_fval = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_fname );
    var_fname = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    Py_XDECREF( var_fval );
    var_fval = NULL;

    Py_XDECREF( var_ent );
    var_ent = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_fname );
    var_fname = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_33_get_components );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_34___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type_name = python_pars[ 1 ];
    PyObject *par_critical = python_pars[ 2 ];
    PyObject *par_value = python_pars[ 3 ];
    PyObject *par_subject = python_pars[ 4 ];
    PyObject *par_issuer = python_pars[ 5 ];
    PyObject *var_extension = NULL;
    PyObject *var_ctx = NULL;
    struct Nuitka_FrameObject *frame_9ff3a88728c4c3ad3cab48c082dc7fb8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_9ff3a88728c4c3ad3cab48c082dc7fb8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9ff3a88728c4c3ad3cab48c082dc7fb8, codeobj_9ff3a88728c4c3ad3cab48c082dc7fb8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9ff3a88728c4c3ad3cab48c082dc7fb8 = cache_frame_9ff3a88728c4c3ad3cab48c082dc7fb8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9ff3a88728c4c3ad3cab48c082dc7fb8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9ff3a88728c4c3ad3cab48c082dc7fb8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 743;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 743;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_f3b04f8993b30e664e4afacb3d64cdc4_tuple, 0 ) );

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 743;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_ctx == NULL );
        var_ctx = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509V3_set_ctx );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ctx );
        tmp_args_element_name_1 = var_ctx;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_args_element_name_4 );

            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_6 = const_int_0;
        frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 748;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS6( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 748;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 752;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_7;
        CHECK_OBJECT( var_ctx );
        tmp_args_element_name_7 = var_ctx;
        frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 752;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_X509V3_set_ctx_nodb, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 752;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_issuer );
        tmp_compexpr_left_1 = par_issuer;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT( par_issuer );
            tmp_isinstance_inst_1 = par_issuer;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
                exception_tb = NULL;

                exception_lineno = 759;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_8;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 759;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 759;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_7163953ad9ff69e46167d396f5625cf7;
                frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 760;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 760;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_source_name_6;
            PyObject *tmp_assattr_target_1;
            CHECK_OBJECT( par_issuer );
            tmp_source_name_6 = par_issuer;
            tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
            if ( tmp_assattr_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 761;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_ctx );
            tmp_assattr_target_1 = var_ctx;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_issuer_cert, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 761;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_subject );
        tmp_compexpr_left_2 = par_subject;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_mvar_value_9;
            CHECK_OBJECT( par_subject );
            tmp_isinstance_inst_2 = par_subject;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
                exception_tb = NULL;

                exception_lineno = 763;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_2 = tmp_mvar_value_9;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 763;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 763;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_3c820c2fc1d76f73132dab0e4e8d3a14;
                frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 764;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 764;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_source_name_7;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( par_subject );
            tmp_source_name_7 = par_subject;
            tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__x509 );
            if ( tmp_assattr_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 765;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_ctx );
            tmp_assattr_target_2 = var_ctx;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_subject_cert, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 765;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_critical );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_critical );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 767;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            tmp_left_name_1 = const_str_digest_3c5d018dd809b9a6147c1b47d39e8d31;
            CHECK_OBJECT( par_value );
            tmp_right_name_1 = par_value;
            tmp_assign_source_2 = BINARY_OPERATION_ADD_STR_OBJECT( tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 775;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_value;
                assert( old != NULL );
                par_value = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_10;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509V3_EXT_nconf );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_11;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_NULL );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ctx );
        tmp_args_element_name_9 = var_ctx;
        CHECK_OBJECT( par_type_name );
        tmp_args_element_name_10 = par_type_name;
        CHECK_OBJECT( par_value );
        tmp_args_element_name_11 = par_value;
        frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 777;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 777;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_extension == NULL );
        var_extension = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_12;
        CHECK_OBJECT( var_extension );
        tmp_compexpr_left_3 = var_extension;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 778;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_12;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 778;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 778;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_13;
            PyObject *tmp_call_result_3;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_13 == NULL ))
            {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_13 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 779;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_13;
            frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 779;
            tmp_call_result_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 779;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_11;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_assattr_target_3;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = tmp_mvar_value_14;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_extension );
        tmp_args_element_name_12 = var_extension;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_15 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_15;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_X509_EXTENSION_free );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame.f_lineno = 780;
        {
            PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
            tmp_assattr_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_13 );
        if ( tmp_assattr_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__extension, tmp_assattr_name_3 );
        Py_DECREF( tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 780;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ff3a88728c4c3ad3cab48c082dc7fb8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ff3a88728c4c3ad3cab48c082dc7fb8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9ff3a88728c4c3ad3cab48c082dc7fb8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9ff3a88728c4c3ad3cab48c082dc7fb8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9ff3a88728c4c3ad3cab48c082dc7fb8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9ff3a88728c4c3ad3cab48c082dc7fb8,
        type_description_1,
        par_self,
        par_type_name,
        par_critical,
        par_value,
        par_subject,
        par_issuer,
        var_extension,
        var_ctx
    );


    // Release cached frame.
    if ( frame_9ff3a88728c4c3ad3cab48c082dc7fb8 == cache_frame_9ff3a88728c4c3ad3cab48c082dc7fb8 )
    {
        Py_DECREF( frame_9ff3a88728c4c3ad3cab48c082dc7fb8 );
    }
    cache_frame_9ff3a88728c4c3ad3cab48c082dc7fb8 = NULL;

    assertFrameObject( frame_9ff3a88728c4c3ad3cab48c082dc7fb8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_34___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_extension );
    Py_DECREF( var_extension );
    var_extension = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type_name );
    Py_DECREF( par_type_name );
    par_type_name = NULL;

    CHECK_OBJECT( (PyObject *)var_ctx );
    Py_DECREF( var_ctx );
    var_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_critical );
    Py_DECREF( par_critical );
    par_critical = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_extension );
    var_extension = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type_name );
    Py_DECREF( par_type_name );
    par_type_name = NULL;

    Py_XDECREF( var_ctx );
    var_ctx = NULL;

    Py_XDECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_critical );
    Py_DECREF( par_critical );
    par_critical = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_34___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_35__nid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_78e8acd21cb941da83b042ef8579466b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_78e8acd21cb941da83b042ef8579466b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_78e8acd21cb941da83b042ef8579466b, codeobj_78e8acd21cb941da83b042ef8579466b, module_OpenSSL$crypto, sizeof(void *) );
    frame_78e8acd21cb941da83b042ef8579466b = cache_frame_78e8acd21cb941da83b042ef8579466b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_78e8acd21cb941da83b042ef8579466b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_78e8acd21cb941da83b042ef8579466b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 784;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OBJ_obj2nid );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_EXTENSION_get_object );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__extension );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_78e8acd21cb941da83b042ef8579466b->m_frame.f_lineno = 785;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 785;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_78e8acd21cb941da83b042ef8579466b->m_frame.f_lineno = 784;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 784;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78e8acd21cb941da83b042ef8579466b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_78e8acd21cb941da83b042ef8579466b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_78e8acd21cb941da83b042ef8579466b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_78e8acd21cb941da83b042ef8579466b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_78e8acd21cb941da83b042ef8579466b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_78e8acd21cb941da83b042ef8579466b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_78e8acd21cb941da83b042ef8579466b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_78e8acd21cb941da83b042ef8579466b == cache_frame_78e8acd21cb941da83b042ef8579466b )
    {
        Py_DECREF( frame_78e8acd21cb941da83b042ef8579466b );
    }
    cache_frame_78e8acd21cb941da83b042ef8579466b = NULL;

    assertFrameObject( frame_78e8acd21cb941da83b042ef8579466b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_35__nid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_35__nid );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_36__subjectAltNameString( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_name = NULL;
    PyObject *var_i = NULL;
    PyObject *var_value = NULL;
    PyObject *var_label = NULL;
    PyObject *var_parts = NULL;
    PyObject *var_names = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_try_except_1__unhandled_indicator = NULL;
    struct Nuitka_FrameObject *frame_c99ce10f3d0860a31e6597cc2063e968;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c99ce10f3d0860a31e6597cc2063e968 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c99ce10f3d0860a31e6597cc2063e968, codeobj_c99ce10f3d0860a31e6597cc2063e968, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c99ce10f3d0860a31e6597cc2063e968 = cache_frame_c99ce10f3d0860a31e6597cc2063e968;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c99ce10f3d0860a31e6597cc2063e968 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c99ce10f3d0860a31e6597cc2063e968 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 795;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cast );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 795;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = const_str_digest_1dbb147d3e039266688c4d87287eaaad;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509V3_EXT_d2i );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__extension );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 796;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 796;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 795;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 795;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_names == NULL );
        var_names = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_names );
        tmp_args_element_name_4 = var_names;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_GENERAL_NAMES_free );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 799;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 799;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_names;
            assert( old != NULL );
            var_names = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New( 0 );
        assert( var_parts == NULL );
        var_parts = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT( var_names );
        tmp_args_element_name_6 = var_names;
        frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 801;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_GENERAL_NAME_num, call_args );
        }

        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 801;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                exception_lineno = 801;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_6;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 802;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_6;
        CHECK_OBJECT( var_names );
        tmp_args_element_name_7 = var_names;
        CHECK_OBJECT( var_i );
        tmp_args_element_name_8 = var_i;
        frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 802;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_GENERAL_NAME_value, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 802;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_name;
            var_name = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_8;
        tmp_assign_source_8 = Py_True;
        {
            PyObject *old = tmp_try_except_1__unhandled_indicator;
            tmp_try_except_1__unhandled_indicator = tmp_assign_source_8;
            Py_INCREF( tmp_try_except_1__unhandled_indicator );
            Py_XDECREF( old );
        }

    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_6;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_source_name_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__prefixes );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 804;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        CHECK_OBJECT( var_name );
        tmp_source_name_7 = var_name;
        tmp_subscript_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_type );
        if ( tmp_subscript_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_subscribed_name_1 );

            exception_lineno = 804;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        tmp_assign_source_9 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        Py_DECREF( tmp_subscript_name_1 );
        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 804;
            type_description_1 = "oooooooo";
            goto try_except_handler_4;
        }
        {
            PyObject *old = var_label;
            var_label = tmp_assign_source_9;
            Py_XDECREF( old );
        }

    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_assign_source_10;
        tmp_assign_source_10 = Py_False;
        {
            PyObject *old = tmp_try_except_1__unhandled_indicator;
            assert( old != NULL );
            tmp_try_except_1__unhandled_indicator = tmp_assign_source_10;
            Py_INCREF( tmp_try_except_1__unhandled_indicator );
            Py_DECREF( old );
        }

    }
    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_c99ce10f3d0860a31e6597cc2063e968 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_c99ce10f3d0860a31e6597cc2063e968, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_c99ce10f3d0860a31e6597cc2063e968, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_KeyError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 805;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
                exception_tb = NULL;

                exception_lineno = 806;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_4 = tmp_mvar_value_7;
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 806;
            tmp_assign_source_11 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_assign_source_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 806;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            {
                PyObject *old = var_bio;
                var_bio = tmp_assign_source_11;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 807;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_instance_3 = tmp_mvar_value_8;
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_9 = var_bio;
            CHECK_OBJECT( var_name );
            tmp_args_element_name_10 = var_name;
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 807;
            {
                PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_GENERAL_NAME_print, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 807;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_8;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_called_name_7;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_args_element_name_13;
            CHECK_OBJECT( var_parts );
            tmp_source_name_8 = var_parts;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_append );
            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
            }

            if ( tmp_mvar_value_9 == NULL )
            {
                Py_DECREF( tmp_called_name_5 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
                exception_tb = NULL;

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_6 = tmp_mvar_value_9;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
            }

            if ( tmp_mvar_value_10 == NULL )
            {
                Py_DECREF( tmp_called_name_5 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
                exception_tb = NULL;

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_7 = tmp_mvar_value_10;
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_13 = var_bio;
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 808;
            {
                PyObject *call_args[] = { tmp_args_element_name_13 };
                tmp_args_element_name_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
            }

            if ( tmp_args_element_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 808;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_args_element_name_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_args_element_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 808;
            {
                PyObject *call_args[] = { tmp_args_element_name_11 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_11 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 808;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 803;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_c99ce10f3d0860a31e6597cc2063e968->m_frame) frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
        branch_end_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_36__subjectAltNameString );
    return NULL;
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_2;
        nuitka_bool tmp_compexpr_left_2;
        nuitka_bool tmp_compexpr_right_2;
        int tmp_truth_name_1;
        CHECK_OBJECT( tmp_try_except_1__unhandled_indicator );
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_try_except_1__unhandled_indicator );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 803;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_compexpr_left_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_compexpr_right_2 = NUITKA_BOOL_TRUE;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_14;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_called_name_9;
            PyObject *tmp_source_name_9;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_source_name_10;
            PyObject *tmp_source_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_args_element_name_16;
            PyObject *tmp_source_name_13;
            PyObject *tmp_source_name_14;
            PyObject *tmp_source_name_15;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
                exception_tb = NULL;

                exception_lineno = 810;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_called_name_8 = tmp_mvar_value_11;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_source_name_9 = tmp_mvar_value_12;
            tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_buffer );
            if ( tmp_called_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT( var_name );
            tmp_source_name_12 = var_name;
            tmp_source_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_d );
            if ( tmp_source_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_source_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_ia5 );
            Py_DECREF( tmp_source_name_11 );
            if ( tmp_source_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_data );
            Py_DECREF( tmp_source_name_10 );
            if ( tmp_args_element_name_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT( var_name );
            tmp_source_name_15 = var_name;
            tmp_source_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_d );
            if ( tmp_source_name_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );
                Py_DECREF( tmp_args_element_name_15 );

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_source_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_ia5 );
            Py_DECREF( tmp_source_name_14 );
            if ( tmp_source_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );
                Py_DECREF( tmp_args_element_name_15 );

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_args_element_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_length );
            Py_DECREF( tmp_source_name_13 );
            if ( tmp_args_element_name_16 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_9 );
                Py_DECREF( tmp_args_element_name_15 );

                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 811;
            {
                PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16 };
                tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_9, call_args );
            }

            Py_DECREF( tmp_called_name_9 );
            Py_DECREF( tmp_args_element_name_15 );
            Py_DECREF( tmp_args_element_name_16 );
            if ( tmp_slice_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            tmp_args_element_name_14 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
            Py_DECREF( tmp_slice_source_1 );
            if ( tmp_args_element_name_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 811;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 810;
            {
                PyObject *call_args[] = { tmp_args_element_name_14 };
                tmp_assign_source_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
            }

            Py_DECREF( tmp_args_element_name_14 );
            if ( tmp_assign_source_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 810;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            {
                PyObject *old = var_value;
                var_value = tmp_assign_source_12;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_source_name_16;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_17;
            PyObject *tmp_left_name_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_1;
            PyObject *tmp_right_name_2;
            CHECK_OBJECT( var_parts );
            tmp_source_name_16 = var_parts;
            tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_append );
            if ( tmp_called_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            if ( var_label == NULL )
            {
                Py_DECREF( tmp_called_name_10 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "label" );
                exception_tb = NULL;

                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }

            tmp_left_name_2 = var_label;
            tmp_right_name_1 = const_str_chr_58;
            tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_STR( tmp_left_name_2, tmp_right_name_1 );
            if ( tmp_left_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_10 );

                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            CHECK_OBJECT( var_value );
            tmp_right_name_2 = var_value;
            tmp_args_element_name_17 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
            Py_DECREF( tmp_left_name_1 );
            if ( tmp_args_element_name_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_10 );

                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 812;
            {
                PyObject *call_args[] = { tmp_args_element_name_17 };
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
            }

            Py_DECREF( tmp_called_name_10 );
            Py_DECREF( tmp_args_element_name_17 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 812;
                type_description_1 = "oooooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        branch_no_2:;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_try_except_1__unhandled_indicator );
    tmp_try_except_1__unhandled_indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_try_except_1__unhandled_indicator );
    Py_DECREF( tmp_try_except_1__unhandled_indicator );
    tmp_try_except_1__unhandled_indicator = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 801;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_args_element_name_18;
        tmp_called_instance_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
        CHECK_OBJECT( var_parts );
        tmp_args_element_name_18 = var_parts;
        frame_c99ce10f3d0860a31e6597cc2063e968->m_frame.f_lineno = 813;
        {
            PyObject *call_args[] = { tmp_args_element_name_18 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_join, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 813;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_c99ce10f3d0860a31e6597cc2063e968 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_c99ce10f3d0860a31e6597cc2063e968 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_c99ce10f3d0860a31e6597cc2063e968 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c99ce10f3d0860a31e6597cc2063e968, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c99ce10f3d0860a31e6597cc2063e968->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c99ce10f3d0860a31e6597cc2063e968, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c99ce10f3d0860a31e6597cc2063e968,
        type_description_1,
        par_self,
        var_bio,
        var_name,
        var_i,
        var_value,
        var_label,
        var_parts,
        var_names
    );


    // Release cached frame.
    if ( frame_c99ce10f3d0860a31e6597cc2063e968 == cache_frame_c99ce10f3d0860a31e6597cc2063e968 )
    {
        Py_DECREF( frame_c99ce10f3d0860a31e6597cc2063e968 );
    }
    cache_frame_c99ce10f3d0860a31e6597cc2063e968 = NULL;

    assertFrameObject( frame_c99ce10f3d0860a31e6597cc2063e968 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_36__subjectAltNameString );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_label );
    var_label = NULL;

    CHECK_OBJECT( (PyObject *)var_parts );
    Py_DECREF( var_parts );
    var_parts = NULL;

    CHECK_OBJECT( (PyObject *)var_names );
    Py_DECREF( var_names );
    var_names = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_label );
    var_label = NULL;

    Py_XDECREF( var_parts );
    var_parts = NULL;

    Py_XDECREF( var_names );
    var_names = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_36__subjectAltNameString );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_37___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_print_result = NULL;
    struct Nuitka_FrameObject *frame_8f3d95c9a6254aa6ef78af56f493d9f8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8f3d95c9a6254aa6ef78af56f493d9f8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f3d95c9a6254aa6ef78af56f493d9f8, codeobj_8f3d95c9a6254aa6ef78af56f493d9f8, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8f3d95c9a6254aa6ef78af56f493d9f8 = cache_frame_8f3d95c9a6254aa6ef78af56f493d9f8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f3d95c9a6254aa6ef78af56f493d9f8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f3d95c9a6254aa6ef78af56f493d9f8 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NID_subject_alt_name );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__nid );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 819;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            frame_8f3d95c9a6254aa6ef78af56f493d9f8->m_frame.f_lineno = 820;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__subjectAltNameString );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 820;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 822;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        frame_8f3d95c9a6254aa6ef78af56f493d9f8->m_frame.f_lineno = 822;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 822;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509V3_EXT_print );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_1 = var_bio;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__extension );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_int_0;
        tmp_args_element_name_4 = const_int_0;
        frame_8f3d95c9a6254aa6ef78af56f493d9f8->m_frame.f_lineno = 823;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 823;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_print_result == NULL );
        var_print_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 824;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT( var_print_result );
        tmp_compexpr_left_2 = var_print_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 824;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_8f3d95c9a6254aa6ef78af56f493d9f8->m_frame.f_lineno = 824;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 824;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
            exception_tb = NULL;

            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_6;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_7 = var_bio;
        frame_8f3d95c9a6254aa6ef78af56f493d9f8->m_frame.f_lineno = 826;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_args_element_name_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_8f3d95c9a6254aa6ef78af56f493d9f8->m_frame.f_lineno = 826;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 826;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f3d95c9a6254aa6ef78af56f493d9f8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f3d95c9a6254aa6ef78af56f493d9f8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f3d95c9a6254aa6ef78af56f493d9f8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f3d95c9a6254aa6ef78af56f493d9f8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f3d95c9a6254aa6ef78af56f493d9f8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f3d95c9a6254aa6ef78af56f493d9f8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f3d95c9a6254aa6ef78af56f493d9f8,
        type_description_1,
        par_self,
        var_bio,
        var_print_result
    );


    // Release cached frame.
    if ( frame_8f3d95c9a6254aa6ef78af56f493d9f8 == cache_frame_8f3d95c9a6254aa6ef78af56f493d9f8 )
    {
        Py_DECREF( frame_8f3d95c9a6254aa6ef78af56f493d9f8 );
    }
    cache_frame_8f3d95c9a6254aa6ef78af56f493d9f8 = NULL;

    assertFrameObject( frame_8f3d95c9a6254aa6ef78af56f493d9f8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_37___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_37___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_38_get_critical( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_07e8a0b0547d18c5e7adbf11c5000bd2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_07e8a0b0547d18c5e7adbf11c5000bd2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_07e8a0b0547d18c5e7adbf11c5000bd2, codeobj_07e8a0b0547d18c5e7adbf11c5000bd2, module_OpenSSL$crypto, sizeof(void *) );
    frame_07e8a0b0547d18c5e7adbf11c5000bd2 = cache_frame_07e8a0b0547d18c5e7adbf11c5000bd2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_07e8a0b0547d18c5e7adbf11c5000bd2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_07e8a0b0547d18c5e7adbf11c5000bd2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_EXTENSION_get_critical );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__extension );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_07e8a0b0547d18c5e7adbf11c5000bd2->m_frame.f_lineno = 834;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 834;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_07e8a0b0547d18c5e7adbf11c5000bd2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_07e8a0b0547d18c5e7adbf11c5000bd2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_07e8a0b0547d18c5e7adbf11c5000bd2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_07e8a0b0547d18c5e7adbf11c5000bd2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_07e8a0b0547d18c5e7adbf11c5000bd2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_07e8a0b0547d18c5e7adbf11c5000bd2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_07e8a0b0547d18c5e7adbf11c5000bd2,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_07e8a0b0547d18c5e7adbf11c5000bd2 == cache_frame_07e8a0b0547d18c5e7adbf11c5000bd2 )
    {
        Py_DECREF( frame_07e8a0b0547d18c5e7adbf11c5000bd2 );
    }
    cache_frame_07e8a0b0547d18c5e7adbf11c5000bd2 = NULL;

    assertFrameObject( frame_07e8a0b0547d18c5e7adbf11c5000bd2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_38_get_critical );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_38_get_critical );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_39_get_short_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_obj = NULL;
    PyObject *var_nid = NULL;
    struct Nuitka_FrameObject *frame_cf6f76fdcb2c9248257e81564c818063;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cf6f76fdcb2c9248257e81564c818063 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cf6f76fdcb2c9248257e81564c818063, codeobj_cf6f76fdcb2c9248257e81564c818063, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_cf6f76fdcb2c9248257e81564c818063 = cache_frame_cf6f76fdcb2c9248257e81564c818063;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cf6f76fdcb2c9248257e81564c818063 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cf6f76fdcb2c9248257e81564c818063 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_EXTENSION_get_object );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__extension );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cf6f76fdcb2c9248257e81564c818063->m_frame.f_lineno = 847;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 847;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_obj == NULL );
        var_obj = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 848;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_obj );
        tmp_args_element_name_2 = var_obj;
        frame_cf6f76fdcb2c9248257e81564c818063->m_frame.f_lineno = 848;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_OBJ_obj2nid, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 848;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_nid == NULL );
        var_nid = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_string );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT( var_nid );
        tmp_args_element_name_4 = var_nid;
        frame_cf6f76fdcb2c9248257e81564c818063->m_frame.f_lineno = 849;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_nid2sn, call_args );
        }

        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_cf6f76fdcb2c9248257e81564c818063->m_frame.f_lineno = 849;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf6f76fdcb2c9248257e81564c818063 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf6f76fdcb2c9248257e81564c818063 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cf6f76fdcb2c9248257e81564c818063 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cf6f76fdcb2c9248257e81564c818063, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cf6f76fdcb2c9248257e81564c818063->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cf6f76fdcb2c9248257e81564c818063, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cf6f76fdcb2c9248257e81564c818063,
        type_description_1,
        par_self,
        var_obj,
        var_nid
    );


    // Release cached frame.
    if ( frame_cf6f76fdcb2c9248257e81564c818063 == cache_frame_cf6f76fdcb2c9248257e81564c818063 )
    {
        Py_DECREF( frame_cf6f76fdcb2c9248257e81564c818063 );
    }
    cache_frame_cf6f76fdcb2c9248257e81564c818063 = NULL;

    assertFrameObject( frame_cf6f76fdcb2c9248257e81564c818063 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_39_get_short_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_obj );
    Py_DECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_39_get_short_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_40_get_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_char_result = NULL;
    PyObject *var_octet_result = NULL;
    PyObject *var_string_result = NULL;
    PyObject *var_result_length = NULL;
    struct Nuitka_FrameObject *frame_95f4633cd0b82a09b30e9e453fe96c0e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_95f4633cd0b82a09b30e9e453fe96c0e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_95f4633cd0b82a09b30e9e453fe96c0e, codeobj_95f4633cd0b82a09b30e9e453fe96c0e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_95f4633cd0b82a09b30e9e453fe96c0e = cache_frame_95f4633cd0b82a09b30e9e453fe96c0e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_95f4633cd0b82a09b30e9e453fe96c0e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_95f4633cd0b82a09b30e9e453fe96c0e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_EXTENSION_get_data );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__extension );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_95f4633cd0b82a09b30e9e453fe96c0e->m_frame.f_lineno = 860;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 860;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_octet_result == NULL );
        var_octet_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 861;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        tmp_args_element_name_2 = const_str_digest_dc9f0c0121231dfd2bb64dc64aae6cc9;
        CHECK_OBJECT( var_octet_result );
        tmp_args_element_name_3 = var_octet_result;
        frame_95f4633cd0b82a09b30e9e453fe96c0e->m_frame.f_lineno = 861;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_cast, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 861;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_string_result == NULL );
        var_string_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 862;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_string_result );
        tmp_args_element_name_4 = var_string_result;
        frame_95f4633cd0b82a09b30e9e453fe96c0e->m_frame.f_lineno = 862;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_ASN1_STRING_data, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 862;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_char_result == NULL );
        var_char_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 863;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_4;
        CHECK_OBJECT( var_string_result );
        tmp_args_element_name_5 = var_string_result;
        frame_95f4633cd0b82a09b30e9e453fe96c0e->m_frame.f_lineno = 863;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_ASN1_STRING_length, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 863;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_length == NULL );
        var_result_length = tmp_assign_source_4;
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 864;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_5;
        CHECK_OBJECT( var_char_result );
        tmp_args_element_name_6 = var_char_result;
        CHECK_OBJECT( var_result_length );
        tmp_args_element_name_7 = var_result_length;
        frame_95f4633cd0b82a09b30e9e453fe96c0e->m_frame.f_lineno = 864;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_slice_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_buffer, call_args );
        }

        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 864;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 864;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95f4633cd0b82a09b30e9e453fe96c0e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_95f4633cd0b82a09b30e9e453fe96c0e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95f4633cd0b82a09b30e9e453fe96c0e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_95f4633cd0b82a09b30e9e453fe96c0e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_95f4633cd0b82a09b30e9e453fe96c0e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_95f4633cd0b82a09b30e9e453fe96c0e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_95f4633cd0b82a09b30e9e453fe96c0e,
        type_description_1,
        par_self,
        var_char_result,
        var_octet_result,
        var_string_result,
        var_result_length
    );


    // Release cached frame.
    if ( frame_95f4633cd0b82a09b30e9e453fe96c0e == cache_frame_95f4633cd0b82a09b30e9e453fe96c0e )
    {
        Py_DECREF( frame_95f4633cd0b82a09b30e9e453fe96c0e );
    }
    cache_frame_95f4633cd0b82a09b30e9e453fe96c0e = NULL;

    assertFrameObject( frame_95f4633cd0b82a09b30e9e453fe96c0e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_40_get_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_char_result );
    Py_DECREF( var_char_result );
    var_char_result = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_octet_result );
    Py_DECREF( var_octet_result );
    var_octet_result = NULL;

    CHECK_OBJECT( (PyObject *)var_string_result );
    Py_DECREF( var_string_result );
    var_string_result = NULL;

    CHECK_OBJECT( (PyObject *)var_result_length );
    Py_DECREF( var_result_length );
    var_result_length = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_char_result );
    var_char_result = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_octet_result );
    var_octet_result = NULL;

    Py_XDECREF( var_string_result );
    var_string_result = NULL;

    Py_XDECREF( var_result_length );
    var_result_length = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_40_get_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_41___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_req = NULL;
    struct Nuitka_FrameObject *frame_507773a59fe1a3d6025f2d54e3fa4c0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_507773a59fe1a3d6025f2d54e3fa4c0b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_507773a59fe1a3d6025f2d54e3fa4c0b, codeobj_507773a59fe1a3d6025f2d54e3fa4c0b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_507773a59fe1a3d6025f2d54e3fa4c0b = cache_frame_507773a59fe1a3d6025f2d54e3fa4c0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_507773a59fe1a3d6025f2d54e3fa4c0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_507773a59fe1a3d6025f2d54e3fa4c0b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 880;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_507773a59fe1a3d6025f2d54e3fa4c0b->m_frame.f_lineno = 880;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_REQ_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 880;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_req == NULL );
        var_req = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_req );
        tmp_args_element_name_1 = var_req;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REQ_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_507773a59fe1a3d6025f2d54e3fa4c0b->m_frame.f_lineno = 881;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 881;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_507773a59fe1a3d6025f2d54e3fa4c0b->m_frame.f_lineno = 883;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_set_version, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 883;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_507773a59fe1a3d6025f2d54e3fa4c0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_507773a59fe1a3d6025f2d54e3fa4c0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_507773a59fe1a3d6025f2d54e3fa4c0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_507773a59fe1a3d6025f2d54e3fa4c0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_507773a59fe1a3d6025f2d54e3fa4c0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_507773a59fe1a3d6025f2d54e3fa4c0b,
        type_description_1,
        par_self,
        var_req
    );


    // Release cached frame.
    if ( frame_507773a59fe1a3d6025f2d54e3fa4c0b == cache_frame_507773a59fe1a3d6025f2d54e3fa4c0b )
    {
        Py_DECREF( frame_507773a59fe1a3d6025f2d54e3fa4c0b );
    }
    cache_frame_507773a59fe1a3d6025f2d54e3fa4c0b = NULL;

    assertFrameObject( frame_507773a59fe1a3d6025f2d54e3fa4c0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_41___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_req );
    Py_DECREF( var_req );
    var_req = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_req );
    var_req = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_41___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_42_to_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__CertificateSigningRequest = NULL;
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_209bfbe606aa2e251590784a110971a9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_209bfbe606aa2e251590784a110971a9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_209bfbe606aa2e251590784a110971a9, codeobj_209bfbe606aa2e251590784a110971a9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_209bfbe606aa2e251590784a110971a9 = cache_frame_209bfbe606aa2e251590784a110971a9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_209bfbe606aa2e251590784a110971a9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_209bfbe606aa2e251590784a110971a9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain__CertificateSigningRequest_tuple;
        frame_209bfbe606aa2e251590784a110971a9->m_frame.f_lineno = 893;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 893;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain__CertificateSigningRequest );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 893;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var__CertificateSigningRequest == NULL );
        var__CertificateSigningRequest = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
            exception_tb = NULL;

            exception_lineno = 896;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_209bfbe606aa2e251590784a110971a9->m_frame.f_lineno = 896;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 896;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_backend == NULL );
        var_backend = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var__CertificateSigningRequest );
        tmp_called_name_2 = var__CertificateSigningRequest;
        CHECK_OBJECT( var_backend );
        tmp_args_element_name_1 = var_backend;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__req );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 897;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_209bfbe606aa2e251590784a110971a9->m_frame.f_lineno = 897;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 897;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_209bfbe606aa2e251590784a110971a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_209bfbe606aa2e251590784a110971a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_209bfbe606aa2e251590784a110971a9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_209bfbe606aa2e251590784a110971a9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_209bfbe606aa2e251590784a110971a9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_209bfbe606aa2e251590784a110971a9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_209bfbe606aa2e251590784a110971a9,
        type_description_1,
        par_self,
        var__CertificateSigningRequest,
        var_backend
    );


    // Release cached frame.
    if ( frame_209bfbe606aa2e251590784a110971a9 == cache_frame_209bfbe606aa2e251590784a110971a9 )
    {
        Py_DECREF( frame_209bfbe606aa2e251590784a110971a9 );
    }
    cache_frame_209bfbe606aa2e251590784a110971a9 = NULL;

    assertFrameObject( frame_209bfbe606aa2e251590784a110971a9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_42_to_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__CertificateSigningRequest );
    Py_DECREF( var__CertificateSigningRequest );
    var__CertificateSigningRequest = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__CertificateSigningRequest );
    var__CertificateSigningRequest = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_42_to_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_43_from_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_req = python_pars[ 1 ];
    PyObject *var_req = NULL;
    struct Nuitka_FrameObject *frame_e73694d63eb3a283fa48580107273fb0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_e73694d63eb3a283fa48580107273fb0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e73694d63eb3a283fa48580107273fb0, codeobj_e73694d63eb3a283fa48580107273fb0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e73694d63eb3a283fa48580107273fb0 = cache_frame_e73694d63eb3a283fa48580107273fb0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e73694d63eb3a283fa48580107273fb0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e73694d63eb3a283fa48580107273fb0 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_crypto_req );
        tmp_isinstance_inst_1 = par_crypto_req;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_x509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "x509" );
            exception_tb = NULL;

            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_CertificateSigningRequest );
        if ( tmp_isinstance_cls_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 911;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_39641ea33feffed70915f1c391cc979e;
            frame_e73694d63eb3a283fa48580107273fb0->m_frame.f_lineno = 912;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 912;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_name_1 = par_cls;
        frame_e73694d63eb3a283fa48580107273fb0->m_frame.f_lineno = 914;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 914;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_req == NULL );
        var_req = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_crypto_req );
        tmp_source_name_2 = par_crypto_req;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509_req );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 915;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_req );
        tmp_assattr_target_1 = var_req;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 915;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e73694d63eb3a283fa48580107273fb0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e73694d63eb3a283fa48580107273fb0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e73694d63eb3a283fa48580107273fb0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e73694d63eb3a283fa48580107273fb0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e73694d63eb3a283fa48580107273fb0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e73694d63eb3a283fa48580107273fb0,
        type_description_1,
        par_cls,
        par_crypto_req,
        var_req
    );


    // Release cached frame.
    if ( frame_e73694d63eb3a283fa48580107273fb0 == cache_frame_e73694d63eb3a283fa48580107273fb0 )
    {
        Py_DECREF( frame_e73694d63eb3a283fa48580107273fb0 );
    }
    cache_frame_e73694d63eb3a283fa48580107273fb0 = NULL;

    assertFrameObject( frame_e73694d63eb3a283fa48580107273fb0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_req );
    tmp_return_value = var_req;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_43_from_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_req );
    Py_DECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_req );
    Py_DECREF( par_crypto_req );
    par_crypto_req = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_req );
    Py_DECREF( par_crypto_req );
    par_crypto_req = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_43_from_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_44_set_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_68a36fb583f00099fdddf6bbbc375aee;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_68a36fb583f00099fdddf6bbbc375aee = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_68a36fb583f00099fdddf6bbbc375aee, codeobj_68a36fb583f00099fdddf6bbbc375aee, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_68a36fb583f00099fdddf6bbbc375aee = cache_frame_68a36fb583f00099fdddf6bbbc375aee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_68a36fb583f00099fdddf6bbbc375aee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_68a36fb583f00099fdddf6bbbc375aee ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_set_pubkey );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_68a36fb583f00099fdddf6bbbc375aee->m_frame.f_lineno = 927;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 927;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_set_result == NULL );
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 928;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_set_result );
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 928;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_68a36fb583f00099fdddf6bbbc375aee->m_frame.f_lineno = 928;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 928;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68a36fb583f00099fdddf6bbbc375aee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68a36fb583f00099fdddf6bbbc375aee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_68a36fb583f00099fdddf6bbbc375aee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_68a36fb583f00099fdddf6bbbc375aee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_68a36fb583f00099fdddf6bbbc375aee, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_68a36fb583f00099fdddf6bbbc375aee,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if ( frame_68a36fb583f00099fdddf6bbbc375aee == cache_frame_68a36fb583f00099fdddf6bbbc375aee )
    {
        Py_DECREF( frame_68a36fb583f00099fdddf6bbbc375aee );
    }
    cache_frame_68a36fb583f00099fdddf6bbbc375aee = NULL;

    assertFrameObject( frame_68a36fb583f00099fdddf6bbbc375aee );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_44_set_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_44_set_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_45_get_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_8c37e52f9e85331b386989d0fa841a7d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8c37e52f9e85331b386989d0fa841a7d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8c37e52f9e85331b386989d0fa841a7d, codeobj_8c37e52f9e85331b386989d0fa841a7d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_8c37e52f9e85331b386989d0fa841a7d = cache_frame_8c37e52f9e85331b386989d0fa841a7d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8c37e52f9e85331b386989d0fa841a7d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8c37e52f9e85331b386989d0fa841a7d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_8c37e52f9e85331b386989d0fa841a7d->m_frame.f_lineno = 937;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 937;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REQ_get_pubkey );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__req );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8c37e52f9e85331b386989d0fa841a7d->m_frame.f_lineno = 938;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 938;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT( var_pkey );
        tmp_source_name_4 = var_pkey;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__pkey );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8c37e52f9e85331b386989d0fa841a7d->m_frame.f_lineno = 939;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 939;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_source_name_7 = var_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_PKEY_free );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_4 );

            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8c37e52f9e85331b386989d0fa841a7d->m_frame.f_lineno = 940;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 940;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 941;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8c37e52f9e85331b386989d0fa841a7d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8c37e52f9e85331b386989d0fa841a7d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8c37e52f9e85331b386989d0fa841a7d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8c37e52f9e85331b386989d0fa841a7d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8c37e52f9e85331b386989d0fa841a7d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8c37e52f9e85331b386989d0fa841a7d,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_8c37e52f9e85331b386989d0fa841a7d == cache_frame_8c37e52f9e85331b386989d0fa841a7d )
    {
        Py_DECREF( frame_8c37e52f9e85331b386989d0fa841a7d );
    }
    cache_frame_8c37e52f9e85331b386989d0fa841a7d = NULL;

    assertFrameObject( frame_8c37e52f9e85331b386989d0fa841a7d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pkey );
    tmp_return_value = var_pkey;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_45_get_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_45_get_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_46_set_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_version = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_8e211ad8a1c8e21a1a72dcaf0e373537;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8e211ad8a1c8e21a1a72dcaf0e373537 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8e211ad8a1c8e21a1a72dcaf0e373537, codeobj_8e211ad8a1c8e21a1a72dcaf0e373537, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8e211ad8a1c8e21a1a72dcaf0e373537 = cache_frame_8e211ad8a1c8e21a1a72dcaf0e373537;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8e211ad8a1c8e21a1a72dcaf0e373537 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8e211ad8a1c8e21a1a72dcaf0e373537 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_set_version );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_version );
        tmp_args_element_name_2 = par_version;
        frame_8e211ad8a1c8e21a1a72dcaf0e373537->m_frame.f_lineno = 952;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 952;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_set_result == NULL );
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 953;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_set_result );
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 953;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_8e211ad8a1c8e21a1a72dcaf0e373537->m_frame.f_lineno = 953;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 953;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e211ad8a1c8e21a1a72dcaf0e373537 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8e211ad8a1c8e21a1a72dcaf0e373537 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8e211ad8a1c8e21a1a72dcaf0e373537, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8e211ad8a1c8e21a1a72dcaf0e373537->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8e211ad8a1c8e21a1a72dcaf0e373537, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8e211ad8a1c8e21a1a72dcaf0e373537,
        type_description_1,
        par_self,
        par_version,
        var_set_result
    );


    // Release cached frame.
    if ( frame_8e211ad8a1c8e21a1a72dcaf0e373537 == cache_frame_8e211ad8a1c8e21a1a72dcaf0e373537 )
    {
        Py_DECREF( frame_8e211ad8a1c8e21a1a72dcaf0e373537 );
    }
    cache_frame_8e211ad8a1c8e21a1a72dcaf0e373537 = NULL;

    assertFrameObject( frame_8e211ad8a1c8e21a1a72dcaf0e373537 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_46_set_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_46_set_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_47_get_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_417f224a16eb9c304a2c9c356d7916aa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_417f224a16eb9c304a2c9c356d7916aa = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_417f224a16eb9c304a2c9c356d7916aa, codeobj_417f224a16eb9c304a2c9c356d7916aa, module_OpenSSL$crypto, sizeof(void *) );
    frame_417f224a16eb9c304a2c9c356d7916aa = cache_frame_417f224a16eb9c304a2c9c356d7916aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_417f224a16eb9c304a2c9c356d7916aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_417f224a16eb9c304a2c9c356d7916aa ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_get_version );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_417f224a16eb9c304a2c9c356d7916aa->m_frame.f_lineno = 963;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 963;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_417f224a16eb9c304a2c9c356d7916aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_417f224a16eb9c304a2c9c356d7916aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_417f224a16eb9c304a2c9c356d7916aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_417f224a16eb9c304a2c9c356d7916aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_417f224a16eb9c304a2c9c356d7916aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_417f224a16eb9c304a2c9c356d7916aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_417f224a16eb9c304a2c9c356d7916aa,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_417f224a16eb9c304a2c9c356d7916aa == cache_frame_417f224a16eb9c304a2c9c356d7916aa )
    {
        Py_DECREF( frame_417f224a16eb9c304a2c9c356d7916aa );
    }
    cache_frame_417f224a16eb9c304a2c9c356d7916aa = NULL;

    assertFrameObject( frame_417f224a16eb9c304a2c9c356d7916aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_47_get_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_47_get_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_48_get_subject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_c707a22aafaa65d7b3d974108e264db4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_c707a22aafaa65d7b3d974108e264db4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c707a22aafaa65d7b3d974108e264db4, codeobj_c707a22aafaa65d7b3d974108e264db4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_c707a22aafaa65d7b3d974108e264db4 = cache_frame_c707a22aafaa65d7b3d974108e264db4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c707a22aafaa65d7b3d974108e264db4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c707a22aafaa65d7b3d974108e264db4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_c707a22aafaa65d7b3d974108e264db4->m_frame.f_lineno = 977;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 977;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_name == NULL );
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REQ_get_subject_name );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__req );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c707a22aafaa65d7b3d974108e264db4->m_frame.f_lineno = 978;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_name );
        tmp_assattr_target_1 = var_name;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 978;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT( var_name );
        tmp_source_name_4 = var_name;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__name );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_c707a22aafaa65d7b3d974108e264db4->m_frame.f_lineno = 979;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 979;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_self );
        tmp_assattr_name_2 = par_self;
        CHECK_OBJECT( var_name );
        tmp_assattr_target_2 = var_name;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__owner, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 983;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c707a22aafaa65d7b3d974108e264db4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c707a22aafaa65d7b3d974108e264db4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c707a22aafaa65d7b3d974108e264db4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c707a22aafaa65d7b3d974108e264db4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c707a22aafaa65d7b3d974108e264db4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c707a22aafaa65d7b3d974108e264db4,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_c707a22aafaa65d7b3d974108e264db4 == cache_frame_c707a22aafaa65d7b3d974108e264db4 )
    {
        Py_DECREF( frame_c707a22aafaa65d7b3d974108e264db4 );
    }
    cache_frame_c707a22aafaa65d7b3d974108e264db4 = NULL;

    assertFrameObject( frame_c707a22aafaa65d7b3d974108e264db4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_name );
    tmp_return_value = var_name;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_48_get_subject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_48_get_subject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_49_add_extensions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_extensions = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *var_stack = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_0d0a6cfa23df0134bf276c6438f2ab9f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_0d0a6cfa23df0134bf276c6438f2ab9f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0d0a6cfa23df0134bf276c6438f2ab9f, codeobj_0d0a6cfa23df0134bf276c6438f2ab9f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0d0a6cfa23df0134bf276c6438f2ab9f = cache_frame_0d0a6cfa23df0134bf276c6438f2ab9f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0d0a6cfa23df0134bf276c6438f2ab9f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0d0a6cfa23df0134bf276c6438f2ab9f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 995;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame.f_lineno = 995;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_sk_X509_EXTENSION_new_null );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 995;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_stack == NULL );
        var_stack = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_stack );
        tmp_compexpr_left_1 = var_stack;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame.f_lineno = 996;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_gc );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_stack );
        tmp_args_element_name_2 = var_stack;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_sk_X509_EXTENSION_free );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame.f_lineno = 998;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 998;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_stack;
            assert( old != NULL );
            var_stack = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_extensions );
        tmp_iter_arg_1 = par_extensions;
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1000;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                exception_lineno = 1000;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_5;
            Py_INCREF( var_ext );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_6;
        CHECK_OBJECT( var_ext );
        tmp_isinstance_inst_1 = var_ext;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
            exception_tb = NULL;

            exception_lineno = 1001;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_6;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1001;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1001;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
            frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame.f_lineno = 1002;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1002;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_sk_X509_EXTENSION_push );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_stack );
        tmp_args_element_name_4 = var_stack;
        CHECK_OBJECT( var_ext );
        tmp_source_name_5 = var_ext;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__extension );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame.f_lineno = 1005;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1005;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_8;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_REQ_add_extensions );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__req );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_stack );
        tmp_args_element_name_7 = var_stack;
        frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame.f_lineno = 1007;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1007;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_add_result == NULL );
        var_add_result = tmp_assign_source_6;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1008;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_9;
        CHECK_OBJECT( var_add_result );
        tmp_compexpr_left_2 = var_add_result;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_8 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1008;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame.f_lineno = 1008;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1008;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d0a6cfa23df0134bf276c6438f2ab9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d0a6cfa23df0134bf276c6438f2ab9f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0d0a6cfa23df0134bf276c6438f2ab9f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0d0a6cfa23df0134bf276c6438f2ab9f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0d0a6cfa23df0134bf276c6438f2ab9f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0d0a6cfa23df0134bf276c6438f2ab9f,
        type_description_1,
        par_self,
        par_extensions,
        var_ext,
        var_stack,
        var_add_result
    );


    // Release cached frame.
    if ( frame_0d0a6cfa23df0134bf276c6438f2ab9f == cache_frame_0d0a6cfa23df0134bf276c6438f2ab9f )
    {
        Py_DECREF( frame_0d0a6cfa23df0134bf276c6438f2ab9f );
    }
    cache_frame_0d0a6cfa23df0134bf276c6438f2ab9f = NULL;

    assertFrameObject( frame_0d0a6cfa23df0134bf276c6438f2ab9f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_49_add_extensions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    CHECK_OBJECT( (PyObject *)var_stack );
    Py_DECREF( var_stack );
    var_stack = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    Py_XDECREF( var_stack );
    var_stack = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_49_add_extensions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_50_get_extensions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_ext = NULL;
    PyObject *var_exts = NULL;
    PyObject *var_native_exts_obj = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_5a0f6d45c706c470bc2bce1f1d87be1f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_5a0f6d45c706c470bc2bce1f1d87be1f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New( 0 );
        assert( var_exts == NULL );
        var_exts = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5a0f6d45c706c470bc2bce1f1d87be1f, codeobj_5a0f6d45c706c470bc2bce1f1d87be1f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5a0f6d45c706c470bc2bce1f1d87be1f = cache_frame_5a0f6d45c706c470bc2bce1f1d87be1f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5a0f6d45c706c470bc2bce1f1d87be1f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5a0f6d45c706c470bc2bce1f1d87be1f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_get_extensions );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_5a0f6d45c706c470bc2bce1f1d87be1f->m_frame.f_lineno = 1020;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1020;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_native_exts_obj == NULL );
        var_native_exts_obj = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_native_exts_obj );
        tmp_args_element_name_2 = var_native_exts_obj;
        frame_5a0f6d45c706c470bc2bce1f1d87be1f->m_frame.f_lineno = 1021;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_EXTENSION_num, call_args );
        }

        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1021;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                exception_lineno = 1021;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
            exception_tb = NULL;

            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___new__ );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
            exception_tb = NULL;

            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_args_element_name_3 = tmp_mvar_value_4;
        frame_5a0f6d45c706c470bc2bce1f1d87be1f->m_frame.f_lineno = 1022;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1022;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1023;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT( var_native_exts_obj );
        tmp_args_element_name_4 = var_native_exts_obj;
        CHECK_OBJECT( var_i );
        tmp_args_element_name_5 = var_i;
        frame_5a0f6d45c706c470bc2bce1f1d87be1f->m_frame.f_lineno = 1023;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_EXTENSION_value, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1023;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_ext );
        tmp_assattr_target_1 = var_ext;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__extension, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1023;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT( var_exts );
        tmp_called_instance_3 = var_exts;
        CHECK_OBJECT( var_ext );
        tmp_args_element_name_6 = var_ext;
        frame_5a0f6d45c706c470bc2bce1f1d87be1f->m_frame.f_lineno = 1024;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1024;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1021;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a0f6d45c706c470bc2bce1f1d87be1f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a0f6d45c706c470bc2bce1f1d87be1f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5a0f6d45c706c470bc2bce1f1d87be1f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5a0f6d45c706c470bc2bce1f1d87be1f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5a0f6d45c706c470bc2bce1f1d87be1f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5a0f6d45c706c470bc2bce1f1d87be1f,
        type_description_1,
        par_self,
        var_i,
        var_ext,
        var_exts,
        var_native_exts_obj
    );


    // Release cached frame.
    if ( frame_5a0f6d45c706c470bc2bce1f1d87be1f == cache_frame_5a0f6d45c706c470bc2bce1f1d87be1f )
    {
        Py_DECREF( frame_5a0f6d45c706c470bc2bce1f1d87be1f );
    }
    cache_frame_5a0f6d45c706c470bc2bce1f1d87be1f = NULL;

    assertFrameObject( frame_5a0f6d45c706c470bc2bce1f1d87be1f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( var_exts );
    tmp_return_value = var_exts;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_50_get_extensions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_exts );
    Py_DECREF( var_exts );
    var_exts = NULL;

    CHECK_OBJECT( (PyObject *)var_native_exts_obj );
    Py_DECREF( var_native_exts_obj );
    var_native_exts_obj = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_exts );
    Py_DECREF( var_exts );
    var_exts = NULL;

    Py_XDECREF( var_native_exts_obj );
    var_native_exts_obj = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_50_get_extensions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_51_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    struct Nuitka_FrameObject *frame_587512bae47cea562886e765c3184c29;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_587512bae47cea562886e765c3184c29 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_587512bae47cea562886e765c3184c29, codeobj_587512bae47cea562886e765c3184c29, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_587512bae47cea562886e765c3184c29 = cache_frame_587512bae47cea562886e765c3184c29;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_587512bae47cea562886e765c3184c29 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_587512bae47cea562886e765c3184c29 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_1 = par_pkey;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1038;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1038;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
            frame_587512bae47cea562886e765c3184c29->m_frame.f_lineno = 1039;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1039;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_2 = par_pkey;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__initialized );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1041;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1041;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
            frame_587512bae47cea562886e765c3184c29->m_frame.f_lineno = 1042;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1042;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_get_digestbyname );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_digest );
        tmp_args_element_name_2 = par_digest;
        frame_587512bae47cea562886e765c3184c29->m_frame.f_lineno = 1044;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_587512bae47cea562886e765c3184c29->m_frame.f_lineno = 1044;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1044;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest_obj == NULL );
        var_digest_obj = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_digest_obj );
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1045;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1045;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1045;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_587512bae47cea562886e765c3184c29->m_frame.f_lineno = 1046;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_3 == NULL) );
            exception_type = tmp_raise_type_3;
            exception_lineno = 1046;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_REQ_sign );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__req );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_digest_obj );
        tmp_args_element_name_5 = var_digest_obj;
        frame_587512bae47cea562886e765c3184c29->m_frame.f_lineno = 1048;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1048;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_sign_result == NULL );
        var_sign_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1049;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        CHECK_OBJECT( var_sign_result );
        tmp_compexpr_left_2 = var_sign_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_6 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1049;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_587512bae47cea562886e765c3184c29->m_frame.f_lineno = 1049;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1049;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_587512bae47cea562886e765c3184c29 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_587512bae47cea562886e765c3184c29 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_587512bae47cea562886e765c3184c29, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_587512bae47cea562886e765c3184c29->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_587512bae47cea562886e765c3184c29, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_587512bae47cea562886e765c3184c29,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if ( frame_587512bae47cea562886e765c3184c29 == cache_frame_587512bae47cea562886e765c3184c29 )
    {
        Py_DECREF( frame_587512bae47cea562886e765c3184c29 );
    }
    cache_frame_587512bae47cea562886e765c3184c29 = NULL;

    assertFrameObject( frame_587512bae47cea562886e765c3184c29 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_51_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_51_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_52_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_d05172d050310e43eef8f47311a18aa3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_d05172d050310e43eef8f47311a18aa3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d05172d050310e43eef8f47311a18aa3, codeobj_d05172d050310e43eef8f47311a18aa3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d05172d050310e43eef8f47311a18aa3 = cache_frame_d05172d050310e43eef8f47311a18aa3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d05172d050310e43eef8f47311a18aa3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d05172d050310e43eef8f47311a18aa3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_pkey );
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_d05172d050310e43eef8f47311a18aa3->m_frame.f_lineno = 1064;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1064;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REQ_verify );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d05172d050310e43eef8f47311a18aa3->m_frame.f_lineno = 1066;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1066;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_result );
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1067;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1068;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_d05172d050310e43eef8f47311a18aa3->m_frame.f_lineno = 1068;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1068;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d05172d050310e43eef8f47311a18aa3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d05172d050310e43eef8f47311a18aa3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d05172d050310e43eef8f47311a18aa3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d05172d050310e43eef8f47311a18aa3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d05172d050310e43eef8f47311a18aa3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d05172d050310e43eef8f47311a18aa3,
        type_description_1,
        par_self,
        par_pkey,
        var_result
    );


    // Release cached frame.
    if ( frame_d05172d050310e43eef8f47311a18aa3 == cache_frame_d05172d050310e43eef8f47311a18aa3 )
    {
        Py_DECREF( frame_d05172d050310e43eef8f47311a18aa3 );
    }
    cache_frame_d05172d050310e43eef8f47311a18aa3 = NULL;

    assertFrameObject( frame_d05172d050310e43eef8f47311a18aa3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_52_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_52_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_53___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_x509 = NULL;
    struct Nuitka_FrameObject *frame_a0582cf67145aa1223c5c2d1c9e689f4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_a0582cf67145aa1223c5c2d1c9e689f4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a0582cf67145aa1223c5c2d1c9e689f4, codeobj_a0582cf67145aa1223c5c2d1c9e689f4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_a0582cf67145aa1223c5c2d1c9e689f4 = cache_frame_a0582cf67145aa1223c5c2d1c9e689f4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a0582cf67145aa1223c5c2d1c9e689f4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a0582cf67145aa1223c5c2d1c9e689f4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1085;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_a0582cf67145aa1223c5c2d1c9e689f4->m_frame.f_lineno = 1085;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1085;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_x509 == NULL );
        var_x509 = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_x509 );
        tmp_compexpr_left_1 = var_x509;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_a0582cf67145aa1223c5c2d1c9e689f4->m_frame.f_lineno = 1086;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1086;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_gc );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_x509 );
        tmp_args_element_name_2 = var_x509;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_free );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_a0582cf67145aa1223c5c2d1c9e689f4->m_frame.f_lineno = 1087;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1087;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
            exception_tb = NULL;

            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_6;
        frame_a0582cf67145aa1223c5c2d1c9e689f4->m_frame.f_lineno = 1089;
        tmp_assattr_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__issuer_invalidator, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_3;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
            exception_tb = NULL;

            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        frame_a0582cf67145aa1223c5c2d1c9e689f4->m_frame.f_lineno = 1090;
        tmp_assattr_name_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
        if ( tmp_assattr_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__subject_invalidator, tmp_assattr_name_3 );
        Py_DECREF( tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1090;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0582cf67145aa1223c5c2d1c9e689f4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0582cf67145aa1223c5c2d1c9e689f4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a0582cf67145aa1223c5c2d1c9e689f4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a0582cf67145aa1223c5c2d1c9e689f4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a0582cf67145aa1223c5c2d1c9e689f4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a0582cf67145aa1223c5c2d1c9e689f4,
        type_description_1,
        par_self,
        var_x509
    );


    // Release cached frame.
    if ( frame_a0582cf67145aa1223c5c2d1c9e689f4 == cache_frame_a0582cf67145aa1223c5c2d1c9e689f4 )
    {
        Py_DECREF( frame_a0582cf67145aa1223c5c2d1c9e689f4 );
    }
    cache_frame_a0582cf67145aa1223c5c2d1c9e689f4 = NULL;

    assertFrameObject( frame_a0582cf67145aa1223c5c2d1c9e689f4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_53___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_x509 );
    Py_DECREF( var_x509 );
    var_x509 = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_53___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_54__from_raw_x509_ptr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_x509 = python_pars[ 1 ];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_0589830efba91376579341caa89dd6a4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0589830efba91376579341caa89dd6a4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0589830efba91376579341caa89dd6a4, codeobj_0589830efba91376579341caa89dd6a4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0589830efba91376579341caa89dd6a4 = cache_frame_0589830efba91376579341caa89dd6a4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0589830efba91376579341caa89dd6a4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0589830efba91376579341caa89dd6a4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT( par_cls );
        tmp_args_element_name_1 = par_cls;
        frame_0589830efba91376579341caa89dd6a4->m_frame.f_lineno = 1094;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___new__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1094;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_cert == NULL );
        var_cert = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x509 );
        tmp_args_element_name_2 = par_x509;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_free );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_0589830efba91376579341caa89dd6a4->m_frame.f_lineno = 1095;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_cert );
        tmp_assattr_target_1 = var_cert;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1095;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
            exception_tb = NULL;

            exception_lineno = 1096;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        frame_0589830efba91376579341caa89dd6a4->m_frame.f_lineno = 1096;
        tmp_assattr_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1096;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_cert );
        tmp_assattr_target_2 = var_cert;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__issuer_invalidator, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1096;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_assattr_target_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_X509NameInvalidator" );
            exception_tb = NULL;

            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        frame_0589830efba91376579341caa89dd6a4->m_frame.f_lineno = 1097;
        tmp_assattr_name_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
        if ( tmp_assattr_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_cert );
        tmp_assattr_target_3 = var_cert;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__subject_invalidator, tmp_assattr_name_3 );
        Py_DECREF( tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1097;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0589830efba91376579341caa89dd6a4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0589830efba91376579341caa89dd6a4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0589830efba91376579341caa89dd6a4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0589830efba91376579341caa89dd6a4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0589830efba91376579341caa89dd6a4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0589830efba91376579341caa89dd6a4,
        type_description_1,
        par_cls,
        par_x509,
        var_cert
    );


    // Release cached frame.
    if ( frame_0589830efba91376579341caa89dd6a4 == cache_frame_0589830efba91376579341caa89dd6a4 )
    {
        Py_DECREF( frame_0589830efba91376579341caa89dd6a4 );
    }
    cache_frame_0589830efba91376579341caa89dd6a4 = NULL;

    assertFrameObject( frame_0589830efba91376579341caa89dd6a4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_cert );
    tmp_return_value = var_cert;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_54__from_raw_x509_ptr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x509 );
    Py_DECREF( par_x509 );
    par_x509 = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x509 );
    Py_DECREF( par_x509 );
    par_x509 = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_54__from_raw_x509_ptr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_55_to_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__Certificate = NULL;
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_ac5cf5ddb389d171d9f49512989a34d2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ac5cf5ddb389d171d9f49512989a34d2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ac5cf5ddb389d171d9f49512989a34d2, codeobj_ac5cf5ddb389d171d9f49512989a34d2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ac5cf5ddb389d171d9f49512989a34d2 = cache_frame_ac5cf5ddb389d171d9f49512989a34d2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ac5cf5ddb389d171d9f49512989a34d2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ac5cf5ddb389d171d9f49512989a34d2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain__Certificate_tuple;
        frame_ac5cf5ddb389d171d9f49512989a34d2->m_frame.f_lineno = 1108;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1108;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain__Certificate );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1108;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var__Certificate == NULL );
        var__Certificate = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
            exception_tb = NULL;

            exception_lineno = 1109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_ac5cf5ddb389d171d9f49512989a34d2->m_frame.f_lineno = 1109;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_backend == NULL );
        var_backend = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var__Certificate );
        tmp_called_name_2 = var__Certificate;
        CHECK_OBJECT( var_backend );
        tmp_args_element_name_1 = var_backend;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_ac5cf5ddb389d171d9f49512989a34d2->m_frame.f_lineno = 1110;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac5cf5ddb389d171d9f49512989a34d2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac5cf5ddb389d171d9f49512989a34d2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac5cf5ddb389d171d9f49512989a34d2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ac5cf5ddb389d171d9f49512989a34d2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ac5cf5ddb389d171d9f49512989a34d2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ac5cf5ddb389d171d9f49512989a34d2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ac5cf5ddb389d171d9f49512989a34d2,
        type_description_1,
        par_self,
        var__Certificate,
        var_backend
    );


    // Release cached frame.
    if ( frame_ac5cf5ddb389d171d9f49512989a34d2 == cache_frame_ac5cf5ddb389d171d9f49512989a34d2 )
    {
        Py_DECREF( frame_ac5cf5ddb389d171d9f49512989a34d2 );
    }
    cache_frame_ac5cf5ddb389d171d9f49512989a34d2 = NULL;

    assertFrameObject( frame_ac5cf5ddb389d171d9f49512989a34d2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_55_to_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__Certificate );
    Py_DECREF( var__Certificate );
    var__Certificate = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__Certificate );
    var__Certificate = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_55_to_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_56_from_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_cert = python_pars[ 1 ];
    PyObject *var_cert = NULL;
    struct Nuitka_FrameObject *frame_1e309d622f57f1df6afb5655a5cbc12f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_1e309d622f57f1df6afb5655a5cbc12f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1e309d622f57f1df6afb5655a5cbc12f, codeobj_1e309d622f57f1df6afb5655a5cbc12f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1e309d622f57f1df6afb5655a5cbc12f = cache_frame_1e309d622f57f1df6afb5655a5cbc12f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1e309d622f57f1df6afb5655a5cbc12f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1e309d622f57f1df6afb5655a5cbc12f ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_crypto_cert );
        tmp_isinstance_inst_1 = par_crypto_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_x509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "x509" );
            exception_tb = NULL;

            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Certificate );
        if ( tmp_isinstance_cls_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1124;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_6674ab14e1178de501dfb968278a50b9;
            frame_1e309d622f57f1df6afb5655a5cbc12f->m_frame.f_lineno = 1125;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1125;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_name_1 = par_cls;
        frame_1e309d622f57f1df6afb5655a5cbc12f->m_frame.f_lineno = 1127;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1127;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_cert == NULL );
        var_cert = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_crypto_cert );
        tmp_source_name_2 = par_crypto_cert;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1128;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_cert );
        tmp_assattr_target_1 = var_cert;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__x509, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1128;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e309d622f57f1df6afb5655a5cbc12f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1e309d622f57f1df6afb5655a5cbc12f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1e309d622f57f1df6afb5655a5cbc12f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1e309d622f57f1df6afb5655a5cbc12f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1e309d622f57f1df6afb5655a5cbc12f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1e309d622f57f1df6afb5655a5cbc12f,
        type_description_1,
        par_cls,
        par_crypto_cert,
        var_cert
    );


    // Release cached frame.
    if ( frame_1e309d622f57f1df6afb5655a5cbc12f == cache_frame_1e309d622f57f1df6afb5655a5cbc12f )
    {
        Py_DECREF( frame_1e309d622f57f1df6afb5655a5cbc12f );
    }
    cache_frame_1e309d622f57f1df6afb5655a5cbc12f = NULL;

    assertFrameObject( frame_1e309d622f57f1df6afb5655a5cbc12f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_cert );
    tmp_return_value = var_cert;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_56_from_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_cert );
    Py_DECREF( par_crypto_cert );
    par_crypto_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_crypto_cert );
    Py_DECREF( par_crypto_cert );
    par_crypto_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_56_from_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_57_set_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_version = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_10bd3e802582e0d9c677ad46e3411b69;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_10bd3e802582e0d9c677ad46e3411b69 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_10bd3e802582e0d9c677ad46e3411b69, codeobj_10bd3e802582e0d9c677ad46e3411b69, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_10bd3e802582e0d9c677ad46e3411b69 = cache_frame_10bd3e802582e0d9c677ad46e3411b69;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_10bd3e802582e0d9c677ad46e3411b69 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_10bd3e802582e0d9c677ad46e3411b69 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_version );
        tmp_isinstance_inst_1 = par_version;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1141;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1141;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_2dbcbe3e7da77178b4a9da40244d072a;
            frame_10bd3e802582e0d9c677ad46e3411b69->m_frame.f_lineno = 1142;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1142;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_set_version );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_version );
        tmp_args_element_name_2 = par_version;
        frame_10bd3e802582e0d9c677ad46e3411b69->m_frame.f_lineno = 1144;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1144;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10bd3e802582e0d9c677ad46e3411b69 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10bd3e802582e0d9c677ad46e3411b69 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_10bd3e802582e0d9c677ad46e3411b69, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_10bd3e802582e0d9c677ad46e3411b69->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_10bd3e802582e0d9c677ad46e3411b69, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_10bd3e802582e0d9c677ad46e3411b69,
        type_description_1,
        par_self,
        par_version
    );


    // Release cached frame.
    if ( frame_10bd3e802582e0d9c677ad46e3411b69 == cache_frame_10bd3e802582e0d9c677ad46e3411b69 )
    {
        Py_DECREF( frame_10bd3e802582e0d9c677ad46e3411b69 );
    }
    cache_frame_10bd3e802582e0d9c677ad46e3411b69 = NULL;

    assertFrameObject( frame_10bd3e802582e0d9c677ad46e3411b69 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_57_set_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_57_set_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_58_get_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_5143552858fa1f886627571bace5fd5b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5143552858fa1f886627571bace5fd5b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5143552858fa1f886627571bace5fd5b, codeobj_5143552858fa1f886627571bace5fd5b, module_OpenSSL$crypto, sizeof(void *) );
    frame_5143552858fa1f886627571bace5fd5b = cache_frame_5143552858fa1f886627571bace5fd5b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5143552858fa1f886627571bace5fd5b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5143552858fa1f886627571bace5fd5b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_version );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_5143552858fa1f886627571bace5fd5b->m_frame.f_lineno = 1153;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1153;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5143552858fa1f886627571bace5fd5b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5143552858fa1f886627571bace5fd5b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5143552858fa1f886627571bace5fd5b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5143552858fa1f886627571bace5fd5b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5143552858fa1f886627571bace5fd5b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5143552858fa1f886627571bace5fd5b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5143552858fa1f886627571bace5fd5b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5143552858fa1f886627571bace5fd5b == cache_frame_5143552858fa1f886627571bace5fd5b )
    {
        Py_DECREF( frame_5143552858fa1f886627571bace5fd5b );
    }
    cache_frame_5143552858fa1f886627571bace5fd5b = NULL;

    assertFrameObject( frame_5143552858fa1f886627571bace5fd5b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_58_get_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_58_get_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_59_get_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_856ed1c292c994af7bfce0923beed35a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_856ed1c292c994af7bfce0923beed35a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_856ed1c292c994af7bfce0923beed35a, codeobj_856ed1c292c994af7bfce0923beed35a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_856ed1c292c994af7bfce0923beed35a = cache_frame_856ed1c292c994af7bfce0923beed35a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_856ed1c292c994af7bfce0923beed35a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_856ed1c292c994af7bfce0923beed35a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_856ed1c292c994af7bfce0923beed35a->m_frame.f_lineno = 1162;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1162;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_pubkey );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_856ed1c292c994af7bfce0923beed35a->m_frame.f_lineno = 1163;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1163;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_pkey );
        tmp_source_name_4 = var_pkey;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__pkey );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1164;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1165;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_5;
            frame_856ed1c292c994af7bfce0923beed35a->m_frame.f_lineno = 1165;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1165;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_source_name_7 = var_pkey;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_PKEY_free );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_856ed1c292c994af7bfce0923beed35a->m_frame.f_lineno = 1166;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1166;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1167;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_856ed1c292c994af7bfce0923beed35a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_856ed1c292c994af7bfce0923beed35a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_856ed1c292c994af7bfce0923beed35a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_856ed1c292c994af7bfce0923beed35a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_856ed1c292c994af7bfce0923beed35a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_856ed1c292c994af7bfce0923beed35a,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_856ed1c292c994af7bfce0923beed35a == cache_frame_856ed1c292c994af7bfce0923beed35a )
    {
        Py_DECREF( frame_856ed1c292c994af7bfce0923beed35a );
    }
    cache_frame_856ed1c292c994af7bfce0923beed35a = NULL;

    assertFrameObject( frame_856ed1c292c994af7bfce0923beed35a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pkey );
    tmp_return_value = var_pkey;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_59_get_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_59_get_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_60_set_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e, codeobj_5cb75a6ba9401b5ee9f8f9fd264c5f1e, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e = cache_frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_pkey );
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 1179;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1179;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1179;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e->m_frame.f_lineno = 1180;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1180;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_set_pubkey );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e->m_frame.f_lineno = 1182;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1182;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_set_result == NULL );
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1183;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_set_result );
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1183;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e->m_frame.f_lineno = 1183;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1183;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if ( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e == cache_frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e )
    {
        Py_DECREF( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e );
    }
    cache_frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e = NULL;

    assertFrameObject( frame_5cb75a6ba9401b5ee9f8f9fd264c5f1e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_60_set_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_60_set_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_61_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_sign_result = NULL;
    PyObject *var_evp_md = NULL;
    struct Nuitka_FrameObject *frame_ff3315c115fcc0322838af618aa26d9c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_ff3315c115fcc0322838af618aa26d9c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ff3315c115fcc0322838af618aa26d9c, codeobj_ff3315c115fcc0322838af618aa26d9c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ff3315c115fcc0322838af618aa26d9c = cache_frame_ff3315c115fcc0322838af618aa26d9c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ff3315c115fcc0322838af618aa26d9c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ff3315c115fcc0322838af618aa26d9c ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_pkey );
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 1197;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1197;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1197;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1198;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1198;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_1 = par_pkey;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1200;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1200;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_dc44ec2c02bcac7fac23b8eea57aa5d6;
            frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1201;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 1201;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_2 = par_pkey;
        tmp_operand_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__initialized );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1203;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1203;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
            frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1204;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_3 == NULL) );
            exception_type = tmp_raise_type_3;
            exception_lineno = 1204;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_get_digestbyname );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( par_digest );
        tmp_args_element_name_2 = par_digest;
        frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1206;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1206;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1206;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_evp_md == NULL );
        var_evp_md = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_evp_md );
        tmp_compexpr_left_1 = var_evp_md;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1207;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1207;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1207;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            tmp_make_exception_arg_4 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1208;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_4 };
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_4 == NULL) );
            exception_type = tmp_raise_type_4;
            exception_lineno = 1208;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_sign );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_evp_md );
        tmp_args_element_name_5 = var_evp_md;
        frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1210;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_sign_result == NULL );
        var_sign_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1211;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT( var_sign_result );
        tmp_compexpr_left_2 = var_sign_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_6 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1211;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_ff3315c115fcc0322838af618aa26d9c->m_frame.f_lineno = 1211;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1211;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff3315c115fcc0322838af618aa26d9c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ff3315c115fcc0322838af618aa26d9c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ff3315c115fcc0322838af618aa26d9c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ff3315c115fcc0322838af618aa26d9c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ff3315c115fcc0322838af618aa26d9c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff3315c115fcc0322838af618aa26d9c,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_sign_result,
        var_evp_md
    );


    // Release cached frame.
    if ( frame_ff3315c115fcc0322838af618aa26d9c == cache_frame_ff3315c115fcc0322838af618aa26d9c )
    {
        Py_DECREF( frame_ff3315c115fcc0322838af618aa26d9c );
    }
    cache_frame_ff3315c115fcc0322838af618aa26d9c = NULL;

    assertFrameObject( frame_ff3315c115fcc0322838af618aa26d9c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_61_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    CHECK_OBJECT( (PyObject *)var_evp_md );
    Py_DECREF( var_evp_md );
    var_evp_md = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    Py_XDECREF( var_evp_md );
    var_evp_md = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_61_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_62_get_signature_algorithm( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_algor = NULL;
    PyObject *var_nid = NULL;
    struct Nuitka_FrameObject *frame_3e38fc9f9c9ed1ca78f0a360ad365d63;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3e38fc9f9c9ed1ca78f0a360ad365d63 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3e38fc9f9c9ed1ca78f0a360ad365d63, codeobj_3e38fc9f9c9ed1ca78f0a360ad365d63, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3e38fc9f9c9ed1ca78f0a360ad365d63 = cache_frame_3e38fc9f9c9ed1ca78f0a360ad365d63;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get0_tbs_sigalg );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3e38fc9f9c9ed1ca78f0a360ad365d63->m_frame.f_lineno = 1224;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1224;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_algor == NULL );
        var_algor = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_OBJ_obj2nid );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_algor );
        tmp_source_name_4 = var_algor;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_algorithm );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3e38fc9f9c9ed1ca78f0a360ad365d63->m_frame.f_lineno = 1225;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1225;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_nid == NULL );
        var_nid = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_nid );
        tmp_compexpr_left_1 = var_nid;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NID_undef );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1226;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_79dac080796da8f8fc9c66ebe460ce2f;
            frame_3e38fc9f9c9ed1ca78f0a360ad365d63->m_frame.f_lineno = 1227;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1227;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_string );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT( var_nid );
        tmp_args_element_name_4 = var_nid;
        frame_3e38fc9f9c9ed1ca78f0a360ad365d63->m_frame.f_lineno = 1228;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_OBJ_nid2ln, call_args );
        }

        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3e38fc9f9c9ed1ca78f0a360ad365d63->m_frame.f_lineno = 1228;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1228;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3e38fc9f9c9ed1ca78f0a360ad365d63, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3e38fc9f9c9ed1ca78f0a360ad365d63->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3e38fc9f9c9ed1ca78f0a360ad365d63, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3e38fc9f9c9ed1ca78f0a360ad365d63,
        type_description_1,
        par_self,
        var_algor,
        var_nid
    );


    // Release cached frame.
    if ( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 == cache_frame_3e38fc9f9c9ed1ca78f0a360ad365d63 )
    {
        Py_DECREF( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 );
    }
    cache_frame_3e38fc9f9c9ed1ca78f0a360ad365d63 = NULL;

    assertFrameObject( frame_3e38fc9f9c9ed1ca78f0a360ad365d63 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_62_get_signature_algorithm );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_algor );
    Py_DECREF( var_algor );
    var_algor = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_algor );
    var_algor = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_62_get_signature_algorithm );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_63_digest( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_digest_name = python_pars[ 1 ];
    PyObject *var_digest_result = NULL;
    PyObject *var_ch = NULL;
    PyObject *var_result_length = NULL;
    PyObject *var_result_buffer = NULL;
    PyObject *var_digest = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_83351a66f26ebd1513f374fe4435cbc6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_83351a66f26ebd1513f374fe4435cbc6 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_83351a66f26ebd1513f374fe4435cbc6, codeobj_83351a66f26ebd1513f374fe4435cbc6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_83351a66f26ebd1513f374fe4435cbc6 = cache_frame_83351a66f26ebd1513f374fe4435cbc6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_83351a66f26ebd1513f374fe4435cbc6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_83351a66f26ebd1513f374fe4435cbc6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_digestbyname );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_digest_name );
        tmp_args_element_name_2 = par_digest_name;
        frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1241;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1241;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1241;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest == NULL );
        var_digest = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_digest );
        tmp_compexpr_left_1 = var_digest;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1242;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1242;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1242;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1243;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1243;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_new );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_EVP_MAX_MD_SIZE );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1245;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1245;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_buffer == NULL );
        var_result_buffer = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1246;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_6;
        frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1246;
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_bc7a2d385ac0b4ca6f6caa64ccb6a3b9_int_pos_1_tuple, 0 ) );

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1246;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_length == NULL );
        var_result_length = tmp_assign_source_3;
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT( var_result_buffer );
        tmp_len_arg_1 = var_result_buffer;
        tmp_ass_subvalue_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_ass_subvalue_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1247;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result_length );
        tmp_ass_subscribed_1 = var_result_length;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subvalue_1 );
        if ( tmp_ass_subscript_res_1 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1247;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1249;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_digest );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1249;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1250;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_digest );
        tmp_args_element_name_6 = var_digest;
        CHECK_OBJECT( var_result_buffer );
        tmp_args_element_name_7 = var_result_buffer;
        CHECK_OBJECT( var_result_length );
        tmp_args_element_name_8 = var_result_length;
        frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1249;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1249;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest_result == NULL );
        var_digest_result = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1251;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        CHECK_OBJECT( var_digest_result );
        tmp_compexpr_left_2 = var_digest_result;
        tmp_compexpr_right_2 = const_int_pos_1;
        tmp_args_element_name_9 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1251;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1251;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1251;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_10;
        tmp_source_name_7 = const_str_chr_58;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_join );
        assert( !(tmp_called_name_6 == NULL) );
        // Tried code:
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_7;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }

            tmp_source_name_8 = tmp_mvar_value_9;
            tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_buffer );
            if ( tmp_called_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( var_result_buffer );
            tmp_args_element_name_11 = var_result_buffer;
            CHECK_OBJECT( var_result_length );
            tmp_subscribed_name_1 = var_result_length;
            tmp_subscript_name_1 = const_int_0;
            tmp_args_element_name_12 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_args_element_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_7 );

                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1255;
            {
                PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
                tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
            }

            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_12 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1255;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            assert( tmp_list_contraction_1__$0 == NULL );
            tmp_list_contraction_1__$0 = tmp_assign_source_5;
        }
        {
            PyObject *tmp_assign_source_6;
            tmp_assign_source_6 = PyList_New( 0 );
            assert( tmp_list_contraction_1__contraction_result == NULL );
            tmp_list_contraction_1__contraction_result = tmp_assign_source_6;
        }
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_7;
            CHECK_OBJECT( tmp_list_contraction_1__$0 );
            tmp_next_source_1 = tmp_list_contraction_1__$0;
            tmp_assign_source_7 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_7 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooo";
                    exception_lineno = 1254;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_list_contraction_1__iter_value_0;
                tmp_list_contraction_1__iter_value_0 = tmp_assign_source_7;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_8;
            CHECK_OBJECT( tmp_list_contraction_1__iter_value_0 );
            tmp_assign_source_8 = tmp_list_contraction_1__iter_value_0;
            {
                PyObject *old = var_ch;
                var_ch = tmp_assign_source_8;
                Py_INCREF( var_ch );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_called_name_8;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_args_element_name_13;
            CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
            tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_b16encode );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_b16encode );
            }

            if ( tmp_mvar_value_10 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "b16encode" );
                exception_tb = NULL;

                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_8 = tmp_mvar_value_10;
            CHECK_OBJECT( var_ch );
            tmp_args_element_name_13 = var_ch;
            frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1254;
            {
                PyObject *call_args[] = { tmp_args_element_name_13 };
                tmp_called_instance_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
            }

            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1254;
            tmp_append_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_upper );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_append_value_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            assert( PyList_Check( tmp_append_list_1 ) );
            tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
            Py_DECREF( tmp_append_value_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1254;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1254;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
        tmp_args_element_name_10 = tmp_list_contraction_1__contraction_result;
        Py_INCREF( tmp_args_element_name_10 );
        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
        Py_DECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
        Py_DECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        Py_XDECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
        return NULL;
        outline_result_1:;
        frame_83351a66f26ebd1513f374fe4435cbc6->m_frame.f_lineno = 1253;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1253;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83351a66f26ebd1513f374fe4435cbc6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_83351a66f26ebd1513f374fe4435cbc6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_83351a66f26ebd1513f374fe4435cbc6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_83351a66f26ebd1513f374fe4435cbc6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_83351a66f26ebd1513f374fe4435cbc6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_83351a66f26ebd1513f374fe4435cbc6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_83351a66f26ebd1513f374fe4435cbc6,
        type_description_1,
        par_self,
        par_digest_name,
        var_digest_result,
        var_ch,
        var_result_length,
        var_result_buffer,
        var_digest
    );


    // Release cached frame.
    if ( frame_83351a66f26ebd1513f374fe4435cbc6 == cache_frame_83351a66f26ebd1513f374fe4435cbc6 )
    {
        Py_DECREF( frame_83351a66f26ebd1513f374fe4435cbc6 );
    }
    cache_frame_83351a66f26ebd1513f374fe4435cbc6 = NULL;

    assertFrameObject( frame_83351a66f26ebd1513f374fe4435cbc6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_digest_result );
    Py_DECREF( var_digest_result );
    var_digest_result = NULL;

    Py_XDECREF( var_ch );
    var_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_digest_name );
    Py_DECREF( par_digest_name );
    par_digest_name = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result_length );
    Py_DECREF( var_result_length );
    var_result_length = NULL;

    CHECK_OBJECT( (PyObject *)var_result_buffer );
    Py_DECREF( var_result_buffer );
    var_result_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_digest );
    Py_DECREF( var_digest );
    var_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_digest_result );
    var_digest_result = NULL;

    Py_XDECREF( var_ch );
    var_ch = NULL;

    CHECK_OBJECT( (PyObject *)par_digest_name );
    Py_DECREF( par_digest_name );
    par_digest_name = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result_length );
    var_result_length = NULL;

    Py_XDECREF( var_result_buffer );
    var_result_buffer = NULL;

    Py_XDECREF( var_digest );
    var_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_63_digest );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_64_subject_name_hash( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c474aed261102d3b5e4f6b3f98e8fe00;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c474aed261102d3b5e4f6b3f98e8fe00 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c474aed261102d3b5e4f6b3f98e8fe00, codeobj_c474aed261102d3b5e4f6b3f98e8fe00, module_OpenSSL$crypto, sizeof(void *) );
    frame_c474aed261102d3b5e4f6b3f98e8fe00 = cache_frame_c474aed261102d3b5e4f6b3f98e8fe00;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c474aed261102d3b5e4f6b3f98e8fe00 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c474aed261102d3b5e4f6b3f98e8fe00 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_subject_name_hash );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_c474aed261102d3b5e4f6b3f98e8fe00->m_frame.f_lineno = 1264;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1264;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c474aed261102d3b5e4f6b3f98e8fe00 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c474aed261102d3b5e4f6b3f98e8fe00 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c474aed261102d3b5e4f6b3f98e8fe00 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c474aed261102d3b5e4f6b3f98e8fe00, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c474aed261102d3b5e4f6b3f98e8fe00->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c474aed261102d3b5e4f6b3f98e8fe00, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c474aed261102d3b5e4f6b3f98e8fe00,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c474aed261102d3b5e4f6b3f98e8fe00 == cache_frame_c474aed261102d3b5e4f6b3f98e8fe00 )
    {
        Py_DECREF( frame_c474aed261102d3b5e4f6b3f98e8fe00 );
    }
    cache_frame_c474aed261102d3b5e4f6b3f98e8fe00 = NULL;

    assertFrameObject( frame_c474aed261102d3b5e4f6b3f98e8fe00 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_64_subject_name_hash );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_64_subject_name_hash );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_65_set_serial_number( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_serial = python_pars[ 1 ];
    PyObject *var_asn1_serial = NULL;
    PyObject *var_bignum_serial = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_small_serial = NULL;
    PyObject *var_hex_serial = NULL;
    struct Nuitka_FrameObject *frame_0c71584586f74ec422d71fb95ed763aa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0c71584586f74ec422d71fb95ed763aa = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0c71584586f74ec422d71fb95ed763aa, codeobj_0c71584586f74ec422d71fb95ed763aa, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0c71584586f74ec422d71fb95ed763aa = cache_frame_0c71584586f74ec422d71fb95ed763aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0c71584586f74ec422d71fb95ed763aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0c71584586f74ec422d71fb95ed763aa ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_serial );
        tmp_isinstance_inst_1 = par_serial;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__integer_types );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__integer_types );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_integer_types" );
            exception_tb = NULL;

            exception_lineno = 1275;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1275;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1275;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_b1f5a355e1403668d0044e1a65ec29ce;
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1276;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1276;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_hex_arg_1;
        tmp_sliceslicedel_index_lower_1 = 2;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        CHECK_OBJECT( par_serial );
        tmp_hex_arg_1 = par_serial;
        tmp_slice_source_1 = BUILTIN_HEX( tmp_hex_arg_1 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1278;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1278;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_hex_serial == NULL );
        var_hex_serial = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( var_hex_serial );
        tmp_isinstance_inst_2 = var_hex_serial;
        tmp_isinstance_cls_2 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1279;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1279;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( var_hex_serial );
            tmp_called_instance_1 = var_hex_serial;
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1280;
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1280;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_hex_serial;
                assert( old != NULL );
                var_hex_serial = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1282;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1282;
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0 ) );

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1282;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bignum_serial == NULL );
        var_bignum_serial = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1287;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_3;
        CHECK_OBJECT( var_bignum_serial );
        tmp_args_element_name_1 = var_bignum_serial;
        CHECK_OBJECT( var_hex_serial );
        tmp_args_element_name_2 = var_hex_serial;
        frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1287;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_BN_hex2bn, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1287;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_small_serial == NULL );
        var_small_serial = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_bignum_serial );
        tmp_subscribed_name_1 = var_bignum_serial;
        tmp_subscript_name_1 = const_int_0;
        tmp_compexpr_left_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1289;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1290;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ASN1_INTEGER_set );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1290;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_get_serialNumber );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__x509 );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1291;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 1291;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_small_serial );
            tmp_args_element_name_5 = var_small_serial;
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1290;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_5 };
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1290;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_set_result == NULL );
            var_set_result = tmp_assign_source_5;
        }
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_truth_name_1;
            CHECK_OBJECT( var_set_result );
            tmp_truth_name_1 = CHECK_IF_TRUE( var_set_result );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1292;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_called_name_3;
                PyObject *tmp_mvar_value_7;
                PyObject *tmp_call_result_1;
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

                if (unlikely( tmp_mvar_value_7 == NULL ))
                {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
                }

                if ( tmp_mvar_value_7 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                    exception_tb = NULL;

                    exception_lineno = 1294;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_3 = tmp_mvar_value_7;
                frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1294;
                tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1294;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            branch_no_4:;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_5 = tmp_mvar_value_8;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_BN_to_ASN1_INTEGER );
            if ( tmp_called_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bignum_serial );
            tmp_subscribed_name_2 = var_bignum_serial;
            tmp_subscript_name_2 = const_int_0;
            tmp_args_element_name_6 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_4 );

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_9 == NULL )
            {
                Py_DECREF( tmp_called_name_4 );
                Py_DECREF( tmp_args_element_name_6 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_9;
            tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
            if ( tmp_args_element_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_4 );
                Py_DECREF( tmp_args_element_name_6 );

                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1296;
            {
                PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_6 );
            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1296;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_asn1_serial == NULL );
            var_asn1_serial = tmp_assign_source_6;
        }
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_7;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_10 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_7 = tmp_mvar_value_10;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_BN_free );
            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bignum_serial );
            tmp_subscribed_name_3 = var_bignum_serial;
            tmp_subscript_name_3 = const_int_0;
            tmp_args_element_name_8 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1297;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_8 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1297;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_11;
            CHECK_OBJECT( var_asn1_serial );
            tmp_compexpr_left_2 = var_asn1_serial;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1298;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_8 = tmp_mvar_value_11;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_NULL );
            if ( tmp_compexpr_right_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1298;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1298;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_5;
            }
            else
            {
                goto branch_no_5;
            }
            branch_yes_5:;
            {
                PyObject *tmp_called_name_6;
                PyObject *tmp_mvar_value_12;
                PyObject *tmp_call_result_3;
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

                if (unlikely( tmp_mvar_value_12 == NULL ))
                {
                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
                }

                if ( tmp_mvar_value_12 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                    exception_tb = NULL;

                    exception_lineno = 1300;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_6 = tmp_mvar_value_12;
                frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1300;
                tmp_call_result_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1300;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_3 );
            }
            branch_no_5:;
        }
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_called_name_7;
            PyObject *tmp_source_name_9;
            PyObject *tmp_mvar_value_13;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_14;
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_13 == NULL ))
            {
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_13 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_9 = tmp_mvar_value_13;
            tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
            if ( tmp_called_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_asn1_serial );
            tmp_args_element_name_9 = var_asn1_serial;
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_14 == NULL ))
            {
                tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_14 == NULL )
            {
                Py_DECREF( tmp_called_name_7 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_14;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_ASN1_INTEGER_free );
            if ( tmp_args_element_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_7 );

                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1301;
            {
                PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
                tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
            }

            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_10 );
            if ( tmp_assign_source_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1301;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_asn1_serial;
                assert( old != NULL );
                var_asn1_serial = tmp_assign_source_7;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_called_name_8;
            PyObject *tmp_source_name_11;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_args_element_name_12;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_11 = tmp_mvar_value_15;
            tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_X509_set_serialNumber );
            if ( tmp_called_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_12 = par_self;
            tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__x509 );
            if ( tmp_args_element_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_8 );

                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_asn1_serial );
            tmp_args_element_name_12 = var_asn1_serial;
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1302;
            {
                PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
                tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
            }

            Py_DECREF( tmp_called_name_8 );
            Py_DECREF( tmp_args_element_name_11 );
            if ( tmp_assign_source_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1302;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_set_result == NULL );
            var_set_result = tmp_assign_source_8;
        }
        {
            PyObject *tmp_called_name_9;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_call_result_4;
            PyObject *tmp_args_element_name_13;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_16 == NULL ))
            {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_16 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 1303;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_9 = tmp_mvar_value_16;
            CHECK_OBJECT( var_set_result );
            tmp_compexpr_left_3 = var_set_result;
            tmp_compexpr_right_3 = const_int_pos_1;
            tmp_args_element_name_13 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            if ( tmp_args_element_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1303;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_0c71584586f74ec422d71fb95ed763aa->m_frame.f_lineno = 1303;
            {
                PyObject *call_args[] = { tmp_args_element_name_13 };
                tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
            }

            Py_DECREF( tmp_args_element_name_13 );
            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1303;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        branch_end_3:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c71584586f74ec422d71fb95ed763aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0c71584586f74ec422d71fb95ed763aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0c71584586f74ec422d71fb95ed763aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0c71584586f74ec422d71fb95ed763aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0c71584586f74ec422d71fb95ed763aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c71584586f74ec422d71fb95ed763aa,
        type_description_1,
        par_self,
        par_serial,
        var_asn1_serial,
        var_bignum_serial,
        var_set_result,
        var_small_serial,
        var_hex_serial
    );


    // Release cached frame.
    if ( frame_0c71584586f74ec422d71fb95ed763aa == cache_frame_0c71584586f74ec422d71fb95ed763aa )
    {
        Py_DECREF( frame_0c71584586f74ec422d71fb95ed763aa );
    }
    cache_frame_0c71584586f74ec422d71fb95ed763aa = NULL;

    assertFrameObject( frame_0c71584586f74ec422d71fb95ed763aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_65_set_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_bignum_serial );
    Py_DECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    CHECK_OBJECT( (PyObject *)var_small_serial );
    Py_DECREF( var_small_serial );
    var_small_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_hex_serial );
    Py_DECREF( var_hex_serial );
    var_hex_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_serial );
    Py_DECREF( par_serial );
    par_serial = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    Py_XDECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    Py_XDECREF( var_small_serial );
    var_small_serial = NULL;

    Py_XDECREF( var_hex_serial );
    var_hex_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_serial );
    Py_DECREF( par_serial );
    par_serial = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_65_set_serial_number );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_66_get_serial_number( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bignum_serial = NULL;
    PyObject *var_hexstring_serial = NULL;
    PyObject *var_asn1_serial = NULL;
    PyObject *var_hex_serial = NULL;
    PyObject *var_serial = NULL;
    struct Nuitka_FrameObject *frame_de4c7e237ff7a4f38726d637549766fd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_de4c7e237ff7a4f38726d637549766fd = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_de4c7e237ff7a4f38726d637549766fd, codeobj_de4c7e237ff7a4f38726d637549766fd, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_de4c7e237ff7a4f38726d637549766fd = cache_frame_de4c7e237ff7a4f38726d637549766fd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_de4c7e237ff7a4f38726d637549766fd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_de4c7e237ff7a4f38726d637549766fd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_serialNumber );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1312;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1312;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_asn1_serial == NULL );
        var_asn1_serial = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_ASN1_INTEGER_to_BN );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_asn1_serial );
        tmp_args_element_name_2 = var_asn1_serial;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1313;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1313;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bignum_serial == NULL );
        var_bignum_serial = tmp_assign_source_2;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1315;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT( var_bignum_serial );
        tmp_args_element_name_4 = var_bignum_serial;
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1315;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_BN_bn2hex, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1315;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        assert( var_hex_serial == NULL );
        var_hex_serial = tmp_assign_source_3;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1317;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_2 = tmp_mvar_value_5;
        CHECK_OBJECT( var_hex_serial );
        tmp_args_element_name_5 = var_hex_serial;
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1317;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_string, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1317;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        assert( var_hexstring_serial == NULL );
        var_hexstring_serial = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_value_name_1;
        PyObject *tmp_base_name_1;
        CHECK_OBJECT( var_hexstring_serial );
        tmp_value_name_1 = var_hexstring_serial;
        tmp_base_name_1 = const_int_pos_16;
        tmp_assign_source_5 = TO_INT2( tmp_value_name_1, tmp_base_name_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1318;
            type_description_1 = "oooooo";
            goto try_except_handler_3;
        }
        assert( var_serial == NULL );
        var_serial = tmp_assign_source_5;
    }
    CHECK_OBJECT( var_serial );
    tmp_return_value = var_serial;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_6;
        CHECK_OBJECT( var_hex_serial );
        tmp_args_element_name_6 = var_hex_serial;
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1321;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_OPENSSL_free, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            Py_DECREF( exception_keeper_type_1 );
            Py_XDECREF( exception_keeper_value_1 );
            Py_XDECREF( exception_keeper_tb_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_4 = tmp_mvar_value_7;
        CHECK_OBJECT( var_hex_serial );
        tmp_args_element_name_7 = var_hex_serial;
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1321;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_OPENSSL_free, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            Py_DECREF( exception_keeper_type_1 );
            Py_XDECREF( exception_keeper_value_1 );
            Py_XDECREF( exception_keeper_tb_1 );

            exception_lineno = 1321;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    {
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_5 = tmp_mvar_value_8;
        CHECK_OBJECT( var_bignum_serial );
        tmp_args_element_name_8 = var_bignum_serial;
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1323;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_BN_free, call_args );
        }

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    {
        PyObject *tmp_called_instance_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            Py_DECREF( exception_keeper_type_2 );
            Py_XDECREF( exception_keeper_value_2 );
            Py_XDECREF( exception_keeper_tb_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_6 = tmp_mvar_value_9;
        CHECK_OBJECT( var_bignum_serial );
        tmp_args_element_name_9 = var_bignum_serial;
        frame_de4c7e237ff7a4f38726d637549766fd->m_frame.f_lineno = 1323;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_BN_free, call_args );
        }

        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            Py_DECREF( exception_keeper_type_2 );
            Py_XDECREF( exception_keeper_value_2 );
            Py_XDECREF( exception_keeper_tb_2 );

            exception_lineno = 1323;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_de4c7e237ff7a4f38726d637549766fd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_de4c7e237ff7a4f38726d637549766fd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_de4c7e237ff7a4f38726d637549766fd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_de4c7e237ff7a4f38726d637549766fd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_de4c7e237ff7a4f38726d637549766fd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_de4c7e237ff7a4f38726d637549766fd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_de4c7e237ff7a4f38726d637549766fd,
        type_description_1,
        par_self,
        var_bignum_serial,
        var_hexstring_serial,
        var_asn1_serial,
        var_hex_serial,
        var_serial
    );


    // Release cached frame.
    if ( frame_de4c7e237ff7a4f38726d637549766fd == cache_frame_de4c7e237ff7a4f38726d637549766fd )
    {
        Py_DECREF( frame_de4c7e237ff7a4f38726d637549766fd );
    }
    cache_frame_de4c7e237ff7a4f38726d637549766fd = NULL;

    assertFrameObject( frame_de4c7e237ff7a4f38726d637549766fd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bignum_serial );
    Py_DECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_hexstring_serial );
    Py_DECREF( var_hexstring_serial );
    var_hexstring_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_asn1_serial );
    Py_DECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_hex_serial );
    Py_DECREF( var_hex_serial );
    var_hex_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_serial );
    Py_DECREF( var_serial );
    var_serial = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_hexstring_serial );
    var_hexstring_serial = NULL;

    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    Py_XDECREF( var_hex_serial );
    var_hex_serial = NULL;

    Py_XDECREF( var_serial );
    var_serial = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_66_get_serial_number );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_amount = python_pars[ 1 ];
    PyObject *var_notAfter = NULL;
    struct Nuitka_FrameObject *frame_3fc7b9425fa546666c4ea6616c19376d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3fc7b9425fa546666c4ea6616c19376d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3fc7b9425fa546666c4ea6616c19376d, codeobj_3fc7b9425fa546666c4ea6616c19376d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3fc7b9425fa546666c4ea6616c19376d = cache_frame_3fc7b9425fa546666c4ea6616c19376d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3fc7b9425fa546666c4ea6616c19376d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3fc7b9425fa546666c4ea6616c19376d ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_amount );
        tmp_isinstance_inst_1 = par_amount;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1333;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1333;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
            frame_3fc7b9425fa546666c4ea6616c19376d->m_frame.f_lineno = 1334;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1334;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_notAfter );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3fc7b9425fa546666c4ea6616c19376d->m_frame.f_lineno = 1336;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_notAfter == NULL );
        var_notAfter = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1337;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_notAfter );
        tmp_args_element_name_2 = var_notAfter;
        CHECK_OBJECT( par_amount );
        tmp_args_element_name_3 = par_amount;
        frame_3fc7b9425fa546666c4ea6616c19376d->m_frame.f_lineno = 1337;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_X509_gmtime_adj, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1337;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fc7b9425fa546666c4ea6616c19376d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fc7b9425fa546666c4ea6616c19376d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3fc7b9425fa546666c4ea6616c19376d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3fc7b9425fa546666c4ea6616c19376d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3fc7b9425fa546666c4ea6616c19376d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3fc7b9425fa546666c4ea6616c19376d,
        type_description_1,
        par_self,
        par_amount,
        var_notAfter
    );


    // Release cached frame.
    if ( frame_3fc7b9425fa546666c4ea6616c19376d == cache_frame_3fc7b9425fa546666c4ea6616c19376d )
    {
        Py_DECREF( frame_3fc7b9425fa546666c4ea6616c19376d );
    }
    cache_frame_3fc7b9425fa546666c4ea6616c19376d = NULL;

    assertFrameObject( frame_3fc7b9425fa546666c4ea6616c19376d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_67_gmtime_adj_notAfter );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    CHECK_OBJECT( (PyObject *)var_notAfter );
    Py_DECREF( var_notAfter );
    var_notAfter = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    Py_XDECREF( var_notAfter );
    var_notAfter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_67_gmtime_adj_notAfter );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_amount = python_pars[ 1 ];
    PyObject *var_notBefore = NULL;
    struct Nuitka_FrameObject *frame_6f4b7a8a0a555afc1990275873d5d9ae;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6f4b7a8a0a555afc1990275873d5d9ae = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6f4b7a8a0a555afc1990275873d5d9ae, codeobj_6f4b7a8a0a555afc1990275873d5d9ae, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6f4b7a8a0a555afc1990275873d5d9ae = cache_frame_6f4b7a8a0a555afc1990275873d5d9ae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6f4b7a8a0a555afc1990275873d5d9ae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6f4b7a8a0a555afc1990275873d5d9ae ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_amount );
        tmp_isinstance_inst_1 = par_amount;
        tmp_isinstance_cls_1 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_117006b03ff8e10f330ac900a6cd41e8;
            frame_6f4b7a8a0a555afc1990275873d5d9ae->m_frame.f_lineno = 1347;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1347;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_notBefore );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_6f4b7a8a0a555afc1990275873d5d9ae->m_frame.f_lineno = 1349;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1349;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_notBefore == NULL );
        var_notBefore = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1350;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_notBefore );
        tmp_args_element_name_2 = var_notBefore;
        CHECK_OBJECT( par_amount );
        tmp_args_element_name_3 = par_amount;
        frame_6f4b7a8a0a555afc1990275873d5d9ae->m_frame.f_lineno = 1350;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_X509_gmtime_adj, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1350;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f4b7a8a0a555afc1990275873d5d9ae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6f4b7a8a0a555afc1990275873d5d9ae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6f4b7a8a0a555afc1990275873d5d9ae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6f4b7a8a0a555afc1990275873d5d9ae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6f4b7a8a0a555afc1990275873d5d9ae, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6f4b7a8a0a555afc1990275873d5d9ae,
        type_description_1,
        par_self,
        par_amount,
        var_notBefore
    );


    // Release cached frame.
    if ( frame_6f4b7a8a0a555afc1990275873d5d9ae == cache_frame_6f4b7a8a0a555afc1990275873d5d9ae )
    {
        Py_DECREF( frame_6f4b7a8a0a555afc1990275873d5d9ae );
    }
    cache_frame_6f4b7a8a0a555afc1990275873d5d9ae = NULL;

    assertFrameObject( frame_6f4b7a8a0a555afc1990275873d5d9ae );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_68_gmtime_adj_notBefore );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    CHECK_OBJECT( (PyObject *)var_notBefore );
    Py_DECREF( var_notBefore );
    var_notBefore = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_amount );
    Py_DECREF( par_amount );
    par_amount = NULL;

    Py_XDECREF( var_notBefore );
    var_notBefore = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_68_gmtime_adj_notBefore );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_69_has_expired( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_not_after = NULL;
    PyObject *var_time_string = NULL;
    struct Nuitka_FrameObject *frame_da38dadd4eb8df9253df88a35a690ea3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_da38dadd4eb8df9253df88a35a690ea3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_da38dadd4eb8df9253df88a35a690ea3, codeobj_da38dadd4eb8df9253df88a35a690ea3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_da38dadd4eb8df9253df88a35a690ea3 = cache_frame_da38dadd4eb8df9253df88a35a690ea3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_da38dadd4eb8df9253df88a35a690ea3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_da38dadd4eb8df9253df88a35a690ea3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
            exception_tb = NULL;

            exception_lineno = 1359;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_da38dadd4eb8df9253df88a35a690ea3->m_frame.f_lineno = 1359;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_get_notAfter );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1359;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_da38dadd4eb8df9253df88a35a690ea3->m_frame.f_lineno = 1359;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1359;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_time_string == NULL );
        var_time_string = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "datetime" );
            exception_tb = NULL;

            exception_lineno = 1360;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_datetime );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1360;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_time_string );
        tmp_args_element_name_2 = var_time_string;
        tmp_args_element_name_3 = const_str_digest_9838c39bdf9fdb401c17b0106d8660a3;
        frame_da38dadd4eb8df9253df88a35a690ea3->m_frame.f_lineno = 1360;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_strptime, call_args );
        }

        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1360;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_not_after == NULL );
        var_not_after = tmp_assign_source_2;
    }
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_not_after );
        tmp_compexpr_left_1 = var_not_after;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_datetime );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "datetime" );
            exception_tb = NULL;

            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_datetime );
        if ( tmp_called_instance_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_da38dadd4eb8df9253df88a35a690ea3->m_frame.f_lineno = 1362;
        tmp_compexpr_right_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_utcnow );
        Py_DECREF( tmp_called_instance_3 );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_da38dadd4eb8df9253df88a35a690ea3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_da38dadd4eb8df9253df88a35a690ea3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_da38dadd4eb8df9253df88a35a690ea3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_da38dadd4eb8df9253df88a35a690ea3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_da38dadd4eb8df9253df88a35a690ea3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_da38dadd4eb8df9253df88a35a690ea3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_da38dadd4eb8df9253df88a35a690ea3,
        type_description_1,
        par_self,
        var_not_after,
        var_time_string
    );


    // Release cached frame.
    if ( frame_da38dadd4eb8df9253df88a35a690ea3 == cache_frame_da38dadd4eb8df9253df88a35a690ea3 )
    {
        Py_DECREF( frame_da38dadd4eb8df9253df88a35a690ea3 );
    }
    cache_frame_da38dadd4eb8df9253df88a35a690ea3 = NULL;

    assertFrameObject( frame_da38dadd4eb8df9253df88a35a690ea3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_69_has_expired );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_not_after );
    Py_DECREF( var_not_after );
    var_not_after = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_time_string );
    Py_DECREF( var_time_string );
    var_time_string = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_not_after );
    var_not_after = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_time_string );
    var_time_string = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_69_has_expired );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_70__get_boundary_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_0d1f0497dba37a9b164ae4b60dcd4d90;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0d1f0497dba37a9b164ae4b60dcd4d90 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0d1f0497dba37a9b164ae4b60dcd4d90, codeobj_0d1f0497dba37a9b164ae4b60dcd4d90, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_0d1f0497dba37a9b164ae4b60dcd4d90 = cache_frame_0d1f0497dba37a9b164ae4b60dcd4d90;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0d1f0497dba37a9b164ae4b60dcd4d90 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0d1f0497dba37a9b164ae4b60dcd4d90 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_asn1_time );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_asn1_time" );
            exception_tb = NULL;

            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_which );
        tmp_called_name_2 = par_which;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_0d1f0497dba37a9b164ae4b60dcd4d90->m_frame.f_lineno = 1365;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_0d1f0497dba37a9b164ae4b60dcd4d90->m_frame.f_lineno = 1365;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1365;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d1f0497dba37a9b164ae4b60dcd4d90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d1f0497dba37a9b164ae4b60dcd4d90 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d1f0497dba37a9b164ae4b60dcd4d90 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0d1f0497dba37a9b164ae4b60dcd4d90, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0d1f0497dba37a9b164ae4b60dcd4d90->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0d1f0497dba37a9b164ae4b60dcd4d90, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0d1f0497dba37a9b164ae4b60dcd4d90,
        type_description_1,
        par_self,
        par_which
    );


    // Release cached frame.
    if ( frame_0d1f0497dba37a9b164ae4b60dcd4d90 == cache_frame_0d1f0497dba37a9b164ae4b60dcd4d90 )
    {
        Py_DECREF( frame_0d1f0497dba37a9b164ae4b60dcd4d90 );
    }
    cache_frame_0d1f0497dba37a9b164ae4b60dcd4d90 = NULL;

    assertFrameObject( frame_0d1f0497dba37a9b164ae4b60dcd4d90 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_70__get_boundary_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_70__get_boundary_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_71_get_notBefore( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d4151e0f9a9e8aa47862a42aa12c8f43;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d4151e0f9a9e8aa47862a42aa12c8f43 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d4151e0f9a9e8aa47862a42aa12c8f43, codeobj_d4151e0f9a9e8aa47862a42aa12c8f43, module_OpenSSL$crypto, sizeof(void *) );
    frame_d4151e0f9a9e8aa47862a42aa12c8f43 = cache_frame_d4151e0f9a9e8aa47862a42aa12c8f43;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d4151e0f9a9e8aa47862a42aa12c8f43 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d4151e0f9a9e8aa47862a42aa12c8f43 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_boundary_time );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_notBefore );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_d4151e0f9a9e8aa47862a42aa12c8f43->m_frame.f_lineno = 1378;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1378;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4151e0f9a9e8aa47862a42aa12c8f43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4151e0f9a9e8aa47862a42aa12c8f43 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4151e0f9a9e8aa47862a42aa12c8f43 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d4151e0f9a9e8aa47862a42aa12c8f43, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d4151e0f9a9e8aa47862a42aa12c8f43->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d4151e0f9a9e8aa47862a42aa12c8f43, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d4151e0f9a9e8aa47862a42aa12c8f43,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d4151e0f9a9e8aa47862a42aa12c8f43 == cache_frame_d4151e0f9a9e8aa47862a42aa12c8f43 )
    {
        Py_DECREF( frame_d4151e0f9a9e8aa47862a42aa12c8f43 );
    }
    cache_frame_d4151e0f9a9e8aa47862a42aa12c8f43 = NULL;

    assertFrameObject( frame_d4151e0f9a9e8aa47862a42aa12c8f43 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_71_get_notBefore );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_71_get_notBefore );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_72__set_boundary_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *par_when = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_3127dbe27680f0c65ac42a57d59c9b15;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3127dbe27680f0c65ac42a57d59c9b15 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3127dbe27680f0c65ac42a57d59c9b15, codeobj_3127dbe27680f0c65ac42a57d59c9b15, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3127dbe27680f0c65ac42a57d59c9b15 = cache_frame_3127dbe27680f0c65ac42a57d59c9b15;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3127dbe27680f0c65ac42a57d59c9b15 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3127dbe27680f0c65ac42a57d59c9b15 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_set_asn1_time" );
            exception_tb = NULL;

            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_which );
        tmp_called_name_2 = par_which;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3127dbe27680f0c65ac42a57d59c9b15->m_frame.f_lineno = 1381;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_when );
        tmp_args_element_name_3 = par_when;
        frame_3127dbe27680f0c65ac42a57d59c9b15->m_frame.f_lineno = 1381;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3127dbe27680f0c65ac42a57d59c9b15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3127dbe27680f0c65ac42a57d59c9b15 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3127dbe27680f0c65ac42a57d59c9b15 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3127dbe27680f0c65ac42a57d59c9b15, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3127dbe27680f0c65ac42a57d59c9b15->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3127dbe27680f0c65ac42a57d59c9b15, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3127dbe27680f0c65ac42a57d59c9b15,
        type_description_1,
        par_self,
        par_which,
        par_when
    );


    // Release cached frame.
    if ( frame_3127dbe27680f0c65ac42a57d59c9b15 == cache_frame_3127dbe27680f0c65ac42a57d59c9b15 )
    {
        Py_DECREF( frame_3127dbe27680f0c65ac42a57d59c9b15 );
    }
    cache_frame_3127dbe27680f0c65ac42a57d59c9b15 = NULL;

    assertFrameObject( frame_3127dbe27680f0c65ac42a57d59c9b15 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_72__set_boundary_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_72__set_boundary_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_73_set_notBefore( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_dbe86b73598b46271e67f0b9f613c00a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_dbe86b73598b46271e67f0b9f613c00a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dbe86b73598b46271e67f0b9f613c00a, codeobj_dbe86b73598b46271e67f0b9f613c00a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_dbe86b73598b46271e67f0b9f613c00a = cache_frame_dbe86b73598b46271e67f0b9f613c00a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dbe86b73598b46271e67f0b9f613c00a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dbe86b73598b46271e67f0b9f613c00a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_notBefore );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_when );
        tmp_args_element_name_2 = par_when;
        frame_dbe86b73598b46271e67f0b9f613c00a->m_frame.f_lineno = 1394;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbe86b73598b46271e67f0b9f613c00a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbe86b73598b46271e67f0b9f613c00a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbe86b73598b46271e67f0b9f613c00a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dbe86b73598b46271e67f0b9f613c00a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dbe86b73598b46271e67f0b9f613c00a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dbe86b73598b46271e67f0b9f613c00a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dbe86b73598b46271e67f0b9f613c00a,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_dbe86b73598b46271e67f0b9f613c00a == cache_frame_dbe86b73598b46271e67f0b9f613c00a )
    {
        Py_DECREF( frame_dbe86b73598b46271e67f0b9f613c00a );
    }
    cache_frame_dbe86b73598b46271e67f0b9f613c00a = NULL;

    assertFrameObject( frame_dbe86b73598b46271e67f0b9f613c00a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_73_set_notBefore );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_73_set_notBefore );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_74_get_notAfter( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9c55547d55b45e1f2119700eb745837a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9c55547d55b45e1f2119700eb745837a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9c55547d55b45e1f2119700eb745837a, codeobj_9c55547d55b45e1f2119700eb745837a, module_OpenSSL$crypto, sizeof(void *) );
    frame_9c55547d55b45e1f2119700eb745837a = cache_frame_9c55547d55b45e1f2119700eb745837a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9c55547d55b45e1f2119700eb745837a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9c55547d55b45e1f2119700eb745837a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_boundary_time );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_notAfter );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_9c55547d55b45e1f2119700eb745837a->m_frame.f_lineno = 1407;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c55547d55b45e1f2119700eb745837a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c55547d55b45e1f2119700eb745837a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c55547d55b45e1f2119700eb745837a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9c55547d55b45e1f2119700eb745837a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9c55547d55b45e1f2119700eb745837a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9c55547d55b45e1f2119700eb745837a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9c55547d55b45e1f2119700eb745837a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9c55547d55b45e1f2119700eb745837a == cache_frame_9c55547d55b45e1f2119700eb745837a )
    {
        Py_DECREF( frame_9c55547d55b45e1f2119700eb745837a );
    }
    cache_frame_9c55547d55b45e1f2119700eb745837a = NULL;

    assertFrameObject( frame_9c55547d55b45e1f2119700eb745837a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_74_get_notAfter );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_74_get_notAfter );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_75_set_notAfter( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_f8c39137ff00684bc5503c4fb8f68575;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f8c39137ff00684bc5503c4fb8f68575 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f8c39137ff00684bc5503c4fb8f68575, codeobj_f8c39137ff00684bc5503c4fb8f68575, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_f8c39137ff00684bc5503c4fb8f68575 = cache_frame_f8c39137ff00684bc5503c4fb8f68575;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f8c39137ff00684bc5503c4fb8f68575 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f8c39137ff00684bc5503c4fb8f68575 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_notAfter );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_when );
        tmp_args_element_name_2 = par_when;
        frame_f8c39137ff00684bc5503c4fb8f68575->m_frame.f_lineno = 1420;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1420;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8c39137ff00684bc5503c4fb8f68575 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8c39137ff00684bc5503c4fb8f68575 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8c39137ff00684bc5503c4fb8f68575 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f8c39137ff00684bc5503c4fb8f68575, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f8c39137ff00684bc5503c4fb8f68575->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f8c39137ff00684bc5503c4fb8f68575, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f8c39137ff00684bc5503c4fb8f68575,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_f8c39137ff00684bc5503c4fb8f68575 == cache_frame_f8c39137ff00684bc5503c4fb8f68575 )
    {
        Py_DECREF( frame_f8c39137ff00684bc5503c4fb8f68575 );
    }
    cache_frame_f8c39137ff00684bc5503c4fb8f68575 = NULL;

    assertFrameObject( frame_f8c39137ff00684bc5503c4fb8f68575 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_75_set_notAfter );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_75_set_notAfter );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_76__get_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_87faf2505fcb253335d3ffaa0e318e59;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_87faf2505fcb253335d3ffaa0e318e59 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_87faf2505fcb253335d3ffaa0e318e59, codeobj_87faf2505fcb253335d3ffaa0e318e59, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_87faf2505fcb253335d3ffaa0e318e59 = cache_frame_87faf2505fcb253335d3ffaa0e318e59;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_87faf2505fcb253335d3ffaa0e318e59 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_87faf2505fcb253335d3ffaa0e318e59 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_87faf2505fcb253335d3ffaa0e318e59->m_frame.f_lineno = 1423;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1423;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_name == NULL );
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_which );
        tmp_called_name_2 = par_which;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1424;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_87faf2505fcb253335d3ffaa0e318e59->m_frame.f_lineno = 1424;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1424;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_name );
        tmp_assattr_target_1 = var_name;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1424;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT( var_name );
        tmp_source_name_3 = var_name;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__name );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_87faf2505fcb253335d3ffaa0e318e59->m_frame.f_lineno = 1425;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1425;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_self );
        tmp_assattr_name_2 = par_self;
        CHECK_OBJECT( var_name );
        tmp_assattr_target_2 = var_name;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__owner, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1429;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87faf2505fcb253335d3ffaa0e318e59 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87faf2505fcb253335d3ffaa0e318e59 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_87faf2505fcb253335d3ffaa0e318e59, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_87faf2505fcb253335d3ffaa0e318e59->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_87faf2505fcb253335d3ffaa0e318e59, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_87faf2505fcb253335d3ffaa0e318e59,
        type_description_1,
        par_self,
        par_which,
        var_name
    );


    // Release cached frame.
    if ( frame_87faf2505fcb253335d3ffaa0e318e59 == cache_frame_87faf2505fcb253335d3ffaa0e318e59 )
    {
        Py_DECREF( frame_87faf2505fcb253335d3ffaa0e318e59 );
    }
    cache_frame_87faf2505fcb253335d3ffaa0e318e59 = NULL;

    assertFrameObject( frame_87faf2505fcb253335d3ffaa0e318e59 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_name );
    tmp_return_value = var_name;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_76__get_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_76__get_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_77__set_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_a6726744ebe17f9af48cee0d79422468;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a6726744ebe17f9af48cee0d79422468 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a6726744ebe17f9af48cee0d79422468, codeobj_a6726744ebe17f9af48cee0d79422468, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a6726744ebe17f9af48cee0d79422468 = cache_frame_a6726744ebe17f9af48cee0d79422468;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a6726744ebe17f9af48cee0d79422468 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a6726744ebe17f9af48cee0d79422468 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_name );
        tmp_isinstance_inst_1 = par_name;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 1434;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1434;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1434;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_b3f225987bb27e065a500d7fe8bd7c70;
            frame_a6726744ebe17f9af48cee0d79422468->m_frame.f_lineno = 1435;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1435;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_which );
        tmp_called_name_1 = par_which;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1436;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_source_name_2 = par_name;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__name );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1436;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_a6726744ebe17f9af48cee0d79422468->m_frame.f_lineno = 1436;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1436;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_set_result == NULL );
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1437;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_set_result );
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1437;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_a6726744ebe17f9af48cee0d79422468->m_frame.f_lineno = 1437;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1437;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a6726744ebe17f9af48cee0d79422468 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a6726744ebe17f9af48cee0d79422468 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a6726744ebe17f9af48cee0d79422468, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a6726744ebe17f9af48cee0d79422468->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a6726744ebe17f9af48cee0d79422468, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a6726744ebe17f9af48cee0d79422468,
        type_description_1,
        par_self,
        par_which,
        par_name,
        var_set_result
    );


    // Release cached frame.
    if ( frame_a6726744ebe17f9af48cee0d79422468 == cache_frame_a6726744ebe17f9af48cee0d79422468 )
    {
        Py_DECREF( frame_a6726744ebe17f9af48cee0d79422468 );
    }
    cache_frame_a6726744ebe17f9af48cee0d79422468 = NULL;

    assertFrameObject( frame_a6726744ebe17f9af48cee0d79422468 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_77__set_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_77__set_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_78_get_issuer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_fd58d0714ce26a74bd1e7f490fd4c5d4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fd58d0714ce26a74bd1e7f490fd4c5d4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fd58d0714ce26a74bd1e7f490fd4c5d4, codeobj_fd58d0714ce26a74bd1e7f490fd4c5d4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_fd58d0714ce26a74bd1e7f490fd4c5d4 = cache_frame_fd58d0714ce26a74bd1e7f490fd4c5d4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fd58d0714ce26a74bd1e7f490fd4c5d4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fd58d0714ce26a74bd1e7f490fd4c5d4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_name );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_issuer_name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_fd58d0714ce26a74bd1e7f490fd4c5d4->m_frame.f_lineno = 1451;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1451;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_name == NULL );
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__issuer_invalidator );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1452;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_name );
        tmp_args_element_name_2 = var_name;
        frame_fd58d0714ce26a74bd1e7f490fd4c5d4->m_frame.f_lineno = 1452;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_add, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1452;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd58d0714ce26a74bd1e7f490fd4c5d4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd58d0714ce26a74bd1e7f490fd4c5d4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fd58d0714ce26a74bd1e7f490fd4c5d4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fd58d0714ce26a74bd1e7f490fd4c5d4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fd58d0714ce26a74bd1e7f490fd4c5d4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fd58d0714ce26a74bd1e7f490fd4c5d4,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_fd58d0714ce26a74bd1e7f490fd4c5d4 == cache_frame_fd58d0714ce26a74bd1e7f490fd4c5d4 )
    {
        Py_DECREF( frame_fd58d0714ce26a74bd1e7f490fd4c5d4 );
    }
    cache_frame_fd58d0714ce26a74bd1e7f490fd4c5d4 = NULL;

    assertFrameObject( frame_fd58d0714ce26a74bd1e7f490fd4c5d4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_name );
    tmp_return_value = var_name;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_78_get_issuer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_78_get_issuer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_79_set_issuer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_issuer = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_8871586b9593b7dcfe1a8959b4852b60;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8871586b9593b7dcfe1a8959b4852b60 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8871586b9593b7dcfe1a8959b4852b60, codeobj_8871586b9593b7dcfe1a8959b4852b60, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_8871586b9593b7dcfe1a8959b4852b60 = cache_frame_8871586b9593b7dcfe1a8959b4852b60;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8871586b9593b7dcfe1a8959b4852b60 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8871586b9593b7dcfe1a8959b4852b60 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_name );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_set_issuer_name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_issuer );
        tmp_args_element_name_2 = par_issuer;
        frame_8871586b9593b7dcfe1a8959b4852b60->m_frame.f_lineno = 1464;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1464;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__issuer_invalidator );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1465;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8871586b9593b7dcfe1a8959b4852b60->m_frame.f_lineno = 1465;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_clear );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1465;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8871586b9593b7dcfe1a8959b4852b60 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8871586b9593b7dcfe1a8959b4852b60 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8871586b9593b7dcfe1a8959b4852b60, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8871586b9593b7dcfe1a8959b4852b60->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8871586b9593b7dcfe1a8959b4852b60, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8871586b9593b7dcfe1a8959b4852b60,
        type_description_1,
        par_self,
        par_issuer
    );


    // Release cached frame.
    if ( frame_8871586b9593b7dcfe1a8959b4852b60 == cache_frame_8871586b9593b7dcfe1a8959b4852b60 )
    {
        Py_DECREF( frame_8871586b9593b7dcfe1a8959b4852b60 );
    }
    cache_frame_8871586b9593b7dcfe1a8959b4852b60 = NULL;

    assertFrameObject( frame_8871586b9593b7dcfe1a8959b4852b60 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_79_set_issuer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer );
    Py_DECREF( par_issuer );
    par_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_79_set_issuer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_80_get_subject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_name = NULL;
    struct Nuitka_FrameObject *frame_ebc8c731c4308b3df5f2999eec8135b7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ebc8c731c4308b3df5f2999eec8135b7 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ebc8c731c4308b3df5f2999eec8135b7, codeobj_ebc8c731c4308b3df5f2999eec8135b7, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_ebc8c731c4308b3df5f2999eec8135b7 = cache_frame_ebc8c731c4308b3df5f2999eec8135b7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ebc8c731c4308b3df5f2999eec8135b7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ebc8c731c4308b3df5f2999eec8135b7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__get_name );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_subject_name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_ebc8c731c4308b3df5f2999eec8135b7->m_frame.f_lineno = 1479;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1479;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_name == NULL );
        var_name = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__subject_invalidator );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_name );
        tmp_args_element_name_2 = var_name;
        frame_ebc8c731c4308b3df5f2999eec8135b7->m_frame.f_lineno = 1480;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_add, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1480;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebc8c731c4308b3df5f2999eec8135b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebc8c731c4308b3df5f2999eec8135b7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ebc8c731c4308b3df5f2999eec8135b7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ebc8c731c4308b3df5f2999eec8135b7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ebc8c731c4308b3df5f2999eec8135b7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ebc8c731c4308b3df5f2999eec8135b7,
        type_description_1,
        par_self,
        var_name
    );


    // Release cached frame.
    if ( frame_ebc8c731c4308b3df5f2999eec8135b7 == cache_frame_ebc8c731c4308b3df5f2999eec8135b7 )
    {
        Py_DECREF( frame_ebc8c731c4308b3df5f2999eec8135b7 );
    }
    cache_frame_ebc8c731c4308b3df5f2999eec8135b7 = NULL;

    assertFrameObject( frame_ebc8c731c4308b3df5f2999eec8135b7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_name );
    tmp_return_value = var_name;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_80_get_subject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_80_get_subject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_81_set_subject( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_subject = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_ae1f066821a09f20b88eb8608a297549;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ae1f066821a09f20b88eb8608a297549 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ae1f066821a09f20b88eb8608a297549, codeobj_ae1f066821a09f20b88eb8608a297549, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_ae1f066821a09f20b88eb8608a297549 = cache_frame_ae1f066821a09f20b88eb8608a297549;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ae1f066821a09f20b88eb8608a297549 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ae1f066821a09f20b88eb8608a297549 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_name );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_set_subject_name );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_subject );
        tmp_args_element_name_2 = par_subject;
        frame_ae1f066821a09f20b88eb8608a297549->m_frame.f_lineno = 1492;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1492;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__subject_invalidator );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_ae1f066821a09f20b88eb8608a297549->m_frame.f_lineno = 1493;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_clear );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1493;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ae1f066821a09f20b88eb8608a297549 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ae1f066821a09f20b88eb8608a297549 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ae1f066821a09f20b88eb8608a297549, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ae1f066821a09f20b88eb8608a297549->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ae1f066821a09f20b88eb8608a297549, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ae1f066821a09f20b88eb8608a297549,
        type_description_1,
        par_self,
        par_subject
    );


    // Release cached frame.
    if ( frame_ae1f066821a09f20b88eb8608a297549 == cache_frame_ae1f066821a09f20b88eb8608a297549 )
    {
        Py_DECREF( frame_ae1f066821a09f20b88eb8608a297549 );
    }
    cache_frame_ae1f066821a09f20b88eb8608a297549 = NULL;

    assertFrameObject( frame_ae1f066821a09f20b88eb8608a297549 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_81_set_subject );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_subject );
    Py_DECREF( par_subject );
    par_subject = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_81_set_subject );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_82_get_extension_count( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_4c8ce226b675a3a62920440c65572b34;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4c8ce226b675a3a62920440c65572b34 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4c8ce226b675a3a62920440c65572b34, codeobj_4c8ce226b675a3a62920440c65572b34, module_OpenSSL$crypto, sizeof(void *) );
    frame_4c8ce226b675a3a62920440c65572b34 = cache_frame_4c8ce226b675a3a62920440c65572b34;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4c8ce226b675a3a62920440c65572b34 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4c8ce226b675a3a62920440c65572b34 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_get_ext_count );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_4c8ce226b675a3a62920440c65572b34->m_frame.f_lineno = 1504;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1504;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c8ce226b675a3a62920440c65572b34 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c8ce226b675a3a62920440c65572b34 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4c8ce226b675a3a62920440c65572b34 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4c8ce226b675a3a62920440c65572b34, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4c8ce226b675a3a62920440c65572b34->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4c8ce226b675a3a62920440c65572b34, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4c8ce226b675a3a62920440c65572b34,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_4c8ce226b675a3a62920440c65572b34 == cache_frame_4c8ce226b675a3a62920440c65572b34 )
    {
        Py_DECREF( frame_4c8ce226b675a3a62920440c65572b34 );
    }
    cache_frame_4c8ce226b675a3a62920440c65572b34 = NULL;

    assertFrameObject( frame_4c8ce226b675a3a62920440c65572b34 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_82_get_extension_count );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_82_get_extension_count );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_83_add_extensions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_extensions = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *var_add_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_eaea0b733ecd041102dac535c4e48296;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_eaea0b733ecd041102dac535c4e48296 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eaea0b733ecd041102dac535c4e48296, codeobj_eaea0b733ecd041102dac535c4e48296, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_eaea0b733ecd041102dac535c4e48296 = cache_frame_eaea0b733ecd041102dac535c4e48296;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eaea0b733ecd041102dac535c4e48296 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eaea0b733ecd041102dac535c4e48296 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_extensions );
        tmp_iter_arg_1 = par_extensions;
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1514;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 1514;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_3;
            Py_INCREF( var_ext );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( var_ext );
        tmp_isinstance_inst_1 = var_ext;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
            exception_tb = NULL;

            exception_lineno = 1515;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1515;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1515;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c57795fb6a9ac3d47e928f9a8b608571;
            frame_eaea0b733ecd041102dac535c4e48296->m_frame.f_lineno = 1516;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1516;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_add_ext );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_ext );
        tmp_source_name_3 = var_ext;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__extension );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_3 = const_int_neg_1;
        frame_eaea0b733ecd041102dac535c4e48296->m_frame.f_lineno = 1518;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1518;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_add_result;
            var_add_result = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_add_result );
        tmp_operand_name_2 = var_add_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1519;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1520;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_eaea0b733ecd041102dac535c4e48296->m_frame.f_lineno = 1520;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1520;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_2:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1514;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eaea0b733ecd041102dac535c4e48296 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eaea0b733ecd041102dac535c4e48296 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eaea0b733ecd041102dac535c4e48296, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eaea0b733ecd041102dac535c4e48296->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eaea0b733ecd041102dac535c4e48296, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eaea0b733ecd041102dac535c4e48296,
        type_description_1,
        par_self,
        par_extensions,
        var_ext,
        var_add_result
    );


    // Release cached frame.
    if ( frame_eaea0b733ecd041102dac535c4e48296 == cache_frame_eaea0b733ecd041102dac535c4e48296 )
    {
        Py_DECREF( frame_eaea0b733ecd041102dac535c4e48296 );
    }
    cache_frame_eaea0b733ecd041102dac535c4e48296 = NULL;

    assertFrameObject( frame_eaea0b733ecd041102dac535c4e48296 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_83_add_extensions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_extensions );
    Py_DECREF( par_extensions );
    par_extensions = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_83_add_extensions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_84_get_extension( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_index = python_pars[ 1 ];
    PyObject *var_ext = NULL;
    PyObject *var_extension = NULL;
    struct Nuitka_FrameObject *frame_36dd5b9a4d1d6a7dc1fc5a680c728521;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_36dd5b9a4d1d6a7dc1fc5a680c728521 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_36dd5b9a4d1d6a7dc1fc5a680c728521, codeobj_36dd5b9a4d1d6a7dc1fc5a680c728521, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_36dd5b9a4d1d6a7dc1fc5a680c728521 = cache_frame_36dd5b9a4d1d6a7dc1fc5a680c728521;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_36dd5b9a4d1d6a7dc1fc5a680c728521 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_36dd5b9a4d1d6a7dc1fc5a680c728521 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
            exception_tb = NULL;

            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Extension" );
            exception_tb = NULL;

            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_36dd5b9a4d1d6a7dc1fc5a680c728521->m_frame.f_lineno = 1536;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1536;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_ext == NULL );
        var_ext = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_get_ext );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_index );
        tmp_args_element_name_3 = par_index;
        frame_36dd5b9a4d1d6a7dc1fc5a680c728521->m_frame.f_lineno = 1537;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ext );
        tmp_assattr_target_1 = var_ext;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__extension, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1537;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_ext );
        tmp_source_name_4 = var_ext;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__extension );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1538;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7a5005a2e44b5258634f5b2837cd8b81;
            frame_36dd5b9a4d1d6a7dc1fc5a680c728521->m_frame.f_lineno = 1539;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_IndexError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1539;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_EXTENSION_dup );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ext );
        tmp_source_name_7 = var_ext;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__extension );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_36dd5b9a4d1d6a7dc1fc5a680c728521->m_frame.f_lineno = 1541;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1541;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_extension == NULL );
        var_extension = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_extension );
        tmp_args_element_name_5 = var_extension;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_7;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_X509_EXTENSION_free );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_36dd5b9a4d1d6a7dc1fc5a680c728521->m_frame.f_lineno = 1542;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ext );
        tmp_assattr_target_2 = var_ext;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__extension, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1542;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36dd5b9a4d1d6a7dc1fc5a680c728521 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36dd5b9a4d1d6a7dc1fc5a680c728521 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_36dd5b9a4d1d6a7dc1fc5a680c728521, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_36dd5b9a4d1d6a7dc1fc5a680c728521->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_36dd5b9a4d1d6a7dc1fc5a680c728521, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_36dd5b9a4d1d6a7dc1fc5a680c728521,
        type_description_1,
        par_self,
        par_index,
        var_ext,
        var_extension
    );


    // Release cached frame.
    if ( frame_36dd5b9a4d1d6a7dc1fc5a680c728521 == cache_frame_36dd5b9a4d1d6a7dc1fc5a680c728521 )
    {
        Py_DECREF( frame_36dd5b9a4d1d6a7dc1fc5a680c728521 );
    }
    cache_frame_36dd5b9a4d1d6a7dc1fc5a680c728521 = NULL;

    assertFrameObject( frame_36dd5b9a4d1d6a7dc1fc5a680c728521 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_ext );
    tmp_return_value = var_ext;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_84_get_extension );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_index );
    Py_DECREF( par_index );
    par_index = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ext );
    Py_DECREF( var_ext );
    var_ext = NULL;

    CHECK_OBJECT( (PyObject *)var_extension );
    Py_DECREF( var_extension );
    var_extension = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_index );
    Py_DECREF( par_index );
    par_index = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    Py_XDECREF( var_extension );
    var_extension = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_84_get_extension );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_85___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_store = NULL;
    struct Nuitka_FrameObject *frame_87626e6c1de4d18891ada0519a066a50;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_87626e6c1de4d18891ada0519a066a50 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_87626e6c1de4d18891ada0519a066a50, codeobj_87626e6c1de4d18891ada0519a066a50, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_87626e6c1de4d18891ada0519a066a50 = cache_frame_87626e6c1de4d18891ada0519a066a50;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_87626e6c1de4d18891ada0519a066a50 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_87626e6c1de4d18891ada0519a066a50 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1591;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_87626e6c1de4d18891ada0519a066a50->m_frame.f_lineno = 1591;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_STORE_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1591;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_store == NULL );
        var_store = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_store );
        tmp_args_element_name_1 = var_store;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_STORE_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_87626e6c1de4d18891ada0519a066a50->m_frame.f_lineno = 1592;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1592;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87626e6c1de4d18891ada0519a066a50 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87626e6c1de4d18891ada0519a066a50 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_87626e6c1de4d18891ada0519a066a50, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_87626e6c1de4d18891ada0519a066a50->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_87626e6c1de4d18891ada0519a066a50, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_87626e6c1de4d18891ada0519a066a50,
        type_description_1,
        par_self,
        var_store
    );


    // Release cached frame.
    if ( frame_87626e6c1de4d18891ada0519a066a50 == cache_frame_87626e6c1de4d18891ada0519a066a50 )
    {
        Py_DECREF( frame_87626e6c1de4d18891ada0519a066a50 );
    }
    cache_frame_87626e6c1de4d18891ada0519a066a50 = NULL;

    assertFrameObject( frame_87626e6c1de4d18891ada0519a066a50 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_85___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_store );
    Py_DECREF( var_store );
    var_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_store );
    var_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_85___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_86_add_cert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *var_code = NULL;
    PyObject *var_err_reason = NULL;
    struct Nuitka_FrameObject *frame_dbc361cccf29968e2e8df96cd0cf2935;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_dbc361cccf29968e2e8df96cd0cf2935 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dbc361cccf29968e2e8df96cd0cf2935, codeobj_dbc361cccf29968e2e8df96cd0cf2935, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_dbc361cccf29968e2e8df96cd0cf2935 = cache_frame_dbc361cccf29968e2e8df96cd0cf2935;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dbc361cccf29968e2e8df96cd0cf2935 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dbc361cccf29968e2e8df96cd0cf2935 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cert );
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 1610;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1610;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1610;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            frame_dbc361cccf29968e2e8df96cd0cf2935->m_frame.f_lineno = 1611;
            tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS( PyExc_TypeError );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1611;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_add_cert );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cert );
        tmp_source_name_3 = par_cert;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__x509 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_dbc361cccf29968e2e8df96cd0cf2935->m_frame.f_lineno = 1616;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1616;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1617;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            frame_dbc361cccf29968e2e8df96cd0cf2935->m_frame.f_lineno = 1617;
            tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_ERR_peek_error );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1617;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_code == NULL );
            var_code = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1618;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_2 = tmp_mvar_value_4;
            CHECK_OBJECT( var_code );
            tmp_args_element_name_3 = var_code;
            frame_dbc361cccf29968e2e8df96cd0cf2935->m_frame.f_lineno = 1618;
            {
                PyObject *call_args[] = { tmp_args_element_name_3 };
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_ERR_GET_REASON, call_args );
            }

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1618;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_err_reason == NULL );
            var_err_reason = tmp_assign_source_2;
        }
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                exception_tb = NULL;

                exception_lineno = 1619;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_5;
            CHECK_OBJECT( var_err_reason );
            tmp_compexpr_left_2 = var_err_reason;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1620;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_6;
            tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_R_CERT_ALREADY_IN_HASH_TABLE );
            if ( tmp_compexpr_right_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1620;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_4 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            Py_DECREF( tmp_compexpr_right_2 );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1620;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_dbc361cccf29968e2e8df96cd0cf2935->m_frame.f_lineno = 1619;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1619;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1622;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_3 = tmp_mvar_value_7;
            frame_dbc361cccf29968e2e8df96cd0cf2935->m_frame.f_lineno = 1622;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_ERR_clear_error );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1622;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbc361cccf29968e2e8df96cd0cf2935 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbc361cccf29968e2e8df96cd0cf2935 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dbc361cccf29968e2e8df96cd0cf2935, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dbc361cccf29968e2e8df96cd0cf2935->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dbc361cccf29968e2e8df96cd0cf2935, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dbc361cccf29968e2e8df96cd0cf2935,
        type_description_1,
        par_self,
        par_cert,
        var_code,
        var_err_reason
    );


    // Release cached frame.
    if ( frame_dbc361cccf29968e2e8df96cd0cf2935 == cache_frame_dbc361cccf29968e2e8df96cd0cf2935 )
    {
        Py_DECREF( frame_dbc361cccf29968e2e8df96cd0cf2935 );
    }
    cache_frame_dbc361cccf29968e2e8df96cd0cf2935 = NULL;

    assertFrameObject( frame_dbc361cccf29968e2e8df96cd0cf2935 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_86_add_cert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_code );
    var_code = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_err_reason );
    var_err_reason = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_code );
    var_code = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_err_reason );
    var_err_reason = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_86_add_cert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_87_add_crl( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_crl = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_bbd2a92a2023b917b723ee2bdc574a0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bbd2a92a2023b917b723ee2bdc574a0b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bbd2a92a2023b917b723ee2bdc574a0b, codeobj_bbd2a92a2023b917b723ee2bdc574a0b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_bbd2a92a2023b917b723ee2bdc574a0b = cache_frame_bbd2a92a2023b917b723ee2bdc574a0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bbd2a92a2023b917b723ee2bdc574a0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bbd2a92a2023b917b723ee2bdc574a0b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_add_crl );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_crl );
        tmp_source_name_3 = par_crl;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__crl );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_bbd2a92a2023b917b723ee2bdc574a0b->m_frame.f_lineno = 1638;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_bbd2a92a2023b917b723ee2bdc574a0b->m_frame.f_lineno = 1638;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1638;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbd2a92a2023b917b723ee2bdc574a0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bbd2a92a2023b917b723ee2bdc574a0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bbd2a92a2023b917b723ee2bdc574a0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bbd2a92a2023b917b723ee2bdc574a0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bbd2a92a2023b917b723ee2bdc574a0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bbd2a92a2023b917b723ee2bdc574a0b,
        type_description_1,
        par_self,
        par_crl
    );


    // Release cached frame.
    if ( frame_bbd2a92a2023b917b723ee2bdc574a0b == cache_frame_bbd2a92a2023b917b723ee2bdc574a0b )
    {
        Py_DECREF( frame_bbd2a92a2023b917b723ee2bdc574a0b );
    }
    cache_frame_bbd2a92a2023b917b723ee2bdc574a0b = NULL;

    assertFrameObject( frame_bbd2a92a2023b917b723ee2bdc574a0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_87_add_crl );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_87_add_crl );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_88_set_flags( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_flags = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_e2e9d6475353a0461a1bce66bbc0f03f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e2e9d6475353a0461a1bce66bbc0f03f = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e2e9d6475353a0461a1bce66bbc0f03f, codeobj_e2e9d6475353a0461a1bce66bbc0f03f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_e2e9d6475353a0461a1bce66bbc0f03f = cache_frame_e2e9d6475353a0461a1bce66bbc0f03f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e2e9d6475353a0461a1bce66bbc0f03f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e2e9d6475353a0461a1bce66bbc0f03f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_set_flags );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_flags );
        tmp_args_element_name_3 = par_flags;
        frame_e2e9d6475353a0461a1bce66bbc0f03f->m_frame.f_lineno = 1662;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_e2e9d6475353a0461a1bce66bbc0f03f->m_frame.f_lineno = 1662;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1662;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2e9d6475353a0461a1bce66bbc0f03f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e2e9d6475353a0461a1bce66bbc0f03f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e2e9d6475353a0461a1bce66bbc0f03f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e2e9d6475353a0461a1bce66bbc0f03f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e2e9d6475353a0461a1bce66bbc0f03f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e2e9d6475353a0461a1bce66bbc0f03f,
        type_description_1,
        par_self,
        par_flags
    );


    // Release cached frame.
    if ( frame_e2e9d6475353a0461a1bce66bbc0f03f == cache_frame_e2e9d6475353a0461a1bce66bbc0f03f )
    {
        Py_DECREF( frame_e2e9d6475353a0461a1bce66bbc0f03f );
    }
    cache_frame_e2e9d6475353a0461a1bce66bbc0f03f = NULL;

    assertFrameObject( frame_e2e9d6475353a0461a1bce66bbc0f03f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_88_set_flags );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_flags );
    Py_DECREF( par_flags );
    par_flags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_88_set_flags );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_89_set_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_vfy_time = python_pars[ 1 ];
    PyObject *var_param = NULL;
    struct Nuitka_FrameObject *frame_3fea67ca1b07373944ae6c41f77a4858;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3fea67ca1b07373944ae6c41f77a4858 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3fea67ca1b07373944ae6c41f77a4858, codeobj_3fea67ca1b07373944ae6c41f77a4858, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3fea67ca1b07373944ae6c41f77a4858 = cache_frame_3fea67ca1b07373944ae6c41f77a4858;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3fea67ca1b07373944ae6c41f77a4858 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3fea67ca1b07373944ae6c41f77a4858 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1680;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_3fea67ca1b07373944ae6c41f77a4858->m_frame.f_lineno = 1680;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_VERIFY_PARAM_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1680;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_param == NULL );
        var_param = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_param );
        tmp_args_element_name_1 = var_param;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_VERIFY_PARAM_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3fea67ca1b07373944ae6c41f77a4858->m_frame.f_lineno = 1681;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1681;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_param;
            assert( old != NULL );
            var_param = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_int_arg_1;
        PyObject *tmp_called_instance_2;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_VERIFY_PARAM_set_time );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_param );
        tmp_args_element_name_3 = var_param;
        CHECK_OBJECT( par_vfy_time );
        tmp_called_instance_2 = par_vfy_time;
        frame_3fea67ca1b07373944ae6c41f77a4858->m_frame.f_lineno = 1683;
        tmp_int_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_strftime, &PyTuple_GET_ITEM( const_tuple_str_digest_eee7b0934fe224b34ba6722d84ccd2bf_tuple, 0 ) );

        if ( tmp_int_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = PyNumber_Int( tmp_int_arg_1 );
        Py_DECREF( tmp_int_arg_1 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3fea67ca1b07373944ae6c41f77a4858->m_frame.f_lineno = 1683;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1683;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_STORE_set1_param );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__store );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_param );
        tmp_args_element_name_7 = var_param;
        frame_3fea67ca1b07373944ae6c41f77a4858->m_frame.f_lineno = 1684;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3fea67ca1b07373944ae6c41f77a4858->m_frame.f_lineno = 1684;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1684;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fea67ca1b07373944ae6c41f77a4858 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3fea67ca1b07373944ae6c41f77a4858 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3fea67ca1b07373944ae6c41f77a4858, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3fea67ca1b07373944ae6c41f77a4858->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3fea67ca1b07373944ae6c41f77a4858, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3fea67ca1b07373944ae6c41f77a4858,
        type_description_1,
        par_self,
        par_vfy_time,
        var_param
    );


    // Release cached frame.
    if ( frame_3fea67ca1b07373944ae6c41f77a4858 == cache_frame_3fea67ca1b07373944ae6c41f77a4858 )
    {
        Py_DECREF( frame_3fea67ca1b07373944ae6c41f77a4858 );
    }
    cache_frame_3fea67ca1b07373944ae6c41f77a4858 = NULL;

    assertFrameObject( frame_3fea67ca1b07373944ae6c41f77a4858 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_89_set_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_vfy_time );
    Py_DECREF( par_vfy_time );
    par_vfy_time = NULL;

    CHECK_OBJECT( (PyObject *)var_param );
    Py_DECREF( var_param );
    var_param = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_vfy_time );
    Py_DECREF( par_vfy_time );
    par_vfy_time = NULL;

    Py_XDECREF( var_param );
    var_param = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_89_set_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_90___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_message = python_pars[ 1 ];
    PyObject *par_certificate = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_5b8fb2eb4576f5266e57e0af3d70a55b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_5b8fb2eb4576f5266e57e0af3d70a55b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5b8fb2eb4576f5266e57e0af3d70a55b, codeobj_5b8fb2eb4576f5266e57e0af3d70a55b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5b8fb2eb4576f5266e57e0af3d70a55b = cache_frame_5b8fb2eb4576f5266e57e0af3d70a55b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5b8fb2eb4576f5266e57e0af3d70a55b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5b8fb2eb4576f5266e57e0af3d70a55b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509StoreContextError" );
            exception_tb = NULL;

            exception_lineno = 1704;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1704;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_message );
        tmp_args_element_name_1 = par_message;
        frame_5b8fb2eb4576f5266e57e0af3d70a55b->m_frame.f_lineno = 1704;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1704;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_certificate );
        tmp_assattr_name_1 = par_certificate;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_certificate, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1705;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5b8fb2eb4576f5266e57e0af3d70a55b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5b8fb2eb4576f5266e57e0af3d70a55b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5b8fb2eb4576f5266e57e0af3d70a55b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5b8fb2eb4576f5266e57e0af3d70a55b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5b8fb2eb4576f5266e57e0af3d70a55b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5b8fb2eb4576f5266e57e0af3d70a55b,
        type_description_1,
        par_self,
        par_message,
        par_certificate
    );


    // Release cached frame.
    if ( frame_5b8fb2eb4576f5266e57e0af3d70a55b == cache_frame_5b8fb2eb4576f5266e57e0af3d70a55b )
    {
        Py_DECREF( frame_5b8fb2eb4576f5266e57e0af3d70a55b );
    }
    cache_frame_5b8fb2eb4576f5266e57e0af3d70a55b = NULL;

    assertFrameObject( frame_5b8fb2eb4576f5266e57e0af3d70a55b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_90___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_message );
    Py_DECREF( par_message );
    par_message = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_message );
    Py_DECREF( par_message );
    par_message = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_90___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_91___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_store = python_pars[ 1 ];
    PyObject *par_certificate = python_pars[ 2 ];
    PyObject *var_store_ctx = NULL;
    struct Nuitka_FrameObject *frame_01b9cb7c90c52be647b05193f717878b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_01b9cb7c90c52be647b05193f717878b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_01b9cb7c90c52be647b05193f717878b, codeobj_01b9cb7c90c52be647b05193f717878b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_01b9cb7c90c52be647b05193f717878b = cache_frame_01b9cb7c90c52be647b05193f717878b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_01b9cb7c90c52be647b05193f717878b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_01b9cb7c90c52be647b05193f717878b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1727;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_01b9cb7c90c52be647b05193f717878b->m_frame.f_lineno = 1727;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_STORE_CTX_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1727;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_store_ctx == NULL );
        var_store_ctx = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_store_ctx );
        tmp_args_element_name_1 = var_store_ctx;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_STORE_CTX_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_01b9cb7c90c52be647b05193f717878b->m_frame.f_lineno = 1728;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store_ctx, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1728;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_store );
        tmp_assattr_name_2 = par_store;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__store, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1729;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_certificate );
        tmp_assattr_name_3 = par_certificate;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__cert, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1730;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_01b9cb7c90c52be647b05193f717878b->m_frame.f_lineno = 1734;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__init );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1734;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_01b9cb7c90c52be647b05193f717878b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_01b9cb7c90c52be647b05193f717878b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_01b9cb7c90c52be647b05193f717878b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_01b9cb7c90c52be647b05193f717878b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_01b9cb7c90c52be647b05193f717878b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_01b9cb7c90c52be647b05193f717878b,
        type_description_1,
        par_self,
        par_store,
        par_certificate,
        var_store_ctx
    );


    // Release cached frame.
    if ( frame_01b9cb7c90c52be647b05193f717878b == cache_frame_01b9cb7c90c52be647b05193f717878b )
    {
        Py_DECREF( frame_01b9cb7c90c52be647b05193f717878b );
    }
    cache_frame_01b9cb7c90c52be647b05193f717878b = NULL;

    assertFrameObject( frame_01b9cb7c90c52be647b05193f717878b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_91___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_store_ctx );
    Py_DECREF( var_store_ctx );
    var_store_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_store_ctx );
    var_store_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_certificate );
    Py_DECREF( par_certificate );
    par_certificate = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_91___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_92__init( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ret = NULL;
    struct Nuitka_FrameObject *frame_e290698928eff63f6a91ddfadc9c203c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e290698928eff63f6a91ddfadc9c203c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e290698928eff63f6a91ddfadc9c203c, codeobj_e290698928eff63f6a91ddfadc9c203c, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_e290698928eff63f6a91ddfadc9c203c = cache_frame_e290698928eff63f6a91ddfadc9c203c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e290698928eff63f6a91ddfadc9c203c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e290698928eff63f6a91ddfadc9c203c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1743;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_CTX_init );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1743;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__store );
        if ( tmp_source_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__store );
        Py_DECREF( tmp_source_name_3 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__cert );
        if ( tmp_source_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__x509 );
        Py_DECREF( tmp_source_name_5 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            Py_DECREF( tmp_args_element_name_2 );

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_2;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 1744;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_e290698928eff63f6a91ddfadc9c203c->m_frame.f_lineno = 1743;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1743;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_ret == NULL );
        var_ret = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_ret );
        tmp_compexpr_left_1 = var_ret;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1746;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1747;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_3;
            frame_e290698928eff63f6a91ddfadc9c203c->m_frame.f_lineno = 1747;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1747;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e290698928eff63f6a91ddfadc9c203c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e290698928eff63f6a91ddfadc9c203c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e290698928eff63f6a91ddfadc9c203c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e290698928eff63f6a91ddfadc9c203c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e290698928eff63f6a91ddfadc9c203c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e290698928eff63f6a91ddfadc9c203c,
        type_description_1,
        par_self,
        var_ret
    );


    // Release cached frame.
    if ( frame_e290698928eff63f6a91ddfadc9c203c == cache_frame_e290698928eff63f6a91ddfadc9c203c )
    {
        Py_DECREF( frame_e290698928eff63f6a91ddfadc9c203c );
    }
    cache_frame_e290698928eff63f6a91ddfadc9c203c = NULL;

    assertFrameObject( frame_e290698928eff63f6a91ddfadc9c203c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_92__init );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_92__init );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_93__cleanup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0b3107fda7e0aa194200a083196e49c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0b3107fda7e0aa194200a083196e49c5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0b3107fda7e0aa194200a083196e49c5, codeobj_0b3107fda7e0aa194200a083196e49c5, module_OpenSSL$crypto, sizeof(void *) );
    frame_0b3107fda7e0aa194200a083196e49c5 = cache_frame_0b3107fda7e0aa194200a083196e49c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0b3107fda7e0aa194200a083196e49c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0b3107fda7e0aa194200a083196e49c5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_CTX_cleanup );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_0b3107fda7e0aa194200a083196e49c5->m_frame.f_lineno = 1755;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1755;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b3107fda7e0aa194200a083196e49c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0b3107fda7e0aa194200a083196e49c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0b3107fda7e0aa194200a083196e49c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0b3107fda7e0aa194200a083196e49c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0b3107fda7e0aa194200a083196e49c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0b3107fda7e0aa194200a083196e49c5,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0b3107fda7e0aa194200a083196e49c5 == cache_frame_0b3107fda7e0aa194200a083196e49c5 )
    {
        Py_DECREF( frame_0b3107fda7e0aa194200a083196e49c5 );
    }
    cache_frame_0b3107fda7e0aa194200a083196e49c5 = NULL;

    assertFrameObject( frame_0b3107fda7e0aa194200a083196e49c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_93__cleanup );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_93__cleanup );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_94__exception_from_context( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_errors = NULL;
    PyObject *var__cert = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var__x509 = NULL;
    struct Nuitka_FrameObject *frame_064c50c5cfb37771136fe7d568d247de;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_064c50c5cfb37771136fe7d568d247de = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_064c50c5cfb37771136fe7d568d247de, codeobj_064c50c5cfb37771136fe7d568d247de, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_064c50c5cfb37771136fe7d568d247de = cache_frame_064c50c5cfb37771136fe7d568d247de;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_064c50c5cfb37771136fe7d568d247de );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_064c50c5cfb37771136fe7d568d247de ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_8;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_STORE_CTX_get_error );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1766;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1766;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = PyList_New( 3 );
        PyList_SET_ITEM( tmp_assign_source_1, 0, tmp_list_element_1 );
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_assign_source_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_STORE_CTX_get_error_depth );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__store_ctx );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1767;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 1767;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        PyList_SET_ITEM( tmp_assign_source_1, 1, tmp_list_element_1 );
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__native );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_assign_source_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_native" );
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_assign_source_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_string );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_5;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_verify_cert_error_string );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_6;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_STORE_CTX_get_error );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__store_ctx );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1769;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_args_element_name_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 1769;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1768;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1768;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1768;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_list_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_1 );

            exception_lineno = 1768;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        PyList_SET_ITEM( tmp_assign_source_1, 2, tmp_list_element_1 );
        assert( var_errors == NULL );
        var_errors = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_10;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_7;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_X509_STORE_CTX_get_current_cert );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_10 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__store_ctx );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1773;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1773;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var__x509 == NULL );
        var__x509 = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1774;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_8;
        CHECK_OBJECT( var__x509 );
        tmp_args_element_name_8 = var__x509;
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1774;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_dup, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1774;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var__cert == NULL );
        var__cert = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 1775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_9;
        CHECK_OBJECT( var__cert );
        tmp_args_element_name_9 = var__cert;
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1775;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__from_raw_x509_ptr, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pycert == NULL );
        var_pycert = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509StoreContextError );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509StoreContextError" );
            exception_tb = NULL;

            exception_lineno = 1776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_8 = tmp_mvar_value_10;
        CHECK_OBJECT( var_errors );
        tmp_args_element_name_10 = var_errors;
        CHECK_OBJECT( var_pycert );
        tmp_args_element_name_11 = var_pycert;
        frame_064c50c5cfb37771136fe7d568d247de->m_frame.f_lineno = 1776;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_064c50c5cfb37771136fe7d568d247de );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_064c50c5cfb37771136fe7d568d247de );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_064c50c5cfb37771136fe7d568d247de );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_064c50c5cfb37771136fe7d568d247de, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_064c50c5cfb37771136fe7d568d247de->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_064c50c5cfb37771136fe7d568d247de, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_064c50c5cfb37771136fe7d568d247de,
        type_description_1,
        par_self,
        var_errors,
        var__cert,
        var_pycert,
        var__x509
    );


    // Release cached frame.
    if ( frame_064c50c5cfb37771136fe7d568d247de == cache_frame_064c50c5cfb37771136fe7d568d247de )
    {
        Py_DECREF( frame_064c50c5cfb37771136fe7d568d247de );
    }
    cache_frame_064c50c5cfb37771136fe7d568d247de = NULL;

    assertFrameObject( frame_064c50c5cfb37771136fe7d568d247de );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_94__exception_from_context );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_errors );
    Py_DECREF( var_errors );
    var_errors = NULL;

    CHECK_OBJECT( (PyObject *)var__cert );
    Py_DECREF( var__cert );
    var__cert = NULL;

    CHECK_OBJECT( (PyObject *)var_pycert );
    Py_DECREF( var_pycert );
    var_pycert = NULL;

    CHECK_OBJECT( (PyObject *)var__x509 );
    Py_DECREF( var__x509 );
    var__x509 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_errors );
    var_errors = NULL;

    Py_XDECREF( var__cert );
    var__cert = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var__x509 );
    var__x509 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_94__exception_from_context );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_95_set_store( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_store = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_eabc0b3b7063d9f47931e06c3b6106e5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_eabc0b3b7063d9f47931e06c3b6106e5 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eabc0b3b7063d9f47931e06c3b6106e5, codeobj_eabc0b3b7063d9f47931e06c3b6106e5, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_eabc0b3b7063d9f47931e06c3b6106e5 = cache_frame_eabc0b3b7063d9f47931e06c3b6106e5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eabc0b3b7063d9f47931e06c3b6106e5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eabc0b3b7063d9f47931e06c3b6106e5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_store );
        tmp_assattr_name_1 = par_store;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__store, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1787;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eabc0b3b7063d9f47931e06c3b6106e5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eabc0b3b7063d9f47931e06c3b6106e5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eabc0b3b7063d9f47931e06c3b6106e5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eabc0b3b7063d9f47931e06c3b6106e5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eabc0b3b7063d9f47931e06c3b6106e5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eabc0b3b7063d9f47931e06c3b6106e5,
        type_description_1,
        par_self,
        par_store
    );


    // Release cached frame.
    if ( frame_eabc0b3b7063d9f47931e06c3b6106e5 == cache_frame_eabc0b3b7063d9f47931e06c3b6106e5 )
    {
        Py_DECREF( frame_eabc0b3b7063d9f47931e06c3b6106e5 );
    }
    cache_frame_eabc0b3b7063d9f47931e06c3b6106e5 = NULL;

    assertFrameObject( frame_eabc0b3b7063d9f47931e06c3b6106e5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_95_set_store );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_store );
    Py_DECREF( par_store );
    par_store = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_95_set_store );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_96_verify_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ret = NULL;
    struct Nuitka_FrameObject *frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2, codeobj_8f0dacae7ab4b4acc4d0b5ce81fc6ce2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 = cache_frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2->m_frame.f_lineno = 1804;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__cleanup );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1804;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2->m_frame.f_lineno = 1805;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__init );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1805;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_verify_cert );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__store_ctx );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2->m_frame.f_lineno = 1806;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1806;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_ret == NULL );
        var_ret = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_3 = par_self;
        frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2->m_frame.f_lineno = 1807;
        tmp_call_result_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain__cleanup );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1807;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_ret );
        tmp_compexpr_left_1 = var_ret;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1808;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_instance_4;
            CHECK_OBJECT( par_self );
            tmp_called_instance_4 = par_self;
            frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2->m_frame.f_lineno = 1809;
            tmp_raise_type_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain__exception_from_context );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1809;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 1809;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2,
        type_description_1,
        par_self,
        var_ret
    );


    // Release cached frame.
    if ( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 == cache_frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 )
    {
        Py_DECREF( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 );
    }
    cache_frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 = NULL;

    assertFrameObject( frame_8f0dacae7ab4b4acc4d0b5ce81fc6ce2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_96_verify_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_96_verify_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_97_load_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_x509 = NULL;
    struct Nuitka_FrameObject *frame_84b1e7e21b5757c80ed4f13ea2afff02;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_84b1e7e21b5757c80ed4f13ea2afff02 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_84b1e7e21b5757c80ed4f13ea2afff02, codeobj_84b1e7e21b5757c80ed4f13ea2afff02, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_84b1e7e21b5757c80ed4f13ea2afff02 = cache_frame_84b1e7e21b5757c80ed4f13ea2afff02;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_84b1e7e21b5757c80ed4f13ea2afff02 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_84b1e7e21b5757c80ed4f13ea2afff02 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_buffer );
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 1823;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1823;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buffer );
            tmp_called_instance_1 = par_buffer;
            frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame.f_lineno = 1824;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1824;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert( old != NULL );
                par_buffer = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 1826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_buffer );
        tmp_args_element_name_1 = par_buffer;
        frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame.f_lineno = 1826;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 1828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_X509 );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_5 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_7 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );

                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame.f_lineno = 1829;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_x509 == NULL );
            var_x509 = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 1830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_9 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_X509_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_10 == NULL ))
                {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_10 == NULL )
                {
                    Py_DECREF( tmp_called_name_3 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
                if ( tmp_args_element_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame.f_lineno = 1831;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert( var_x509 == NULL );
                var_x509 = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame.f_lineno = 1833;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 1833;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if ( var_x509 == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x509" );
            exception_tb = NULL;

            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_x509;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1836;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1837;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame.f_lineno = 1837;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1837;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__from_raw_x509_ptr );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        if ( var_x509 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x509" );
            exception_tb = NULL;

            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = var_x509;
        frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame.f_lineno = 1839;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1839;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84b1e7e21b5757c80ed4f13ea2afff02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_84b1e7e21b5757c80ed4f13ea2afff02 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_84b1e7e21b5757c80ed4f13ea2afff02 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_84b1e7e21b5757c80ed4f13ea2afff02, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_84b1e7e21b5757c80ed4f13ea2afff02->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_84b1e7e21b5757c80ed4f13ea2afff02, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_84b1e7e21b5757c80ed4f13ea2afff02,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_x509
    );


    // Release cached frame.
    if ( frame_84b1e7e21b5757c80ed4f13ea2afff02 == cache_frame_84b1e7e21b5757c80ed4f13ea2afff02 )
    {
        Py_DECREF( frame_84b1e7e21b5757c80ed4f13ea2afff02 );
    }
    cache_frame_84b1e7e21b5757c80ed4f13ea2afff02 = NULL;

    assertFrameObject( frame_84b1e7e21b5757c80ed4f13ea2afff02 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_97_load_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_97_load_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_98_dump_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_result_code = NULL;
    struct Nuitka_FrameObject *frame_14e959ce713a9ebb06e99f8e969e2b76;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_14e959ce713a9ebb06e99f8e969e2b76 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_14e959ce713a9ebb06e99f8e969e2b76, codeobj_14e959ce713a9ebb06e99f8e969e2b76, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_14e959ce713a9ebb06e99f8e969e2b76 = cache_frame_14e959ce713a9ebb06e99f8e969e2b76;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_14e959ce713a9ebb06e99f8e969e2b76 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_14e959ce713a9ebb06e99f8e969e2b76 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 1852;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_14e959ce713a9ebb06e99f8e969e2b76->m_frame.f_lineno = 1852;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1852;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 1854;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1854;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_X509 );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_1 = var_bio;
            CHECK_OBJECT( par_cert );
            tmp_source_name_2 = par_cert;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_14e959ce713a9ebb06e99f8e969e2b76->m_frame.f_lineno = 1855;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1855;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_result_code == NULL );
            var_result_code = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 1856;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1856;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_5;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_i2d_X509_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_3 = var_bio;
                CHECK_OBJECT( par_cert );
                tmp_source_name_4 = par_cert;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__x509 );
                if ( tmp_args_element_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_14e959ce713a9ebb06e99f8e969e2b76->m_frame.f_lineno = 1857;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1857;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert( var_result_code == NULL );
                var_result_code = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT( par_type );
                tmp_compexpr_left_3 = par_type;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
                }

                if ( tmp_mvar_value_6 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
                    exception_tb = NULL;

                    exception_lineno = 1858;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_3 = tmp_mvar_value_6;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1858;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_7;
                    PyObject *tmp_args_element_name_5;
                    PyObject *tmp_args_element_name_6;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_args_element_name_7;
                    PyObject *tmp_args_element_name_8;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_7 == NULL ))
                    {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_7 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_7;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_print_ex );
                    if ( tmp_called_name_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( var_bio );
                    tmp_args_element_name_5 = var_bio;
                    CHECK_OBJECT( par_cert );
                    tmp_source_name_6 = par_cert;
                    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__x509 );
                    if ( tmp_args_element_name_6 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_4 );

                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_7 = const_int_0;
                    tmp_args_element_name_8 = const_int_0;
                    frame_14e959ce713a9ebb06e99f8e969e2b76->m_frame.f_lineno = 1859;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
                        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
                    }

                    Py_DECREF( tmp_called_name_4 );
                    Py_DECREF( tmp_args_element_name_6 );
                    if ( tmp_assign_source_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1859;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_result_code == NULL );
                    var_result_code = tmp_assign_source_4;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_14e959ce713a9ebb06e99f8e969e2b76->m_frame.f_lineno = 1861;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                    }

                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 1861;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        if ( var_result_code == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result_code" );
            exception_tb = NULL;

            exception_lineno = 1865;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = var_result_code;
        tmp_compexpr_right_4 = const_int_pos_1;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1865;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1865;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_2;
            tmp_raise_type_2 = PyExc_AssertionError;
            exception_type = tmp_raise_type_2;
            Py_INCREF( tmp_raise_type_2 );
            exception_lineno = 1865;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 1866;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_9 = var_bio;
        frame_14e959ce713a9ebb06e99f8e969e2b76->m_frame.f_lineno = 1866;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1866;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_14e959ce713a9ebb06e99f8e969e2b76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_14e959ce713a9ebb06e99f8e969e2b76 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_14e959ce713a9ebb06e99f8e969e2b76 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_14e959ce713a9ebb06e99f8e969e2b76, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_14e959ce713a9ebb06e99f8e969e2b76->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_14e959ce713a9ebb06e99f8e969e2b76, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_14e959ce713a9ebb06e99f8e969e2b76,
        type_description_1,
        par_type,
        par_cert,
        var_bio,
        var_result_code
    );


    // Release cached frame.
    if ( frame_14e959ce713a9ebb06e99f8e969e2b76 == cache_frame_14e959ce713a9ebb06e99f8e969e2b76 )
    {
        Py_DECREF( frame_14e959ce713a9ebb06e99f8e969e2b76 );
    }
    cache_frame_14e959ce713a9ebb06e99f8e969e2b76 = NULL;

    assertFrameObject( frame_14e959ce713a9ebb06e99f8e969e2b76 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_98_dump_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_98_dump_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_99_dump_publickey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_write_bio = NULL;
    PyObject *var_result_code = NULL;
    PyObject *var_bio = NULL;
    struct Nuitka_FrameObject *frame_0259a49d9dc1def6fc738b9fed343645;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0259a49d9dc1def6fc738b9fed343645 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0259a49d9dc1def6fc738b9fed343645, codeobj_0259a49d9dc1def6fc738b9fed343645, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0259a49d9dc1def6fc738b9fed343645 = cache_frame_0259a49d9dc1def6fc738b9fed343645;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0259a49d9dc1def6fc738b9fed343645 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0259a49d9dc1def6fc738b9fed343645 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 1879;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_0259a49d9dc1def6fc738b9fed343645->m_frame.f_lineno = 1879;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1879;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 1880;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1880;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1881;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_PUBKEY );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1881;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_write_bio == NULL );
            var_write_bio = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 1882;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1882;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_source_name_2;
                PyObject *tmp_mvar_value_5;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 1883;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_2 = tmp_mvar_value_5;
                tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_i2d_PUBKEY_bio );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1883;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_write_bio == NULL );
                var_write_bio = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_0259a49d9dc1def6fc738b9fed343645->m_frame.f_lineno = 1885;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 1885;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        if ( var_write_bio == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "write_bio" );
            exception_tb = NULL;

            exception_lineno = 1887;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = var_write_bio;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_1 = var_bio;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1887;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_0259a49d9dc1def6fc738b9fed343645->m_frame.f_lineno = 1887;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1887;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result_code == NULL );
        var_result_code = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( var_result_code );
        tmp_compexpr_left_3 = var_result_code;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1888;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 1889;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_6;
            frame_0259a49d9dc1def6fc738b9fed343645->m_frame.f_lineno = 1889;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1889;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 1891;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_3 = var_bio;
        frame_0259a49d9dc1def6fc738b9fed343645->m_frame.f_lineno = 1891;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1891;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0259a49d9dc1def6fc738b9fed343645 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0259a49d9dc1def6fc738b9fed343645 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0259a49d9dc1def6fc738b9fed343645 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0259a49d9dc1def6fc738b9fed343645, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0259a49d9dc1def6fc738b9fed343645->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0259a49d9dc1def6fc738b9fed343645, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0259a49d9dc1def6fc738b9fed343645,
        type_description_1,
        par_type,
        par_pkey,
        var_write_bio,
        var_result_code,
        var_bio
    );


    // Release cached frame.
    if ( frame_0259a49d9dc1def6fc738b9fed343645 == cache_frame_0259a49d9dc1def6fc738b9fed343645 )
    {
        Py_DECREF( frame_0259a49d9dc1def6fc738b9fed343645 );
    }
    cache_frame_0259a49d9dc1def6fc738b9fed343645 = NULL;

    assertFrameObject( frame_0259a49d9dc1def6fc738b9fed343645 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_99_dump_publickey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_write_bio );
    var_write_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_result_code );
    Py_DECREF( var_result_code );
    var_result_code = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_write_bio );
    var_write_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_99_dump_publickey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_100_dump_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_cipher = python_pars[ 2 ];
    PyObject *par_passphrase = python_pars[ 3 ];
    PyObject *var_helper = NULL;
    PyObject *var_bio = NULL;
    PyObject *var_cipher_obj = NULL;
    PyObject *var_rsa = NULL;
    PyObject *var_result_code = NULL;
    struct Nuitka_FrameObject *frame_1ac471aeb3398883ade56d46d3bdeb44;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_1ac471aeb3398883ade56d46d3bdeb44 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1ac471aeb3398883ade56d46d3bdeb44, codeobj_1ac471aeb3398883ade56d46d3bdeb44, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1ac471aeb3398883ade56d46d3bdeb44 = cache_frame_1ac471aeb3398883ade56d46d3bdeb44;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1ac471aeb3398883ade56d46d3bdeb44 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1ac471aeb3398883ade56d46d3bdeb44 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 1910;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1910;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1910;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_pkey );
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 1912;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1912;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1912;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_bb334a0dc943b8e820be149d2c515af0;
            frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1913;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1913;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_cipher );
        tmp_compexpr_left_1 = par_cipher;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_passphrase );
            tmp_compexpr_left_2 = par_passphrase;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_3 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_014a797afcc3e1ad4f3e6e9aa4631a8a;
                frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1917;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 1917;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_cipherbyname );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
            }

            if ( tmp_mvar_value_4 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
                exception_tb = NULL;

                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_3 = tmp_mvar_value_4;
            CHECK_OBJECT( par_cipher );
            tmp_args_element_name_2 = par_cipher;
            frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1920;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1920;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1920;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_cipher_obj == NULL );
            var_cipher_obj = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            CHECK_OBJECT( var_cipher_obj );
            tmp_compexpr_left_3 = var_cipher_obj;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1921;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_compexpr_right_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1921;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_right_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1921;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_make_exception_arg_3;
                tmp_make_exception_arg_3 = const_str_digest_fb60d21f52ae521da77e61851d566364;
                frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1922;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_3 };
                    tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_3 == NULL) );
                exception_type = tmp_raise_type_3;
                exception_lineno = 1922;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_4:;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1924;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1924;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_cipher_obj == NULL );
            var_cipher_obj = tmp_assign_source_3;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_PassphraseHelper" );
            exception_tb = NULL;

            exception_lineno = 1926;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_7;
        CHECK_OBJECT( par_type );
        tmp_args_element_name_3 = par_type;
        CHECK_OBJECT( par_passphrase );
        tmp_args_element_name_4 = par_passphrase;
        frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1926;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1926;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_helper == NULL );
        var_helper = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_mvar_value_8;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_4 = par_type;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 1927;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_4 = tmp_mvar_value_8;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1927;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_called_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_9;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_10;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_source_name_7;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_source_name_8;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_9;
            tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_PEM_write_bio_PrivateKey );
            if ( tmp_called_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_5 = var_bio;
            CHECK_OBJECT( par_pkey );
            tmp_source_name_5 = par_pkey;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__pkey );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );

                exception_lineno = 1929;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_cipher_obj );
            tmp_args_element_name_7 = var_cipher_obj;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_10 == NULL )
            {
                Py_DECREF( tmp_called_name_5 );
                Py_DECREF( tmp_args_element_name_6 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 1929;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_6 = tmp_mvar_value_10;
            tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
            if ( tmp_args_element_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );
                Py_DECREF( tmp_args_element_name_6 );

                exception_lineno = 1929;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_9 = const_int_0;
            CHECK_OBJECT( var_helper );
            tmp_source_name_7 = var_helper;
            tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_callback );
            if ( tmp_args_element_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );
                Py_DECREF( tmp_args_element_name_6 );
                Py_DECREF( tmp_args_element_name_8 );

                exception_lineno = 1930;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_helper );
            tmp_source_name_8 = var_helper;
            tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_callback_args );
            if ( tmp_args_element_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_5 );
                Py_DECREF( tmp_args_element_name_6 );
                Py_DECREF( tmp_args_element_name_8 );
                Py_DECREF( tmp_args_element_name_10 );

                exception_lineno = 1930;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1928;
            {
                PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
                tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_5, call_args );
            }

            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_6 );
            Py_DECREF( tmp_args_element_name_8 );
            Py_DECREF( tmp_args_element_name_10 );
            Py_DECREF( tmp_args_element_name_11 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1928;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_result_code == NULL );
            var_result_code = tmp_assign_source_5;
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( var_helper );
            tmp_called_instance_1 = var_helper;
            frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1931;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_raise_if_problem );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1931;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_5;
        branch_no_5:;
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_mvar_value_11;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_5 = par_type;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 1932;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_5 = tmp_mvar_value_11;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1932;
                type_description_1 = "ooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_6;
            }
            else
            {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_assign_source_6;
                PyObject *tmp_called_name_6;
                PyObject *tmp_source_name_9;
                PyObject *tmp_mvar_value_12;
                PyObject *tmp_args_element_name_12;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_source_name_10;
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_12 == NULL ))
                {
                    tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_12 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_9 = tmp_mvar_value_12;
                tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_i2d_PrivateKey_bio );
                if ( tmp_called_name_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_12 = var_bio;
                CHECK_OBJECT( par_pkey );
                tmp_source_name_10 = par_pkey;
                tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__pkey );
                if ( tmp_args_element_name_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_6 );

                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1933;
                {
                    PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
                    tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
                }

                Py_DECREF( tmp_called_name_6 );
                Py_DECREF( tmp_args_element_name_13 );
                if ( tmp_assign_source_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1933;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_result_code == NULL );
                var_result_code = tmp_assign_source_6;
            }
            goto branch_end_6;
            branch_no_6:;
            {
                nuitka_bool tmp_condition_result_7;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                PyObject *tmp_mvar_value_13;
                CHECK_OBJECT( par_type );
                tmp_compexpr_left_6 = par_type;
                tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

                if (unlikely( tmp_mvar_value_13 == NULL ))
                {
                    tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
                }

                if ( tmp_mvar_value_13 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
                    exception_tb = NULL;

                    exception_lineno = 1934;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_6 = tmp_mvar_value_13;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1934;
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_7;
                }
                else
                {
                    goto branch_no_7;
                }
                branch_yes_7:;
                {
                    nuitka_bool tmp_condition_result_8;
                    PyObject *tmp_compexpr_left_7;
                    PyObject *tmp_compexpr_right_7;
                    PyObject *tmp_called_name_7;
                    PyObject *tmp_source_name_11;
                    PyObject *tmp_mvar_value_14;
                    PyObject *tmp_args_element_name_14;
                    PyObject *tmp_source_name_12;
                    PyObject *tmp_source_name_13;
                    PyObject *tmp_mvar_value_15;
                    tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_14 == NULL ))
                    {
                        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_14 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_11 = tmp_mvar_value_14;
                    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_EVP_PKEY_id );
                    if ( tmp_called_name_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( par_pkey );
                    tmp_source_name_12 = par_pkey;
                    tmp_args_element_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain__pkey );
                    if ( tmp_args_element_name_14 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_7 );

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1935;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_14 };
                        tmp_compexpr_left_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
                    }

                    Py_DECREF( tmp_called_name_7 );
                    Py_DECREF( tmp_args_element_name_14 );
                    if ( tmp_compexpr_left_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_15 == NULL ))
                    {
                        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_15 == NULL )
                    {
                        Py_DECREF( tmp_compexpr_left_7 );
                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_13 = tmp_mvar_value_15;
                    tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_EVP_PKEY_RSA );
                    if ( tmp_compexpr_right_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_compexpr_left_7 );

                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_7, tmp_compexpr_right_7 );
                    Py_DECREF( tmp_compexpr_left_7 );
                    Py_DECREF( tmp_compexpr_right_7 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1935;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_8;
                    }
                    else
                    {
                        goto branch_no_8;
                    }
                    branch_yes_8:;
                    {
                        PyObject *tmp_raise_type_4;
                        PyObject *tmp_make_exception_arg_4;
                        tmp_make_exception_arg_4 = const_str_digest_3a45faa244ca861d389c340b29a28988;
                        frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1936;
                        {
                            PyObject *call_args[] = { tmp_make_exception_arg_4 };
                            tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                        }

                        assert( !(tmp_raise_type_4 == NULL) );
                        exception_type = tmp_raise_type_4;
                        exception_lineno = 1936;
                        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    branch_no_8:;
                }
                {
                    PyObject *tmp_assign_source_7;
                    PyObject *tmp_called_name_8;
                    PyObject *tmp_source_name_14;
                    PyObject *tmp_mvar_value_16;
                    PyObject *tmp_args_element_name_15;
                    PyObject *tmp_called_name_9;
                    PyObject *tmp_source_name_15;
                    PyObject *tmp_mvar_value_17;
                    PyObject *tmp_args_element_name_16;
                    PyObject *tmp_source_name_16;
                    PyObject *tmp_args_element_name_17;
                    PyObject *tmp_source_name_17;
                    PyObject *tmp_mvar_value_18;
                    tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                    if (unlikely( tmp_mvar_value_16 == NULL ))
                    {
                        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                    }

                    if ( tmp_mvar_value_16 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                        exception_tb = NULL;

                        exception_lineno = 1938;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_14 = tmp_mvar_value_16;
                    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_gc );
                    if ( tmp_called_name_8 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1938;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_17 == NULL ))
                    {
                        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_17 == NULL )
                    {
                        Py_DECREF( tmp_called_name_8 );
                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_15 = tmp_mvar_value_17;
                    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_EVP_PKEY_get1_RSA );
                    if ( tmp_called_name_9 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_8 );

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( par_pkey );
                    tmp_source_name_16 = par_pkey;
                    tmp_args_element_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain__pkey );
                    if ( tmp_args_element_name_16 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_8 );
                        Py_DECREF( tmp_called_name_9 );

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1939;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_16 };
                        tmp_args_element_name_15 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
                    }

                    Py_DECREF( tmp_called_name_9 );
                    Py_DECREF( tmp_args_element_name_16 );
                    if ( tmp_args_element_name_15 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_8 );

                        exception_lineno = 1939;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_18 == NULL ))
                    {
                        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_18 == NULL )
                    {
                        Py_DECREF( tmp_called_name_8 );
                        Py_DECREF( tmp_args_element_name_15 );
                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1940;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_17 = tmp_mvar_value_18;
                    tmp_args_element_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_RSA_free );
                    if ( tmp_args_element_name_17 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_8 );
                        Py_DECREF( tmp_args_element_name_15 );

                        exception_lineno = 1940;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1938;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_17 };
                        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
                    }

                    Py_DECREF( tmp_called_name_8 );
                    Py_DECREF( tmp_args_element_name_15 );
                    Py_DECREF( tmp_args_element_name_17 );
                    if ( tmp_assign_source_7 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1938;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_rsa == NULL );
                    var_rsa = tmp_assign_source_7;
                }
                {
                    PyObject *tmp_assign_source_8;
                    PyObject *tmp_called_instance_2;
                    PyObject *tmp_mvar_value_19;
                    PyObject *tmp_args_element_name_18;
                    PyObject *tmp_args_element_name_19;
                    PyObject *tmp_args_element_name_20;
                    tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_19 == NULL ))
                    {
                        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_19 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 1942;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_instance_2 = tmp_mvar_value_19;
                    CHECK_OBJECT( var_bio );
                    tmp_args_element_name_18 = var_bio;
                    CHECK_OBJECT( var_rsa );
                    tmp_args_element_name_19 = var_rsa;
                    tmp_args_element_name_20 = const_int_0;
                    frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1942;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20 };
                        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_RSA_print, call_args );
                    }

                    if ( tmp_assign_source_8 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1942;
                        type_description_1 = "ooooooooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_result_code == NULL );
                    var_result_code = tmp_assign_source_8;
                }
                goto branch_end_7;
                branch_no_7:;
                {
                    PyObject *tmp_raise_type_5;
                    PyObject *tmp_make_exception_arg_5;
                    tmp_make_exception_arg_5 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1944;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_5 };
                        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                    }

                    assert( !(tmp_raise_type_5 == NULL) );
                    exception_type = tmp_raise_type_5;
                    exception_lineno = 1944;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooooo";
                    goto frame_exception_exit_1;
                }
                branch_end_7:;
            }
            branch_end_6:;
        }
        branch_end_5:;
    }
    {
        PyObject *tmp_called_name_10;
        PyObject *tmp_mvar_value_20;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_21;
        PyObject *tmp_compexpr_left_8;
        PyObject *tmp_compexpr_right_8;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_20 == NULL ))
        {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_20 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_10 = tmp_mvar_value_20;
        if ( var_result_code == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result_code" );
            exception_tb = NULL;

            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_8 = var_result_code;
        tmp_compexpr_right_8 = const_int_0;
        tmp_args_element_name_21 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
        if ( tmp_args_element_name_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1948;
        {
            PyObject *call_args[] = { tmp_args_element_name_21 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
        }

        Py_DECREF( tmp_args_element_name_21 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1948;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_name_11;
        PyObject *tmp_mvar_value_21;
        PyObject *tmp_args_element_name_22;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_21 == NULL ))
        {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_21 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 1950;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_11 = tmp_mvar_value_21;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_22 = var_bio;
        frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame.f_lineno = 1950;
        {
            PyObject *call_args[] = { tmp_args_element_name_22 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1950;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1ac471aeb3398883ade56d46d3bdeb44 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1ac471aeb3398883ade56d46d3bdeb44 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1ac471aeb3398883ade56d46d3bdeb44 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1ac471aeb3398883ade56d46d3bdeb44, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1ac471aeb3398883ade56d46d3bdeb44->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1ac471aeb3398883ade56d46d3bdeb44, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1ac471aeb3398883ade56d46d3bdeb44,
        type_description_1,
        par_type,
        par_pkey,
        par_cipher,
        par_passphrase,
        var_helper,
        var_bio,
        var_cipher_obj,
        var_rsa,
        var_result_code
    );


    // Release cached frame.
    if ( frame_1ac471aeb3398883ade56d46d3bdeb44 == cache_frame_1ac471aeb3398883ade56d46d3bdeb44 )
    {
        Py_DECREF( frame_1ac471aeb3398883ade56d46d3bdeb44 );
    }
    cache_frame_1ac471aeb3398883ade56d46d3bdeb44 = NULL;

    assertFrameObject( frame_1ac471aeb3398883ade56d46d3bdeb44 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_100_dump_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_cipher_obj );
    Py_DECREF( var_cipher_obj );
    var_cipher_obj = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher );
    Py_DECREF( par_cipher );
    par_cipher = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_cipher_obj );
    var_cipher_obj = NULL;

    Py_XDECREF( var_rsa );
    var_rsa = NULL;

    CHECK_OBJECT( (PyObject *)par_cipher );
    Py_DECREF( par_cipher );
    par_cipher = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_100_dump_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_101___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_revoked = NULL;
    struct Nuitka_FrameObject *frame_338fb2696ad7e2b451292dd99118ec51;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_338fb2696ad7e2b451292dd99118ec51 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_338fb2696ad7e2b451292dd99118ec51, codeobj_338fb2696ad7e2b451292dd99118ec51, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_338fb2696ad7e2b451292dd99118ec51 = cache_frame_338fb2696ad7e2b451292dd99118ec51;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_338fb2696ad7e2b451292dd99118ec51 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_338fb2696ad7e2b451292dd99118ec51 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1973;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_338fb2696ad7e2b451292dd99118ec51->m_frame.f_lineno = 1973;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_REVOKED_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1973;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_revoked == NULL );
        var_revoked = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_revoked );
        tmp_args_element_name_1 = var_revoked;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_REVOKED_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_338fb2696ad7e2b451292dd99118ec51->m_frame.f_lineno = 1974;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__revoked, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1974;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_338fb2696ad7e2b451292dd99118ec51 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_338fb2696ad7e2b451292dd99118ec51 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_338fb2696ad7e2b451292dd99118ec51, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_338fb2696ad7e2b451292dd99118ec51->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_338fb2696ad7e2b451292dd99118ec51, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_338fb2696ad7e2b451292dd99118ec51,
        type_description_1,
        par_self,
        var_revoked
    );


    // Release cached frame.
    if ( frame_338fb2696ad7e2b451292dd99118ec51 == cache_frame_338fb2696ad7e2b451292dd99118ec51 )
    {
        Py_DECREF( frame_338fb2696ad7e2b451292dd99118ec51 );
    }
    cache_frame_338fb2696ad7e2b451292dd99118ec51 = NULL;

    assertFrameObject( frame_338fb2696ad7e2b451292dd99118ec51 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_101___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_revoked );
    Py_DECREF( var_revoked );
    var_revoked = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_revoked );
    var_revoked = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_101___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_102_set_serial( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_hex_str = python_pars[ 1 ];
    PyObject *var_bignum_serial = NULL;
    PyObject *var_asn1_serial = NULL;
    PyObject *var_bn_result = NULL;
    PyObject *var_bignum_ptr = NULL;
    struct Nuitka_FrameObject *frame_72a795899dc57920294fb3185d7828f7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_72a795899dc57920294fb3185d7828f7 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_72a795899dc57920294fb3185d7828f7, codeobj_72a795899dc57920294fb3185d7828f7, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_72a795899dc57920294fb3185d7828f7 = cache_frame_72a795899dc57920294fb3185d7828f7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_72a795899dc57920294fb3185d7828f7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_72a795899dc57920294fb3185d7828f7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1987;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_BN_new );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BN_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1987;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1987;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bignum_serial == NULL );
        var_bignum_serial = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1988;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1988;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_80438074180d95b1a2291874613077b5_tuple, 0 ) );

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1988;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bignum_ptr == NULL );
        var_bignum_ptr = tmp_assign_source_2;
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        int tmp_ass_subscript_res_1;
        CHECK_OBJECT( var_bignum_serial );
        tmp_ass_subvalue_1 = var_bignum_serial;
        CHECK_OBJECT( var_bignum_ptr );
        tmp_ass_subscribed_1 = var_bignum_ptr;
        tmp_ass_subscript_1 = const_int_0;
        tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
        if ( tmp_ass_subscript_res_1 == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1989;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1990;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_5;
        CHECK_OBJECT( var_bignum_ptr );
        tmp_args_element_name_3 = var_bignum_ptr;
        CHECK_OBJECT( par_hex_str );
        tmp_args_element_name_4 = par_hex_str;
        frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1990;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_BN_hex2bn, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1990;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bn_result == NULL );
        var_bn_result = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( var_bn_result );
        tmp_operand_name_1 = var_bn_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1991;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_340717166d8c6af86f5d8a6e35ed5a7f;
            frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1992;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1992;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1994;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1994;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_BN_to_ASN1_INTEGER );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_bignum_serial );
        tmp_args_element_name_6 = var_bignum_serial;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1995;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_args_element_name_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1995;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1996;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_9;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_ASN1_INTEGER_free );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_5 );

            exception_lineno = 1996;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1994;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_8 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1994;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_asn1_serial == NULL );
        var_asn1_serial = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_source_name_8;
        PyObject *tmp_args_element_name_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_10;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_REVOKED_set_serialNumber );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__revoked );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_asn1_serial );
        tmp_args_element_name_10 = var_asn1_serial;
        frame_72a795899dc57920294fb3185d7828f7->m_frame.f_lineno = 1997;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1997;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_72a795899dc57920294fb3185d7828f7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_72a795899dc57920294fb3185d7828f7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_72a795899dc57920294fb3185d7828f7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_72a795899dc57920294fb3185d7828f7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_72a795899dc57920294fb3185d7828f7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_72a795899dc57920294fb3185d7828f7,
        type_description_1,
        par_self,
        par_hex_str,
        var_bignum_serial,
        var_asn1_serial,
        var_bn_result,
        var_bignum_ptr
    );


    // Release cached frame.
    if ( frame_72a795899dc57920294fb3185d7828f7 == cache_frame_72a795899dc57920294fb3185d7828f7 )
    {
        Py_DECREF( frame_72a795899dc57920294fb3185d7828f7 );
    }
    cache_frame_72a795899dc57920294fb3185d7828f7 = NULL;

    assertFrameObject( frame_72a795899dc57920294fb3185d7828f7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_102_set_serial );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_hex_str );
    Py_DECREF( par_hex_str );
    par_hex_str = NULL;

    CHECK_OBJECT( (PyObject *)var_bignum_serial );
    Py_DECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_asn1_serial );
    Py_DECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    CHECK_OBJECT( (PyObject *)var_bn_result );
    Py_DECREF( var_bn_result );
    var_bn_result = NULL;

    CHECK_OBJECT( (PyObject *)var_bignum_ptr );
    Py_DECREF( var_bignum_ptr );
    var_bignum_ptr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_hex_str );
    Py_DECREF( par_hex_str );
    par_hex_str = NULL;

    Py_XDECREF( var_bignum_serial );
    var_bignum_serial = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_asn1_serial );
    var_asn1_serial = NULL;

    Py_XDECREF( var_bn_result );
    var_bn_result = NULL;

    Py_XDECREF( var_bignum_ptr );
    var_bignum_ptr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_102_set_serial );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_103_get_serial( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_result = NULL;
    PyObject *var_asn1_int = NULL;
    struct Nuitka_FrameObject *frame_0dec7b6420a8d454a6e5ea62e48a57d6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0dec7b6420a8d454a6e5ea62e48a57d6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0dec7b6420a8d454a6e5ea62e48a57d6, codeobj_0dec7b6420a8d454a6e5ea62e48a57d6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0dec7b6420a8d454a6e5ea62e48a57d6 = cache_frame_0dec7b6420a8d454a6e5ea62e48a57d6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0dec7b6420a8d454a6e5ea62e48a57d6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0dec7b6420a8d454a6e5ea62e48a57d6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2009;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_0dec7b6420a8d454a6e5ea62e48a57d6->m_frame.f_lineno = 2009;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2009;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get0_serialNumber );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_0dec7b6420a8d454a6e5ea62e48a57d6->m_frame.f_lineno = 2011;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2011;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_asn1_int == NULL );
        var_asn1_int = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT( var_asn1_int );
        tmp_compexpr_left_1 = var_asn1_int;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_0dec7b6420a8d454a6e5ea62e48a57d6->m_frame.f_lineno = 2012;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2012;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2013;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_3 = var_bio;
        CHECK_OBJECT( var_asn1_int );
        tmp_args_element_name_4 = var_asn1_int;
        frame_0dec7b6420a8d454a6e5ea62e48a57d6->m_frame.f_lineno = 2013;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_i2a_ASN1_INTEGER, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2013;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_6;
        CHECK_OBJECT( var_result );
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_GTE_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_0dec7b6420a8d454a6e5ea62e48a57d6->m_frame.f_lineno = 2014;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2014;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_7;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_6 = var_bio;
        frame_0dec7b6420a8d454a6e5ea62e48a57d6->m_frame.f_lineno = 2015;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2015;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dec7b6420a8d454a6e5ea62e48a57d6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dec7b6420a8d454a6e5ea62e48a57d6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dec7b6420a8d454a6e5ea62e48a57d6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0dec7b6420a8d454a6e5ea62e48a57d6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0dec7b6420a8d454a6e5ea62e48a57d6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0dec7b6420a8d454a6e5ea62e48a57d6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0dec7b6420a8d454a6e5ea62e48a57d6,
        type_description_1,
        par_self,
        var_bio,
        var_result,
        var_asn1_int
    );


    // Release cached frame.
    if ( frame_0dec7b6420a8d454a6e5ea62e48a57d6 == cache_frame_0dec7b6420a8d454a6e5ea62e48a57d6 )
    {
        Py_DECREF( frame_0dec7b6420a8d454a6e5ea62e48a57d6 );
    }
    cache_frame_0dec7b6420a8d454a6e5ea62e48a57d6 = NULL;

    assertFrameObject( frame_0dec7b6420a8d454a6e5ea62e48a57d6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_103_get_serial );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)var_asn1_int );
    Py_DECREF( var_asn1_int );
    var_asn1_int = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_asn1_int );
    var_asn1_int = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_103_get_serial );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_104__delete_reason( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_obj = NULL;
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_3c27bf579b7f947bd398a69e11f418fa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_3c27bf579b7f947bd398a69e11f418fa = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3c27bf579b7f947bd398a69e11f418fa, codeobj_3c27bf579b7f947bd398a69e11f418fa, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3c27bf579b7f947bd398a69e11f418fa = cache_frame_3c27bf579b7f947bd398a69e11f418fa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3c27bf579b7f947bd398a69e11f418fa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3c27bf579b7f947bd398a69e11f418fa ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get_ext_count );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_3c27bf579b7f947bd398a69e11f418fa->m_frame.f_lineno = 2018;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2018;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 2018;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_3;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_REVOKED_get_ext );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__revoked );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_i );
        tmp_args_element_name_3 = var_i;
        frame_3c27bf579b7f947bd398a69e11f418fa->m_frame.f_lineno = 2019;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2019;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2020;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_ext );
        tmp_args_element_name_4 = var_ext;
        frame_3c27bf579b7f947bd398a69e11f418fa->m_frame.f_lineno = 2020;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_EXTENSION_get_object, call_args );
        }

        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2020;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_obj;
            var_obj = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT( var_obj );
        tmp_args_element_name_5 = var_obj;
        frame_3c27bf579b7f947bd398a69e11f418fa->m_frame.f_lineno = 2021;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_obj2nid, call_args );
        }

        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NID_crl_reason );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2021;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_6;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2022;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_3 = tmp_mvar_value_6;
            CHECK_OBJECT( var_ext );
            tmp_args_element_name_6 = var_ext;
            frame_3c27bf579b7f947bd398a69e11f418fa->m_frame.f_lineno = 2022;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_X509_EXTENSION_free, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2022;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_source_name_7;
            PyObject *tmp_args_element_name_8;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_source_name_6 = tmp_mvar_value_7;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_REVOKED_delete_ext );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_7 = par_self;
            tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__revoked );
            if ( tmp_args_element_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( var_i );
            tmp_args_element_name_8 = var_i;
            frame_3c27bf579b7f947bd398a69e11f418fa->m_frame.f_lineno = 2023;
            {
                PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2023;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        goto loop_end_1;
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2018;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c27bf579b7f947bd398a69e11f418fa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c27bf579b7f947bd398a69e11f418fa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3c27bf579b7f947bd398a69e11f418fa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3c27bf579b7f947bd398a69e11f418fa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3c27bf579b7f947bd398a69e11f418fa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3c27bf579b7f947bd398a69e11f418fa,
        type_description_1,
        par_self,
        var_i,
        var_obj,
        var_ext
    );


    // Release cached frame.
    if ( frame_3c27bf579b7f947bd398a69e11f418fa == cache_frame_3c27bf579b7f947bd398a69e11f418fa )
    {
        Py_DECREF( frame_3c27bf579b7f947bd398a69e11f418fa );
    }
    cache_frame_3c27bf579b7f947bd398a69e11f418fa = NULL;

    assertFrameObject( frame_3c27bf579b7f947bd398a69e11f418fa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_104__delete_reason );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_104__delete_reason );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_105_set_reason( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_reason = python_pars[ 1 ];
    PyObject *var_reason_code = NULL;
    PyObject *var_set_result = NULL;
    PyObject *var_r = NULL;
    PyObject *var_add_result = NULL;
    PyObject *var_new_reason_ext = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_a1652d3a4f682aed85a3fb220e328368;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_a1652d3a4f682aed85a3fb220e328368 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a1652d3a4f682aed85a3fb220e328368, codeobj_a1652d3a4f682aed85a3fb220e328368, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a1652d3a4f682aed85a3fb220e328368 = cache_frame_a1652d3a4f682aed85a3fb220e328368;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a1652d3a4f682aed85a3fb220e328368 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a1652d3a4f682aed85a3fb220e328368 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_reason );
        tmp_compexpr_left_1 = par_reason;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2043;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__delete_reason );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2043;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            CHECK_OBJECT( par_reason );
            tmp_isinstance_inst_1 = par_reason;
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2044;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2044;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_9ae52cddf69d053d9518f458a81ffa1b;
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2045;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 2045;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_1;
                PyObject *tmp_called_instance_2;
                PyObject *tmp_called_instance_3;
                CHECK_OBJECT( par_reason );
                tmp_called_instance_3 = par_reason;
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2047;
                tmp_called_instance_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_lower );
                if ( tmp_called_instance_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2047;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2047;
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_replace, &PyTuple_GET_ITEM( const_tuple_str_space_str_empty_tuple, 0 ) );

                Py_DECREF( tmp_called_instance_2 );
                if ( tmp_assign_source_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2047;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_reason;
                    assert( old != NULL );
                    par_reason = tmp_assign_source_1;
                    Py_DECREF( old );
                }

            }
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_args_element_name_1;
                // Tried code:
                {
                    PyObject *tmp_assign_source_3;
                    PyObject *tmp_iter_arg_1;
                    PyObject *tmp_source_name_1;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_1 = par_self;
                    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl_reasons );
                    if ( tmp_iter_arg_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
                    Py_DECREF( tmp_iter_arg_1 );
                    if ( tmp_assign_source_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    assert( tmp_list_contraction_1__$0 == NULL );
                    tmp_list_contraction_1__$0 = tmp_assign_source_3;
                }
                {
                    PyObject *tmp_assign_source_4;
                    tmp_assign_source_4 = PyList_New( 0 );
                    assert( tmp_list_contraction_1__contraction_result == NULL );
                    tmp_list_contraction_1__contraction_result = tmp_assign_source_4;
                }
                loop_start_1:;
                {
                    PyObject *tmp_next_source_1;
                    PyObject *tmp_assign_source_5;
                    CHECK_OBJECT( tmp_list_contraction_1__$0 );
                    tmp_next_source_1 = tmp_list_contraction_1__$0;
                    tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
                    if ( tmp_assign_source_5 == NULL )
                    {
                        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                        {

                            goto loop_end_1;
                        }
                        else
                        {

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                            type_description_1 = "ooooooo";
                            exception_lineno = 2048;
                            goto try_except_handler_2;
                        }
                    }

                    {
                        PyObject *old = tmp_list_contraction_1__iter_value_0;
                        tmp_list_contraction_1__iter_value_0 = tmp_assign_source_5;
                        Py_XDECREF( old );
                    }

                }
                {
                    PyObject *tmp_assign_source_6;
                    CHECK_OBJECT( tmp_list_contraction_1__iter_value_0 );
                    tmp_assign_source_6 = tmp_list_contraction_1__iter_value_0;
                    {
                        PyObject *old = var_r;
                        var_r = tmp_assign_source_6;
                        Py_INCREF( var_r );
                        Py_XDECREF( old );
                    }

                }
                {
                    PyObject *tmp_append_list_1;
                    PyObject *tmp_append_value_1;
                    PyObject *tmp_called_instance_5;
                    CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
                    tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
                    CHECK_OBJECT( var_r );
                    tmp_called_instance_5 = var_r;
                    frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2048;
                    tmp_append_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_lower );
                    if ( tmp_append_value_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                    assert( PyList_Check( tmp_append_list_1 ) );
                    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
                    Py_DECREF( tmp_append_value_1 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2048;
                        type_description_1 = "ooooooo";
                        goto try_except_handler_2;
                    }
                }
                if ( CONSIDER_THREADING() == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2048;
                    type_description_1 = "ooooooo";
                    goto try_except_handler_2;
                }
                goto loop_start_1;
                loop_end_1:;
                CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
                tmp_called_instance_4 = tmp_list_contraction_1__contraction_result;
                Py_INCREF( tmp_called_instance_4 );
                goto try_return_handler_2;
                // tried codes exits in all cases
                NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_105_set_reason );
                return NULL;
                // Return handler code:
                try_return_handler_2:;
                CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
                Py_DECREF( tmp_list_contraction_1__$0 );
                tmp_list_contraction_1__$0 = NULL;

                CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
                Py_DECREF( tmp_list_contraction_1__contraction_result );
                tmp_list_contraction_1__contraction_result = NULL;

                Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
                tmp_list_contraction_1__iter_value_0 = NULL;

                goto outline_result_1;
                // Exception handler code:
                try_except_handler_2:;
                exception_keeper_type_1 = exception_type;
                exception_keeper_value_1 = exception_value;
                exception_keeper_tb_1 = exception_tb;
                exception_keeper_lineno_1 = exception_lineno;
                exception_type = NULL;
                exception_value = NULL;
                exception_tb = NULL;
                exception_lineno = 0;

                Py_XDECREF( tmp_list_contraction_1__$0 );
                tmp_list_contraction_1__$0 = NULL;

                Py_XDECREF( tmp_list_contraction_1__contraction_result );
                tmp_list_contraction_1__contraction_result = NULL;

                Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
                tmp_list_contraction_1__iter_value_0 = NULL;

                // Re-raise.
                exception_type = exception_keeper_type_1;
                exception_value = exception_keeper_value_1;
                exception_tb = exception_keeper_tb_1;
                exception_lineno = exception_keeper_lineno_1;

                goto frame_exception_exit_1;
                // End of try:
                // Return statement must have exited already.
                NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_105_set_reason );
                return NULL;
                outline_result_1:;
                CHECK_OBJECT( par_reason );
                tmp_args_element_name_1 = par_reason;
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2048;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1 };
                    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_index, call_args );
                }

                Py_DECREF( tmp_called_instance_4 );
                if ( tmp_assign_source_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2048;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_reason_code == NULL );
                var_reason_code = tmp_assign_source_2;
            }
            {
                PyObject *tmp_assign_source_7;
                PyObject *tmp_called_instance_6;
                PyObject *tmp_mvar_value_1;
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_1 == NULL ))
                {
                    tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_1 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2050;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_6 = tmp_mvar_value_1;
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2050;
                tmp_assign_source_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_ASN1_ENUMERATED_new );
                if ( tmp_assign_source_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2050;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_new_reason_ext == NULL );
                var_new_reason_ext = tmp_assign_source_7;
            }
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_mvar_value_2;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_2;
                PyObject *tmp_compexpr_left_2;
                PyObject *tmp_compexpr_right_2;
                PyObject *tmp_source_name_2;
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_2 == NULL ))
                {
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_2 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_1 = tmp_mvar_value_2;
                CHECK_OBJECT( var_new_reason_ext );
                tmp_compexpr_left_2 = var_new_reason_ext;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_3 == NULL ))
                {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_3 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_2 = tmp_mvar_value_3;
                tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
                if ( tmp_compexpr_right_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
                Py_DECREF( tmp_compexpr_right_2 );
                if ( tmp_args_element_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2051;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_args_element_name_2 );
                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2051;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_name_2;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                PyObject *tmp_mvar_value_5;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_4 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_4;
                tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
                if ( tmp_called_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_new_reason_ext );
                tmp_args_element_name_3 = var_new_reason_ext;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_5 == NULL )
                {
                    Py_DECREF( tmp_called_name_2 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_4 = tmp_mvar_value_5;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_ASN1_ENUMERATED_free );
                if ( tmp_args_element_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_2 );

                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2052;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                    tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
                }

                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_4 );
                if ( tmp_assign_source_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2052;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = var_new_reason_ext;
                    assert( old != NULL );
                    var_new_reason_ext = tmp_assign_source_8;
                    Py_DECREF( old );
                }

            }
            {
                PyObject *tmp_assign_source_9;
                PyObject *tmp_called_instance_7;
                PyObject *tmp_mvar_value_6;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_args_element_name_6;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_6 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2054;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_instance_7 = tmp_mvar_value_6;
                CHECK_OBJECT( var_new_reason_ext );
                tmp_args_element_name_5 = var_new_reason_ext;
                CHECK_OBJECT( var_reason_code );
                tmp_args_element_name_6 = var_reason_code;
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2054;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                    tmp_assign_source_9 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_7, const_str_plain_ASN1_ENUMERATED_set, call_args );
                }

                if ( tmp_assign_source_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2054;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_set_result == NULL );
                var_set_result = tmp_assign_source_9;
            }
            {
                PyObject *tmp_called_name_3;
                PyObject *tmp_mvar_value_7;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_8;
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_7 == NULL ))
                {
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_7 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_3 = tmp_mvar_value_7;
                CHECK_OBJECT( var_set_result );
                tmp_compexpr_left_3 = var_set_result;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_8 == NULL ))
                {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_8 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_8;
                tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
                if ( tmp_compexpr_right_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_args_element_name_7 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
                Py_DECREF( tmp_compexpr_right_3 );
                if ( tmp_args_element_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2055;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2055;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_3 );
            }
            {
                PyObject *tmp_called_instance_8;
                PyObject *tmp_call_result_4;
                CHECK_OBJECT( par_self );
                tmp_called_instance_8 = par_self;
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2057;
                tmp_call_result_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain__delete_reason );
                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2057;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_4 );
            }
            {
                PyObject *tmp_assign_source_10;
                PyObject *tmp_called_name_4;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_8;
                PyObject *tmp_source_name_7;
                PyObject *tmp_args_element_name_9;
                PyObject *tmp_source_name_8;
                PyObject *tmp_mvar_value_10;
                PyObject *tmp_args_element_name_10;
                PyObject *tmp_args_element_name_11;
                PyObject *tmp_args_element_name_12;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_9 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2058;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_9;
                tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_REVOKED_add1_ext_i2d );
                if ( tmp_called_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2058;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_self );
                tmp_source_name_7 = par_self;
                tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__revoked );
                if ( tmp_args_element_name_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_4 );

                    exception_lineno = 2059;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_10 == NULL ))
                {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_10 == NULL )
                {
                    Py_DECREF( tmp_called_name_4 );
                    Py_DECREF( tmp_args_element_name_8 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2059;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_8 = tmp_mvar_value_10;
                tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_NID_crl_reason );
                if ( tmp_args_element_name_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_4 );
                    Py_DECREF( tmp_args_element_name_8 );

                    exception_lineno = 2059;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_new_reason_ext );
                tmp_args_element_name_10 = var_new_reason_ext;
                tmp_args_element_name_11 = const_int_0;
                tmp_args_element_name_12 = const_int_0;
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2058;
                {
                    PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
                    tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS5( tmp_called_name_4, call_args );
                }

                Py_DECREF( tmp_called_name_4 );
                Py_DECREF( tmp_args_element_name_8 );
                Py_DECREF( tmp_args_element_name_9 );
                if ( tmp_assign_source_10 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2058;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_add_result == NULL );
                var_add_result = tmp_assign_source_10;
            }
            {
                PyObject *tmp_called_name_5;
                PyObject *tmp_mvar_value_11;
                PyObject *tmp_call_result_5;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_compexpr_left_4;
                PyObject *tmp_compexpr_right_4;
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_11 == NULL ))
                {
                    tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_11 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 2060;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_5 = tmp_mvar_value_11;
                CHECK_OBJECT( var_add_result );
                tmp_compexpr_left_4 = var_add_result;
                tmp_compexpr_right_4 = const_int_pos_1;
                tmp_args_element_name_13 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
                if ( tmp_args_element_name_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2060;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_a1652d3a4f682aed85a3fb220e328368->m_frame.f_lineno = 2060;
                {
                    PyObject *call_args[] = { tmp_args_element_name_13 };
                    tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
                }

                Py_DECREF( tmp_args_element_name_13 );
                if ( tmp_call_result_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2060;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_5 );
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a1652d3a4f682aed85a3fb220e328368 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a1652d3a4f682aed85a3fb220e328368 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a1652d3a4f682aed85a3fb220e328368, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a1652d3a4f682aed85a3fb220e328368->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a1652d3a4f682aed85a3fb220e328368, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a1652d3a4f682aed85a3fb220e328368,
        type_description_1,
        par_self,
        par_reason,
        var_reason_code,
        var_set_result,
        var_r,
        var_add_result,
        var_new_reason_ext
    );


    // Release cached frame.
    if ( frame_a1652d3a4f682aed85a3fb220e328368 == cache_frame_a1652d3a4f682aed85a3fb220e328368 )
    {
        Py_DECREF( frame_a1652d3a4f682aed85a3fb220e328368 );
    }
    cache_frame_a1652d3a4f682aed85a3fb220e328368 = NULL;

    assertFrameObject( frame_a1652d3a4f682aed85a3fb220e328368 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_105_set_reason );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_reason_code );
    var_reason_code = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    Py_XDECREF( par_reason );
    par_reason = NULL;

    Py_XDECREF( var_r );
    var_r = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    Py_XDECREF( var_new_reason_ext );
    var_new_reason_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_reason_code );
    var_reason_code = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    CHECK_OBJECT( (PyObject *)par_reason );
    Py_DECREF( par_reason );
    par_reason = NULL;

    Py_XDECREF( var_r );
    var_r = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    Py_XDECREF( var_new_reason_ext );
    var_new_reason_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_105_set_reason );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_106_get_reason( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_bio = NULL;
    PyObject *var_obj = NULL;
    PyObject *var_print_result = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ext = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_112f2bcd9e9fd44144e9a47985cb3c6d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_112f2bcd9e9fd44144e9a47985cb3c6d = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_112f2bcd9e9fd44144e9a47985cb3c6d, codeobj_112f2bcd9e9fd44144e9a47985cb3c6d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_112f2bcd9e9fd44144e9a47985cb3c6d = cache_frame_112f2bcd9e9fd44144e9a47985cb3c6d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_112f2bcd9e9fd44144e9a47985cb3c6d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_112f2bcd9e9fd44144e9a47985cb3c6d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get_ext_count );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2074;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_range_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2074;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooo";
                exception_lineno = 2074;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_3;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_REVOKED_get_ext );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__revoked );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_i );
        tmp_args_element_name_3 = var_i;
        frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2075;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2075;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_ext;
            var_ext = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2076;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        CHECK_OBJECT( var_ext );
        tmp_args_element_name_4 = var_ext;
        frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2076;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_X509_EXTENSION_get_object, call_args );
        }

        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2076;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_obj;
            var_obj = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_4;
        CHECK_OBJECT( var_obj );
        tmp_args_element_name_5 = var_obj;
        frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2077;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OBJ_obj2nid, call_args );
        }

        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NID_crl_reason );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2077;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_called_name_3;
            PyObject *tmp_mvar_value_6;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
                exception_tb = NULL;

                exception_lineno = 2078;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_3 = tmp_mvar_value_6;
            frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2078;
            tmp_assign_source_6 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2078;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            assert( var_bio == NULL );
            var_bio = tmp_assign_source_6;
        }
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_args_element_name_9;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2080;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_3 = tmp_mvar_value_7;
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_6 = var_bio;
            CHECK_OBJECT( var_ext );
            tmp_args_element_name_7 = var_ext;
            tmp_args_element_name_8 = const_int_0;
            tmp_args_element_name_9 = const_int_0;
            frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2080;
            {
                PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
                tmp_assign_source_7 = CALL_METHOD_WITH_ARGS4( tmp_called_instance_3, const_str_plain_X509V3_EXT_print, call_args );
            }

            if ( tmp_assign_source_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2080;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            assert( var_print_result == NULL );
            var_print_result = tmp_assign_source_7;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            CHECK_OBJECT( var_print_result );
            tmp_operand_name_1 = var_print_result;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2081;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_name_4;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_8;
                PyObject *tmp_args_element_name_10;
                PyObject *tmp_args_element_name_11;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_12;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_8 == NULL ))
                {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_8 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2082;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }

                tmp_source_name_6 = tmp_mvar_value_8;
                tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_M_ASN1_OCTET_STRING_print );
                if ( tmp_called_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2082;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_10 = var_bio;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_9 == NULL )
                {
                    Py_DECREF( tmp_called_name_4 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2083;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }

                tmp_called_instance_4 = tmp_mvar_value_9;
                CHECK_OBJECT( var_ext );
                tmp_args_element_name_12 = var_ext;
                frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2083;
                {
                    PyObject *call_args[] = { tmp_args_element_name_12 };
                    tmp_args_element_name_11 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_X509_EXTENSION_get_data, call_args );
                }

                if ( tmp_args_element_name_11 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_4 );

                    exception_lineno = 2083;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2082;
                {
                    PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
                    tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
                }

                Py_DECREF( tmp_called_name_4 );
                Py_DECREF( tmp_args_element_name_11 );
                if ( tmp_assign_source_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2082;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                {
                    PyObject *old = var_print_result;
                    assert( old != NULL );
                    var_print_result = tmp_assign_source_8;
                    Py_DECREF( old );
                }

            }
            {
                PyObject *tmp_called_name_5;
                PyObject *tmp_mvar_value_10;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_13;
                PyObject *tmp_compexpr_left_2;
                PyObject *tmp_compexpr_right_2;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

                if (unlikely( tmp_mvar_value_10 == NULL ))
                {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
                }

                if ( tmp_mvar_value_10 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
                    exception_tb = NULL;

                    exception_lineno = 2085;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }

                tmp_called_name_5 = tmp_mvar_value_10;
                CHECK_OBJECT( var_print_result );
                tmp_compexpr_left_2 = var_print_result;
                tmp_compexpr_right_2 = const_int_0;
                tmp_args_element_name_13 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
                if ( tmp_args_element_name_13 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2085;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2085;
                {
                    PyObject *call_args[] = { tmp_args_element_name_13 };
                    tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
                }

                Py_DECREF( tmp_args_element_name_13 );
                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2085;
                    type_description_1 = "oooooo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            branch_no_2:;
        }
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_args_element_name_14;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
                exception_tb = NULL;

                exception_lineno = 2087;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }

            tmp_called_name_6 = tmp_mvar_value_11;
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_14 = var_bio;
            frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame.f_lineno = 2087;
            {
                PyObject *call_args[] = { tmp_args_element_name_14 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2087;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }
            goto try_return_handler_2;
        }
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2074;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_112f2bcd9e9fd44144e9a47985cb3c6d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_112f2bcd9e9fd44144e9a47985cb3c6d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_112f2bcd9e9fd44144e9a47985cb3c6d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_112f2bcd9e9fd44144e9a47985cb3c6d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_112f2bcd9e9fd44144e9a47985cb3c6d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_112f2bcd9e9fd44144e9a47985cb3c6d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_112f2bcd9e9fd44144e9a47985cb3c6d,
        type_description_1,
        par_self,
        var_bio,
        var_obj,
        var_print_result,
        var_i,
        var_ext
    );


    // Release cached frame.
    if ( frame_112f2bcd9e9fd44144e9a47985cb3c6d == cache_frame_112f2bcd9e9fd44144e9a47985cb3c6d )
    {
        Py_DECREF( frame_112f2bcd9e9fd44144e9a47985cb3c6d );
    }
    cache_frame_112f2bcd9e9fd44144e9a47985cb3c6d = NULL;

    assertFrameObject( frame_112f2bcd9e9fd44144e9a47985cb3c6d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_106_get_reason );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_print_result );
    var_print_result = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ext );
    var_ext = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_106_get_reason );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_107_all_reasons( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f29a38d7c45651595cf6aedace7de9aa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f29a38d7c45651595cf6aedace7de9aa = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f29a38d7c45651595cf6aedace7de9aa, codeobj_f29a38d7c45651595cf6aedace7de9aa, module_OpenSSL$crypto, sizeof(void *) );
    frame_f29a38d7c45651595cf6aedace7de9aa = cache_frame_f29a38d7c45651595cf6aedace7de9aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f29a38d7c45651595cf6aedace7de9aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f29a38d7c45651595cf6aedace7de9aa ) == 2 ); // Frame stack

    // Framed code:
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_source_name_1;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_slice_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl_reasons );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f29a38d7c45651595cf6aedace7de9aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f29a38d7c45651595cf6aedace7de9aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f29a38d7c45651595cf6aedace7de9aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f29a38d7c45651595cf6aedace7de9aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f29a38d7c45651595cf6aedace7de9aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f29a38d7c45651595cf6aedace7de9aa, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f29a38d7c45651595cf6aedace7de9aa,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f29a38d7c45651595cf6aedace7de9aa == cache_frame_f29a38d7c45651595cf6aedace7de9aa )
    {
        Py_DECREF( frame_f29a38d7c45651595cf6aedace7de9aa );
    }
    cache_frame_f29a38d7c45651595cf6aedace7de9aa = NULL;

    assertFrameObject( frame_f29a38d7c45651595cf6aedace7de9aa );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_107_all_reasons );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_107_all_reasons );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_108_set_rev_date( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    PyObject *var_dt = NULL;
    struct Nuitka_FrameObject *frame_c110c2c8fcfc71619c84f105eb89bce4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c110c2c8fcfc71619c84f105eb89bce4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c110c2c8fcfc71619c84f105eb89bce4, codeobj_c110c2c8fcfc71619c84f105eb89bce4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c110c2c8fcfc71619c84f105eb89bce4 = cache_frame_c110c2c8fcfc71619c84f105eb89bce4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c110c2c8fcfc71619c84f105eb89bce4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c110c2c8fcfc71619c84f105eb89bce4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get0_revocationDate );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_c110c2c8fcfc71619c84f105eb89bce4->m_frame.f_lineno = 2109;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2109;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_dt == NULL );
        var_dt = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_set_asn1_time" );
            exception_tb = NULL;

            exception_lineno = 2110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_dt );
        tmp_args_element_name_2 = var_dt;
        CHECK_OBJECT( par_when );
        tmp_args_element_name_3 = par_when;
        frame_c110c2c8fcfc71619c84f105eb89bce4->m_frame.f_lineno = 2110;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2110;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c110c2c8fcfc71619c84f105eb89bce4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c110c2c8fcfc71619c84f105eb89bce4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c110c2c8fcfc71619c84f105eb89bce4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c110c2c8fcfc71619c84f105eb89bce4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c110c2c8fcfc71619c84f105eb89bce4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c110c2c8fcfc71619c84f105eb89bce4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c110c2c8fcfc71619c84f105eb89bce4,
        type_description_1,
        par_self,
        par_when,
        var_dt
    );


    // Release cached frame.
    if ( frame_c110c2c8fcfc71619c84f105eb89bce4 == cache_frame_c110c2c8fcfc71619c84f105eb89bce4 )
    {
        Py_DECREF( frame_c110c2c8fcfc71619c84f105eb89bce4 );
    }
    cache_frame_c110c2c8fcfc71619c84f105eb89bce4 = NULL;

    assertFrameObject( frame_c110c2c8fcfc71619c84f105eb89bce4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_108_set_rev_date );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)var_dt );
    Py_DECREF( var_dt );
    var_dt = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    Py_XDECREF( var_dt );
    var_dt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_108_set_rev_date );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_109_get_rev_date( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_dt = NULL;
    struct Nuitka_FrameObject *frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6, codeobj_647ba6ed33a4f2ae30ef81b1cc6e4aa6, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 = cache_frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_REVOKED_get0_revocationDate );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6->m_frame.f_lineno = 2119;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2119;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_dt == NULL );
        var_dt = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_asn1_time );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_asn1_time" );
            exception_tb = NULL;

            exception_lineno = 2120;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_dt );
        tmp_args_element_name_2 = var_dt;
        frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6->m_frame.f_lineno = 2120;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2120;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6,
        type_description_1,
        par_self,
        var_dt
    );


    // Release cached frame.
    if ( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 == cache_frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 )
    {
        Py_DECREF( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 );
    }
    cache_frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 = NULL;

    assertFrameObject( frame_647ba6ed33a4f2ae30ef81b1cc6e4aa6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_109_get_rev_date );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_dt );
    Py_DECREF( var_dt );
    var_dt = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_dt );
    var_dt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_109_get_rev_date );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_110___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_crl = NULL;
    struct Nuitka_FrameObject *frame_ee9f0393ec340507f2d7d8df847a43a2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_ee9f0393ec340507f2d7d8df847a43a2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ee9f0393ec340507f2d7d8df847a43a2, codeobj_ee9f0393ec340507f2d7d8df847a43a2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_ee9f0393ec340507f2d7d8df847a43a2 = cache_frame_ee9f0393ec340507f2d7d8df847a43a2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ee9f0393ec340507f2d7d8df847a43a2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ee9f0393ec340507f2d7d8df847a43a2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2129;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_ee9f0393ec340507f2d7d8df847a43a2->m_frame.f_lineno = 2129;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_X509_CRL_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2129;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_crl == NULL );
        var_crl = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_crl );
        tmp_args_element_name_1 = var_crl;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_ee9f0393ec340507f2d7d8df847a43a2->m_frame.f_lineno = 2130;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2130;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee9f0393ec340507f2d7d8df847a43a2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ee9f0393ec340507f2d7d8df847a43a2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ee9f0393ec340507f2d7d8df847a43a2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ee9f0393ec340507f2d7d8df847a43a2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ee9f0393ec340507f2d7d8df847a43a2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ee9f0393ec340507f2d7d8df847a43a2,
        type_description_1,
        par_self,
        var_crl
    );


    // Release cached frame.
    if ( frame_ee9f0393ec340507f2d7d8df847a43a2 == cache_frame_ee9f0393ec340507f2d7d8df847a43a2 )
    {
        Py_DECREF( frame_ee9f0393ec340507f2d7d8df847a43a2 );
    }
    cache_frame_ee9f0393ec340507f2d7d8df847a43a2 = NULL;

    assertFrameObject( frame_ee9f0393ec340507f2d7d8df847a43a2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_110___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_crl );
    Py_DECREF( var_crl );
    var_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_110___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_111_to_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__CertificateRevocationList = NULL;
    PyObject *var_backend = NULL;
    struct Nuitka_FrameObject *frame_ac9f6b5c97ade7871513f9832183e591;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ac9f6b5c97ade7871513f9832183e591 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ac9f6b5c97ade7871513f9832183e591, codeobj_ac9f6b5c97ade7871513f9832183e591, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ac9f6b5c97ade7871513f9832183e591 = cache_frame_ac9f6b5c97ade7871513f9832183e591;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ac9f6b5c97ade7871513f9832183e591 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ac9f6b5c97ade7871513f9832183e591 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_2b6a6c0099f1f1dd77d2725acd0722df;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain__CertificateRevocationList_tuple;
        frame_ac9f6b5c97ade7871513f9832183e591->m_frame.f_lineno = 2140;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain__CertificateRevocationList );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2140;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var__CertificateRevocationList == NULL );
        var__CertificateRevocationList = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__get_backend );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_get_backend" );
            exception_tb = NULL;

            exception_lineno = 2143;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_ac9f6b5c97ade7871513f9832183e591->m_frame.f_lineno = 2143;
        tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2143;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_backend == NULL );
        var_backend = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var__CertificateRevocationList );
        tmp_called_name_2 = var__CertificateRevocationList;
        CHECK_OBJECT( var_backend );
        tmp_args_element_name_1 = var_backend;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2144;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_ac9f6b5c97ade7871513f9832183e591->m_frame.f_lineno = 2144;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2144;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac9f6b5c97ade7871513f9832183e591 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac9f6b5c97ade7871513f9832183e591 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac9f6b5c97ade7871513f9832183e591 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ac9f6b5c97ade7871513f9832183e591, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ac9f6b5c97ade7871513f9832183e591->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ac9f6b5c97ade7871513f9832183e591, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ac9f6b5c97ade7871513f9832183e591,
        type_description_1,
        par_self,
        var__CertificateRevocationList,
        var_backend
    );


    // Release cached frame.
    if ( frame_ac9f6b5c97ade7871513f9832183e591 == cache_frame_ac9f6b5c97ade7871513f9832183e591 )
    {
        Py_DECREF( frame_ac9f6b5c97ade7871513f9832183e591 );
    }
    cache_frame_ac9f6b5c97ade7871513f9832183e591 = NULL;

    assertFrameObject( frame_ac9f6b5c97ade7871513f9832183e591 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_111_to_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__CertificateRevocationList );
    Py_DECREF( var__CertificateRevocationList );
    var__CertificateRevocationList = NULL;

    CHECK_OBJECT( (PyObject *)var_backend );
    Py_DECREF( var_backend );
    var_backend = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__CertificateRevocationList );
    var__CertificateRevocationList = NULL;

    Py_XDECREF( var_backend );
    var_backend = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_111_to_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_112_from_cryptography( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_crypto_crl = python_pars[ 1 ];
    PyObject *var_crl = NULL;
    struct Nuitka_FrameObject *frame_04292aa6779241fb95227d0370adeed4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_04292aa6779241fb95227d0370adeed4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_04292aa6779241fb95227d0370adeed4, codeobj_04292aa6779241fb95227d0370adeed4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_04292aa6779241fb95227d0370adeed4 = cache_frame_04292aa6779241fb95227d0370adeed4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_04292aa6779241fb95227d0370adeed4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_04292aa6779241fb95227d0370adeed4 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_crypto_crl );
        tmp_isinstance_inst_1 = par_crypto_crl;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_x509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "x509" );
            exception_tb = NULL;

            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_CertificateRevocationList );
        if ( tmp_isinstance_cls_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2158;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_35f6b1c1261cd55e34a5b00d6cb8d5ea;
            frame_04292aa6779241fb95227d0370adeed4->m_frame.f_lineno = 2159;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2159;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        CHECK_OBJECT( par_cls );
        tmp_called_name_1 = par_cls;
        frame_04292aa6779241fb95227d0370adeed4->m_frame.f_lineno = 2161;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2161;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_crl == NULL );
        var_crl = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_crypto_crl );
        tmp_source_name_2 = par_crypto_crl;
        tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__x509_crl );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2162;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_crl );
        tmp_assattr_target_1 = var_crl;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2162;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04292aa6779241fb95227d0370adeed4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_04292aa6779241fb95227d0370adeed4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_04292aa6779241fb95227d0370adeed4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_04292aa6779241fb95227d0370adeed4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_04292aa6779241fb95227d0370adeed4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_04292aa6779241fb95227d0370adeed4,
        type_description_1,
        par_cls,
        par_crypto_crl,
        var_crl
    );


    // Release cached frame.
    if ( frame_04292aa6779241fb95227d0370adeed4 == cache_frame_04292aa6779241fb95227d0370adeed4 )
    {
        Py_DECREF( frame_04292aa6779241fb95227d0370adeed4 );
    }
    cache_frame_04292aa6779241fb95227d0370adeed4 = NULL;

    assertFrameObject( frame_04292aa6779241fb95227d0370adeed4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_crl );
    tmp_return_value = var_crl;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_112_from_cryptography );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_crypto_crl );
    Py_DECREF( par_crypto_crl );
    par_crypto_crl = NULL;

    CHECK_OBJECT( (PyObject *)var_crl );
    Py_DECREF( var_crl );
    var_crl = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_crypto_crl );
    Py_DECREF( par_crypto_crl );
    par_crypto_crl = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_112_from_cryptography );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_113_get_revoked( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_revoked = NULL;
    PyObject *var_i = NULL;
    PyObject *var_pyrev = NULL;
    PyObject *var_results = NULL;
    PyObject *var_revoked_stack = NULL;
    PyObject *var_revoked_copy = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_0bd74d7e47065b77cbb33b10a13c07c3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0bd74d7e47065b77cbb33b10a13c07c3 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New( 0 );
        assert( var_results == NULL );
        var_results = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0bd74d7e47065b77cbb33b10a13c07c3, codeobj_0bd74d7e47065b77cbb33b10a13c07c3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0bd74d7e47065b77cbb33b10a13c07c3 = cache_frame_0bd74d7e47065b77cbb33b10a13c07c3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0bd74d7e47065b77cbb33b10a13c07c3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0bd74d7e47065b77cbb33b10a13c07c3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_CRL_get_REVOKED );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__crl );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame.f_lineno = 2176;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2176;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_revoked_stack == NULL );
        var_revoked_stack = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_revoked_stack );
        tmp_args_element_name_2 = var_revoked_stack;
        frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame.f_lineno = 2177;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sk_X509_REVOKED_num, call_args );
        }

        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2177;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooo";
                exception_lineno = 2177;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_5;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2178;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_revoked_stack );
        tmp_args_element_name_3 = var_revoked_stack;
        CHECK_OBJECT( var_i );
        tmp_args_element_name_4 = var_i;
        frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame.f_lineno = 2178;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_sk_X509_REVOKED_value, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2178;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_revoked;
            var_revoked = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2179;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_called_instance_3 = tmp_mvar_value_4;
        CHECK_OBJECT( var_revoked );
        tmp_args_element_name_5 = var_revoked;
        frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame.f_lineno = 2179;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_Cryptography_X509_REVOKED_dup, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2179;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_revoked_copy;
            var_revoked_copy = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Revoked );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Revoked" );
            exception_tb = NULL;

            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___new__ );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Revoked );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Revoked" );
            exception_tb = NULL;

            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_args_element_name_6 = tmp_mvar_value_6;
        frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame.f_lineno = 2180;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2180;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_pyrev;
            var_pyrev = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_gc );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_revoked_copy );
        tmp_args_element_name_7 = var_revoked_copy;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }

        tmp_source_name_5 = tmp_mvar_value_8;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_REVOKED_free );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame.f_lineno = 2181;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_pyrev );
        tmp_assattr_target_1 = var_pyrev;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__revoked, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2181;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT( var_results );
        tmp_called_instance_4 = var_results;
        CHECK_OBJECT( var_pyrev );
        tmp_args_element_name_9 = var_pyrev;
        frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame.f_lineno = 2182;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2182;
            type_description_1 = "ooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2177;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_results );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_results );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2183;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_tuple_arg_1;
            CHECK_OBJECT( var_results );
            tmp_tuple_arg_1 = var_results;
            tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2184;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0bd74d7e47065b77cbb33b10a13c07c3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0bd74d7e47065b77cbb33b10a13c07c3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0bd74d7e47065b77cbb33b10a13c07c3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0bd74d7e47065b77cbb33b10a13c07c3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0bd74d7e47065b77cbb33b10a13c07c3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0bd74d7e47065b77cbb33b10a13c07c3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0bd74d7e47065b77cbb33b10a13c07c3,
        type_description_1,
        par_self,
        var_revoked,
        var_i,
        var_pyrev,
        var_results,
        var_revoked_stack,
        var_revoked_copy
    );


    // Release cached frame.
    if ( frame_0bd74d7e47065b77cbb33b10a13c07c3 == cache_frame_0bd74d7e47065b77cbb33b10a13c07c3 )
    {
        Py_DECREF( frame_0bd74d7e47065b77cbb33b10a13c07c3 );
    }
    cache_frame_0bd74d7e47065b77cbb33b10a13c07c3 = NULL;

    assertFrameObject( frame_0bd74d7e47065b77cbb33b10a13c07c3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_113_get_revoked );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_revoked );
    var_revoked = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_pyrev );
    var_pyrev = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_results );
    Py_DECREF( var_results );
    var_results = NULL;

    CHECK_OBJECT( (PyObject *)var_revoked_stack );
    Py_DECREF( var_revoked_stack );
    var_revoked_stack = NULL;

    Py_XDECREF( var_revoked_copy );
    var_revoked_copy = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_revoked );
    var_revoked = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_pyrev );
    var_pyrev = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_results );
    Py_DECREF( var_results );
    var_results = NULL;

    Py_XDECREF( var_revoked_stack );
    var_revoked_stack = NULL;

    Py_XDECREF( var_revoked_copy );
    var_revoked_copy = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_113_get_revoked );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_114_add_revoked( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_revoked = python_pars[ 1 ];
    PyObject *var_copy = NULL;
    PyObject *var_add_result = NULL;
    struct Nuitka_FrameObject *frame_c544d0701ee1c350826d019a78afa8e0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c544d0701ee1c350826d019a78afa8e0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c544d0701ee1c350826d019a78afa8e0, codeobj_c544d0701ee1c350826d019a78afa8e0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c544d0701ee1c350826d019a78afa8e0 = cache_frame_c544d0701ee1c350826d019a78afa8e0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c544d0701ee1c350826d019a78afa8e0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c544d0701ee1c350826d019a78afa8e0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Cryptography_X509_REVOKED_dup );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_revoked );
        tmp_source_name_2 = par_revoked;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__revoked );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_c544d0701ee1c350826d019a78afa8e0->m_frame.f_lineno = 2197;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2197;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_copy == NULL );
        var_copy = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_copy );
        tmp_compexpr_left_1 = var_copy;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_c544d0701ee1c350826d019a78afa8e0->m_frame.f_lineno = 2198;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2198;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_CRL_add0_revoked );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__crl );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_copy );
        tmp_args_element_name_4 = var_copy;
        frame_c544d0701ee1c350826d019a78afa8e0->m_frame.f_lineno = 2200;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2200;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_add_result == NULL );
        var_add_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2201;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        CHECK_OBJECT( var_add_result );
        tmp_compexpr_left_2 = var_add_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_5 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2201;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_c544d0701ee1c350826d019a78afa8e0->m_frame.f_lineno = 2201;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2201;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c544d0701ee1c350826d019a78afa8e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c544d0701ee1c350826d019a78afa8e0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c544d0701ee1c350826d019a78afa8e0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c544d0701ee1c350826d019a78afa8e0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c544d0701ee1c350826d019a78afa8e0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c544d0701ee1c350826d019a78afa8e0,
        type_description_1,
        par_self,
        par_revoked,
        var_copy,
        var_add_result
    );


    // Release cached frame.
    if ( frame_c544d0701ee1c350826d019a78afa8e0 == cache_frame_c544d0701ee1c350826d019a78afa8e0 )
    {
        Py_DECREF( frame_c544d0701ee1c350826d019a78afa8e0 );
    }
    cache_frame_c544d0701ee1c350826d019a78afa8e0 = NULL;

    assertFrameObject( frame_c544d0701ee1c350826d019a78afa8e0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_114_add_revoked );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_copy );
    Py_DECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_revoked );
    Py_DECREF( par_revoked );
    par_revoked = NULL;

    CHECK_OBJECT( (PyObject *)var_add_result );
    Py_DECREF( var_add_result );
    var_add_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_copy );
    var_copy = NULL;

    CHECK_OBJECT( (PyObject *)par_revoked );
    Py_DECREF( par_revoked );
    par_revoked = NULL;

    Py_XDECREF( var_add_result );
    var_add_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_114_add_revoked );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_115_get_issuer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var__issuer = NULL;
    PyObject *var_issuer = NULL;
    struct Nuitka_FrameObject *frame_a622427fd2cf1844f047e5dc915ecd01;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_a622427fd2cf1844f047e5dc915ecd01 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a622427fd2cf1844f047e5dc915ecd01, codeobj_a622427fd2cf1844f047e5dc915ecd01, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a622427fd2cf1844f047e5dc915ecd01 = cache_frame_a622427fd2cf1844f047e5dc915ecd01;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a622427fd2cf1844f047e5dc915ecd01 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a622427fd2cf1844f047e5dc915ecd01 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_NAME_dup );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_get_issuer );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__crl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a622427fd2cf1844f047e5dc915ecd01->m_frame.f_lineno = 2211;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a622427fd2cf1844f047e5dc915ecd01->m_frame.f_lineno = 2211;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2211;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var__issuer == NULL );
        var__issuer = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT( var__issuer );
        tmp_compexpr_left_1 = var__issuer;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a622427fd2cf1844f047e5dc915ecd01->m_frame.f_lineno = 2212;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2212;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var__issuer );
        tmp_args_element_name_4 = var__issuer;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_NAME_free );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a622427fd2cf1844f047e5dc915ecd01->m_frame.f_lineno = 2213;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2213;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var__issuer;
            assert( old != NULL );
            var__issuer = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_7;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain___new__ );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_8 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_6 = tmp_mvar_value_8;
        frame_a622427fd2cf1844f047e5dc915ecd01->m_frame.f_lineno = 2214;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2214;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_issuer == NULL );
        var_issuer = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( var__issuer );
        tmp_assattr_name_1 = var__issuer;
        CHECK_OBJECT( var_issuer );
        tmp_assattr_target_1 = var_issuer;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__name, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2215;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a622427fd2cf1844f047e5dc915ecd01 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a622427fd2cf1844f047e5dc915ecd01 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a622427fd2cf1844f047e5dc915ecd01, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a622427fd2cf1844f047e5dc915ecd01->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a622427fd2cf1844f047e5dc915ecd01, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a622427fd2cf1844f047e5dc915ecd01,
        type_description_1,
        par_self,
        var__issuer,
        var_issuer
    );


    // Release cached frame.
    if ( frame_a622427fd2cf1844f047e5dc915ecd01 == cache_frame_a622427fd2cf1844f047e5dc915ecd01 )
    {
        Py_DECREF( frame_a622427fd2cf1844f047e5dc915ecd01 );
    }
    cache_frame_a622427fd2cf1844f047e5dc915ecd01 = NULL;

    assertFrameObject( frame_a622427fd2cf1844f047e5dc915ecd01 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_issuer );
    tmp_return_value = var_issuer;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_115_get_issuer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var__issuer );
    Py_DECREF( var__issuer );
    var__issuer = NULL;

    CHECK_OBJECT( (PyObject *)var_issuer );
    Py_DECREF( var_issuer );
    var_issuer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var__issuer );
    var__issuer = NULL;

    Py_XDECREF( var_issuer );
    var_issuer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_115_get_issuer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_116_set_version( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_version = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_9cbe3542cb01bdd5c50f6b4b4e305557;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9cbe3542cb01bdd5c50f6b4b4e305557 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9cbe3542cb01bdd5c50f6b4b4e305557, codeobj_9cbe3542cb01bdd5c50f6b4b4e305557, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_9cbe3542cb01bdd5c50f6b4b4e305557 = cache_frame_9cbe3542cb01bdd5c50f6b4b4e305557;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9cbe3542cb01bdd5c50f6b4b4e305557 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9cbe3542cb01bdd5c50f6b4b4e305557 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_X509_CRL_set_version );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__crl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_version );
        tmp_args_element_name_3 = par_version;
        frame_9cbe3542cb01bdd5c50f6b4b4e305557->m_frame.f_lineno = 2227;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_args_element_name_1 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_9cbe3542cb01bdd5c50f6b4b4e305557->m_frame.f_lineno = 2227;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2227;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cbe3542cb01bdd5c50f6b4b4e305557 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cbe3542cb01bdd5c50f6b4b4e305557 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9cbe3542cb01bdd5c50f6b4b4e305557, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9cbe3542cb01bdd5c50f6b4b4e305557->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9cbe3542cb01bdd5c50f6b4b4e305557, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9cbe3542cb01bdd5c50f6b4b4e305557,
        type_description_1,
        par_self,
        par_version
    );


    // Release cached frame.
    if ( frame_9cbe3542cb01bdd5c50f6b4b4e305557 == cache_frame_9cbe3542cb01bdd5c50f6b4b4e305557 )
    {
        Py_DECREF( frame_9cbe3542cb01bdd5c50f6b4b4e305557 );
    }
    cache_frame_9cbe3542cb01bdd5c50f6b4b4e305557 = NULL;

    assertFrameObject( frame_9cbe3542cb01bdd5c50f6b4b4e305557 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_116_set_version );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_version );
    Py_DECREF( par_version );
    par_version = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_116_set_version );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_117__set_boundary_time( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_which = python_pars[ 1 ];
    PyObject *par_when = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_50e52f8de0f444400c5e7caf8a75aef0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_50e52f8de0f444400c5e7caf8a75aef0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_50e52f8de0f444400c5e7caf8a75aef0, codeobj_50e52f8de0f444400c5e7caf8a75aef0, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_50e52f8de0f444400c5e7caf8a75aef0 = cache_frame_50e52f8de0f444400c5e7caf8a75aef0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_50e52f8de0f444400c5e7caf8a75aef0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_50e52f8de0f444400c5e7caf8a75aef0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__set_asn1_time );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_set_asn1_time" );
            exception_tb = NULL;

            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_which );
        tmp_called_name_2 = par_which;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__crl );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_50e52f8de0f444400c5e7caf8a75aef0->m_frame.f_lineno = 2230;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_when );
        tmp_args_element_name_3 = par_when;
        frame_50e52f8de0f444400c5e7caf8a75aef0->m_frame.f_lineno = 2230;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_3 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2230;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_50e52f8de0f444400c5e7caf8a75aef0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_50e52f8de0f444400c5e7caf8a75aef0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_50e52f8de0f444400c5e7caf8a75aef0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_50e52f8de0f444400c5e7caf8a75aef0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_50e52f8de0f444400c5e7caf8a75aef0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_50e52f8de0f444400c5e7caf8a75aef0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_50e52f8de0f444400c5e7caf8a75aef0,
        type_description_1,
        par_self,
        par_which,
        par_when
    );


    // Release cached frame.
    if ( frame_50e52f8de0f444400c5e7caf8a75aef0 == cache_frame_50e52f8de0f444400c5e7caf8a75aef0 )
    {
        Py_DECREF( frame_50e52f8de0f444400c5e7caf8a75aef0 );
    }
    cache_frame_50e52f8de0f444400c5e7caf8a75aef0 = NULL;

    assertFrameObject( frame_50e52f8de0f444400c5e7caf8a75aef0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_117__set_boundary_time );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    CHECK_OBJECT( (PyObject *)par_which );
    Py_DECREF( par_which );
    par_which = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_117__set_boundary_time );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_118_set_lastUpdate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_3cf211d19041a0548596ace3209e1f70;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3cf211d19041a0548596ace3209e1f70 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3cf211d19041a0548596ace3209e1f70, codeobj_3cf211d19041a0548596ace3209e1f70, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_3cf211d19041a0548596ace3209e1f70 = cache_frame_3cf211d19041a0548596ace3209e1f70;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3cf211d19041a0548596ace3209e1f70 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3cf211d19041a0548596ace3209e1f70 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_get_lastUpdate );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_when );
        tmp_args_element_name_2 = par_when;
        frame_3cf211d19041a0548596ace3209e1f70->m_frame.f_lineno = 2245;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2245;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3cf211d19041a0548596ace3209e1f70 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3cf211d19041a0548596ace3209e1f70 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3cf211d19041a0548596ace3209e1f70 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3cf211d19041a0548596ace3209e1f70, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3cf211d19041a0548596ace3209e1f70->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3cf211d19041a0548596ace3209e1f70, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3cf211d19041a0548596ace3209e1f70,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_3cf211d19041a0548596ace3209e1f70 == cache_frame_3cf211d19041a0548596ace3209e1f70 )
    {
        Py_DECREF( frame_3cf211d19041a0548596ace3209e1f70 );
    }
    cache_frame_3cf211d19041a0548596ace3209e1f70 = NULL;

    assertFrameObject( frame_3cf211d19041a0548596ace3209e1f70 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_118_set_lastUpdate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_118_set_lastUpdate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_119_set_nextUpdate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_when = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_5a01e627c9af2bcd87343071c673f76b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5a01e627c9af2bcd87343071c673f76b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5a01e627c9af2bcd87343071c673f76b, codeobj_5a01e627c9af2bcd87343071c673f76b, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_5a01e627c9af2bcd87343071c673f76b = cache_frame_5a01e627c9af2bcd87343071c673f76b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5a01e627c9af2bcd87343071c673f76b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5a01e627c9af2bcd87343071c673f76b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__set_boundary_time );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_get_nextUpdate );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_when );
        tmp_args_element_name_2 = par_when;
        frame_5a01e627c9af2bcd87343071c673f76b->m_frame.f_lineno = 2260;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2260;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a01e627c9af2bcd87343071c673f76b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a01e627c9af2bcd87343071c673f76b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5a01e627c9af2bcd87343071c673f76b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5a01e627c9af2bcd87343071c673f76b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5a01e627c9af2bcd87343071c673f76b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5a01e627c9af2bcd87343071c673f76b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5a01e627c9af2bcd87343071c673f76b,
        type_description_1,
        par_self,
        par_when
    );


    // Release cached frame.
    if ( frame_5a01e627c9af2bcd87343071c673f76b == cache_frame_5a01e627c9af2bcd87343071c673f76b )
    {
        Py_DECREF( frame_5a01e627c9af2bcd87343071c673f76b );
    }
    cache_frame_5a01e627c9af2bcd87343071c673f76b = NULL;

    assertFrameObject( frame_5a01e627c9af2bcd87343071c673f76b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_119_set_nextUpdate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_when );
    Py_DECREF( par_when );
    par_when = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_119_set_nextUpdate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_120_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_issuer_cert = python_pars[ 1 ];
    PyObject *par_issuer_key = python_pars[ 2 ];
    PyObject *par_digest = python_pars[ 3 ];
    PyObject *var_digest_obj = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_e01ada03e6cb97935670c2ece19dcde1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e01ada03e6cb97935670c2ece19dcde1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e01ada03e6cb97935670c2ece19dcde1, codeobj_e01ada03e6cb97935670c2ece19dcde1, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e01ada03e6cb97935670c2ece19dcde1 = cache_frame_e01ada03e6cb97935670c2ece19dcde1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e01ada03e6cb97935670c2ece19dcde1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e01ada03e6cb97935670c2ece19dcde1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2279;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_digest );
        tmp_args_element_name_1 = par_digest;
        frame_e01ada03e6cb97935670c2ece19dcde1->m_frame.f_lineno = 2279;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_EVP_get_digestbyname, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2279;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest_obj == NULL );
        var_digest_obj = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_digest_obj );
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_e01ada03e6cb97935670c2ece19dcde1->m_frame.f_lineno = 2280;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2281;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_X509_CRL_set_issuer_name );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2281;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__crl );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_X509_get_subject_name );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_issuer_cert );
        tmp_source_name_5 = par_issuer_cert;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__x509 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_e01ada03e6cb97935670c2ece19dcde1->m_frame.f_lineno = 2282;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 2282;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_e01ada03e6cb97935670c2ece19dcde1->m_frame.f_lineno = 2281;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2281;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_X509_CRL_sort );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__crl );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_e01ada03e6cb97935670c2ece19dcde1->m_frame.f_lineno = 2283;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2283;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_9;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_10;
        PyObject *tmp_args_element_name_9;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509_CRL_sign );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__crl );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_issuer_key );
        tmp_source_name_10 = par_issuer_key;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__pkey );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );
            Py_DECREF( tmp_args_element_name_7 );

            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_digest_obj );
        tmp_args_element_name_9 = var_digest_obj;
        frame_e01ada03e6cb97935670c2ece19dcde1->m_frame.f_lineno = 2284;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2284;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2285;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_8;
        CHECK_OBJECT( var_result );
        tmp_compexpr_left_2 = var_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_10 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2285;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        frame_e01ada03e6cb97935670c2ece19dcde1->m_frame.f_lineno = 2285;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2285;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e01ada03e6cb97935670c2ece19dcde1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e01ada03e6cb97935670c2ece19dcde1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e01ada03e6cb97935670c2ece19dcde1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e01ada03e6cb97935670c2ece19dcde1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e01ada03e6cb97935670c2ece19dcde1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e01ada03e6cb97935670c2ece19dcde1,
        type_description_1,
        par_self,
        par_issuer_cert,
        par_issuer_key,
        par_digest,
        var_digest_obj,
        var_result
    );


    // Release cached frame.
    if ( frame_e01ada03e6cb97935670c2ece19dcde1 == cache_frame_e01ada03e6cb97935670c2ece19dcde1 )
    {
        Py_DECREF( frame_e01ada03e6cb97935670c2ece19dcde1 );
    }
    cache_frame_e01ada03e6cb97935670c2ece19dcde1 = NULL;

    assertFrameObject( frame_e01ada03e6cb97935670c2ece19dcde1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_120_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_cert );
    Py_DECREF( par_issuer_cert );
    par_issuer_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_key );
    Py_DECREF( par_issuer_key );
    par_issuer_key = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_cert );
    Py_DECREF( par_issuer_cert );
    par_issuer_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_issuer_key );
    Py_DECREF( par_issuer_key );
    par_issuer_key = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_120_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_121_export( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    PyObject *par_key = python_pars[ 2 ];
    PyObject *par_type = python_pars[ 3 ];
    PyObject *par_days = python_pars[ 4 ];
    PyObject *par_digest = python_pars[ 5 ];
    PyObject *var_bio = NULL;
    PyObject *var_sometime = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    struct Nuitka_FrameObject *frame_301abfeda8d0b6cd2206b5e57a81b467;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_301abfeda8d0b6cd2206b5e57a81b467 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_301abfeda8d0b6cd2206b5e57a81b467, codeobj_301abfeda8d0b6cd2206b5e57a81b467, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_301abfeda8d0b6cd2206b5e57a81b467 = cache_frame_301abfeda8d0b6cd2206b5e57a81b467;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_301abfeda8d0b6cd2206b5e57a81b467 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_301abfeda8d0b6cd2206b5e57a81b467 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cert );
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 2302;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2302;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2302;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
            frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2303;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2303;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_key );
        tmp_isinstance_inst_2 = par_key;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2304;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2304;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2304;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_0226e12d6e09b849c37787a1a7ec35a4;
            frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2305;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 2305;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        CHECK_OBJECT( par_type );
        tmp_isinstance_inst_3 = par_type;
        tmp_isinstance_cls_3 = (PyObject *)&PyInt_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2306;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_3 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2306;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_50f07d7dbc7dc060eb5685744b92c007;
            frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2307;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_3 == NULL) );
            exception_type = tmp_raise_type_3;
            exception_lineno = 2307;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_digest );
        tmp_compexpr_left_1 = par_digest;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_UNSPECIFIED" );
            exception_tb = NULL;

            exception_lineno = 2309;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_condition_result_4 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_4;
            PyObject *tmp_make_exception_arg_4;
            tmp_make_exception_arg_4 = const_str_digest_e19f4eaf61167e65441aca909fe75b36;
            frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2310;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_4 };
                tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_4 == NULL) );
            exception_type = tmp_raise_type_4;
            exception_lineno = 2310;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2312;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_4;
        CHECK_OBJECT( par_digest );
        tmp_args_element_name_1 = par_digest;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2312;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_EVP_get_digestbyname, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2312;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest_obj == NULL );
        var_digest_obj = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_5;
        CHECK_OBJECT( var_digest_obj );
        tmp_compexpr_left_2 = var_digest_obj;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2313;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_5;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2313;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2313;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_raise_type_5;
            PyObject *tmp_make_exception_arg_5;
            tmp_make_exception_arg_5 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2314;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_5 };
                tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_5 == NULL) );
            exception_type = tmp_raise_type_5;
            exception_lineno = 2314;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_6;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_BIO_new );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_7;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2316;
        tmp_args_element_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_BIO_s_mem );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2316;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2316;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_8;
        CHECK_OBJECT( var_bio );
        tmp_compexpr_left_3 = var_bio;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_9;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2317;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2317;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2321;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_10;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2321;
        tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_ASN1_TIME_new );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2321;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_sometime == NULL );
        var_sometime = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_11;
        CHECK_OBJECT( var_sometime );
        tmp_compexpr_left_4 = var_sometime;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_12;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_4 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_right_4 );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2322;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2322;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2324;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_13;
        CHECK_OBJECT( var_sometime );
        tmp_args_element_name_5 = var_sometime;
        tmp_args_element_name_6 = const_int_0;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2324;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_X509_gmtime_adj, call_args );
        }

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2324;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_14;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_CRL_set_lastUpdate );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__crl );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_sometime );
        tmp_args_element_name_8 = var_sometime;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2325;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2325;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_call_result_5;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_15;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_X509_gmtime_adj );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_sometime );
        tmp_args_element_name_9 = var_sometime;
        CHECK_OBJECT( par_days );
        tmp_left_name_3 = par_days;
        tmp_right_name_1 = const_int_pos_24;
        tmp_left_name_2 = BINARY_OPERATION_MUL( tmp_left_name_3, tmp_right_name_1 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_60;
        tmp_left_name_1 = BINARY_OPERATION_MUL( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_60;
        tmp_args_element_name_10 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2327;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_call_result_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2327;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_5 );
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_call_result_6;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_9;
        PyObject *tmp_args_element_name_12;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_16;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_X509_CRL_set_nextUpdate );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__crl );
        if ( tmp_args_element_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_sometime );
        tmp_args_element_name_12 = var_sometime;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2328;
        {
            PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_call_result_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_11 );
        if ( tmp_call_result_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2328;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_6 );
    }
    {
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_17;
        PyObject *tmp_call_result_7;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_11;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_12;
        PyObject *tmp_mvar_value_18;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_source_name_13;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_17 == NULL ))
        {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_17 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2330;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_17;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_CRL_set_issuer_name );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2330;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_11 = par_self;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__crl );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_18 == NULL )
        {
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_12 = tmp_mvar_value_18;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_X509_get_subject_name );
        if ( tmp_called_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cert );
        tmp_source_name_13 = par_cert;
        tmp_args_element_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain__x509 );
        if ( tmp_args_element_name_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );
            Py_DECREF( tmp_called_name_8 );

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2331;
        {
            PyObject *call_args[] = { tmp_args_element_name_15 };
            tmp_args_element_name_14 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
        }

        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_15 );
        if ( tmp_args_element_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );

            exception_lineno = 2331;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2330;
        {
            PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
            tmp_call_result_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        Py_DECREF( tmp_args_element_name_14 );
        if ( tmp_call_result_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2330;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_7 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_9;
        PyObject *tmp_source_name_14;
        PyObject *tmp_mvar_value_19;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_source_name_15;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_source_name_16;
        PyObject *tmp_args_element_name_18;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_14 = tmp_mvar_value_19;
        tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_X509_CRL_sign );
        if ( tmp_called_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_15 = par_self;
        tmp_args_element_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__crl );
        if ( tmp_args_element_name_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_9 );

            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_key );
        tmp_source_name_16 = par_key;
        tmp_args_element_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain__pkey );
        if ( tmp_args_element_name_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_9 );
            Py_DECREF( tmp_args_element_name_16 );

            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_digest_obj );
        tmp_args_element_name_18 = var_digest_obj;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2334;
        {
            PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
        }

        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_16 );
        Py_DECREF( tmp_args_element_name_17 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2334;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_sign_result == NULL );
        var_sign_result = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_operand_name_4;
        CHECK_OBJECT( var_sign_result );
        tmp_operand_name_4 = var_sign_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2335;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_mvar_value_20;
            PyObject *tmp_call_result_8;
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_20 == NULL ))
            {
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_20 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2336;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_10 = tmp_mvar_value_20;
            frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2336;
            tmp_call_result_8 = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
            if ( tmp_call_result_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2336;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_8 );
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_called_name_11;
        PyObject *tmp_mvar_value_21;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_crl );

        if (unlikely( tmp_mvar_value_21 == NULL ))
        {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_dump_crl );
        }

        if ( tmp_mvar_value_21 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "dump_crl" );
            exception_tb = NULL;

            exception_lineno = 2338;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_11 = tmp_mvar_value_21;
        CHECK_OBJECT( par_type );
        tmp_args_element_name_19 = par_type;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_20 = par_self;
        frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame.f_lineno = 2338;
        {
            PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_11, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2338;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_301abfeda8d0b6cd2206b5e57a81b467 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_301abfeda8d0b6cd2206b5e57a81b467 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_301abfeda8d0b6cd2206b5e57a81b467 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_301abfeda8d0b6cd2206b5e57a81b467, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_301abfeda8d0b6cd2206b5e57a81b467->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_301abfeda8d0b6cd2206b5e57a81b467, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_301abfeda8d0b6cd2206b5e57a81b467,
        type_description_1,
        par_self,
        par_cert,
        par_key,
        par_type,
        par_days,
        par_digest,
        var_bio,
        var_sometime,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if ( frame_301abfeda8d0b6cd2206b5e57a81b467 == cache_frame_301abfeda8d0b6cd2206b5e57a81b467 )
    {
        Py_DECREF( frame_301abfeda8d0b6cd2206b5e57a81b467 );
    }
    cache_frame_301abfeda8d0b6cd2206b5e57a81b467 = NULL;

    assertFrameObject( frame_301abfeda8d0b6cd2206b5e57a81b467 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_121_export );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_days );
    Py_DECREF( par_days );
    par_days = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_sometime );
    Py_DECREF( var_sometime );
    var_sometime = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_days );
    Py_DECREF( par_days );
    par_days = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_sometime );
    var_sometime = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_121_export );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_122_type_is_signed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_298c62d2e62c4e7e7c771a8483b79517;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_298c62d2e62c4e7e7c771a8483b79517 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_298c62d2e62c4e7e7c771a8483b79517, codeobj_298c62d2e62c4e7e7c771a8483b79517, module_OpenSSL$crypto, sizeof(void *) );
    frame_298c62d2e62c4e7e7c771a8483b79517 = cache_frame_298c62d2e62c4e7e7c771a8483b79517;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_298c62d2e62c4e7e7c771a8483b79517 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_298c62d2e62c4e7e7c771a8483b79517 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_signed );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_298c62d2e62c4e7e7c771a8483b79517->m_frame.f_lineno = 2355;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_value_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_value_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_value_name_1 );
        Py_DECREF( tmp_value_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2355;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res != 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_298c62d2e62c4e7e7c771a8483b79517 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_298c62d2e62c4e7e7c771a8483b79517 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_298c62d2e62c4e7e7c771a8483b79517 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_298c62d2e62c4e7e7c771a8483b79517, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_298c62d2e62c4e7e7c771a8483b79517->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_298c62d2e62c4e7e7c771a8483b79517, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_298c62d2e62c4e7e7c771a8483b79517,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_298c62d2e62c4e7e7c771a8483b79517 == cache_frame_298c62d2e62c4e7e7c771a8483b79517 )
    {
        Py_DECREF( frame_298c62d2e62c4e7e7c771a8483b79517 );
    }
    cache_frame_298c62d2e62c4e7e7c771a8483b79517 = NULL;

    assertFrameObject( frame_298c62d2e62c4e7e7c771a8483b79517 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_122_type_is_signed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_122_type_is_signed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_123_type_is_enveloped( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_bb28aa15be6d6ac10ac98d4bd673db31;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_bb28aa15be6d6ac10ac98d4bd673db31 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bb28aa15be6d6ac10ac98d4bd673db31, codeobj_bb28aa15be6d6ac10ac98d4bd673db31, module_OpenSSL$crypto, sizeof(void *) );
    frame_bb28aa15be6d6ac10ac98d4bd673db31 = cache_frame_bb28aa15be6d6ac10ac98d4bd673db31;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bb28aa15be6d6ac10ac98d4bd673db31 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bb28aa15be6d6ac10ac98d4bd673db31 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_enveloped );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_bb28aa15be6d6ac10ac98d4bd673db31->m_frame.f_lineno = 2363;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_value_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_value_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_value_name_1 );
        Py_DECREF( tmp_value_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2363;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res != 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb28aa15be6d6ac10ac98d4bd673db31 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb28aa15be6d6ac10ac98d4bd673db31 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bb28aa15be6d6ac10ac98d4bd673db31 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bb28aa15be6d6ac10ac98d4bd673db31, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bb28aa15be6d6ac10ac98d4bd673db31->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bb28aa15be6d6ac10ac98d4bd673db31, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bb28aa15be6d6ac10ac98d4bd673db31,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_bb28aa15be6d6ac10ac98d4bd673db31 == cache_frame_bb28aa15be6d6ac10ac98d4bd673db31 )
    {
        Py_DECREF( frame_bb28aa15be6d6ac10ac98d4bd673db31 );
    }
    cache_frame_bb28aa15be6d6ac10ac98d4bd673db31 = NULL;

    assertFrameObject( frame_bb28aa15be6d6ac10ac98d4bd673db31 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_123_type_is_enveloped );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_123_type_is_enveloped );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_572d929a0f50dfeb4faf9840be0cf071;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_572d929a0f50dfeb4faf9840be0cf071 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_572d929a0f50dfeb4faf9840be0cf071, codeobj_572d929a0f50dfeb4faf9840be0cf071, module_OpenSSL$crypto, sizeof(void *) );
    frame_572d929a0f50dfeb4faf9840be0cf071 = cache_frame_572d929a0f50dfeb4faf9840be0cf071;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_572d929a0f50dfeb4faf9840be0cf071 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_572d929a0f50dfeb4faf9840be0cf071 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_signedAndEnveloped );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_572d929a0f50dfeb4faf9840be0cf071->m_frame.f_lineno = 2371;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_value_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_value_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_value_name_1 );
        Py_DECREF( tmp_value_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2371;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res != 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_572d929a0f50dfeb4faf9840be0cf071 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_572d929a0f50dfeb4faf9840be0cf071 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_572d929a0f50dfeb4faf9840be0cf071 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_572d929a0f50dfeb4faf9840be0cf071, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_572d929a0f50dfeb4faf9840be0cf071->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_572d929a0f50dfeb4faf9840be0cf071, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_572d929a0f50dfeb4faf9840be0cf071,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_572d929a0f50dfeb4faf9840be0cf071 == cache_frame_572d929a0f50dfeb4faf9840be0cf071 )
    {
        Py_DECREF( frame_572d929a0f50dfeb4faf9840be0cf071 );
    }
    cache_frame_572d929a0f50dfeb4faf9840be0cf071 = NULL;

    assertFrameObject( frame_572d929a0f50dfeb4faf9840be0cf071 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_125_type_is_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6488d3c4867ccfec75048bca1c93e024;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_6488d3c4867ccfec75048bca1c93e024 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6488d3c4867ccfec75048bca1c93e024, codeobj_6488d3c4867ccfec75048bca1c93e024, module_OpenSSL$crypto, sizeof(void *) );
    frame_6488d3c4867ccfec75048bca1c93e024 = cache_frame_6488d3c4867ccfec75048bca1c93e024;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6488d3c4867ccfec75048bca1c93e024 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6488d3c4867ccfec75048bca1c93e024 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_value_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PKCS7_type_is_data );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__pkcs7 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_6488d3c4867ccfec75048bca1c93e024->m_frame.f_lineno = 2379;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_value_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_value_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_value_name_1 );
        Py_DECREF( tmp_value_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2379;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res != 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6488d3c4867ccfec75048bca1c93e024 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6488d3c4867ccfec75048bca1c93e024 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6488d3c4867ccfec75048bca1c93e024 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6488d3c4867ccfec75048bca1c93e024, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6488d3c4867ccfec75048bca1c93e024->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6488d3c4867ccfec75048bca1c93e024, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6488d3c4867ccfec75048bca1c93e024,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6488d3c4867ccfec75048bca1c93e024 == cache_frame_6488d3c4867ccfec75048bca1c93e024 )
    {
        Py_DECREF( frame_6488d3c4867ccfec75048bca1c93e024 );
    }
    cache_frame_6488d3c4867ccfec75048bca1c93e024 = NULL;

    assertFrameObject( frame_6488d3c4867ccfec75048bca1c93e024 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_125_type_is_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_125_type_is_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_126_get_type_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_string_type = NULL;
    PyObject *var_nid = NULL;
    struct Nuitka_FrameObject *frame_96e0f2ade3ce600a5c007e498e0f3fcd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_96e0f2ade3ce600a5c007e498e0f3fcd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_96e0f2ade3ce600a5c007e498e0f3fcd, codeobj_96e0f2ade3ce600a5c007e498e0f3fcd, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_96e0f2ade3ce600a5c007e498e0f3fcd = cache_frame_96e0f2ade3ce600a5c007e498e0f3fcd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_96e0f2ade3ce600a5c007e498e0f3fcd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_96e0f2ade3ce600a5c007e498e0f3fcd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_OBJ_obj2nid );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkcs7 );
        if ( tmp_source_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_type );
        Py_DECREF( tmp_source_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_96e0f2ade3ce600a5c007e498e0f3fcd->m_frame.f_lineno = 2387;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2387;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_nid == NULL );
        var_nid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2388;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_nid );
        tmp_args_element_name_2 = var_nid;
        frame_96e0f2ade3ce600a5c007e498e0f3fcd->m_frame.f_lineno = 2388;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_OBJ_nid2sn, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2388;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_string_type == NULL );
        var_string_type = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2389;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_string_type );
        tmp_args_element_name_3 = var_string_type;
        frame_96e0f2ade3ce600a5c007e498e0f3fcd->m_frame.f_lineno = 2389;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_string, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2389;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_96e0f2ade3ce600a5c007e498e0f3fcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_96e0f2ade3ce600a5c007e498e0f3fcd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_96e0f2ade3ce600a5c007e498e0f3fcd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_96e0f2ade3ce600a5c007e498e0f3fcd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_96e0f2ade3ce600a5c007e498e0f3fcd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_96e0f2ade3ce600a5c007e498e0f3fcd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_96e0f2ade3ce600a5c007e498e0f3fcd,
        type_description_1,
        par_self,
        var_string_type,
        var_nid
    );


    // Release cached frame.
    if ( frame_96e0f2ade3ce600a5c007e498e0f3fcd == cache_frame_96e0f2ade3ce600a5c007e498e0f3fcd )
    {
        Py_DECREF( frame_96e0f2ade3ce600a5c007e498e0f3fcd );
    }
    cache_frame_96e0f2ade3ce600a5c007e498e0f3fcd = NULL;

    assertFrameObject( frame_96e0f2ade3ce600a5c007e498e0f3fcd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_126_get_type_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_string_type );
    Py_DECREF( var_string_type );
    var_string_type = NULL;

    CHECK_OBJECT( (PyObject *)var_nid );
    Py_DECREF( var_nid );
    var_nid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_string_type );
    var_string_type = NULL;

    Py_XDECREF( var_nid );
    var_nid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_126_get_type_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_127___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_a2c62897603cb5a7fc5a6b08caea1638;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a2c62897603cb5a7fc5a6b08caea1638 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a2c62897603cb5a7fc5a6b08caea1638, codeobj_a2c62897603cb5a7fc5a6b08caea1638, module_OpenSSL$crypto, sizeof(void *) );
    frame_a2c62897603cb5a7fc5a6b08caea1638 = cache_frame_a2c62897603cb5a7fc5a6b08caea1638;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a2c62897603cb5a7fc5a6b08caea1638 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a2c62897603cb5a7fc5a6b08caea1638 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2405;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__cert, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2406;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__cacerts, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2407;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__friendlyname, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2408;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a2c62897603cb5a7fc5a6b08caea1638 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a2c62897603cb5a7fc5a6b08caea1638 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a2c62897603cb5a7fc5a6b08caea1638, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a2c62897603cb5a7fc5a6b08caea1638->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a2c62897603cb5a7fc5a6b08caea1638, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a2c62897603cb5a7fc5a6b08caea1638,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a2c62897603cb5a7fc5a6b08caea1638 == cache_frame_a2c62897603cb5a7fc5a6b08caea1638 )
    {
        Py_DECREF( frame_a2c62897603cb5a7fc5a6b08caea1638 );
    }
    cache_frame_a2c62897603cb5a7fc5a6b08caea1638 = NULL;

    assertFrameObject( frame_a2c62897603cb5a7fc5a6b08caea1638 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_127___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_127___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_128_get_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_b54bdbd0210e46dca8f052dcb4a34ee3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b54bdbd0210e46dca8f052dcb4a34ee3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b54bdbd0210e46dca8f052dcb4a34ee3, codeobj_b54bdbd0210e46dca8f052dcb4a34ee3, module_OpenSSL$crypto, sizeof(void *) );
    frame_b54bdbd0210e46dca8f052dcb4a34ee3 = cache_frame_b54bdbd0210e46dca8f052dcb4a34ee3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b54bdbd0210e46dca8f052dcb4a34ee3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b54bdbd0210e46dca8f052dcb4a34ee3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cert );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2417;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b54bdbd0210e46dca8f052dcb4a34ee3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b54bdbd0210e46dca8f052dcb4a34ee3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b54bdbd0210e46dca8f052dcb4a34ee3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b54bdbd0210e46dca8f052dcb4a34ee3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b54bdbd0210e46dca8f052dcb4a34ee3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b54bdbd0210e46dca8f052dcb4a34ee3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b54bdbd0210e46dca8f052dcb4a34ee3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b54bdbd0210e46dca8f052dcb4a34ee3 == cache_frame_b54bdbd0210e46dca8f052dcb4a34ee3 )
    {
        Py_DECREF( frame_b54bdbd0210e46dca8f052dcb4a34ee3 );
    }
    cache_frame_b54bdbd0210e46dca8f052dcb4a34ee3 = NULL;

    assertFrameObject( frame_b54bdbd0210e46dca8f052dcb4a34ee3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_128_get_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_128_get_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_129_set_certificate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cert = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_9e5962b9332e672b73dffe75490da895;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_9e5962b9332e672b73dffe75490da895 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9e5962b9332e672b73dffe75490da895, codeobj_9e5962b9332e672b73dffe75490da895, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_9e5962b9332e672b73dffe75490da895 = cache_frame_9e5962b9332e672b73dffe75490da895;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9e5962b9332e672b73dffe75490da895 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9e5962b9332e672b73dffe75490da895 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cert );
        tmp_isinstance_inst_1 = par_cert;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 2428;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2428;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2428;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_c804b213c384a15865e18bf31cfff70e;
            frame_9e5962b9332e672b73dffe75490da895->m_frame.f_lineno = 2429;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2429;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_cert );
        tmp_assattr_name_1 = par_cert;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__cert, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9e5962b9332e672b73dffe75490da895 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9e5962b9332e672b73dffe75490da895 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9e5962b9332e672b73dffe75490da895, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9e5962b9332e672b73dffe75490da895->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9e5962b9332e672b73dffe75490da895, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9e5962b9332e672b73dffe75490da895,
        type_description_1,
        par_self,
        par_cert
    );


    // Release cached frame.
    if ( frame_9e5962b9332e672b73dffe75490da895 == cache_frame_9e5962b9332e672b73dffe75490da895 )
    {
        Py_DECREF( frame_9e5962b9332e672b73dffe75490da895 );
    }
    cache_frame_9e5962b9332e672b73dffe75490da895 = NULL;

    assertFrameObject( frame_9e5962b9332e672b73dffe75490da895 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_129_set_certificate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_129_set_certificate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_130_get_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d2db5d6448098f1cdeaafc369e0dd5e1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d2db5d6448098f1cdeaafc369e0dd5e1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d2db5d6448098f1cdeaafc369e0dd5e1, codeobj_d2db5d6448098f1cdeaafc369e0dd5e1, module_OpenSSL$crypto, sizeof(void *) );
    frame_d2db5d6448098f1cdeaafc369e0dd5e1 = cache_frame_d2db5d6448098f1cdeaafc369e0dd5e1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d2db5d6448098f1cdeaafc369e0dd5e1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d2db5d6448098f1cdeaafc369e0dd5e1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__pkey );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2439;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2db5d6448098f1cdeaafc369e0dd5e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2db5d6448098f1cdeaafc369e0dd5e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d2db5d6448098f1cdeaafc369e0dd5e1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d2db5d6448098f1cdeaafc369e0dd5e1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d2db5d6448098f1cdeaafc369e0dd5e1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d2db5d6448098f1cdeaafc369e0dd5e1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d2db5d6448098f1cdeaafc369e0dd5e1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d2db5d6448098f1cdeaafc369e0dd5e1 == cache_frame_d2db5d6448098f1cdeaafc369e0dd5e1 )
    {
        Py_DECREF( frame_d2db5d6448098f1cdeaafc369e0dd5e1 );
    }
    cache_frame_d2db5d6448098f1cdeaafc369e0dd5e1 = NULL;

    assertFrameObject( frame_d2db5d6448098f1cdeaafc369e0dd5e1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_130_get_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_130_get_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_131_set_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_06feef7fc51c36afe8e827ad79ecfbd2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_06feef7fc51c36afe8e827ad79ecfbd2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_06feef7fc51c36afe8e827ad79ecfbd2, codeobj_06feef7fc51c36afe8e827ad79ecfbd2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_06feef7fc51c36afe8e827ad79ecfbd2 = cache_frame_06feef7fc51c36afe8e827ad79ecfbd2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_06feef7fc51c36afe8e827ad79ecfbd2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_06feef7fc51c36afe8e827ad79ecfbd2 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_pkey );
        tmp_isinstance_inst_1 = par_pkey;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2450;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2450;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2450;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_499043b9b2da602637f07b1aa101ddfb;
            frame_06feef7fc51c36afe8e827ad79ecfbd2->m_frame.f_lineno = 2451;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2451;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_pkey );
        tmp_assattr_name_1 = par_pkey;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2452;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_06feef7fc51c36afe8e827ad79ecfbd2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_06feef7fc51c36afe8e827ad79ecfbd2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_06feef7fc51c36afe8e827ad79ecfbd2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_06feef7fc51c36afe8e827ad79ecfbd2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_06feef7fc51c36afe8e827ad79ecfbd2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_06feef7fc51c36afe8e827ad79ecfbd2,
        type_description_1,
        par_self,
        par_pkey
    );


    // Release cached frame.
    if ( frame_06feef7fc51c36afe8e827ad79ecfbd2 == cache_frame_06feef7fc51c36afe8e827ad79ecfbd2 )
    {
        Py_DECREF( frame_06feef7fc51c36afe8e827ad79ecfbd2 );
    }
    cache_frame_06feef7fc51c36afe8e827ad79ecfbd2 = NULL;

    assertFrameObject( frame_06feef7fc51c36afe8e827ad79ecfbd2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_131_set_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_131_set_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_132_get_ca_certificates( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8c372eaf0ec75aac95b57337ae37f3da;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8c372eaf0ec75aac95b57337ae37f3da = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8c372eaf0ec75aac95b57337ae37f3da, codeobj_8c372eaf0ec75aac95b57337ae37f3da, module_OpenSSL$crypto, sizeof(void *) );
    frame_8c372eaf0ec75aac95b57337ae37f3da = cache_frame_8c372eaf0ec75aac95b57337ae37f3da;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8c372eaf0ec75aac95b57337ae37f3da );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8c372eaf0ec75aac95b57337ae37f3da ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cacerts );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2462;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_tuple_arg_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_tuple_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__cacerts );
            if ( tmp_tuple_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2463;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PySequence_Tuple( tmp_tuple_arg_1 );
            Py_DECREF( tmp_tuple_arg_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2463;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8c372eaf0ec75aac95b57337ae37f3da );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8c372eaf0ec75aac95b57337ae37f3da );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8c372eaf0ec75aac95b57337ae37f3da );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8c372eaf0ec75aac95b57337ae37f3da, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8c372eaf0ec75aac95b57337ae37f3da->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8c372eaf0ec75aac95b57337ae37f3da, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8c372eaf0ec75aac95b57337ae37f3da,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_8c372eaf0ec75aac95b57337ae37f3da == cache_frame_8c372eaf0ec75aac95b57337ae37f3da )
    {
        Py_DECREF( frame_8c372eaf0ec75aac95b57337ae37f3da );
    }
    cache_frame_8c372eaf0ec75aac95b57337ae37f3da = NULL;

    assertFrameObject( frame_8c372eaf0ec75aac95b57337ae37f3da );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_132_get_ca_certificates );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_132_get_ca_certificates );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_133_set_ca_certificates( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cacerts = python_pars[ 1 ];
    PyObject *var_cert = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_5d7ca7a86f1a69e3c52554fdf475aba9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_5d7ca7a86f1a69e3c52554fdf475aba9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d7ca7a86f1a69e3c52554fdf475aba9, codeobj_5d7ca7a86f1a69e3c52554fdf475aba9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5d7ca7a86f1a69e3c52554fdf475aba9 = cache_frame_5d7ca7a86f1a69e3c52554fdf475aba9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d7ca7a86f1a69e3c52554fdf475aba9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d7ca7a86f1a69e3c52554fdf475aba9 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_cacerts );
        tmp_compexpr_left_1 = par_cacerts;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__cacerts, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2476;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_list_arg_1;
            CHECK_OBJECT( par_cacerts );
            tmp_list_arg_1 = par_cacerts;
            tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2478;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_cacerts;
                assert( old != NULL );
                par_cacerts = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_cacerts );
            tmp_iter_arg_1 = par_cacerts;
            tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2479;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_2;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooo";
                    exception_lineno = 2479;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_3;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_4 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_4;
                Py_INCREF( var_cert );
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( var_cert );
            tmp_isinstance_inst_1 = var_cert;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
                exception_tb = NULL;

                exception_lineno = 2480;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2480;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2480;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_1691c1bfd96a22cfc48aca410da45814;
                frame_5d7ca7a86f1a69e3c52554fdf475aba9->m_frame.f_lineno = 2481;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 2481;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            branch_no_2:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2479;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( par_cacerts );
            tmp_assattr_name_2 = par_cacerts;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__cacerts, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2484;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d7ca7a86f1a69e3c52554fdf475aba9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d7ca7a86f1a69e3c52554fdf475aba9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d7ca7a86f1a69e3c52554fdf475aba9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d7ca7a86f1a69e3c52554fdf475aba9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d7ca7a86f1a69e3c52554fdf475aba9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5d7ca7a86f1a69e3c52554fdf475aba9,
        type_description_1,
        par_self,
        par_cacerts,
        var_cert
    );


    // Release cached frame.
    if ( frame_5d7ca7a86f1a69e3c52554fdf475aba9 == cache_frame_5d7ca7a86f1a69e3c52554fdf475aba9 )
    {
        Py_DECREF( frame_5d7ca7a86f1a69e3c52554fdf475aba9 );
    }
    cache_frame_5d7ca7a86f1a69e3c52554fdf475aba9 = NULL;

    assertFrameObject( frame_5d7ca7a86f1a69e3c52554fdf475aba9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_133_set_ca_certificates );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cacerts );
    Py_DECREF( par_cacerts );
    par_cacerts = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_cacerts );
    Py_DECREF( par_cacerts );
    par_cacerts = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_133_set_ca_certificates );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_134_set_friendlyname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_43c017e77c6895e242ea62099ae753ac;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_43c017e77c6895e242ea62099ae753ac = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_43c017e77c6895e242ea62099ae753ac, codeobj_43c017e77c6895e242ea62099ae753ac, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_43c017e77c6895e242ea62099ae753ac = cache_frame_43c017e77c6895e242ea62099ae753ac;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_43c017e77c6895e242ea62099ae753ac );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_43c017e77c6895e242ea62099ae753ac ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_name );
        tmp_compexpr_left_1 = par_name;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__friendlyname, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2496;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            CHECK_OBJECT( par_name );
            tmp_isinstance_inst_1 = par_name;
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2497;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2497;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_1;
                tmp_left_name_1 = const_str_digest_d7980f3a0e05fb43bc9ed0fa0707a2f9;
                CHECK_OBJECT( par_name );
                tmp_tuple_element_1 = par_name;
                tmp_right_name_1 = PyTuple_New( 1 );
                Py_INCREF( tmp_tuple_element_1 );
                PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
                tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_make_exception_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2499;
                    type_description_1 = "oo";
                    goto frame_exception_exit_1;
                }
                frame_43c017e77c6895e242ea62099ae753ac->m_frame.f_lineno = 2498;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                }

                Py_DECREF( tmp_make_exception_arg_1 );
                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 2498;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_name );
        tmp_assattr_name_2 = par_name;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__friendlyname, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2501;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_43c017e77c6895e242ea62099ae753ac );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_43c017e77c6895e242ea62099ae753ac );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_43c017e77c6895e242ea62099ae753ac, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_43c017e77c6895e242ea62099ae753ac->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_43c017e77c6895e242ea62099ae753ac, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_43c017e77c6895e242ea62099ae753ac,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_43c017e77c6895e242ea62099ae753ac == cache_frame_43c017e77c6895e242ea62099ae753ac )
    {
        Py_DECREF( frame_43c017e77c6895e242ea62099ae753ac );
    }
    cache_frame_43c017e77c6895e242ea62099ae753ac = NULL;

    assertFrameObject( frame_43c017e77c6895e242ea62099ae753ac );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_134_set_friendlyname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_134_set_friendlyname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_135_get_friendlyname( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_b1465cc56b7c48e5a832bb947da5804f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b1465cc56b7c48e5a832bb947da5804f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b1465cc56b7c48e5a832bb947da5804f, codeobj_b1465cc56b7c48e5a832bb947da5804f, module_OpenSSL$crypto, sizeof(void *) );
    frame_b1465cc56b7c48e5a832bb947da5804f = cache_frame_b1465cc56b7c48e5a832bb947da5804f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b1465cc56b7c48e5a832bb947da5804f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b1465cc56b7c48e5a832bb947da5804f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__friendlyname );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2510;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b1465cc56b7c48e5a832bb947da5804f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b1465cc56b7c48e5a832bb947da5804f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b1465cc56b7c48e5a832bb947da5804f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b1465cc56b7c48e5a832bb947da5804f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b1465cc56b7c48e5a832bb947da5804f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b1465cc56b7c48e5a832bb947da5804f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b1465cc56b7c48e5a832bb947da5804f,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_b1465cc56b7c48e5a832bb947da5804f == cache_frame_b1465cc56b7c48e5a832bb947da5804f )
    {
        Py_DECREF( frame_b1465cc56b7c48e5a832bb947da5804f );
    }
    cache_frame_b1465cc56b7c48e5a832bb947da5804f = NULL;

    assertFrameObject( frame_b1465cc56b7c48e5a832bb947da5804f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_135_get_friendlyname );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_135_get_friendlyname );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_136_export( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_passphrase = python_pars[ 1 ];
    PyObject *par_iter = python_pars[ 2 ];
    PyObject *par_maciter = python_pars[ 3 ];
    PyObject *var_pkey = NULL;
    PyObject *var_bio = NULL;
    PyObject *var_cacerts = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_friendlyname = NULL;
    PyObject *var_pkcs12 = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_8a10d3a4b3ce5d07432c2f893bb983ea;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8a10d3a4b3ce5d07432c2f893bb983ea = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8a10d3a4b3ce5d07432c2f893bb983ea, codeobj_8a10d3a4b3ce5d07432c2f893bb983ea, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8a10d3a4b3ce5d07432c2f893bb983ea = cache_frame_8a10d3a4b3ce5d07432c2f893bb983ea;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8a10d3a4b3ce5d07432c2f893bb983ea );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8a10d3a4b3ce5d07432c2f893bb983ea ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 2532;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_passphrase;
        CHECK_OBJECT( par_passphrase );
        tmp_args_element_name_2 = par_passphrase;
        frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2532;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2532;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_passphrase;
            assert( old != NULL );
            par_passphrase = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__cacerts );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2534;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2535;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_2;
            tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2535;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_cacerts == NULL );
            var_cacerts = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_3;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2537;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_3;
            frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2537;
            tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_sk_X509_new_null );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2537;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_cacerts == NULL );
            var_cacerts = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_5;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_cacerts );
            tmp_args_element_name_3 = var_cacerts;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_5 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_5;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_sk_X509_free );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2538;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2538;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_cacerts;
                assert( old != NULL );
                var_cacerts = tmp_assign_source_4;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__cacerts );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2539;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2539;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_5;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_6 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooooooooo";
                    exception_lineno = 2539;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_6;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_7;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_7 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_7;
                Py_INCREF( var_cert );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_6;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_7;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_6 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }

            tmp_source_name_6 = tmp_mvar_value_6;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_sk_X509_push );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( var_cacerts );
            tmp_args_element_name_5 = var_cacerts;
            CHECK_OBJECT( var_cert );
            tmp_source_name_7 = var_cert;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__x509 );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }
            frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2540;
            {
                PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_6 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2540;
                type_description_1 = "oooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2539;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_passphrase );
        tmp_compexpr_left_2 = par_passphrase;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2543;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_8 = tmp_mvar_value_7;
            tmp_assign_source_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_NULL );
            if ( tmp_assign_source_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2543;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_passphrase;
                assert( old != NULL );
                par_passphrase = tmp_assign_source_8;
                Py_DECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_assign_source_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__friendlyname );
        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2545;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_friendlyname == NULL );
        var_friendlyname = tmp_assign_source_9;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( var_friendlyname );
        tmp_compexpr_left_3 = var_friendlyname;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_10;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_8;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2547;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_8;
            tmp_assign_source_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_NULL );
            if ( tmp_assign_source_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2547;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_friendlyname;
                assert( old != NULL );
                var_friendlyname = tmp_assign_source_10;
                Py_DECREF( old );
            }

        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_11;
        CHECK_OBJECT( par_self );
        tmp_source_name_11 = par_self;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__pkey );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2549;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_4 = Py_None;
        tmp_condition_result_4 = ( tmp_compexpr_left_4 == tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_4 );
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_11;
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_9;
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_9 == NULL ))
            {
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_9 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2550;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_12 = tmp_mvar_value_9;
            tmp_assign_source_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_NULL );
            if ( tmp_assign_source_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2550;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_pkey == NULL );
            var_pkey = tmp_assign_source_11;
        }
        goto branch_end_4;
        branch_no_4:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_source_name_13;
            PyObject *tmp_source_name_14;
            CHECK_OBJECT( par_self );
            tmp_source_name_14 = par_self;
            tmp_source_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__pkey );
            if ( tmp_source_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2552;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_12 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain__pkey );
            Py_DECREF( tmp_source_name_13 );
            if ( tmp_assign_source_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2552;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_pkey == NULL );
            var_pkey = tmp_assign_source_12;
        }
        branch_end_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_15;
        CHECK_OBJECT( par_self );
        tmp_source_name_15 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain__cert );
        if ( tmp_compexpr_left_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2554;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_5 = Py_None;
        tmp_condition_result_5 = ( tmp_compexpr_left_5 == tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_5 );
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_13;
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_10;
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_10 == NULL ))
            {
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_10 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2555;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_16 = tmp_mvar_value_10;
            tmp_assign_source_13 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_NULL );
            if ( tmp_assign_source_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2555;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_13;
                Py_XDECREF( old );
            }

        }
        goto branch_end_5;
        branch_no_5:;
        {
            PyObject *tmp_assign_source_14;
            PyObject *tmp_source_name_17;
            PyObject *tmp_source_name_18;
            CHECK_OBJECT( par_self );
            tmp_source_name_18 = par_self;
            tmp_source_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain__cert );
            if ( tmp_source_name_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2557;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_14 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain__x509 );
            Py_DECREF( tmp_source_name_17 );
            if ( tmp_assign_source_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2557;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_cert;
                var_cert = tmp_assign_source_14;
                Py_XDECREF( old );
            }

        }
        branch_end_5:;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_19;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_20;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_source_name_21;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_args_element_name_16;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2559;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_19 = tmp_mvar_value_11;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_PKCS12_create );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2559;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_passphrase );
        tmp_args_element_name_7 = par_passphrase;
        CHECK_OBJECT( var_friendlyname );
        tmp_args_element_name_8 = var_friendlyname;
        CHECK_OBJECT( var_pkey );
        tmp_args_element_name_9 = var_pkey;
        CHECK_OBJECT( var_cert );
        tmp_args_element_name_10 = var_cert;
        CHECK_OBJECT( var_cacerts );
        tmp_args_element_name_11 = var_cacerts;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_12 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2561;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_20 = tmp_mvar_value_12;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC );
        if ( tmp_args_element_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2561;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_13 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_12 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2562;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_21 = tmp_mvar_value_13;
        tmp_args_element_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_NID_pbe_WithSHA1And3_Key_TripleDES_CBC );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_12 );

            exception_lineno = 2562;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_iter );
        tmp_args_element_name_14 = par_iter;
        CHECK_OBJECT( par_maciter );
        tmp_args_element_name_15 = par_maciter;
        tmp_args_element_name_16 = const_int_0;
        frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2559;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12, tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16 };
            tmp_assign_source_15 = CALL_FUNCTION_WITH_ARGS10( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_12 );
        Py_DECREF( tmp_args_element_name_13 );
        if ( tmp_assign_source_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2559;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkcs12 == NULL );
        var_pkcs12 = tmp_assign_source_15;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_22;
        PyObject *tmp_mvar_value_14;
        CHECK_OBJECT( var_pkcs12 );
        tmp_compexpr_left_6 = var_pkcs12;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2564;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_22 = tmp_mvar_value_14;
        tmp_compexpr_right_6 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_NULL );
        if ( tmp_compexpr_right_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2564;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
        Py_DECREF( tmp_compexpr_right_6 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2564;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2565;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_15;
            frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2565;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_5 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2565;
                type_description_1 = "oooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_23;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_source_name_24;
        PyObject *tmp_mvar_value_17;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_23 = tmp_mvar_value_16;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_gc );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkcs12 );
        tmp_args_element_name_17 = var_pkcs12;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_17 == NULL ))
        {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_17 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_24 = tmp_mvar_value_17;
        tmp_args_element_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_PKCS12_free );
        if ( tmp_args_element_name_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2566;
        {
            PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18 };
            tmp_assign_source_16 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_18 );
        if ( tmp_assign_source_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2566;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_pkcs12;
            assert( old != NULL );
            var_pkcs12 = tmp_assign_source_16;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_called_name_7;
        PyObject *tmp_mvar_value_18;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_18 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2568;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_7 = tmp_mvar_value_18;
        frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2568;
        tmp_assign_source_17 = CALL_FUNCTION_NO_ARGS( tmp_called_name_7 );
        if ( tmp_assign_source_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2568;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_17;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_19;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2569;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_19;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_19 = var_bio;
        CHECK_OBJECT( var_pkcs12 );
        tmp_args_element_name_20 = var_pkcs12;
        frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2569;
        {
            PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_i2d_PKCS12_bio, call_args );
        }

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2569;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_mvar_value_20;
        PyObject *tmp_args_element_name_21;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_20 == NULL ))
        {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_20 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 2570;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_8 = tmp_mvar_value_20;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_21 = var_bio;
        frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame.f_lineno = 2570;
        {
            PyObject *call_args[] = { tmp_args_element_name_21 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2570;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a10d3a4b3ce5d07432c2f893bb983ea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a10d3a4b3ce5d07432c2f893bb983ea );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a10d3a4b3ce5d07432c2f893bb983ea );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8a10d3a4b3ce5d07432c2f893bb983ea, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8a10d3a4b3ce5d07432c2f893bb983ea->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8a10d3a4b3ce5d07432c2f893bb983ea, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8a10d3a4b3ce5d07432c2f893bb983ea,
        type_description_1,
        par_self,
        par_passphrase,
        par_iter,
        par_maciter,
        var_pkey,
        var_bio,
        var_cacerts,
        var_cert,
        var_friendlyname,
        var_pkcs12
    );


    // Release cached frame.
    if ( frame_8a10d3a4b3ce5d07432c2f893bb983ea == cache_frame_8a10d3a4b3ce5d07432c2f893bb983ea )
    {
        Py_DECREF( frame_8a10d3a4b3ce5d07432c2f893bb983ea );
    }
    cache_frame_8a10d3a4b3ce5d07432c2f893bb983ea = NULL;

    assertFrameObject( frame_8a10d3a4b3ce5d07432c2f893bb983ea );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_136_export );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_cacerts );
    Py_DECREF( var_cacerts );
    var_cacerts = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_maciter );
    Py_DECREF( par_maciter );
    par_maciter = NULL;

    CHECK_OBJECT( (PyObject *)par_iter );
    Py_DECREF( par_iter );
    par_iter = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)var_friendlyname );
    Py_DECREF( var_friendlyname );
    var_friendlyname = NULL;

    CHECK_OBJECT( (PyObject *)var_pkcs12 );
    Py_DECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_cacerts );
    var_cacerts = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)par_maciter );
    Py_DECREF( par_maciter );
    par_maciter = NULL;

    CHECK_OBJECT( (PyObject *)par_iter );
    Py_DECREF( par_iter );
    par_iter = NULL;

    Py_XDECREF( par_passphrase );
    par_passphrase = NULL;

    Py_XDECREF( var_friendlyname );
    var_friendlyname = NULL;

    Py_XDECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_136_export );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_137___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_spki = NULL;
    struct Nuitka_FrameObject *frame_9b9fe3cd704764cfc5a24bfccdf88473;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_9b9fe3cd704764cfc5a24bfccdf88473 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9b9fe3cd704764cfc5a24bfccdf88473, codeobj_9b9fe3cd704764cfc5a24bfccdf88473, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_9b9fe3cd704764cfc5a24bfccdf88473 = cache_frame_9b9fe3cd704764cfc5a24bfccdf88473;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9b9fe3cd704764cfc5a24bfccdf88473 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9b9fe3cd704764cfc5a24bfccdf88473 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2586;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_9b9fe3cd704764cfc5a24bfccdf88473->m_frame.f_lineno = 2586;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_NETSCAPE_SPKI_new );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2586;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_spki == NULL );
        var_spki = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_gc );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_spki );
        tmp_args_element_name_1 = var_spki;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NETSCAPE_SPKI_free );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_9b9fe3cd704764cfc5a24bfccdf88473->m_frame.f_lineno = 2587;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__spki, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2587;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b9fe3cd704764cfc5a24bfccdf88473 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9b9fe3cd704764cfc5a24bfccdf88473 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9b9fe3cd704764cfc5a24bfccdf88473, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9b9fe3cd704764cfc5a24bfccdf88473->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9b9fe3cd704764cfc5a24bfccdf88473, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b9fe3cd704764cfc5a24bfccdf88473,
        type_description_1,
        par_self,
        var_spki
    );


    // Release cached frame.
    if ( frame_9b9fe3cd704764cfc5a24bfccdf88473 == cache_frame_9b9fe3cd704764cfc5a24bfccdf88473 )
    {
        Py_DECREF( frame_9b9fe3cd704764cfc5a24bfccdf88473 );
    }
    cache_frame_9b9fe3cd704764cfc5a24bfccdf88473 = NULL;

    assertFrameObject( frame_9b9fe3cd704764cfc5a24bfccdf88473 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_137___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_spki );
    Py_DECREF( var_spki );
    var_spki = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_spki );
    var_spki = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_137___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_138_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_digest_obj = NULL;
    PyObject *var_sign_result = NULL;
    struct Nuitka_FrameObject *frame_f6c90cffa233150a81ae6bcf5966b415;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f6c90cffa233150a81ae6bcf5966b415 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f6c90cffa233150a81ae6bcf5966b415, codeobj_f6c90cffa233150a81ae6bcf5966b415, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f6c90cffa233150a81ae6bcf5966b415 = cache_frame_f6c90cffa233150a81ae6bcf5966b415;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f6c90cffa233150a81ae6bcf5966b415 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f6c90cffa233150a81ae6bcf5966b415 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_1 = par_pkey;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__only_public );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2601;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 2601;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_8aae826f04ca2a5df2a0de1a103a1f13;
            frame_f6c90cffa233150a81ae6bcf5966b415->m_frame.f_lineno = 2602;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2602;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_2 = par_pkey;
        tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__initialized );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2604;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2604;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_d84b19202bfdec9cc8e6f9577d4fac5e;
            frame_f6c90cffa233150a81ae6bcf5966b415->m_frame.f_lineno = 2605;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 2605;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_get_digestbyname );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( par_digest );
        tmp_args_element_name_2 = par_digest;
        frame_f6c90cffa233150a81ae6bcf5966b415->m_frame.f_lineno = 2607;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_f6c90cffa233150a81ae6bcf5966b415->m_frame.f_lineno = 2607;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2607;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest_obj == NULL );
        var_digest_obj = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_digest_obj );
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2608;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_3;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2608;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2608;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_3;
            PyObject *tmp_make_exception_arg_3;
            tmp_make_exception_arg_3 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_f6c90cffa233150a81ae6bcf5966b415->m_frame.f_lineno = 2609;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_3 };
                tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_3 == NULL) );
            exception_type = tmp_raise_type_3;
            exception_lineno = 2609;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_4;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NETSCAPE_SPKI_sign );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__spki );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 2612;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_3 );

            exception_lineno = 2612;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_digest_obj );
        tmp_args_element_name_5 = var_digest_obj;
        frame_f6c90cffa233150a81ae6bcf5966b415->m_frame.f_lineno = 2611;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2611;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_sign_result == NULL );
        var_sign_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2614;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_5;
        CHECK_OBJECT( var_sign_result );
        tmp_compexpr_left_2 = var_sign_result;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_6 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2614;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_f6c90cffa233150a81ae6bcf5966b415->m_frame.f_lineno = 2614;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2614;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6c90cffa233150a81ae6bcf5966b415 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6c90cffa233150a81ae6bcf5966b415 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f6c90cffa233150a81ae6bcf5966b415, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f6c90cffa233150a81ae6bcf5966b415->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f6c90cffa233150a81ae6bcf5966b415, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f6c90cffa233150a81ae6bcf5966b415,
        type_description_1,
        par_self,
        par_pkey,
        par_digest,
        var_digest_obj,
        var_sign_result
    );


    // Release cached frame.
    if ( frame_f6c90cffa233150a81ae6bcf5966b415 == cache_frame_f6c90cffa233150a81ae6bcf5966b415 )
    {
        Py_DECREF( frame_f6c90cffa233150a81ae6bcf5966b415 );
    }
    cache_frame_f6c90cffa233150a81ae6bcf5966b415 = NULL;

    assertFrameObject( frame_f6c90cffa233150a81ae6bcf5966b415 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_138_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_sign_result );
    Py_DECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_sign_result );
    var_sign_result = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_138_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_139_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *var_answer = NULL;
    struct Nuitka_FrameObject *frame_bcef8ad01db68d820609cb6453b5f512;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_bcef8ad01db68d820609cb6453b5f512 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bcef8ad01db68d820609cb6453b5f512, codeobj_bcef8ad01db68d820609cb6453b5f512, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_bcef8ad01db68d820609cb6453b5f512 = cache_frame_bcef8ad01db68d820609cb6453b5f512;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bcef8ad01db68d820609cb6453b5f512 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bcef8ad01db68d820609cb6453b5f512 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_verify );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__spki );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_key );
        tmp_source_name_3 = par_key;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_bcef8ad01db68d820609cb6453b5f512->m_frame.f_lineno = 2628;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2628;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_answer == NULL );
        var_answer = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_answer );
        tmp_compexpr_left_1 = var_answer;
        tmp_compexpr_right_1 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_LTE_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2629;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2630;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_2;
            frame_bcef8ad01db68d820609cb6453b5f512->m_frame.f_lineno = 2630;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2630;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bcef8ad01db68d820609cb6453b5f512 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bcef8ad01db68d820609cb6453b5f512 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bcef8ad01db68d820609cb6453b5f512, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bcef8ad01db68d820609cb6453b5f512->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bcef8ad01db68d820609cb6453b5f512, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bcef8ad01db68d820609cb6453b5f512,
        type_description_1,
        par_self,
        par_key,
        var_answer
    );


    // Release cached frame.
    if ( frame_bcef8ad01db68d820609cb6453b5f512 == cache_frame_bcef8ad01db68d820609cb6453b5f512 )
    {
        Py_DECREF( frame_bcef8ad01db68d820609cb6453b5f512 );
    }
    cache_frame_bcef8ad01db68d820609cb6453b5f512 = NULL;

    assertFrameObject( frame_bcef8ad01db68d820609cb6453b5f512 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_139_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_answer );
    Py_DECREF( var_answer );
    var_answer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_answer );
    var_answer = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_139_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_140_b64_encode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_encoded = NULL;
    PyObject *var_result = NULL;
    struct Nuitka_FrameObject *frame_36498b0149329ae65dad35a28b8821d9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_36498b0149329ae65dad35a28b8821d9 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_36498b0149329ae65dad35a28b8821d9, codeobj_36498b0149329ae65dad35a28b8821d9, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_36498b0149329ae65dad35a28b8821d9 = cache_frame_36498b0149329ae65dad35a28b8821d9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_36498b0149329ae65dad35a28b8821d9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_36498b0149329ae65dad35a28b8821d9 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_b64_encode );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__spki );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_36498b0149329ae65dad35a28b8821d9->m_frame.f_lineno = 2640;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2640;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_encoded == NULL );
        var_encoded = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2641;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_encoded );
        tmp_args_element_name_2 = var_encoded;
        frame_36498b0149329ae65dad35a28b8821d9->m_frame.f_lineno = 2641;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_string, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2641;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2642;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_encoded );
        tmp_args_element_name_3 = var_encoded;
        frame_36498b0149329ae65dad35a28b8821d9->m_frame.f_lineno = 2642;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_OPENSSL_free, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2642;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36498b0149329ae65dad35a28b8821d9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36498b0149329ae65dad35a28b8821d9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_36498b0149329ae65dad35a28b8821d9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_36498b0149329ae65dad35a28b8821d9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_36498b0149329ae65dad35a28b8821d9, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_36498b0149329ae65dad35a28b8821d9,
        type_description_1,
        par_self,
        var_encoded,
        var_result
    );


    // Release cached frame.
    if ( frame_36498b0149329ae65dad35a28b8821d9 == cache_frame_36498b0149329ae65dad35a28b8821d9 )
    {
        Py_DECREF( frame_36498b0149329ae65dad35a28b8821d9 );
    }
    cache_frame_36498b0149329ae65dad35a28b8821d9 = NULL;

    assertFrameObject( frame_36498b0149329ae65dad35a28b8821d9 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_140_b64_encode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_encoded );
    Py_DECREF( var_encoded );
    var_encoded = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_encoded );
    var_encoded = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_140_b64_encode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_141_get_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_pkey = NULL;
    struct Nuitka_FrameObject *frame_8b83c9708fea4b878e013c45136fd234;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_8b83c9708fea4b878e013c45136fd234 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8b83c9708fea4b878e013c45136fd234, codeobj_8b83c9708fea4b878e013c45136fd234, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_8b83c9708fea4b878e013c45136fd234 = cache_frame_8b83c9708fea4b878e013c45136fd234;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8b83c9708fea4b878e013c45136fd234 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8b83c9708fea4b878e013c45136fd234 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        frame_8b83c9708fea4b878e013c45136fd234->m_frame.f_lineno = 2652;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2652;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_3;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NETSCAPE_SPKI_get_pubkey );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__spki );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8b83c9708fea4b878e013c45136fd234->m_frame.f_lineno = 2653;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2653;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_4;
        CHECK_OBJECT( var_pkey );
        tmp_source_name_4 = var_pkey;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__pkey );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_1 );

            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8b83c9708fea4b878e013c45136fd234->m_frame.f_lineno = 2654;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2654;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_7;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_assattr_target_2;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_source_name_7 = var_pkey;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_7;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_PKEY_free );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_4 );

            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8b83c9708fea4b878e013c45136fd234->m_frame.f_lineno = 2655;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assattr_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2655;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_True;
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_3 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__only_public, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2656;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b83c9708fea4b878e013c45136fd234 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b83c9708fea4b878e013c45136fd234 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8b83c9708fea4b878e013c45136fd234, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8b83c9708fea4b878e013c45136fd234->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8b83c9708fea4b878e013c45136fd234, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8b83c9708fea4b878e013c45136fd234,
        type_description_1,
        par_self,
        var_pkey
    );


    // Release cached frame.
    if ( frame_8b83c9708fea4b878e013c45136fd234 == cache_frame_8b83c9708fea4b878e013c45136fd234 )
    {
        Py_DECREF( frame_8b83c9708fea4b878e013c45136fd234 );
    }
    cache_frame_8b83c9708fea4b878e013c45136fd234 = NULL;

    assertFrameObject( frame_8b83c9708fea4b878e013c45136fd234 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pkey );
    tmp_return_value = var_pkey;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_141_get_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_141_get_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_142_set_pubkey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_pkey = python_pars[ 1 ];
    PyObject *var_set_result = NULL;
    struct Nuitka_FrameObject *frame_a433b20a090f9b3cd7a05e3cc8726b20;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a433b20a090f9b3cd7a05e3cc8726b20 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a433b20a090f9b3cd7a05e3cc8726b20, codeobj_a433b20a090f9b3cd7a05e3cc8726b20, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a433b20a090f9b3cd7a05e3cc8726b20 = cache_frame_a433b20a090f9b3cd7a05e3cc8726b20;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a433b20a090f9b3cd7a05e3cc8726b20 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a433b20a090f9b3cd7a05e3cc8726b20 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NETSCAPE_SPKI_set_pubkey );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__spki );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_3 = par_pkey;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__pkey );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );

            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a433b20a090f9b3cd7a05e3cc8726b20->m_frame.f_lineno = 2666;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_set_result == NULL );
        var_set_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2667;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_2;
        CHECK_OBJECT( var_set_result );
        tmp_compexpr_left_1 = var_set_result;
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_args_element_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2667;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a433b20a090f9b3cd7a05e3cc8726b20->m_frame.f_lineno = 2667;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2667;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a433b20a090f9b3cd7a05e3cc8726b20 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a433b20a090f9b3cd7a05e3cc8726b20 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a433b20a090f9b3cd7a05e3cc8726b20, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a433b20a090f9b3cd7a05e3cc8726b20->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a433b20a090f9b3cd7a05e3cc8726b20, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a433b20a090f9b3cd7a05e3cc8726b20,
        type_description_1,
        par_self,
        par_pkey,
        var_set_result
    );


    // Release cached frame.
    if ( frame_a433b20a090f9b3cd7a05e3cc8726b20 == cache_frame_a433b20a090f9b3cd7a05e3cc8726b20 )
    {
        Py_DECREF( frame_a433b20a090f9b3cd7a05e3cc8726b20 );
    }
    cache_frame_a433b20a090f9b3cd7a05e3cc8726b20 = NULL;

    assertFrameObject( frame_a433b20a090f9b3cd7a05e3cc8726b20 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_142_set_pubkey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_set_result );
    Py_DECREF( var_set_result );
    var_set_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_set_result );
    var_set_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_142_set_pubkey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_143___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_type = python_pars[ 1 ];
    PyObject *par_passphrase = python_pars[ 2 ];
    PyObject *par_more_args = python_pars[ 3 ];
    PyObject *par_truncate = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_d964ee3167a18a9a588e49cbd6499968;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_d964ee3167a18a9a588e49cbd6499968 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d964ee3167a18a9a588e49cbd6499968, codeobj_d964ee3167a18a9a588e49cbd6499968, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d964ee3167a18a9a588e49cbd6499968 = cache_frame_d964ee3167a18a9a588e49cbd6499968;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d964ee3167a18a9a588e49cbd6499968 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d964ee3167a18a9a588e49cbd6499968 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 2679;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2679;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_passphrase );
        tmp_compexpr_left_2 = par_passphrase;
        tmp_compexpr_right_2 = Py_None;
        tmp_and_right_value_1 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d546905f9a7fd3b3fc24a90a7432aa72;
            frame_d964ee3167a18a9a588e49cbd6499968->m_frame.f_lineno = 2680;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2680;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_passphrase );
        tmp_assattr_name_1 = par_passphrase;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__passphrase, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2683;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_more_args );
        tmp_assattr_name_2 = par_more_args;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__more_args, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2684;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_truncate );
        tmp_assattr_name_3 = par_truncate;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__truncate, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2685;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = PyList_New( 0 );
        CHECK_OBJECT( par_self );
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__problems, tmp_assattr_name_4 );
        Py_DECREF( tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2686;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d964ee3167a18a9a588e49cbd6499968 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d964ee3167a18a9a588e49cbd6499968 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d964ee3167a18a9a588e49cbd6499968, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d964ee3167a18a9a588e49cbd6499968->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d964ee3167a18a9a588e49cbd6499968, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d964ee3167a18a9a588e49cbd6499968,
        type_description_1,
        par_self,
        par_type,
        par_passphrase,
        par_more_args,
        par_truncate
    );


    // Release cached frame.
    if ( frame_d964ee3167a18a9a588e49cbd6499968 == cache_frame_d964ee3167a18a9a588e49cbd6499968 )
    {
        Py_DECREF( frame_d964ee3167a18a9a588e49cbd6499968 );
    }
    cache_frame_d964ee3167a18a9a588e49cbd6499968 = NULL;

    assertFrameObject( frame_d964ee3167a18a9a588e49cbd6499968 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_143___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_more_args );
    Py_DECREF( par_more_args );
    par_more_args = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_truncate );
    Py_DECREF( par_truncate );
    par_truncate = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_more_args );
    Py_DECREF( par_more_args );
    par_more_args = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_truncate );
    Py_DECREF( par_truncate );
    par_truncate = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_143___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_144_callback( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_174bb49227fddc62e7f6e6dd1564c881;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_174bb49227fddc62e7f6e6dd1564c881 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_174bb49227fddc62e7f6e6dd1564c881, codeobj_174bb49227fddc62e7f6e6dd1564c881, module_OpenSSL$crypto, sizeof(void *) );
    frame_174bb49227fddc62e7f6e6dd1564c881 = cache_frame_174bb49227fddc62e7f6e6dd1564c881;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_174bb49227fddc62e7f6e6dd1564c881 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_174bb49227fddc62e7f6e6dd1564c881 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2690;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2691;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_1;
            tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2691;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__passphrase );
            if ( tmp_isinstance_inst_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2692;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            Py_DECREF( tmp_isinstance_inst_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2692;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_source_name_4;
                PyObject *tmp_mvar_value_2;
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_2 == NULL ))
                {
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_2 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2693;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_4 = tmp_mvar_value_2;
                tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2693;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_called_name_1;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_1;
                PyObject *tmp_source_name_5;
                int tmp_truth_name_1;
                tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
                assert( tmp_called_name_1 != NULL );
                CHECK_OBJECT( par_self );
                tmp_source_name_5 = par_self;
                tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__passphrase );
                if ( tmp_args_element_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2694;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                frame_174bb49227fddc62e7f6e6dd1564c881->m_frame.f_lineno = 2694;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1 };
                    tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_args_element_name_1 );
                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2694;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
                if ( tmp_truth_name_1 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_call_result_1 );

                    exception_lineno = 2694;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_call_result_1 );
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_mvar_value_3;
                    PyObject *tmp_args_element_name_2;
                    PyObject *tmp_args_element_name_3;
                    PyObject *tmp_source_name_7;
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                    if (unlikely( tmp_mvar_value_3 == NULL ))
                    {
                        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                    }

                    if ( tmp_mvar_value_3 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                        exception_tb = NULL;

                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_6 = tmp_mvar_value_3;
                    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_callback );
                    if ( tmp_called_name_2 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_2 = const_str_plain_pem_password_cb;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_7 = par_self;
                    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__read_passphrase );
                    if ( tmp_args_element_name_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_2 );

                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    frame_174bb49227fddc62e7f6e6dd1564c881->m_frame.f_lineno = 2695;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
                    }

                    Py_DECREF( tmp_called_name_2 );
                    Py_DECREF( tmp_args_element_name_3 );
                    if ( tmp_return_value == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2695;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    goto frame_return_exit_1;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_7db2dd03172a07cae912434bb4ced82e;
                    frame_174bb49227fddc62e7f6e6dd1564c881->m_frame.f_lineno = 2697;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                    }

                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2697;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_174bb49227fddc62e7f6e6dd1564c881 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_174bb49227fddc62e7f6e6dd1564c881 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_174bb49227fddc62e7f6e6dd1564c881 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_174bb49227fddc62e7f6e6dd1564c881, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_174bb49227fddc62e7f6e6dd1564c881->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_174bb49227fddc62e7f6e6dd1564c881, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_174bb49227fddc62e7f6e6dd1564c881,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_174bb49227fddc62e7f6e6dd1564c881 == cache_frame_174bb49227fddc62e7f6e6dd1564c881 )
    {
        Py_DECREF( frame_174bb49227fddc62e7f6e6dd1564c881 );
    }
    cache_frame_174bb49227fddc62e7f6e6dd1564c881 = NULL;

    assertFrameObject( frame_174bb49227fddc62e7f6e6dd1564c881 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_144_callback );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_144_callback );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_145_callback_args( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_2c29d90d26933595e91a312e32e549af;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2c29d90d26933595e91a312e32e549af = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2c29d90d26933595e91a312e32e549af, codeobj_2c29d90d26933595e91a312e32e549af, module_OpenSSL$crypto, sizeof(void *) );
    frame_2c29d90d26933595e91a312e32e549af = cache_frame_2c29d90d26933595e91a312e32e549af;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2c29d90d26933595e91a312e32e549af );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2c29d90d26933595e91a312e32e549af ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__passphrase );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2703;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2704;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_1;
            tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2704;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__passphrase );
            if ( tmp_isinstance_inst_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2705;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            Py_DECREF( tmp_isinstance_inst_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2705;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_source_name_4;
                CHECK_OBJECT( par_self );
                tmp_source_name_4 = par_self;
                tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__passphrase );
                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2706;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_called_name_1;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_1;
                PyObject *tmp_source_name_5;
                int tmp_truth_name_1;
                tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_callable );
                assert( tmp_called_name_1 != NULL );
                CHECK_OBJECT( par_self );
                tmp_source_name_5 = par_self;
                tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__passphrase );
                if ( tmp_args_element_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2707;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                frame_2c29d90d26933595e91a312e32e549af->m_frame.f_lineno = 2707;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1 };
                    tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_args_element_name_1 );
                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2707;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
                if ( tmp_truth_name_1 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_call_result_1 );

                    exception_lineno = 2707;
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_call_result_1 );
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_mvar_value_2;
                    tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                    if (unlikely( tmp_mvar_value_2 == NULL ))
                    {
                        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                    }

                    if ( tmp_mvar_value_2 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                        exception_tb = NULL;

                        exception_lineno = 2708;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_6 = tmp_mvar_value_2;
                    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
                    if ( tmp_return_value == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2708;
                        type_description_1 = "o";
                        goto frame_exception_exit_1;
                    }
                    goto frame_return_exit_1;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_7db2dd03172a07cae912434bb4ced82e;
                    frame_2c29d90d26933595e91a312e32e549af->m_frame.f_lineno = 2710;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
                    }

                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2710;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "o";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2c29d90d26933595e91a312e32e549af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2c29d90d26933595e91a312e32e549af );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2c29d90d26933595e91a312e32e549af );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2c29d90d26933595e91a312e32e549af, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2c29d90d26933595e91a312e32e549af->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2c29d90d26933595e91a312e32e549af, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2c29d90d26933595e91a312e32e549af,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_2c29d90d26933595e91a312e32e549af == cache_frame_2c29d90d26933595e91a312e32e549af )
    {
        Py_DECREF( frame_2c29d90d26933595e91a312e32e549af );
    }
    cache_frame_2c29d90d26933595e91a312e32e549af = NULL;

    assertFrameObject( frame_2c29d90d26933595e91a312e32e549af );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_145_callback_args );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_145_callback_args );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_146_raise_if_problem( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exceptionType = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_7b59db8d8529b0892574d3e63b0668e4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_7b59db8d8529b0892574d3e63b0668e4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7b59db8d8529b0892574d3e63b0668e4, codeobj_7b59db8d8529b0892574d3e63b0668e4, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *) );
    frame_7b59db8d8529b0892574d3e63b0668e4 = cache_frame_7b59db8d8529b0892574d3e63b0668e4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7b59db8d8529b0892574d3e63b0668e4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7b59db8d8529b0892574d3e63b0668e4 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__problems );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2715;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 2715;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        // Tried code:
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_exception_from_error_queue" );
                exception_tb = NULL;

                exception_lineno = 2719;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }

            tmp_called_name_1 = tmp_mvar_value_1;
            CHECK_OBJECT( par_exceptionType );
            tmp_args_element_name_1 = par_exceptionType;
            frame_7b59db8d8529b0892574d3e63b0668e4->m_frame.f_lineno = 2719;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2719;
                type_description_1 = "oo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Preserve existing published exception.
        PRESERVE_FRAME_EXCEPTION( frame_7b59db8d8529b0892574d3e63b0668e4 );
        if ( exception_keeper_tb_1 == NULL )
        {
            exception_keeper_tb_1 = MAKE_TRACEBACK( frame_7b59db8d8529b0892574d3e63b0668e4, exception_keeper_lineno_1 );
        }
        else if ( exception_keeper_lineno_1 != 0 )
        {
            exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_7b59db8d8529b0892574d3e63b0668e4, exception_keeper_lineno_1 );
        }

        NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
            CHECK_OBJECT( par_exceptionType );
            tmp_compexpr_right_1 = par_exceptionType;
            tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2720;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2720;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            if (unlikely( tmp_result == false ))
            {
                exception_lineno = 2718;
            }

            if (exception_tb && exception_tb->tb_frame == &frame_7b59db8d8529b0892574d3e63b0668e4->m_frame) frame_7b59db8d8529b0892574d3e63b0668e4->m_frame.f_lineno = exception_tb->tb_lineno;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
            branch_no_2:;
        }
        goto try_end_1;
        // exception handler codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_146_raise_if_problem );
        return NULL;
        // End of try:
        try_end_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__problems );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2723;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_7b59db8d8529b0892574d3e63b0668e4->m_frame.f_lineno = 2723;
            tmp_raise_type_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_pop, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_raise_type_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2723;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            exception_type = tmp_raise_type_1;
            exception_lineno = 2723;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_7b59db8d8529b0892574d3e63b0668e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_7b59db8d8529b0892574d3e63b0668e4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7b59db8d8529b0892574d3e63b0668e4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7b59db8d8529b0892574d3e63b0668e4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7b59db8d8529b0892574d3e63b0668e4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7b59db8d8529b0892574d3e63b0668e4,
        type_description_1,
        par_self,
        par_exceptionType
    );


    // Release cached frame.
    if ( frame_7b59db8d8529b0892574d3e63b0668e4 == cache_frame_7b59db8d8529b0892574d3e63b0668e4 )
    {
        Py_DECREF( frame_7b59db8d8529b0892574d3e63b0668e4 );
    }
    cache_frame_7b59db8d8529b0892574d3e63b0668e4 = NULL;

    assertFrameObject( frame_7b59db8d8529b0892574d3e63b0668e4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_146_raise_if_problem );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exceptionType );
    Py_DECREF( par_exceptionType );
    par_exceptionType = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exceptionType );
    Py_DECREF( par_exceptionType );
    par_exceptionType = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_146_raise_if_problem );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_147__read_passphrase( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_buf = python_pars[ 1 ];
    PyObject *par_size = python_pars[ 2 ];
    PyObject *par_rwflag = python_pars[ 3 ];
    PyObject *par_userdata = python_pars[ 4 ];
    PyObject *var_e = NULL;
    PyObject *var_i = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_3ee8a1e08a2e2b1ed44dccfa5075f32a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_3ee8a1e08a2e2b1ed44dccfa5075f32a = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ee8a1e08a2e2b1ed44dccfa5075f32a, codeobj_3ee8a1e08a2e2b1ed44dccfa5075f32a, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3ee8a1e08a2e2b1ed44dccfa5075f32a = cache_frame_3ee8a1e08a2e2b1ed44dccfa5075f32a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__more_args );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2727;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 2727;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_size );
            tmp_args_element_name_1 = par_size;
            CHECK_OBJECT( par_rwflag );
            tmp_args_element_name_2 = par_rwflag;
            CHECK_OBJECT( par_userdata );
            tmp_args_element_name_3 = par_userdata;
            frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame.f_lineno = 2728;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain__passphrase, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2728;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            assert( var_result == NULL );
            var_result = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( par_rwflag );
            tmp_args_element_name_4 = par_rwflag;
            frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame.f_lineno = 2730;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain__passphrase, call_args );
            }

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2730;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            assert( var_result == NULL );
            var_result = tmp_assign_source_2;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( var_result );
        tmp_isinstance_inst_1 = var_result;
        tmp_isinstance_cls_1 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2731;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2731;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_7338acfc5a3b91c07965b6befadc8c7a;
            frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame.f_lineno = 2732;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2732;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        CHECK_OBJECT( var_result );
        tmp_len_arg_1 = var_result;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2733;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( par_size );
        tmp_compexpr_right_1 = par_size;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2733;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_source_name_2;
            PyObject *tmp_attribute_value_2;
            int tmp_truth_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_attribute_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__truncate );
            if ( tmp_attribute_value_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2734;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            tmp_truth_name_2 = CHECK_IF_TRUE( tmp_attribute_value_2 );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_attribute_value_2 );

                exception_lineno = 2734;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_4 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_attribute_value_2 );
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_slice_source_1;
                PyObject *tmp_slice_upper_1;
                CHECK_OBJECT( var_result );
                tmp_slice_source_1 = var_result;
                CHECK_OBJECT( par_size );
                tmp_slice_upper_1 = par_size;
                tmp_assign_source_3 = LOOKUP_SLICE( tmp_slice_source_1, Py_None, tmp_slice_upper_1 );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2735;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_2;
                }
                {
                    PyObject *old = var_result;
                    assert( old != NULL );
                    var_result = tmp_assign_source_3;
                    Py_DECREF( old );
                }

            }
            goto branch_end_4;
            branch_no_4:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_make_exception_arg_2;
                tmp_make_exception_arg_2 = const_str_digest_9cb57ebafd0926d1746d2e66a6198efe;
                frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame.f_lineno = 2737;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_2 };
                    tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_2 == NULL) );
                exception_type = tmp_raise_type_2;
                exception_lineno = 2737;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            branch_end_4:;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_len_arg_2;
        if ( var_result == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
            exception_tb = NULL;

            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_len_arg_2 = var_result;
        tmp_range_arg_1 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2740;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                exception_lineno = 2740;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_6;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_slice_source_2;
        PyObject *tmp_slice_lower_1;
        PyObject *tmp_slice_upper_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        if ( var_result == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
            exception_tb = NULL;

            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }

        tmp_slice_source_2 = var_result;
        CHECK_OBJECT( var_i );
        tmp_slice_lower_1 = var_i;
        CHECK_OBJECT( var_i );
        tmp_left_name_1 = var_i;
        tmp_right_name_1 = const_int_pos_1;
        tmp_slice_upper_2 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_slice_upper_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_ass_subvalue_1 = LOOKUP_SLICE( tmp_slice_source_2, tmp_slice_lower_1, tmp_slice_upper_2 );
        Py_DECREF( tmp_slice_upper_2 );
        if ( tmp_ass_subvalue_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( par_buf );
        tmp_ass_subscribed_1 = par_buf;
        CHECK_OBJECT( var_i );
        tmp_ass_subscript_1 = var_i;
        tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subvalue_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2741;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 2740;
        type_description_1 = "oooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_len_arg_3;
        if ( var_result == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
            exception_tb = NULL;

            exception_lineno = 2742;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_len_arg_3 = var_result;
        tmp_return_value = BUILTIN_LEN( tmp_len_arg_3 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2742;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        goto frame_return_exit_1;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_147__read_passphrase );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_3ee8a1e08a2e2b1ed44dccfa5075f32a, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_Exception;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2743;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = EXC_VALUE(PyThreadState_GET());
            assert( var_e == NULL );
            Py_INCREF( tmp_assign_source_7 );
            var_e = tmp_assign_source_7;
        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_source_name_3;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__problems );
            if ( tmp_called_instance_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2744;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_e );
            tmp_args_element_name_5 = var_e;
            frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame.f_lineno = 2744;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_append, call_args );
            }

            Py_DECREF( tmp_called_instance_3 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2744;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        tmp_return_value = const_int_0;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_5;
        branch_no_5:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 2726;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame) frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooo";
        goto frame_exception_exit_1;
        branch_end_5:;
    }
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ee8a1e08a2e2b1ed44dccfa5075f32a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ee8a1e08a2e2b1ed44dccfa5075f32a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3ee8a1e08a2e2b1ed44dccfa5075f32a,
        type_description_1,
        par_self,
        par_buf,
        par_size,
        par_rwflag,
        par_userdata,
        var_e,
        var_i,
        var_result
    );


    // Release cached frame.
    if ( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a == cache_frame_3ee8a1e08a2e2b1ed44dccfa5075f32a )
    {
        Py_DECREF( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a );
    }
    cache_frame_3ee8a1e08a2e2b1ed44dccfa5075f32a = NULL;

    assertFrameObject( frame_3ee8a1e08a2e2b1ed44dccfa5075f32a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_147__read_passphrase );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_rwflag );
    Py_DECREF( par_rwflag );
    par_rwflag = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_userdata );
    Py_DECREF( par_userdata );
    par_userdata = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    CHECK_OBJECT( (PyObject *)par_rwflag );
    Py_DECREF( par_rwflag );
    par_rwflag = NULL;

    CHECK_OBJECT( (PyObject *)par_buf );
    Py_DECREF( par_buf );
    par_buf = NULL;

    CHECK_OBJECT( (PyObject *)par_size );
    Py_DECREF( par_size );
    par_size = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_147__read_passphrase );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_148_load_publickey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_evp_pkey = NULL;
    struct Nuitka_FrameObject *frame_0dfc2596049ebde55e199985efd3a197;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_0dfc2596049ebde55e199985efd3a197 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0dfc2596049ebde55e199985efd3a197, codeobj_0dfc2596049ebde55e199985efd3a197, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0dfc2596049ebde55e199985efd3a197 = cache_frame_0dfc2596049ebde55e199985efd3a197;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0dfc2596049ebde55e199985efd3a197 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0dfc2596049ebde55e199985efd3a197 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_buffer );
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 2759;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2759;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buffer );
            tmp_called_instance_1 = par_buffer;
            frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2760;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2760;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert( old != NULL );
                par_buffer = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2762;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_buffer );
        tmp_args_element_name_1 = par_buffer;
        frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2762;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2762;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 2764;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2764;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2765;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_PUBKEY );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2765;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_5 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_7 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );

                exception_lineno = 2766;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2765;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2765;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_evp_pkey == NULL );
            var_evp_pkey = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 2767;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2767;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_9 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_PUBKEY_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_10 == NULL ))
                {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_10 == NULL )
                {
                    Py_DECREF( tmp_called_name_3 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
                if ( tmp_args_element_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2768;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2768;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_evp_pkey == NULL );
                var_evp_pkey = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2770;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 2770;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if ( var_evp_pkey == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
            exception_tb = NULL;

            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_evp_pkey;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2772;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2773;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2773;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2773;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_14 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = tmp_mvar_value_14;
        frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2775;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2775;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if ( var_evp_pkey == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
            exception_tb = NULL;

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = var_evp_pkey;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_16 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_EVP_PKEY_free );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_0dfc2596049ebde55e199985efd3a197->m_frame.f_lineno = 2776;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2776;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        tmp_assattr_name_2 = Py_True;
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_2 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__only_public, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2777;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dfc2596049ebde55e199985efd3a197 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0dfc2596049ebde55e199985efd3a197 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0dfc2596049ebde55e199985efd3a197, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0dfc2596049ebde55e199985efd3a197->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0dfc2596049ebde55e199985efd3a197, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0dfc2596049ebde55e199985efd3a197,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_pkey,
        var_evp_pkey
    );


    // Release cached frame.
    if ( frame_0dfc2596049ebde55e199985efd3a197 == cache_frame_0dfc2596049ebde55e199985efd3a197 )
    {
        Py_DECREF( frame_0dfc2596049ebde55e199985efd3a197 );
    }
    cache_frame_0dfc2596049ebde55e199985efd3a197 = NULL;

    assertFrameObject( frame_0dfc2596049ebde55e199985efd3a197 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pkey );
    tmp_return_value = var_pkey;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_148_load_publickey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_148_load_publickey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_149_load_privatekey( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *par_passphrase = python_pars[ 2 ];
    PyObject *var_bio = NULL;
    PyObject *var_helper = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_evp_pkey = NULL;
    struct Nuitka_FrameObject *frame_3cc7e9e47e498ec30d4ee192b216714d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_3cc7e9e47e498ec30d4ee192b216714d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3cc7e9e47e498ec30d4ee192b216714d, codeobj_3cc7e9e47e498ec30d4ee192b216714d, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3cc7e9e47e498ec30d4ee192b216714d = cache_frame_3cc7e9e47e498ec30d4ee192b216714d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3cc7e9e47e498ec30d4ee192b216714d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3cc7e9e47e498ec30d4ee192b216714d ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_buffer );
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 2794;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2794;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buffer );
            tmp_called_instance_1 = par_buffer;
            frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2795;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2795;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert( old != NULL );
                par_buffer = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2797;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_buffer );
        tmp_args_element_name_1 = par_buffer;
        frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2797;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2797;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PassphraseHelper );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_PassphraseHelper" );
            exception_tb = NULL;

            exception_lineno = 2799;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( par_type );
        tmp_args_element_name_2 = par_type;
        CHECK_OBJECT( par_passphrase );
        tmp_args_element_name_3 = par_passphrase;
        frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2799;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2799;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_helper == NULL );
        var_helper = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 2800;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_4;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2800;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_source_name_4;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2801;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_5;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_PrivateKey );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2801;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_4 = var_bio;
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_6;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_helper );
            tmp_source_name_3 = var_helper;
            tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_callback );
            if ( tmp_args_element_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_5 );

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_helper );
            tmp_source_name_4 = var_helper;
            tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_callback_args );
            if ( tmp_args_element_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_5 );
                Py_DECREF( tmp_args_element_name_6 );

                exception_lineno = 2802;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2801;
            {
                PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
                tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_5 );
            Py_DECREF( tmp_args_element_name_6 );
            Py_DECREF( tmp_args_element_name_7 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2801;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_evp_pkey == NULL );
            var_evp_pkey = tmp_assign_source_4;
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_1;
            CHECK_OBJECT( var_helper );
            tmp_called_instance_2 = var_helper;
            frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2803;
            tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_raise_if_problem );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2803;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_7;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 2804;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_7;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2804;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_5;
                PyObject *tmp_called_name_4;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_8;
                PyObject *tmp_args_element_name_8;
                PyObject *tmp_args_element_name_9;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_9;
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_8 == NULL ))
                {
                    tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_8 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_8;
                tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_PrivateKey_bio );
                if ( tmp_called_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_8 = var_bio;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_9 == NULL )
                {
                    Py_DECREF( tmp_called_name_4 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_9;
                tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
                if ( tmp_args_element_name_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_4 );

                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2805;
                {
                    PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
                    tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
                }

                Py_DECREF( tmp_called_name_4 );
                Py_DECREF( tmp_args_element_name_9 );
                if ( tmp_assign_source_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2805;
                    type_description_1 = "ooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_evp_pkey == NULL );
                var_evp_pkey = tmp_assign_source_5;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2807;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 2807;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_10;
        if ( var_evp_pkey == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
            exception_tb = NULL;

            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_evp_pkey;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_10;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2809;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_5;
            PyObject *tmp_mvar_value_11;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_11 == NULL ))
            {
                tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_11 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2810;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_5 = tmp_mvar_value_11;
            frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2810;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_5 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2810;
                type_description_1 = "ooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_12;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_13 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_10 = tmp_mvar_value_13;
        frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2812;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2812;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_14;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        if ( var_evp_pkey == NULL )
        {
            Py_DECREF( tmp_called_name_7 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "evp_pkey" );
            exception_tb = NULL;

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_11 = var_evp_pkey;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_15 == NULL )
        {
            Py_DECREF( tmp_called_name_7 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_15;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_EVP_PKEY_free );
        if ( tmp_args_element_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame.f_lineno = 2813;
        {
            PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_12 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_assattr_target_1 = var_pkey;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2813;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3cc7e9e47e498ec30d4ee192b216714d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3cc7e9e47e498ec30d4ee192b216714d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3cc7e9e47e498ec30d4ee192b216714d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3cc7e9e47e498ec30d4ee192b216714d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3cc7e9e47e498ec30d4ee192b216714d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3cc7e9e47e498ec30d4ee192b216714d,
        type_description_1,
        par_type,
        par_buffer,
        par_passphrase,
        var_bio,
        var_helper,
        var_pkey,
        var_evp_pkey
    );


    // Release cached frame.
    if ( frame_3cc7e9e47e498ec30d4ee192b216714d == cache_frame_3cc7e9e47e498ec30d4ee192b216714d )
    {
        Py_DECREF( frame_3cc7e9e47e498ec30d4ee192b216714d );
    }
    cache_frame_3cc7e9e47e498ec30d4ee192b216714d = NULL;

    assertFrameObject( frame_3cc7e9e47e498ec30d4ee192b216714d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pkey );
    tmp_return_value = var_pkey;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_149_load_privatekey );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_helper );
    Py_DECREF( var_helper );
    var_helper = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_helper );
    var_helper = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_evp_pkey );
    var_evp_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_149_load_privatekey );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_150_dump_certificate_request( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_req = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_result_code = NULL;
    struct Nuitka_FrameObject *frame_713cab84aff1c754e3062c3169ef4209;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_713cab84aff1c754e3062c3169ef4209 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_713cab84aff1c754e3062c3169ef4209, codeobj_713cab84aff1c754e3062c3169ef4209, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_713cab84aff1c754e3062c3169ef4209 = cache_frame_713cab84aff1c754e3062c3169ef4209;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_713cab84aff1c754e3062c3169ef4209 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_713cab84aff1c754e3062c3169ef4209 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_713cab84aff1c754e3062c3169ef4209->m_frame.f_lineno = 2826;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2826;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 2828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2828;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_X509_REQ );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_1 = var_bio;
            CHECK_OBJECT( par_req );
            tmp_source_name_2 = par_req;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__req );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_713cab84aff1c754e3062c3169ef4209->m_frame.f_lineno = 2829;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2829;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_result_code == NULL );
            var_result_code = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 2830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2830;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_5;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_i2d_X509_REQ_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_3 = var_bio;
                CHECK_OBJECT( par_req );
                tmp_source_name_4 = par_req;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__req );
                if ( tmp_args_element_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_713cab84aff1c754e3062c3169ef4209->m_frame.f_lineno = 2831;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2831;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert( var_result_code == NULL );
                var_result_code = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT( par_type );
                tmp_compexpr_left_3 = par_type;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
                }

                if ( tmp_mvar_value_6 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
                    exception_tb = NULL;

                    exception_lineno = 2832;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_3 = tmp_mvar_value_6;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2832;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_7;
                    PyObject *tmp_args_element_name_5;
                    PyObject *tmp_args_element_name_6;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_args_element_name_7;
                    PyObject *tmp_args_element_name_8;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_7 == NULL ))
                    {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_7 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_7;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_REQ_print_ex );
                    if ( tmp_called_name_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( var_bio );
                    tmp_args_element_name_5 = var_bio;
                    CHECK_OBJECT( par_req );
                    tmp_source_name_6 = par_req;
                    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__req );
                    if ( tmp_args_element_name_6 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_4 );

                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_args_element_name_7 = const_int_0;
                    tmp_args_element_name_8 = const_int_0;
                    frame_713cab84aff1c754e3062c3169ef4209->m_frame.f_lineno = 2833;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
                        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
                    }

                    Py_DECREF( tmp_called_name_4 );
                    Py_DECREF( tmp_args_element_name_6 );
                    if ( tmp_assign_source_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2833;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_result_code == NULL );
                    var_result_code = tmp_assign_source_4;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_713cab84aff1c754e3062c3169ef4209->m_frame.f_lineno = 2835;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                    }

                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2835;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        if ( var_result_code == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result_code" );
            exception_tb = NULL;

            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = var_result_code;
        tmp_compexpr_right_4 = const_int_0;
        tmp_args_element_name_9 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_args_element_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_713cab84aff1c754e3062c3169ef4209->m_frame.f_lineno = 2840;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_args_element_name_9 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2840;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_10;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 2842;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_9;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_10 = var_bio;
        frame_713cab84aff1c754e3062c3169ef4209->m_frame.f_lineno = 2842;
        {
            PyObject *call_args[] = { tmp_args_element_name_10 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2842;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_713cab84aff1c754e3062c3169ef4209 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_713cab84aff1c754e3062c3169ef4209 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_713cab84aff1c754e3062c3169ef4209 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_713cab84aff1c754e3062c3169ef4209, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_713cab84aff1c754e3062c3169ef4209->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_713cab84aff1c754e3062c3169ef4209, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_713cab84aff1c754e3062c3169ef4209,
        type_description_1,
        par_type,
        par_req,
        var_bio,
        var_result_code
    );


    // Release cached frame.
    if ( frame_713cab84aff1c754e3062c3169ef4209 == cache_frame_713cab84aff1c754e3062c3169ef4209 )
    {
        Py_DECREF( frame_713cab84aff1c754e3062c3169ef4209 );
    }
    cache_frame_713cab84aff1c754e3062c3169ef4209 = NULL;

    assertFrameObject( frame_713cab84aff1c754e3062c3169ef4209 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_150_dump_certificate_request );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_req );
    Py_DECREF( par_req );
    par_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_req );
    Py_DECREF( par_req );
    par_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result_code );
    var_result_code = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_150_dump_certificate_request );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_151_load_certificate_request( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_req = NULL;
    PyObject *var_x509req = NULL;
    struct Nuitka_FrameObject *frame_67f4c23d4eea6c453c888d6f47275f62;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_67f4c23d4eea6c453c888d6f47275f62 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_67f4c23d4eea6c453c888d6f47275f62, codeobj_67f4c23d4eea6c453c888d6f47275f62, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_67f4c23d4eea6c453c888d6f47275f62 = cache_frame_67f4c23d4eea6c453c888d6f47275f62;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_67f4c23d4eea6c453c888d6f47275f62 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_67f4c23d4eea6c453c888d6f47275f62 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_buffer );
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 2854;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2854;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buffer );
            tmp_called_instance_1 = par_buffer;
            frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2855;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2855;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert( old != NULL );
                par_buffer = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2857;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_buffer );
        tmp_args_element_name_1 = par_buffer;
        frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2857;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2857;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 2859;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2859;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_X509_REQ );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_5 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_7 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );

                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2860;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2860;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_req == NULL );
            var_req = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 2861;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2861;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_9 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_X509_REQ_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_10 == NULL ))
                {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_10 == NULL )
                {
                    Py_DECREF( tmp_called_name_3 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
                if ( tmp_args_element_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2862;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2862;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_req == NULL );
                var_req = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2864;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 2864;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_4 = tmp_mvar_value_11;
        if ( var_req == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "req" );
            exception_tb = NULL;

            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_req;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_12;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_8 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2866;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2866;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Req" );
            exception_tb = NULL;

            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req );
        }

        if ( tmp_mvar_value_14 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509Req" );
            exception_tb = NULL;

            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = tmp_mvar_value_14;
        frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2868;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2868;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_x509req == NULL );
        var_x509req = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if ( var_req == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "req" );
            exception_tb = NULL;

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_10 = var_req;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_16 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_REQ_free );
        if ( tmp_args_element_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_67f4c23d4eea6c453c888d6f47275f62->m_frame.f_lineno = 2869;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_11 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_x509req );
        tmp_assattr_target_1 = var_x509req;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__req, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2869;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67f4c23d4eea6c453c888d6f47275f62 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_67f4c23d4eea6c453c888d6f47275f62 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_67f4c23d4eea6c453c888d6f47275f62, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_67f4c23d4eea6c453c888d6f47275f62->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_67f4c23d4eea6c453c888d6f47275f62, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_67f4c23d4eea6c453c888d6f47275f62,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_req,
        var_x509req
    );


    // Release cached frame.
    if ( frame_67f4c23d4eea6c453c888d6f47275f62 == cache_frame_67f4c23d4eea6c453c888d6f47275f62 )
    {
        Py_DECREF( frame_67f4c23d4eea6c453c888d6f47275f62 );
    }
    cache_frame_67f4c23d4eea6c453c888d6f47275f62 = NULL;

    assertFrameObject( frame_67f4c23d4eea6c453c888d6f47275f62 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_x509req );
    tmp_return_value = var_x509req;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_151_load_certificate_request );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_x509req );
    Py_DECREF( var_x509req );
    var_x509req = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_req );
    var_req = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_x509req );
    var_x509req = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_151_load_certificate_request );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_152_sign( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_pkey = python_pars[ 0 ];
    PyObject *par_data = python_pars[ 1 ];
    PyObject *par_digest = python_pars[ 2 ];
    PyObject *var_final_result = NULL;
    PyObject *var_signature_length = NULL;
    PyObject *var_length = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_signature_buffer = NULL;
    PyObject *var_md_ctx = NULL;
    struct Nuitka_FrameObject *frame_7b18b41aa1a7fb07c2565ad2e80412f3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7b18b41aa1a7fb07c2565ad2e80412f3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7b18b41aa1a7fb07c2565ad2e80412f3, codeobj_7b18b41aa1a7fb07c2565ad2e80412f3, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7b18b41aa1a7fb07c2565ad2e80412f3 = cache_frame_7b18b41aa1a7fb07c2565ad2e80412f3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7b18b41aa1a7fb07c2565ad2e80412f3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7b18b41aa1a7fb07c2565ad2e80412f3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 2884;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_data;
        CHECK_OBJECT( par_data );
        tmp_args_element_name_2 = par_data;
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2884;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2884;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_data;
            assert( old != NULL );
            par_data = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_digestbyname );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT( par_digest );
        tmp_args_element_name_4 = par_digest;
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2886;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2886;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2886;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest_obj == NULL );
        var_digest_obj = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_digest_obj );
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2887;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2887;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2887;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2888;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2888;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2890;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_5;
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2890;
        tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_Cryptography_EVP_MD_CTX_new );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2890;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_md_ctx == NULL );
        var_md_ctx = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_gc );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_5 = var_md_ctx;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_7 == NULL )
        {
            Py_DECREF( tmp_called_name_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_Cryptography_EVP_MD_CTX_free );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2891;
        {
            PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2891;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_md_ctx;
            assert( old != NULL );
            var_md_ctx = tmp_assign_source_4;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2893;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_8;
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_7 = var_md_ctx;
        CHECK_OBJECT( var_digest_obj );
        tmp_args_element_name_8 = var_digest_obj;
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2893;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_EVP_SignInit, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2893;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_9;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_EVP_SignUpdate );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_9 = var_md_ctx;
        CHECK_OBJECT( par_data );
        tmp_args_element_name_10 = par_data;
        CHECK_OBJECT( par_data );
        tmp_len_arg_1 = par_data;
        tmp_args_element_name_11 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2894;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_11 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2894;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_source_name_7;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_10;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_EVP_PKEY_size );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_pkey );
        tmp_source_name_7 = par_pkey;
        tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__pkey );
        if ( tmp_args_element_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2896;
        {
            PyObject *call_args[] = { tmp_args_element_name_12 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_12 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2896;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_length == NULL );
        var_length = tmp_assign_source_5;
    }
    {
        PyObject *tmp_called_name_7;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2897;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_7 = tmp_mvar_value_11;
        CHECK_OBJECT( var_length );
        tmp_compexpr_left_2 = var_length;
        tmp_compexpr_right_2 = const_int_0;
        tmp_args_element_name_13 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2897;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2897;
        {
            PyObject *call_args[] = { tmp_args_element_name_13 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_args_element_name_13 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2897;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2898;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_12;
        tmp_args_element_name_14 = const_str_digest_81f1b0dfcc7a862e6940580ec4cc42d3;
        CHECK_OBJECT( var_length );
        tmp_args_element_name_15 = var_length;
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2898;
        {
            PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_new, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2898;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_signature_buffer == NULL );
        var_signature_buffer = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2899;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_13;
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2899;
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_e33a7f733650e687efe98e5491512b82_tuple, 0 ) );

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2899;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_signature_length == NULL );
        var_signature_length = tmp_assign_source_7;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_source_name_9;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2900;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_14;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_EVP_SignFinal );
        if ( tmp_called_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2900;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_16 = var_md_ctx;
        CHECK_OBJECT( var_signature_buffer );
        tmp_args_element_name_17 = var_signature_buffer;
        CHECK_OBJECT( var_signature_length );
        tmp_args_element_name_18 = var_signature_length;
        CHECK_OBJECT( par_pkey );
        tmp_source_name_9 = par_pkey;
        tmp_args_element_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__pkey );
        if ( tmp_args_element_name_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_8 );

            exception_lineno = 2901;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2900;
        {
            PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
            tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_8, call_args );
        }

        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_19 );
        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2900;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_final_result == NULL );
        var_final_result = tmp_assign_source_8;
    }
    {
        PyObject *tmp_called_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_20;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2902;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_9 = tmp_mvar_value_15;
        CHECK_OBJECT( var_final_result );
        tmp_compexpr_left_3 = var_final_result;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_args_element_name_20 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_args_element_name_20 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2902;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2902;
        {
            PyObject *call_args[] = { tmp_args_element_name_20 };
            tmp_call_result_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
        }

        Py_DECREF( tmp_args_element_name_20 );
        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2902;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_4 );
    }
    {
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_called_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_args_element_name_21;
        PyObject *tmp_args_element_name_22;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_buffer );
        if ( tmp_called_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_signature_buffer );
        tmp_args_element_name_21 = var_signature_buffer;
        CHECK_OBJECT( var_signature_length );
        tmp_subscribed_name_1 = var_signature_length;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_22 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_22 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_10 );

            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame.f_lineno = 2904;
        {
            PyObject *call_args[] = { tmp_args_element_name_21, tmp_args_element_name_22 };
            tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, call_args );
        }

        Py_DECREF( tmp_called_name_10 );
        Py_DECREF( tmp_args_element_name_22 );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2904;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7b18b41aa1a7fb07c2565ad2e80412f3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7b18b41aa1a7fb07c2565ad2e80412f3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7b18b41aa1a7fb07c2565ad2e80412f3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7b18b41aa1a7fb07c2565ad2e80412f3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7b18b41aa1a7fb07c2565ad2e80412f3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7b18b41aa1a7fb07c2565ad2e80412f3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7b18b41aa1a7fb07c2565ad2e80412f3,
        type_description_1,
        par_pkey,
        par_data,
        par_digest,
        var_final_result,
        var_signature_length,
        var_length,
        var_digest_obj,
        var_signature_buffer,
        var_md_ctx
    );


    // Release cached frame.
    if ( frame_7b18b41aa1a7fb07c2565ad2e80412f3 == cache_frame_7b18b41aa1a7fb07c2565ad2e80412f3 )
    {
        Py_DECREF( frame_7b18b41aa1a7fb07c2565ad2e80412f3 );
    }
    cache_frame_7b18b41aa1a7fb07c2565ad2e80412f3 = NULL;

    assertFrameObject( frame_7b18b41aa1a7fb07c2565ad2e80412f3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_152_sign );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_final_result );
    Py_DECREF( var_final_result );
    var_final_result = NULL;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    CHECK_OBJECT( (PyObject *)var_signature_length );
    Py_DECREF( var_signature_length );
    var_signature_length = NULL;

    CHECK_OBJECT( (PyObject *)var_length );
    Py_DECREF( var_length );
    var_length = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_signature_buffer );
    Py_DECREF( var_signature_buffer );
    var_signature_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_md_ctx );
    Py_DECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_final_result );
    var_final_result = NULL;

    CHECK_OBJECT( (PyObject *)par_pkey );
    Py_DECREF( par_pkey );
    par_pkey = NULL;

    Py_XDECREF( var_signature_length );
    var_signature_length = NULL;

    Py_XDECREF( var_length );
    var_length = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    Py_XDECREF( var_signature_buffer );
    var_signature_buffer = NULL;

    Py_XDECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_152_sign );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_153_verify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cert = python_pars[ 0 ];
    PyObject *par_signature = python_pars[ 1 ];
    PyObject *par_data = python_pars[ 2 ];
    PyObject *par_digest = python_pars[ 3 ];
    PyObject *var_pkey = NULL;
    PyObject *var_digest_obj = NULL;
    PyObject *var_verify_result = NULL;
    PyObject *var_md_ctx = NULL;
    struct Nuitka_FrameObject *frame_d973aa6ad6702c4cbe398efc4bf93b64;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_d973aa6ad6702c4cbe398efc4bf93b64 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d973aa6ad6702c4cbe398efc4bf93b64, codeobj_d973aa6ad6702c4cbe398efc4bf93b64, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d973aa6ad6702c4cbe398efc4bf93b64 = cache_frame_d973aa6ad6702c4cbe398efc4bf93b64;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d973aa6ad6702c4cbe398efc4bf93b64 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d973aa6ad6702c4cbe398efc4bf93b64 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 2920;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_data;
        CHECK_OBJECT( par_data );
        tmp_args_element_name_2 = par_data;
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2920;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2920;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_data;
            assert( old != NULL );
            par_data = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EVP_get_digestbyname );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__byte_string );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_byte_string" );
            exception_tb = NULL;

            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_3;
        CHECK_OBJECT( par_digest );
        tmp_args_element_name_4 = par_digest;
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2922;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2922;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2922;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_digest_obj == NULL );
        var_digest_obj = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_4;
        CHECK_OBJECT( var_digest_obj );
        tmp_compexpr_left_1 = var_digest_obj;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2923;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_4;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2923;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2923;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_500f278b67471fc0f770fccc80d65d95;
            frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2924;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 2924;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_4;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_4;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_5;
        tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_X509_get_pubkey );
        if ( tmp_called_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cert );
        tmp_source_name_4 = par_cert;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__x509 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_4 );

            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2926;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
        }

        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2926;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_3;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__openssl_assert );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_openssl_assert" );
            exception_tb = NULL;

            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_6;
        CHECK_OBJECT( var_pkey );
        tmp_compexpr_left_2 = var_pkey;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_7;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_NULL );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_6 = RICH_COMPARE_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_args_element_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2927;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_args_element_name_6 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2927;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_8;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_gc );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_args_element_name_7 = var_pkey;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_9 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_9;
        tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_EVP_PKEY_free );
        if ( tmp_args_element_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2928;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_8 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2928;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_pkey;
            assert( old != NULL );
            var_pkey = tmp_assign_source_4;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2930;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_10;
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2930;
        tmp_assign_source_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_Cryptography_EVP_MD_CTX_new );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2930;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_md_ctx == NULL );
        var_md_ctx = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_11;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_gc );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_9 = var_md_ctx;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_12 == NULL )
        {
            Py_DECREF( tmp_called_name_7 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_12;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_Cryptography_EVP_MD_CTX_free );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2931;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2931;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_md_ctx;
            assert( old != NULL );
            var_md_ctx = tmp_assign_source_6;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2933;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_13;
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_11 = var_md_ctx;
        CHECK_OBJECT( var_digest_obj );
        tmp_args_element_name_12 = var_digest_obj;
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2933;
        {
            PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_EVP_VerifyInit, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2933;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_14;
        tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_EVP_VerifyUpdate );
        if ( tmp_called_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_13 = var_md_ctx;
        CHECK_OBJECT( par_data );
        tmp_args_element_name_14 = par_data;
        CHECK_OBJECT( par_data );
        tmp_len_arg_1 = par_data;
        tmp_args_element_name_15 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_8 );

            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2934;
        {
            PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
        }

        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_15 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2934;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_9;
        PyObject *tmp_source_name_11;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_len_arg_2;
        PyObject *tmp_args_element_name_19;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2935;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = tmp_mvar_value_15;
        tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_EVP_VerifyFinal );
        if ( tmp_called_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2935;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_md_ctx );
        tmp_args_element_name_16 = var_md_ctx;
        CHECK_OBJECT( par_signature );
        tmp_args_element_name_17 = par_signature;
        CHECK_OBJECT( par_signature );
        tmp_len_arg_2 = par_signature;
        tmp_args_element_name_18 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_args_element_name_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_9 );

            exception_lineno = 2936;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pkey );
        tmp_args_element_name_19 = var_pkey;
        frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2935;
        {
            PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_9, call_args );
        }

        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_args_element_name_18 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2935;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_verify_result == NULL );
        var_verify_result = tmp_assign_source_7;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( var_verify_result );
        tmp_compexpr_left_3 = var_verify_result;
        tmp_compexpr_right_3 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2939;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_call_result_4;
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_16 == NULL ))
            {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_16 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2940;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_10 = tmp_mvar_value_16;
            frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame.f_lineno = 2940;
            tmp_call_result_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
            if ( tmp_call_result_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2940;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_4 );
        }
        branch_no_2:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d973aa6ad6702c4cbe398efc4bf93b64 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d973aa6ad6702c4cbe398efc4bf93b64 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d973aa6ad6702c4cbe398efc4bf93b64, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d973aa6ad6702c4cbe398efc4bf93b64->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d973aa6ad6702c4cbe398efc4bf93b64, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d973aa6ad6702c4cbe398efc4bf93b64,
        type_description_1,
        par_cert,
        par_signature,
        par_data,
        par_digest,
        var_pkey,
        var_digest_obj,
        var_verify_result,
        var_md_ctx
    );


    // Release cached frame.
    if ( frame_d973aa6ad6702c4cbe398efc4bf93b64 == cache_frame_d973aa6ad6702c4cbe398efc4bf93b64 )
    {
        Py_DECREF( frame_d973aa6ad6702c4cbe398efc4bf93b64 );
    }
    cache_frame_d973aa6ad6702c4cbe398efc4bf93b64 = NULL;

    assertFrameObject( frame_d973aa6ad6702c4cbe398efc4bf93b64 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_153_verify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_digest_obj );
    Py_DECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_signature );
    Py_DECREF( par_signature );
    par_signature = NULL;

    CHECK_OBJECT( (PyObject *)var_verify_result );
    Py_DECREF( var_verify_result );
    var_verify_result = NULL;

    CHECK_OBJECT( (PyObject *)var_md_ctx );
    Py_DECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_cert );
    Py_DECREF( par_cert );
    par_cert = NULL;

    Py_XDECREF( var_digest_obj );
    var_digest_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_signature );
    Py_DECREF( par_signature );
    par_signature = NULL;

    Py_XDECREF( var_verify_result );
    var_verify_result = NULL;

    Py_XDECREF( var_md_ctx );
    var_md_ctx = NULL;

    CHECK_OBJECT( (PyObject *)par_data );
    Py_DECREF( par_data );
    par_data = NULL;

    CHECK_OBJECT( (PyObject *)par_digest );
    Py_DECREF( par_digest );
    par_digest = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_153_verify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_154_dump_crl( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_crl = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_ret = NULL;
    struct Nuitka_FrameObject *frame_c1d3d7e0cb19e2d22f67d229f398e65f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c1d3d7e0cb19e2d22f67d229f398e65f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c1d3d7e0cb19e2d22f67d229f398e65f, codeobj_c1d3d7e0cb19e2d22f67d229f398e65f, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c1d3d7e0cb19e2d22f67d229f398e65f = cache_frame_c1d3d7e0cb19e2d22f67d229f398e65f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c1d3d7e0cb19e2d22f67d229f398e65f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c1d3d7e0cb19e2d22f67d229f398e65f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2954;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        frame_c1d3d7e0cb19e2d22f67d229f398e65f->m_frame.f_lineno = 2954;
        tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2954;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 2956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_2;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2956;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_source_name_2;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_3;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_write_bio_X509_CRL );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_1 = var_bio;
            CHECK_OBJECT( par_crl );
            tmp_source_name_2 = par_crl;
            tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__crl );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            frame_c1d3d7e0cb19e2d22f67d229f398e65f->m_frame.f_lineno = 2957;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2957;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_ret == NULL );
            var_ret = tmp_assign_source_2;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 2958;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_4;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2958;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_5;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_source_name_4;
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_5 == NULL ))
                {
                    tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_5 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_5;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_i2d_X509_CRL_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_3 = var_bio;
                CHECK_OBJECT( par_crl );
                tmp_source_name_4 = par_crl;
                tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__crl );
                if ( tmp_args_element_name_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                frame_c1d3d7e0cb19e2d22f67d229f398e65f->m_frame.f_lineno = 2959;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2959;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert( var_ret == NULL );
                var_ret = tmp_assign_source_3;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                PyObject *tmp_mvar_value_6;
                CHECK_OBJECT( par_type );
                tmp_compexpr_left_3 = par_type;
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );

                if (unlikely( tmp_mvar_value_6 == NULL ))
                {
                    tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT );
                }

                if ( tmp_mvar_value_6 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_TEXT" );
                    exception_tb = NULL;

                    exception_lineno = 2960;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_3 = tmp_mvar_value_6;
                tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2960;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_3;
                }
                else
                {
                    goto branch_no_3;
                }
                branch_yes_3:;
                {
                    PyObject *tmp_assign_source_4;
                    PyObject *tmp_called_name_4;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_mvar_value_7;
                    PyObject *tmp_args_element_name_5;
                    PyObject *tmp_args_element_name_6;
                    PyObject *tmp_source_name_6;
                    tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                    if (unlikely( tmp_mvar_value_7 == NULL ))
                    {
                        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                    }

                    if ( tmp_mvar_value_7 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                        exception_tb = NULL;

                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_source_name_5 = tmp_mvar_value_7;
                    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_X509_CRL_print );
                    if ( tmp_called_name_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( var_bio );
                    tmp_args_element_name_5 = var_bio;
                    CHECK_OBJECT( par_crl );
                    tmp_source_name_6 = par_crl;
                    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__crl );
                    if ( tmp_args_element_name_6 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_4 );

                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    frame_c1d3d7e0cb19e2d22f67d229f398e65f->m_frame.f_lineno = 2961;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
                    }

                    Py_DECREF( tmp_called_name_4 );
                    Py_DECREF( tmp_args_element_name_6 );
                    if ( tmp_assign_source_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 2961;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    assert( var_ret == NULL );
                    var_ret = tmp_assign_source_4;
                }
                goto branch_end_3;
                branch_no_3:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    tmp_make_exception_arg_1 = const_str_digest_11c225ccbab9acffc38107dee9691702;
                    frame_c1d3d7e0cb19e2d22f67d229f398e65f->m_frame.f_lineno = 2963;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                    }

                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 2963;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                branch_end_3:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        if ( var_ret == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "ret" );
            exception_tb = NULL;

            exception_lineno = 2967;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_4 = var_ret;
        tmp_compexpr_right_4 = const_int_pos_1;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2967;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2967;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_raise_type_2;
            tmp_raise_type_2 = PyExc_AssertionError;
            exception_type = tmp_raise_type_2;
            Py_INCREF( tmp_raise_type_2 );
            exception_lineno = 2967;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bio_to_string );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_bio_to_string" );
            exception_tb = NULL;

            exception_lineno = 2968;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_5 = tmp_mvar_value_8;
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_7 = var_bio;
        frame_c1d3d7e0cb19e2d22f67d229f398e65f->m_frame.f_lineno = 2968;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2968;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c1d3d7e0cb19e2d22f67d229f398e65f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c1d3d7e0cb19e2d22f67d229f398e65f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c1d3d7e0cb19e2d22f67d229f398e65f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c1d3d7e0cb19e2d22f67d229f398e65f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c1d3d7e0cb19e2d22f67d229f398e65f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c1d3d7e0cb19e2d22f67d229f398e65f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c1d3d7e0cb19e2d22f67d229f398e65f,
        type_description_1,
        par_type,
        par_crl,
        var_bio,
        var_ret
    );


    // Release cached frame.
    if ( frame_c1d3d7e0cb19e2d22f67d229f398e65f == cache_frame_c1d3d7e0cb19e2d22f67d229f398e65f )
    {
        Py_DECREF( frame_c1d3d7e0cb19e2d22f67d229f398e65f );
    }
    cache_frame_c1d3d7e0cb19e2d22f67d229f398e65f = NULL;

    assertFrameObject( frame_c1d3d7e0cb19e2d22f67d229f398e65f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_154_dump_crl );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    CHECK_OBJECT( (PyObject *)par_crl );
    Py_DECREF( par_crl );
    par_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_154_dump_crl );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_155_load_crl( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_result = NULL;
    PyObject *var_crl = NULL;
    struct Nuitka_FrameObject *frame_b149ec0eb89f519088e871e4ad91a2cc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_b149ec0eb89f519088e871e4ad91a2cc = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b149ec0eb89f519088e871e4ad91a2cc, codeobj_b149ec0eb89f519088e871e4ad91a2cc, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b149ec0eb89f519088e871e4ad91a2cc = cache_frame_b149ec0eb89f519088e871e4ad91a2cc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b149ec0eb89f519088e871e4ad91a2cc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b149ec0eb89f519088e871e4ad91a2cc ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_buffer );
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 2981;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2981;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buffer );
            tmp_called_instance_1 = par_buffer;
            frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2982;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2982;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert( old != NULL );
                par_buffer = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 2984;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_buffer );
        tmp_args_element_name_1 = par_buffer;
        frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2984;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2984;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 2986;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2986;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_X509_CRL );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_5 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_7 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );

                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2987;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2987;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_crl == NULL );
            var_crl = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 2988;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2988;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_9 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_X509_CRL_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_10 == NULL ))
                {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_10 == NULL )
                {
                    Py_DECREF( tmp_called_name_3 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
                if ( tmp_args_element_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2989;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 2989;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_crl == NULL );
                var_crl = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2991;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 2991;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if ( var_crl == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "crl" );
            exception_tb = NULL;

            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_crl;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2993;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 2994;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2994;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2994;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "CRL" );
            exception_tb = NULL;

            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL );
        }

        if ( tmp_mvar_value_14 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "CRL" );
            exception_tb = NULL;

            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = tmp_mvar_value_14;
        frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2996;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2996;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_result == NULL );
        var_result = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if ( var_crl == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "crl" );
            exception_tb = NULL;

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = var_crl;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_16 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_CRL_free );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame.f_lineno = 2997;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_result );
        tmp_assattr_target_1 = var_result;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__crl, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2997;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b149ec0eb89f519088e871e4ad91a2cc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b149ec0eb89f519088e871e4ad91a2cc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b149ec0eb89f519088e871e4ad91a2cc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b149ec0eb89f519088e871e4ad91a2cc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b149ec0eb89f519088e871e4ad91a2cc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b149ec0eb89f519088e871e4ad91a2cc,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_result,
        var_crl
    );


    // Release cached frame.
    if ( frame_b149ec0eb89f519088e871e4ad91a2cc == cache_frame_b149ec0eb89f519088e871e4ad91a2cc )
    {
        Py_DECREF( frame_b149ec0eb89f519088e871e4ad91a2cc );
    }
    cache_frame_b149ec0eb89f519088e871e4ad91a2cc = NULL;

    assertFrameObject( frame_b149ec0eb89f519088e871e4ad91a2cc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_result );
    tmp_return_value = var_result;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_155_load_crl );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)var_result );
    Py_DECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    Py_XDECREF( var_crl );
    var_crl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_155_load_crl );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_156_load_pkcs7_data( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_type = python_pars[ 0 ];
    PyObject *par_buffer = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_pypkcs7 = NULL;
    PyObject *var_pkcs7 = NULL;
    struct Nuitka_FrameObject *frame_206aa892821ceb22b8152788bccc5cec;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_206aa892821ceb22b8152788bccc5cec = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_206aa892821ceb22b8152788bccc5cec, codeobj_206aa892821ceb22b8152788bccc5cec, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_206aa892821ceb22b8152788bccc5cec = cache_frame_206aa892821ceb22b8152788bccc5cec;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_206aa892821ceb22b8152788bccc5cec );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_206aa892821ceb22b8152788bccc5cec ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_buffer );
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 3010;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3010;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buffer );
            tmp_called_instance_1 = par_buffer;
            frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3011;
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3011;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert( old != NULL );
                par_buffer = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 3013;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_buffer );
        tmp_args_element_name_1 = par_buffer;
        frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3013;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3013;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_type );
        tmp_compexpr_left_1 = par_type;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_PEM" );
            exception_tb = NULL;

            exception_lineno = 3015;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_3;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3015;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_source_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_7;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PEM_read_bio_PKCS7 );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_bio );
            tmp_args_element_name_2 = var_bio;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_5 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_2 = tmp_mvar_value_5;
            tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_NULL );
            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_6 == NULL ))
            {
                tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_6 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_3 = tmp_mvar_value_6;
            tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_7 == NULL )
            {
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_4 = tmp_mvar_value_7;
            tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
            if ( tmp_args_element_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_3 );
                Py_DECREF( tmp_args_element_name_4 );

                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3016;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_2, call_args );
            }

            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_element_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            Py_DECREF( tmp_args_element_name_5 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3016;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_pkcs7 == NULL );
            var_pkcs7 = tmp_assign_source_3;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_8;
            CHECK_OBJECT( par_type );
            tmp_compexpr_left_2 = par_type;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1 );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "FILETYPE_ASN1" );
                exception_tb = NULL;

                exception_lineno = 3017;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_8;
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3017;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_name_3;
                PyObject *tmp_source_name_5;
                PyObject *tmp_mvar_value_9;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_source_name_6;
                PyObject *tmp_mvar_value_10;
                tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

                if (unlikely( tmp_mvar_value_9 == NULL ))
                {
                    tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
                }

                if ( tmp_mvar_value_9 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                    exception_tb = NULL;

                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_5 = tmp_mvar_value_9;
                tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_d2i_PKCS7_bio );
                if ( tmp_called_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( var_bio );
                tmp_args_element_name_6 = var_bio;
                tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

                if (unlikely( tmp_mvar_value_10 == NULL ))
                {
                    tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
                }

                if ( tmp_mvar_value_10 == NULL )
                {
                    Py_DECREF( tmp_called_name_3 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                    exception_tb = NULL;

                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_6 = tmp_mvar_value_10;
                tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_NULL );
                if ( tmp_args_element_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_3 );

                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3018;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
                    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
                }

                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 3018;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_pkcs7 == NULL );
                var_pkcs7 = tmp_assign_source_4;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_make_exception_arg_1;
                tmp_make_exception_arg_1 = const_str_digest_f019d8c1ebbf58631ace92b4423b3aad;
                frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3020;
                {
                    PyObject *call_args[] = { tmp_make_exception_arg_1 };
                    tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
                }

                assert( !(tmp_raise_type_1 == NULL) );
                exception_type = tmp_raise_type_1;
                exception_lineno = 3020;
                RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_11;
        if ( var_pkcs7 == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "pkcs7" );
            exception_tb = NULL;

            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = var_pkcs7;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_11;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3022;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_12;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_12 == NULL ))
            {
                tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_12 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 3023;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_12;
            frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3023;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3023;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7 );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7 );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS7" );
            exception_tb = NULL;

            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_13;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain___new__ );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7 );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7 );
        }

        if ( tmp_mvar_value_14 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS7" );
            exception_tb = NULL;

            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = tmp_mvar_value_14;
        frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3025;
        {
            PyObject *call_args[] = { tmp_args_element_name_8 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3025;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pypkcs7 == NULL );
        var_pypkcs7 = tmp_assign_source_5;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_name_6;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_10;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_15 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_15;
        tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_gc );
        if ( tmp_called_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if ( var_pkcs7 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "pkcs7" );
            exception_tb = NULL;

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_9 = var_pkcs7;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_16 == NULL )
        {
            Py_DECREF( tmp_called_name_6 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_10 = tmp_mvar_value_16;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_PKCS7_free );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_6 );

            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_206aa892821ceb22b8152788bccc5cec->m_frame.f_lineno = 3026;
        {
            PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
            tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
        }

        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_args_element_name_10 );
        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_pypkcs7 );
        tmp_assattr_target_1 = var_pypkcs7;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkcs7, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3026;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_206aa892821ceb22b8152788bccc5cec );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_206aa892821ceb22b8152788bccc5cec );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_206aa892821ceb22b8152788bccc5cec, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_206aa892821ceb22b8152788bccc5cec->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_206aa892821ceb22b8152788bccc5cec, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_206aa892821ceb22b8152788bccc5cec,
        type_description_1,
        par_type,
        par_buffer,
        var_bio,
        var_pypkcs7,
        var_pkcs7
    );


    // Release cached frame.
    if ( frame_206aa892821ceb22b8152788bccc5cec == cache_frame_206aa892821ceb22b8152788bccc5cec )
    {
        Py_DECREF( frame_206aa892821ceb22b8152788bccc5cec );
    }
    cache_frame_206aa892821ceb22b8152788bccc5cec = NULL;

    assertFrameObject( frame_206aa892821ceb22b8152788bccc5cec );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pypkcs7 );
    tmp_return_value = var_pypkcs7;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_156_load_pkcs7_data );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_pypkcs7 );
    Py_DECREF( var_pypkcs7 );
    var_pypkcs7 = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_pkcs7 );
    var_pkcs7 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_pypkcs7 );
    var_pypkcs7 = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    Py_XDECREF( var_pkcs7 );
    var_pkcs7 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_156_load_pkcs7_data );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_OpenSSL$crypto$$$function_157_load_pkcs12( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_buffer = python_pars[ 0 ];
    PyObject *par_passphrase = python_pars[ 1 ];
    PyObject *var_bio = NULL;
    PyObject *var_pykey = NULL;
    PyObject *var_x509 = NULL;
    PyObject *var_friendlyname_buffer = NULL;
    PyObject *var_pkey = NULL;
    PyObject *var_i = NULL;
    PyObject *var_cert = NULL;
    PyObject *var_cacerts = NULL;
    PyObject *var_pycert = NULL;
    PyObject *var_friendlyname_length = NULL;
    PyObject *var_p12 = NULL;
    PyObject *var_pycacert = NULL;
    PyObject *var_pkcs12 = NULL;
    PyObject *var_friendlyname = NULL;
    PyObject *var_pycacerts = NULL;
    PyObject *var_parse_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_0428bad59ec7b5a66149d8e2c88e0cb2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_0428bad59ec7b5a66149d8e2c88e0cb2 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0428bad59ec7b5a66149d8e2c88e0cb2, codeobj_0428bad59ec7b5a66149d8e2c88e0cb2, module_OpenSSL$crypto, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0428bad59ec7b5a66149d8e2c88e0cb2 = cache_frame_0428bad59ec7b5a66149d8e2c88e0cb2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0428bad59ec7b5a66149d8e2c88e0cb2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0428bad59ec7b5a66149d8e2c88e0cb2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_to_bytes_and_warn" );
            exception_tb = NULL;

            exception_lineno = 3042;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_passphrase;
        CHECK_OBJECT( par_passphrase );
        tmp_args_element_name_2 = par_passphrase;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3042;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3042;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_passphrase;
            assert( old != NULL );
            par_passphrase = tmp_assign_source_1;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_buffer );
        tmp_isinstance_inst_1 = par_buffer;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__text_type );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_text_type" );
            exception_tb = NULL;

            exception_lineno = 3044;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3044;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_buffer );
            tmp_called_instance_1 = par_buffer;
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3045;
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_encode, &PyTuple_GET_ITEM( const_tuple_str_plain_ascii_tuple, 0 ) );

            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3045;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_buffer;
                assert( old != NULL );
                par_buffer = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__new_mem_buf );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_new_mem_buf" );
            exception_tb = NULL;

            exception_lineno = 3047;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT( par_buffer );
        tmp_args_element_name_3 = par_buffer;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3047;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3047;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_bio == NULL );
        var_bio = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_passphrase );
        tmp_operand_name_1 = par_passphrase;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3053;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3054;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_4;
            tmp_assign_source_4 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NULL );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3054;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_passphrase;
                assert( old != NULL );
                par_passphrase = tmp_assign_source_4;
                Py_DECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_5;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_d2i_PKCS12_bio );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_bio );
        tmp_args_element_name_4 = var_bio;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_6;
        tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_NULL );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3056;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3056;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_p12 == NULL );
        var_p12 = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_7;
        CHECK_OBJECT( var_p12 );
        tmp_compexpr_left_1 = var_p12;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3057;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_7;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NULL );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3057;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3057;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_8;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_8 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 3058;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_8;
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3058;
            tmp_call_result_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3058;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_name_5;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_9;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_gc );
        if ( tmp_called_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_p12 );
        tmp_args_element_name_6 = var_p12;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_10 == NULL )
        {
            Py_DECREF( tmp_called_name_5 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_10;
        tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_PKCS12_free );
        if ( tmp_args_element_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_5 );

            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3059;
        {
            PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
        }

        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_7 );
        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3059;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_p12;
            assert( old != NULL );
            var_p12 = tmp_assign_source_6;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3061;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_11;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3061;
        tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_016ce3807ea72a262d921fa7d1804717_tuple, 0 ) );

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3061;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkey == NULL );
        var_pkey = tmp_assign_source_7;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3062;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_12;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3062;
        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_e1dc452ac5e3c17f3e15bbf44d17e339_tuple, 0 ) );

        if ( tmp_assign_source_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3062;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_cert == NULL );
        var_cert = tmp_assign_source_8;
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3063;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = tmp_mvar_value_13;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3063;
        tmp_assign_source_9 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_4560cdf69c017b7cd264323295e708cb_tuple, 0 ) );

        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3063;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_cacerts == NULL );
        var_cacerts = tmp_assign_source_9;
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_called_instance_5;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3065;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_5 = tmp_mvar_value_14;
        CHECK_OBJECT( var_p12 );
        tmp_args_element_name_8 = var_p12;
        CHECK_OBJECT( par_passphrase );
        tmp_args_element_name_9 = par_passphrase;
        CHECK_OBJECT( var_pkey );
        tmp_args_element_name_10 = var_pkey;
        CHECK_OBJECT( var_cert );
        tmp_args_element_name_11 = var_cert;
        CHECK_OBJECT( var_cacerts );
        tmp_args_element_name_12 = var_cacerts;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3065;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_assign_source_10 = CALL_METHOD_WITH_ARGS5( tmp_called_instance_5, const_str_plain_PKCS12_parse, call_args );
        }

        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3065;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_parse_result == NULL );
        var_parse_result = tmp_assign_source_10;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_operand_name_2;
        CHECK_OBJECT( var_parse_result );
        tmp_operand_name_2 = var_parse_result;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3066;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_called_name_6;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_call_result_2;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
                exception_tb = NULL;

                exception_lineno = 3067;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_6 = tmp_mvar_value_15;
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3067;
            tmp_call_result_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3067;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_called_name_7;
        PyObject *tmp_source_name_7;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_source_name_8;
        PyObject *tmp_mvar_value_17;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_7 = tmp_mvar_value_16;
        tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_gc );
        if ( tmp_called_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_cacerts );
        tmp_subscribed_name_1 = var_cacerts;
        tmp_subscript_name_1 = const_int_0;
        tmp_args_element_name_13 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        if ( tmp_args_element_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_17 == NULL ))
        {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_17 == NULL )
        {
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_8 = tmp_mvar_value_17;
        tmp_args_element_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_sk_X509_free );
        if ( tmp_args_element_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_7 );
            Py_DECREF( tmp_args_element_name_13 );

            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3069;
        {
            PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
            tmp_assign_source_11 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
        }

        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_13 );
        Py_DECREF( tmp_args_element_name_14 );
        if ( tmp_assign_source_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3069;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_cacerts;
            assert( old != NULL );
            var_cacerts = tmp_assign_source_11;
            Py_DECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_called_name_8;
        PyObject *tmp_mvar_value_18;
        PyObject *tmp_call_result_3;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__raise_current_error );
        }

        if ( tmp_mvar_value_18 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_raise_current_error" );
            exception_tb = NULL;

            exception_lineno = 3075;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_2;
        }

        tmp_called_name_8 = tmp_mvar_value_18;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3075;
        tmp_call_result_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3075;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_0428bad59ec7b5a66149d8e2c88e0cb2 );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_0428bad59ec7b5a66149d8e2c88e0cb2, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_0428bad59ec7b5a66149d8e2c88e0cb2, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_mvar_value_19;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 3076;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_2 = tmp_mvar_value_19;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3076;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_3 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3076;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 3074;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame) frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooooooooooooooo";
        goto frame_exception_exit_1;
        branch_no_5:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_157_load_pkcs12 );
    return NULL;
    // End of try:
    try_end_1:;
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_source_name_9;
        PyObject *tmp_mvar_value_20;
        CHECK_OBJECT( var_pkey );
        tmp_subscribed_name_2 = var_pkey;
        tmp_subscript_name_2 = const_int_0;
        tmp_compexpr_left_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_20 == NULL ))
        {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_20 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_9 = tmp_mvar_value_20;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_NULL );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_3 );

            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3079;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_12;
            tmp_assign_source_12 = Py_None;
            assert( var_pykey == NULL );
            Py_INCREF( tmp_assign_source_12 );
            var_pykey = tmp_assign_source_12;
        }
        goto branch_end_6;
        branch_no_6:;
        {
            PyObject *tmp_assign_source_13;
            PyObject *tmp_called_name_9;
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_21;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_mvar_value_22;
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

            if (unlikely( tmp_mvar_value_21 == NULL ))
            {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
            }

            if ( tmp_mvar_value_21 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
                exception_tb = NULL;

                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_10 = tmp_mvar_value_21;
            tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain___new__ );
            if ( tmp_called_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

            if (unlikely( tmp_mvar_value_22 == NULL ))
            {
                tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
            }

            if ( tmp_mvar_value_22 == NULL )
            {
                Py_DECREF( tmp_called_name_9 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKey" );
                exception_tb = NULL;

                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_15 = tmp_mvar_value_22;
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3082;
            {
                PyObject *call_args[] = { tmp_args_element_name_15 };
                tmp_assign_source_13 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
            }

            Py_DECREF( tmp_called_name_9 );
            if ( tmp_assign_source_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3082;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_pykey == NULL );
            var_pykey = tmp_assign_source_13;
        }
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_called_name_10;
            PyObject *tmp_source_name_11;
            PyObject *tmp_mvar_value_23;
            PyObject *tmp_args_element_name_16;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            PyObject *tmp_args_element_name_17;
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_24;
            PyObject *tmp_assattr_target_1;
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_23 == NULL ))
            {
                tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_23 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_11 = tmp_mvar_value_23;
            tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_gc );
            if ( tmp_called_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_pkey );
            tmp_subscribed_name_3 = var_pkey;
            tmp_subscript_name_3 = const_int_0;
            tmp_args_element_name_16 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
            if ( tmp_args_element_name_16 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_10 );

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_24 == NULL ))
            {
                tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_24 == NULL )
            {
                Py_DECREF( tmp_called_name_10 );
                Py_DECREF( tmp_args_element_name_16 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_12 = tmp_mvar_value_24;
            tmp_args_element_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_EVP_PKEY_free );
            if ( tmp_args_element_name_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_10 );
                Py_DECREF( tmp_args_element_name_16 );

                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3083;
            {
                PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17 };
                tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, call_args );
            }

            Py_DECREF( tmp_called_name_10 );
            Py_DECREF( tmp_args_element_name_16 );
            Py_DECREF( tmp_args_element_name_17 );
            if ( tmp_assattr_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_pykey );
            tmp_assattr_target_1 = var_pykey;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__pkey, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3083;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_6:;
    }
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_source_name_13;
        PyObject *tmp_mvar_value_25;
        CHECK_OBJECT( var_cert );
        tmp_subscribed_name_4 = var_cert;
        tmp_subscript_name_4 = const_int_0;
        tmp_compexpr_left_4 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 0 );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

        if (unlikely( tmp_mvar_value_25 == NULL ))
        {
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
        }

        if ( tmp_mvar_value_25 == NULL )
        {
            Py_DECREF( tmp_compexpr_left_4 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
            exception_tb = NULL;

            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_13 = tmp_mvar_value_25;
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_NULL );
        if ( tmp_compexpr_right_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_4 );

            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        Py_DECREF( tmp_compexpr_right_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3085;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_assign_source_14;
            tmp_assign_source_14 = Py_None;
            assert( var_pycert == NULL );
            Py_INCREF( tmp_assign_source_14 );
            var_pycert = tmp_assign_source_14;
        }
        {
            PyObject *tmp_assign_source_15;
            tmp_assign_source_15 = Py_None;
            assert( var_friendlyname == NULL );
            Py_INCREF( tmp_assign_source_15 );
            var_friendlyname = tmp_assign_source_15;
        }
        goto branch_end_7;
        branch_no_7:;
        {
            PyObject *tmp_assign_source_16;
            PyObject *tmp_called_name_11;
            PyObject *tmp_source_name_14;
            PyObject *tmp_mvar_value_26;
            PyObject *tmp_args_element_name_18;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

            if (unlikely( tmp_mvar_value_26 == NULL ))
            {
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
            }

            if ( tmp_mvar_value_26 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
                exception_tb = NULL;

                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_14 = tmp_mvar_value_26;
            tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain__from_raw_x509_ptr );
            if ( tmp_called_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_cert );
            tmp_subscribed_name_5 = var_cert;
            tmp_subscript_name_5 = const_int_0;
            tmp_args_element_name_18 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 0 );
            if ( tmp_args_element_name_18 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_11 );

                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3089;
            {
                PyObject *call_args[] = { tmp_args_element_name_18 };
                tmp_assign_source_16 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
            }

            Py_DECREF( tmp_called_name_11 );
            Py_DECREF( tmp_args_element_name_18 );
            if ( tmp_assign_source_16 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3089;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_pycert == NULL );
            var_pycert = tmp_assign_source_16;
        }
        {
            PyObject *tmp_assign_source_17;
            PyObject *tmp_called_instance_6;
            PyObject *tmp_mvar_value_27;
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_27 == NULL ))
            {
                tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_27 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3091;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_instance_6 = tmp_mvar_value_27;
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3091;
            tmp_assign_source_17 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_new, &PyTuple_GET_ITEM( const_tuple_str_digest_8e9fba48e24a08144a915d52e31f6d23_tuple, 0 ) );

            if ( tmp_assign_source_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3091;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_friendlyname_length == NULL );
            var_friendlyname_length = tmp_assign_source_17;
        }
        {
            PyObject *tmp_assign_source_18;
            PyObject *tmp_called_name_12;
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_28;
            PyObject *tmp_args_element_name_19;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            PyObject *tmp_args_element_name_20;
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_28 == NULL ))
            {
                tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_28 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 3092;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_15 = tmp_mvar_value_28;
            tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_X509_alias_get0 );
            if ( tmp_called_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3092;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_cert );
            tmp_subscribed_name_6 = var_cert;
            tmp_subscript_name_6 = const_int_0;
            tmp_args_element_name_19 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 0 );
            if ( tmp_args_element_name_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_12 );

                exception_lineno = 3093;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_friendlyname_length );
            tmp_args_element_name_20 = var_friendlyname_length;
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3092;
            {
                PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
                tmp_assign_source_18 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_12, call_args );
            }

            Py_DECREF( tmp_called_name_12 );
            Py_DECREF( tmp_args_element_name_19 );
            if ( tmp_assign_source_18 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3092;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_friendlyname_buffer == NULL );
            var_friendlyname_buffer = tmp_assign_source_18;
        }
        {
            PyObject *tmp_assign_source_19;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_called_name_13;
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_29;
            PyObject *tmp_args_element_name_21;
            PyObject *tmp_args_element_name_22;
            PyObject *tmp_subscribed_name_7;
            PyObject *tmp_subscript_name_7;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_29 == NULL ))
            {
                tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_29 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_16 = tmp_mvar_value_29;
            tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_buffer );
            if ( tmp_called_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_friendlyname_buffer );
            tmp_args_element_name_21 = var_friendlyname_buffer;
            CHECK_OBJECT( var_friendlyname_length );
            tmp_subscribed_name_7 = var_friendlyname_length;
            tmp_subscript_name_7 = const_int_0;
            tmp_args_element_name_22 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 0 );
            if ( tmp_args_element_name_22 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_13 );

                exception_lineno = 3096;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3095;
            {
                PyObject *call_args[] = { tmp_args_element_name_21, tmp_args_element_name_22 };
                tmp_slice_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_13, call_args );
            }

            Py_DECREF( tmp_called_name_13 );
            Py_DECREF( tmp_args_element_name_22 );
            if ( tmp_slice_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_19 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
            Py_DECREF( tmp_slice_source_1 );
            if ( tmp_assign_source_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3095;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_friendlyname == NULL );
            var_friendlyname = tmp_assign_source_19;
        }
        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_source_name_17;
            PyObject *tmp_mvar_value_30;
            CHECK_OBJECT( var_friendlyname_buffer );
            tmp_compexpr_left_5 = var_friendlyname_buffer;
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi );

            if (unlikely( tmp_mvar_value_30 == NULL ))
            {
                tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ffi );
            }

            if ( tmp_mvar_value_30 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "_ffi" );
                exception_tb = NULL;

                exception_lineno = 3098;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_17 = tmp_mvar_value_30;
            tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_NULL );
            if ( tmp_compexpr_right_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3098;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            Py_DECREF( tmp_compexpr_right_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 3098;
                type_description_1 = "oooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_8;
            }
            else
            {
                goto branch_no_8;
            }
            branch_yes_8:;
            {
                PyObject *tmp_assign_source_20;
                tmp_assign_source_20 = Py_None;
                {
                    PyObject *old = var_friendlyname;
                    assert( old != NULL );
                    var_friendlyname = tmp_assign_source_20;
                    Py_INCREF( var_friendlyname );
                    Py_DECREF( old );
                }

            }
            branch_no_8:;
        }
        branch_end_7:;
    }
    {
        PyObject *tmp_assign_source_21;
        tmp_assign_source_21 = PyList_New( 0 );
        assert( var_pycacerts == NULL );
        var_pycacerts = tmp_assign_source_21;
    }
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_range_arg_1;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_mvar_value_31;
        PyObject *tmp_args_element_name_23;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_31 == NULL ))
        {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_31 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_7 = tmp_mvar_value_31;
        CHECK_OBJECT( var_cacerts );
        tmp_args_element_name_23 = var_cacerts;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3102;
        {
            PyObject *call_args[] = { tmp_args_element_name_23 };
            tmp_range_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_sk_X509_num, call_args );
        }

        if ( tmp_range_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
        Py_DECREF( tmp_range_arg_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_22 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_22 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3102;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_22;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_23;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_23 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_23 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooooooooooooo";
                exception_lineno = 3102;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_23;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_24;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_24 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_24;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_called_instance_8;
        PyObject *tmp_mvar_value_32;
        PyObject *tmp_args_element_name_24;
        PyObject *tmp_args_element_name_25;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_32 == NULL ))
        {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_32 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3103;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_8 = tmp_mvar_value_32;
        CHECK_OBJECT( var_cacerts );
        tmp_args_element_name_24 = var_cacerts;
        CHECK_OBJECT( var_i );
        tmp_args_element_name_25 = var_i;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3103;
        {
            PyObject *call_args[] = { tmp_args_element_name_24, tmp_args_element_name_25 };
            tmp_assign_source_25 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_8, const_str_plain_sk_X509_value, call_args );
        }

        if ( tmp_assign_source_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3103;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_x509;
            var_x509 = tmp_assign_source_25;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_called_instance_9;
        PyObject *tmp_mvar_value_33;
        PyObject *tmp_args_element_name_26;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_33 == NULL ))
        {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_33 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 3104;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_9 = tmp_mvar_value_33;
        CHECK_OBJECT( var_x509 );
        tmp_args_element_name_26 = var_x509;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3104;
        {
            PyObject *call_args[] = { tmp_args_element_name_26 };
            tmp_assign_source_26 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain__from_raw_x509_ptr, call_args );
        }

        if ( tmp_assign_source_26 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3104;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_pycacert;
            var_pycacert = tmp_assign_source_26;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_10;
        PyObject *tmp_call_result_4;
        PyObject *tmp_args_element_name_27;
        CHECK_OBJECT( var_pycacerts );
        tmp_called_instance_10 = var_pycacerts;
        CHECK_OBJECT( var_pycacert );
        tmp_args_element_name_27 = var_pycacert;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3105;
        {
            PyObject *call_args[] = { tmp_args_element_name_27 };
            tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3105;
            type_description_1 = "oooooooooooooooooo";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_4 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 3102;
        type_description_1 = "oooooooooooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_operand_name_4;
        CHECK_OBJECT( var_pycacerts );
        tmp_operand_name_4 = var_pycacerts;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3106;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_9 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_assign_source_27;
            tmp_assign_source_27 = Py_None;
            {
                PyObject *old = var_pycacerts;
                assert( old != NULL );
                var_pycacerts = tmp_assign_source_27;
                Py_INCREF( var_pycacerts );
                Py_DECREF( old );
            }

        }
        branch_no_9:;
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_called_name_14;
        PyObject *tmp_source_name_18;
        PyObject *tmp_mvar_value_34;
        PyObject *tmp_args_element_name_28;
        PyObject *tmp_mvar_value_35;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12 );

        if (unlikely( tmp_mvar_value_34 == NULL ))
        {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12 );
        }

        if ( tmp_mvar_value_34 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS12" );
            exception_tb = NULL;

            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_18 = tmp_mvar_value_34;
        tmp_called_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain___new__ );
        if ( tmp_called_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12 );

        if (unlikely( tmp_mvar_value_35 == NULL ))
        {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12 );
        }

        if ( tmp_mvar_value_35 == NULL )
        {
            Py_DECREF( tmp_called_name_14 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PKCS12" );
            exception_tb = NULL;

            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_28 = tmp_mvar_value_35;
        frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame.f_lineno = 3109;
        {
            PyObject *call_args[] = { tmp_args_element_name_28 };
            tmp_assign_source_28 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
        }

        Py_DECREF( tmp_called_name_14 );
        if ( tmp_assign_source_28 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3109;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pkcs12 == NULL );
        var_pkcs12 = tmp_assign_source_28;
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( var_pykey );
        tmp_assattr_name_2 = var_pykey;
        CHECK_OBJECT( var_pkcs12 );
        tmp_assattr_target_2 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__pkey, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3110;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( var_pycert );
        tmp_assattr_name_3 = var_pycert;
        CHECK_OBJECT( var_pkcs12 );
        tmp_assattr_target_3 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__cert, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3111;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT( var_pycacerts );
        tmp_assattr_name_4 = var_pycacerts;
        CHECK_OBJECT( var_pkcs12 );
        tmp_assattr_target_4 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__cacerts, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3112;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        if ( var_friendlyname == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "friendlyname" );
            exception_tb = NULL;

            exception_lineno = 3113;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_assattr_name_5 = var_friendlyname;
        CHECK_OBJECT( var_pkcs12 );
        tmp_assattr_target_5 = var_pkcs12;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__friendlyname, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3113;
            type_description_1 = "oooooooooooooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 1
    RESTORE_FRAME_EXCEPTION( frame_0428bad59ec7b5a66149d8e2c88e0cb2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_0428bad59ec7b5a66149d8e2c88e0cb2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0428bad59ec7b5a66149d8e2c88e0cb2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0428bad59ec7b5a66149d8e2c88e0cb2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0428bad59ec7b5a66149d8e2c88e0cb2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0428bad59ec7b5a66149d8e2c88e0cb2,
        type_description_1,
        par_buffer,
        par_passphrase,
        var_bio,
        var_pykey,
        var_x509,
        var_friendlyname_buffer,
        var_pkey,
        var_i,
        var_cert,
        var_cacerts,
        var_pycert,
        var_friendlyname_length,
        var_p12,
        var_pycacert,
        var_pkcs12,
        var_friendlyname,
        var_pycacerts,
        var_parse_result
    );


    // Release cached frame.
    if ( frame_0428bad59ec7b5a66149d8e2c88e0cb2 == cache_frame_0428bad59ec7b5a66149d8e2c88e0cb2 )
    {
        Py_DECREF( frame_0428bad59ec7b5a66149d8e2c88e0cb2 );
    }
    cache_frame_0428bad59ec7b5a66149d8e2c88e0cb2 = NULL;

    assertFrameObject( frame_0428bad59ec7b5a66149d8e2c88e0cb2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_pkcs12 );
    tmp_return_value = var_pkcs12;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_157_load_pkcs12 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_bio );
    Py_DECREF( var_bio );
    var_bio = NULL;

    CHECK_OBJECT( (PyObject *)var_pykey );
    Py_DECREF( var_pykey );
    var_pykey = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    Py_XDECREF( var_friendlyname_buffer );
    var_friendlyname_buffer = NULL;

    CHECK_OBJECT( (PyObject *)var_pkey );
    Py_DECREF( var_pkey );
    var_pkey = NULL;

    CHECK_OBJECT( (PyObject *)par_buffer );
    Py_DECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)var_cert );
    Py_DECREF( var_cert );
    var_cert = NULL;

    CHECK_OBJECT( (PyObject *)var_cacerts );
    Py_DECREF( var_cacerts );
    var_cacerts = NULL;

    CHECK_OBJECT( (PyObject *)var_pycert );
    Py_DECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_friendlyname_length );
    var_friendlyname_length = NULL;

    CHECK_OBJECT( (PyObject *)var_p12 );
    Py_DECREF( var_p12 );
    var_p12 = NULL;

    Py_XDECREF( var_pycacert );
    var_pycacert = NULL;

    CHECK_OBJECT( (PyObject *)var_pkcs12 );
    Py_DECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    CHECK_OBJECT( (PyObject *)par_passphrase );
    Py_DECREF( par_passphrase );
    par_passphrase = NULL;

    Py_XDECREF( var_friendlyname );
    var_friendlyname = NULL;

    CHECK_OBJECT( (PyObject *)var_pycacerts );
    Py_DECREF( var_pycacerts );
    var_pycacerts = NULL;

    CHECK_OBJECT( (PyObject *)var_parse_result );
    Py_DECREF( var_parse_result );
    var_parse_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_bio );
    var_bio = NULL;

    Py_XDECREF( var_pykey );
    var_pykey = NULL;

    Py_XDECREF( var_x509 );
    var_x509 = NULL;

    Py_XDECREF( var_friendlyname_buffer );
    var_friendlyname_buffer = NULL;

    Py_XDECREF( var_pkey );
    var_pkey = NULL;

    Py_XDECREF( par_buffer );
    par_buffer = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_cert );
    var_cert = NULL;

    Py_XDECREF( var_cacerts );
    var_cacerts = NULL;

    Py_XDECREF( var_pycert );
    var_pycert = NULL;

    Py_XDECREF( var_friendlyname_length );
    var_friendlyname_length = NULL;

    Py_XDECREF( var_p12 );
    var_p12 = NULL;

    Py_XDECREF( var_pycacert );
    var_pycacert = NULL;

    Py_XDECREF( var_pkcs12 );
    var_pkcs12 = NULL;

    Py_XDECREF( par_passphrase );
    par_passphrase = NULL;

    Py_XDECREF( var_friendlyname );
    var_friendlyname = NULL;

    Py_XDECREF( var_pycacerts );
    var_pycacerts = NULL;

    Py_XDECREF( var_parse_result );
    var_parse_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( OpenSSL$crypto$$$function_157_load_pkcs12 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_100_dump_privatekey( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_100_dump_privatekey,
        const_str_plain_dump_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1ac471aeb3398883ade56d46d3bdeb44,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c71c443223c73b253b21961ef3bd7c9e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_101___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_101___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_338fb2696ad7e2b451292dd99118ec51,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_102_set_serial(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_102_set_serial,
        const_str_plain_set_serial,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_72a795899dc57920294fb3185d7828f7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8bcf6e6fbaf96377cbe58ba9960c9d58,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_103_get_serial(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_103_get_serial,
        const_str_plain_get_serial,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0dec7b6420a8d454a6e5ea62e48a57d6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_007f81c06fa49e709fd9306cc6c26627,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_104__delete_reason(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_104__delete_reason,
        const_str_plain__delete_reason,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3c27bf579b7f947bd398a69e11f418fa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_reason(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_105_set_reason,
        const_str_plain_set_reason,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a1652d3a4f682aed85a3fb220e328368,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a12e23c82fcdd4004653da2260294f18,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_reason(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_106_get_reason,
        const_str_plain_get_reason,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_112f2bcd9e9fd44144e9a47985cb3c6d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_435662c26b2c422edb954b82c85c55d9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_107_all_reasons(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_107_all_reasons,
        const_str_plain_all_reasons,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f29a38d7c45651595cf6aedace7de9aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4097a084fab55cf5c5baa1b785e7c82a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_rev_date(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_108_set_rev_date,
        const_str_plain_set_rev_date,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c110c2c8fcfc71619c84f105eb89bce4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_11e1356f3459cf012eb88d7288e20e85,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_rev_date(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_109_get_rev_date,
        const_str_plain_get_rev_date,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_647ba6ed33a4f2ae30ef81b1cc6e4aa6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1ca413f5b66374db6a573ac0926a99ae,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_10___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1e9a0d222889b318a7dbd80de8f45303,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_110___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_110___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ee9f0393ec340507f2d7d8df847a43a2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_111_to_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_111_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ac9f6b5c97ade7871513f9832183e591,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2f591e55cc116ed5223c119e2f7da344,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_112_from_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_112_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_04292aa6779241fb95227d0370adeed4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f56881bccbbc40c6643f9603628e7a5c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_113_get_revoked(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_113_get_revoked,
        const_str_plain_get_revoked,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0bd74d7e47065b77cbb33b10a13c07c3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0b9d4db9119537682a1f5302a9cbcc57,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_114_add_revoked(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_114_add_revoked,
        const_str_plain_add_revoked,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c544d0701ee1c350826d019a78afa8e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_880f67f2b28115a7ad1d1bfb533fc6bc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_115_get_issuer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_115_get_issuer,
        const_str_plain_get_issuer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a622427fd2cf1844f047e5dc915ecd01,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_48639cf22fbd4e6b3714265dae0dbed8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_116_set_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_116_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9cbe3542cb01bdd5c50f6b4b4e305557,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0b708bb28192f1a165c843c47343f35a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_117__set_boundary_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_117__set_boundary_time,
        const_str_plain__set_boundary_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_50e52f8de0f444400c5e7caf8a75aef0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_118_set_lastUpdate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_118_set_lastUpdate,
        const_str_plain_set_lastUpdate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3cf211d19041a0548596ace3209e1f70,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_333948d9e51f0e161201a16305959930,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_nextUpdate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_119_set_nextUpdate,
        const_str_plain_set_nextUpdate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5a01e627c9af2bcd87343071c673f76b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2c2564e59b067260d7d96d252fc73cd1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_11_to_cryptography_key,
        const_str_plain_to_cryptography_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_412e6657a113f901d16d6c82c1c25936,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_26a65c58106d086427e37cb87b0bc3b3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_120_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_120_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e01ada03e6cb97935670c2ece19dcde1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cf86a9123926465ab14a7bd2861326f6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_121_export( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_121_export,
        const_str_plain_export,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_301abfeda8d0b6cd2206b5e57a81b467,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_14af5bef46557b92b5b6c4d670b7a1b8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_122_type_is_signed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_122_type_is_signed,
        const_str_plain_type_is_signed,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_298c62d2e62c4e7e7c771a8483b79517,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c384f9f99d5890cd2aae342c30dbaa14,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_123_type_is_enveloped(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_123_type_is_enveloped,
        const_str_plain_type_is_enveloped,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bb28aa15be6d6ac10ac98d4bd673db31,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_40ce736ad6e52bc3df10a00233b89318,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped,
        const_str_plain_type_is_signedAndEnveloped,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_572d929a0f50dfeb4faf9840be0cf071,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a078d66f5fc281c4117a5e5c24749809,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_125_type_is_data,
        const_str_plain_type_is_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6488d3c4867ccfec75048bca1c93e024,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_90de967a5219b9210479f7eac5c285c8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_126_get_type_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_126_get_type_name,
        const_str_plain_get_type_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_96e0f2ade3ce600a5c007e498e0f3fcd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_782fa7272fdd3d3abdc1a0298e5e83fc,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_127___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_127___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a2c62897603cb5a7fc5a6b08caea1638,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_128_get_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_128_get_certificate,
        const_str_plain_get_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b54bdbd0210e46dca8f052dcb4a34ee3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f68048107421fed17c8f1bc19be3ec03,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_129_set_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_129_set_certificate,
        const_str_plain_set_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9e5962b9332e672b73dffe75490da895,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_62c9c3f244d467c166be64cd38a755a7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_12_from_cryptography_key,
        const_str_plain_from_cryptography_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_71fdf953dd46d53e76e9fdeae2b36d1e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ffd290e8bf49a587d94041b1fd6c3c55,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_130_get_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_130_get_privatekey,
        const_str_plain_get_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d2db5d6448098f1cdeaafc369e0dd5e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a9bcf1af78e6d912e13685d8a606fe30,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_131_set_privatekey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_131_set_privatekey,
        const_str_plain_set_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_06feef7fc51c36afe8e827ad79ecfbd2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5e37d069c5e76ee6d50c7e91b7181934,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_132_get_ca_certificates(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_132_get_ca_certificates,
        const_str_plain_get_ca_certificates,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8c372eaf0ec75aac95b57337ae37f3da,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_978cd476d4acffdfb043e6a5e0ebae26,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_133_set_ca_certificates(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_133_set_ca_certificates,
        const_str_plain_set_ca_certificates,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5d7ca7a86f1a69e3c52554fdf475aba9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9781f115d6516693d922717b11376a73,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_friendlyname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_134_set_friendlyname,
        const_str_plain_set_friendlyname,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_43c017e77c6895e242ea62099ae753ac,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9c28b2ef32679900c21c54152be8ce03,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_friendlyname(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_135_get_friendlyname,
        const_str_plain_get_friendlyname,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b1465cc56b7c48e5a832bb947da5804f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4357c956c1f3628f437632877b5d8593,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_136_export( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_136_export,
        const_str_plain_export,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8a10d3a4b3ce5d07432c2f893bb983ea,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_44f664275c70041c9ae4bef2565506f3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_137___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_137___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9b9fe3cd704764cfc5a24bfccdf88473,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_138_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_138_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f6c90cffa233150a81ae6bcf5966b415,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_03f3989a7f0f1ec9623bd001f5a005a7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_139_verify(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_139_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bcef8ad01db68d820609cb6453b5f512,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5699814601a04aa972bd2f18de396c39,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_13_generate_key,
        const_str_plain_generate_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b4af7bab50c450318505ff73850146b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9a71d9e6319c409dff859e67083fc41c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_140_b64_encode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_140_b64_encode,
        const_str_plain_b64_encode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_36498b0149329ae65dad35a28b8821d9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_af63c2663b0a5e83daac69d308dcb1d6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_141_get_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_141_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8b83c9708fea4b878e013c45136fd234,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3b5fd85224219fd172d589ec8f98a12a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_142_set_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_142_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a433b20a090f9b3cd7a05e3cc8726b20,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_686e4f9f1c51b7038afe792590c33346,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_143___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_143___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d964ee3167a18a9a588e49cbd6499968,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_144_callback(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_144_callback,
        const_str_plain_callback,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_174bb49227fddc62e7f6e6dd1564c881,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_145_callback_args(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_145_callback_args,
        const_str_plain_callback_args,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2c29d90d26933595e91a312e32e549af,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_146_raise_if_problem( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_146_raise_if_problem,
        const_str_plain_raise_if_problem,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7b59db8d8529b0892574d3e63b0668e4,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_147__read_passphrase(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_147__read_passphrase,
        const_str_plain__read_passphrase,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3ee8a1e08a2e2b1ed44dccfa5075f32a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_148_load_publickey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_148_load_publickey,
        const_str_plain_load_publickey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0dfc2596049ebde55e199985efd3a197,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0a3eb1716e7caaaf09c8582b572bcb60,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_149_load_privatekey( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_149_load_privatekey,
        const_str_plain_load_privatekey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3cc7e9e47e498ec30d4ee192b216714d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f41f911aba33894e1da796354264d96a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_14_check,
        const_str_plain_check,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_021a09f6ae6938555af0896436365d60,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8db7448b8246dd51f74c33bda58590bd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_150_dump_certificate_request(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_150_dump_certificate_request,
        const_str_plain_dump_certificate_request,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_713cab84aff1c754e3062c3169ef4209,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_97388c7ddfea4f913fec5c846dd26ef1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_certificate_request(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_151_load_certificate_request,
        const_str_plain_load_certificate_request,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_67f4c23d4eea6c453c888d6f47275f62,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1c1759444507dc6d4c0d7b4ce6b62611,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_152_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_152_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7b18b41aa1a7fb07c2565ad2e80412f3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d6b3262f79e4b59cd83ab54699c92117,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_153_verify(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_153_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d973aa6ad6702c4cbe398efc4bf93b64,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_9acbe023ce14d1d2ba528bd23b2423a0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_154_dump_crl(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_154_dump_crl,
        const_str_plain_dump_crl,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c1d3d7e0cb19e2d22f67d229f398e65f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_721230a42e287d5632d061ff8f0376d6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_155_load_crl(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_155_load_crl,
        const_str_plain_load_crl,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b149ec0eb89f519088e871e4ad91a2cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_05b2bb16e6ee73fd972536e52cc4cabf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_156_load_pkcs7_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_156_load_pkcs7_data,
        const_str_plain_load_pkcs7_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_206aa892821ceb22b8152788bccc5cec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1565887baecc678658a50e7d1f245653,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_157_load_pkcs12( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_157_load_pkcs12,
        const_str_plain_load_pkcs12,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0428bad59ec7b5a66149d8e2c88e0cb2,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_75a631b53fc267af68d162051a06411c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_15_type,
        const_str_plain_type,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dbc23fd6b5a9b4b62f8f2245725b8cc9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c237653198d1acecae3452511968b22e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_16_bits,
        const_str_plain_bits,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_457291e3f25809c88b1764bd146b0304,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a658b60d9bffa55a9bdfb85ba96aec98,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_17___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_34cc9897f64823e467bbb021110e428b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_4d14f6e4d6647c6573e3ca9449c2b51f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_18__load_elliptic_curves,
        const_str_plain__load_elliptic_curves,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3f35dc87711e3416ee84ceaf5ce82fc4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_74b73fd54833bfb6b761307c477c0a28,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_19__get_elliptic_curves,
        const_str_plain__get_elliptic_curves,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f1b4064961f0e278b8e11fc39e19cd03,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7de17ac920010129977e4280610f275c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_1__get_backend,
        const_str_plain__get_backend,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_475e786458065e1c4a97a0ef87abac1c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d03be6fc9f3e6729b366e69e0856a450,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_20_from_nid,
        const_str_plain_from_nid,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_61d8a1f2a778a009244666e966ebfedc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0ba82c04a076f46925a74539c2a8ba40,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_21___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_50fc6fa6c0ba7d87e3e63c2bfa99b0ec,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f76c1a90d81cc9627b0b6df42991dbc9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_22___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d0de697e0ff0841e276f18046e633c8c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_23__to_EC_KEY,
        const_str_plain__to_EC_KEY,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_751e01039a709a9872d0145d6873cd38,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c4a5d29f3ecd810d59e3d04a7a935f38,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_24_get_elliptic_curves,
        const_str_plain_get_elliptic_curves,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_598b2e7282a2c0052171ad54e31c80cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3121be4a855650e38916196ca238bf2b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_25_get_elliptic_curve,
        const_str_plain_get_elliptic_curve,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c02f074eb4c422487aa6b3df9c1e1e4d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f583009b639aad56f3c96c175e595626,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_26___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b3eeb60a67b100f9108e6a5c3cf04ffc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_12c1bc175ad6309f9cfc24942b8c76ac,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_27___setattr__,
        const_str_plain___setattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d7b026a4f1f66fd2b9e84f2cfbc64af8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_28___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d860a737664a16683e8d212dd9ae54eb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c7bf9684574689f7d764ff6fbd5eab60,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_29__cmp,
        const_str_plain__cmp,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4e2b2ba154ff2752acf2cd9a9d89cc43,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp$$$function_1_f(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_29__cmp$$$function_1_f,
        const_str_plain_f,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1772a6013264994a984e605cd7a40693,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_2__untested_error,
        const_str_plain__untested_error,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6f027376d854b905b5ee53119d46201b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_de1d9872d12371b2ead20f3aa79dc834,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_30___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_78f117206d8a841a588d9bb177b70ecd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_463cb3c7dbe7753c6683d3195629dca3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_31_hash,
        const_str_plain_hash,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f108fefac443a30560644004e534a6dd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e4c79524acf8a72de25c6c6491f370a8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_32_der,
        const_str_plain_der,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_459e5c608fc9cc34bd5565608d5b7717,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_61d70cefdce1472400ab8a06d64ef78a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_33_get_components,
        const_str_plain_get_components,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d8c8cfa251a7ea6bd085c75d033cb23e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7e62ce69c000886ecc0ae0b3e8ae9e79,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_34___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9ff3a88728c4c3ad3cab48c082dc7fb8,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_152d11f8848fac60442a26592ab3da87,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_35__nid,
        const_str_plain__nid,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_78e8acd21cb941da83b042ef8579466b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_36__subjectAltNameString,
        const_str_plain__subjectAltNameString,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c99ce10f3d0860a31e6597cc2063e968,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_37___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f3d95c9a6254aa6ef78af56f493d9f8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5bd123cbe57a454c8d9d37867b598cb2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_38_get_critical,
        const_str_plain_get_critical,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_07e8a0b0547d18c5e7adbf11c5000bd2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5f245d1740d80da82563e21c9c4f4fbf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_39_get_short_name,
        const_str_plain_get_short_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cf6f76fdcb2c9248257e81564c818063,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_213346f5e36f3faf7ff7a566deec4adb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_3__new_mem_buf,
        const_str_plain__new_mem_buf,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_82c4e32bfec555b110886c6016f6efba,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1a7a898c4490dd89b305492a40bf2633,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_3__new_mem_buf$$$function_1_free,
        const_str_plain_free,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0e95773403f38cc930f5b88f7ea092a0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_40_get_data,
        const_str_plain_get_data,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_95f4633cd0b82a09b30e9e453fe96c0e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_719137938e890576c1050ba31a668078,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_41___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_507773a59fe1a3d6025f2d54e3fa4c0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_42_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_209bfbe606aa2e251590784a110971a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_66b2a3b8e35254752e96fbbddc255dfd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_43_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e73694d63eb3a283fa48580107273fb0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b16563a844474e8eed4710209909ab32,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_44_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_68a36fb583f00099fdddf6bbbc375aee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ab9563b0fc32f09cfde9a1636d8d2b80,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_45_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8c37e52f9e85331b386989d0fa841a7d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_07697dd6fa4854473fa24b52569d5636,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_46_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8e211ad8a1c8e21a1a72dcaf0e373537,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_b2d5bbfa3f949ddcc231b89e71aa8d92,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_47_get_version,
        const_str_plain_get_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_417f224a16eb9c304a2c9c356d7916aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_ac089bdfaafc466d410fc6ffe7dfee50,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_48_get_subject,
        const_str_plain_get_subject,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c707a22aafaa65d7b3d974108e264db4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cac81eaf46e08badbc89f13fa3bbdf6b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_49_add_extensions,
        const_str_plain_add_extensions,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0d0a6cfa23df0134bf276c6438f2ab9f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_52cbe8d655a10e46907a30970ef9889a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_4__bio_to_string,
        const_str_plain__bio_to_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8baf017b3c354fe764f7b750d89261a3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_859c7c43c5cf3124cdd58374d6e7359e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_50_get_extensions,
        const_str_plain_get_extensions,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5a0f6d45c706c470bc2bce1f1d87be1f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2e4273bc9cbcc16bcfe5bca70ee1b585,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_51_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_587512bae47cea562886e765c3184c29,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_cd7d7b6c262cf257f5bafa26f39b567e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_52_verify,
        const_str_plain_verify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d05172d050310e43eef8f47311a18aa3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0d3c537bf958e2cc2494cf1be5c283dd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_53___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a0582cf67145aa1223c5c2d1c9e689f4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_54__from_raw_x509_ptr,
        const_str_plain__from_raw_x509_ptr,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0589830efba91376579341caa89dd6a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_55_to_cryptography,
        const_str_plain_to_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ac5cf5ddb389d171d9f49512989a34d2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f737de4a45174195dc1e46101235dc35,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_56_from_cryptography,
        const_str_plain_from_cryptography,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1e309d622f57f1df6afb5655a5cbc12f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1f681e9f80c6df652cbc3a085be49171,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_57_set_version,
        const_str_plain_set_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_10bd3e802582e0d9c677ad46e3411b69,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_603c60edaf58a8746faa757f20f3f938,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_58_get_version,
        const_str_plain_get_version,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5143552858fa1f886627571bace5fd5b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c47cfcedcc7803c0a6ef28b85213e16f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_59_get_pubkey,
        const_str_plain_get_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_856ed1c292c994af7bfce0923beed35a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_11dbf726734533c622c12e725d15648e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_5__set_asn1_time,
        const_str_plain__set_asn1_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b2f2763c19dc9c314be26f15048c5fd6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_670c62a34c6767f6ecd5db6f969b2f34,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_60_set_pubkey,
        const_str_plain_set_pubkey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5cb75a6ba9401b5ee9f8f9fd264c5f1e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a7eaace656db47cf2975484b27c818e9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_61_sign,
        const_str_plain_sign,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ff3315c115fcc0322838af618aa26d9c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_685b3ded6e482839a3710e6a448d8669,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_62_get_signature_algorithm,
        const_str_plain_get_signature_algorithm,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3e38fc9f9c9ed1ca78f0a360ad365d63,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_79b48b443a4edf88bd64a278e98529d3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_63_digest,
        const_str_plain_digest,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_83351a66f26ebd1513f374fe4435cbc6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_5cb0319d0378026eb0ef49838e525520,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_64_subject_name_hash,
        const_str_plain_subject_name_hash,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c474aed261102d3b5e4f6b3f98e8fe00,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e69f89000e2dc720ec6a70b8f9cb0cac,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_65_set_serial_number,
        const_str_plain_set_serial_number,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0c71584586f74ec422d71fb95ed763aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_6b664ec0d0974a050be8b09b84bd0a5d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_66_get_serial_number,
        const_str_plain_get_serial_number,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_de4c7e237ff7a4f38726d637549766fd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_7d6056c968d1eebfab898757e6f3054e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter,
        const_str_plain_gmtime_adj_notAfter,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3fc7b9425fa546666c4ea6616c19376d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a643e6a1050d6f3782a0d190235d80a7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore,
        const_str_plain_gmtime_adj_notBefore,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6f4b7a8a0a555afc1990275873d5d9ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0807c1b9c5bc0ac3cc25375c4a9ebb2e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_69_has_expired,
        const_str_plain_has_expired,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_da38dadd4eb8df9253df88a35a690ea3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8ad6e418a1b04e7939cf7e738b8257d2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_6__get_asn1_time,
        const_str_plain__get_asn1_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_729446125c4d798b28cb589d422e8d78,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_c0aedec8dc85440d3dace529a9d9050e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_70__get_boundary_time,
        const_str_plain__get_boundary_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0d1f0497dba37a9b164ae4b60dcd4d90,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_71_get_notBefore,
        const_str_plain_get_notBefore,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d4151e0f9a9e8aa47862a42aa12c8f43,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_60cf4d81fa4ac0fb8a6d16cafc145b24,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_72__set_boundary_time,
        const_str_plain__set_boundary_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3127dbe27680f0c65ac42a57d59c9b15,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_73_set_notBefore,
        const_str_plain_set_notBefore,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dbe86b73598b46271e67f0b9f613c00a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f35548e1d45f67292233a83f1d0adcce,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_74_get_notAfter,
        const_str_plain_get_notAfter,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9c55547d55b45e1f2119700eb745837a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_35e2a27cee76091329550405e1cb7dc4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_75_set_notAfter,
        const_str_plain_set_notAfter,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f8c39137ff00684bc5503c4fb8f68575,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e335a7c8a0dd4d8ab6096b1597d79143,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_76__get_name,
        const_str_plain__get_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_87faf2505fcb253335d3ffaa0e318e59,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_77__set_name,
        const_str_plain__set_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a6726744ebe17f9af48cee0d79422468,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_78_get_issuer,
        const_str_plain_get_issuer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fd58d0714ce26a74bd1e7f490fd4c5d4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_40e46351c3b918f338d6e675fea0b1ca,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_79_set_issuer,
        const_str_plain_set_issuer,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8871586b9593b7dcfe1a8959b4852b60,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_92b8d1a7fa93b4e7d2fab02e37bc15f8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_7___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_10b38ed4f0743b3bdeee62d537a0c90a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_80_get_subject,
        const_str_plain_get_subject,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ebc8c731c4308b3df5f2999eec8135b7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_2f350f536232587387680a9435c758f6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_81_set_subject,
        const_str_plain_set_subject,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ae1f066821a09f20b88eb8608a297549,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_e2d5c2f473553b6759cc455da987e04a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_82_get_extension_count,
        const_str_plain_get_extension_count,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4c8ce226b675a3a62920440c65572b34,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_3f7d687efa133ae490fe62a28c3c2584,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_83_add_extensions,
        const_str_plain_add_extensions,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_eaea0b733ecd041102dac535c4e48296,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_141cd36b231fb1bf7caa692f86984b7e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_84_get_extension,
        const_str_plain_get_extension,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_36dd5b9a4d1d6a7dc1fc5a680c728521,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d0137950921f709b6c00a3276a078e5f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_85___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_87626e6c1de4d18891ada0519a066a50,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_86_add_cert,
        const_str_plain_add_cert,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dbc361cccf29968e2e8df96cd0cf2935,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_866d2e2176ccb47ef7515cbc6c993151,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_87_add_crl,
        const_str_plain_add_crl,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_bbd2a92a2023b917b723ee2bdc574a0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_998fe297d663eb0475d60a56d2b84182,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_88_set_flags,
        const_str_plain_set_flags,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e2e9d6475353a0461a1bce66bbc0f03f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1d1fec7c0642196df296efbe43db1801,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_89_set_time,
        const_str_plain_set_time,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3fea67ca1b07373944ae6c41f77a4858,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_1d608c98cc8048d3f7b439059ee29b66,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_8_add,
        const_str_plain_add,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a07fd4d8b0764d77370791e3c0281e5f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_90___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_90___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5b8fb2eb4576f5266e57e0af3d70a55b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_91___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_01b9cb7c90c52be647b05193f717878b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_92__init(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_92__init,
        const_str_plain__init,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e290698928eff63f6a91ddfadc9c203c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_32726a73c20427f70712d109be7712b4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_93__cleanup(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_93__cleanup,
        const_str_plain__cleanup,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0b3107fda7e0aa194200a083196e49c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_61dbd227935e54cb40eecc7de8b8596b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_94__exception_from_context(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_94__exception_from_context,
        const_str_plain__exception_from_context,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_064c50c5cfb37771136fe7d568d247de,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_8fda740163dc7d07c78736dc2ebb17b1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_95_set_store(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_95_set_store,
        const_str_plain_set_store,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_eabc0b3b7063d9f47931e06c3b6106e5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_d85051204198165c5d51e35c1e5d5077,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_96_verify_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_96_verify_certificate,
        const_str_plain_verify_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8f0dacae7ab4b4acc4d0b5ce81fc6ce2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_a2b9bb33a11d02b696dfc736bf45c56d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_97_load_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_97_load_certificate,
        const_str_plain_load_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_84b1e7e21b5757c80ed4f13ea2afff02,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_f979ae5e9b0a9a41a05276169a44e7e9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_98_dump_certificate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_98_dump_certificate,
        const_str_plain_dump_certificate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_14e959ce713a9ebb06e99f8e969e2b76,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_193e0ef9a8bffd6c41bf909f2da817bd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_99_dump_publickey(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_99_dump_publickey,
        const_str_plain_dump_publickey,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0259a49d9dc1def6fc738b9fed343645,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        const_str_digest_0d8911e895179dcd467b4e9de2f411d4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_OpenSSL$crypto$$$function_9_clear,
        const_str_plain_clear,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5379defb662177ec26632ddbc4192577,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_OpenSSL$crypto,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_OpenSSL$crypto =
{
    PyModuleDef_HEAD_INIT,
    "OpenSSL.crypto",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;

extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( OpenSSL$crypto )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_OpenSSL$crypto );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("OpenSSL.crypto: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.crypto: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("OpenSSL.crypto: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initOpenSSL$crypto" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_OpenSSL$crypto = Py_InitModule4(
        "OpenSSL.crypto",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_OpenSSL$crypto = PyModule_Create( &mdef_OpenSSL$crypto );
#endif

    moduledict_OpenSSL$crypto = MODULE_DICT( module_OpenSSL$crypto );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_OpenSSL$crypto,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$crypto,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_OpenSSL$crypto,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_OpenSSL$crypto );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_digest_6d237a1253b74549ee18fb0e488e3cf9, module_OpenSSL$crypto );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_18__class = NULL;
    PyObject *tmp_class_creation_18__class_dict = NULL;
    PyObject *tmp_class_creation_18__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_import_from_2__module = NULL;
    PyObject *tmp_import_from_3__module = NULL;
    PyObject *tmp_import_from_4__module = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_add_cert = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_add_crl = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_set_flags = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1576_key_set_time = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1694_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key__cleanup = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key__exception_from_context = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key__init = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key_set_store = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1708_key_verify_certificate = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key__crl_reasons = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key__delete_reason = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_all_reasons = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_get_reason = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_get_rev_date = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_get_serial = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_set_reason = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_set_rev_date = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_1953_key_set_serial = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_206_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_206_key_add = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_206_key_clear = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_get_type_name = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_data = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_signed = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_export = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_certificate = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_get_privatekey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_certificate = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2399_key_set_privatekey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key___init__ = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_b64_encode = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_get_pubkey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_set_pubkey = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_sign = NULL;
    PyObject *tmp_locals_OpenSSL$crypto_2580_key_verify = NULL;
    struct Nuitka_FrameObject *frame_57aaabf758aa7c8c4a6e68a7dcea7c0c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    int tmp_res;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *locals_OpenSSL$crypto_219 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_746bb3fa3035767ed3cd36b6784141e9_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_746bb3fa3035767ed3cd36b6784141e9_2 = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *locals_OpenSSL$crypto_377 = NULL;
    struct Nuitka_FrameObject *frame_815faf1bae776438a2806f882aa20cdb_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_815faf1bae776438a2806f882aa20cdb_3 = NULL;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_OpenSSL$crypto_516 = NULL;
    struct Nuitka_FrameObject *frame_282c2f71fc2cfcb78842aae5c1418e1a_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_282c2f71fc2cfcb78842aae5c1418e1a_4 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *locals_OpenSSL$crypto_716 = NULL;
    struct Nuitka_FrameObject *frame_e115d65213e4a52485ea15b6051b88e9_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_e115d65213e4a52485ea15b6051b88e9_5 = NULL;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *locals_OpenSSL$crypto_874 = NULL;
    struct Nuitka_FrameObject *frame_1642adfffc73b068bfa3ff06f1921759_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_1642adfffc73b068bfa3ff06f1921759_6 = NULL;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *locals_OpenSSL$crypto_1080 = NULL;
    struct Nuitka_FrameObject *frame_053b533781a7f6d764fff943a8c7efe9_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_053b533781a7f6d764fff943a8c7efe9_7 = NULL;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *locals_OpenSSL$crypto_1553 = NULL;
    struct Nuitka_FrameObject *frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 = NULL;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *locals_OpenSSL$crypto_2123 = NULL;
    struct Nuitka_FrameObject *frame_762cff70b659b0b1614f9749662cbdb5_9;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    static struct Nuitka_FrameObject *cache_frame_762cff70b659b0b1614f9749662cbdb5_9 = NULL;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *locals_OpenSSL$crypto_2677 = NULL;
    struct Nuitka_FrameObject *frame_cf6295d0383197dc8a74dbef60884f33_10;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    static struct Nuitka_FrameObject *cache_frame_cf6295d0383197dc8a74dbef60884f33_10 = NULL;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_str_digest_bb6f5ad807179d7105a669c98779d984;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_datetime;
        tmp_globals_name_1 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        tmp_assign_source_3 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        assert( !(tmp_assign_source_3 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_datetime, tmp_assign_source_3 );
    }
    // Frame without reuse.
    frame_57aaabf758aa7c8c4a6e68a7dcea7c0c = MAKE_MODULE_FRAME( codeobj_57aaabf758aa7c8c4a6e68a7dcea7c0c, module_OpenSSL$crypto );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_57aaabf758aa7c8c4a6e68a7dcea7c0c );
    assert( Py_REFCNT( frame_57aaabf758aa7c8c4a6e68a7dcea7c0c ) == 2 );

    // Framed code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        tmp_name_name_2 = const_str_plain_base64;
        tmp_globals_name_2 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = const_tuple_str_plain_b16encode_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 3;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_b16encode );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_b16encode, tmp_assign_source_4 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_import_name_from_2;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        tmp_name_name_3 = const_str_plain_functools;
        tmp_globals_name_3 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = const_tuple_str_plain_partial_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 4;
        tmp_import_name_from_2 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
        if ( tmp_import_name_from_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 4;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_partial );
        Py_DECREF( tmp_import_name_from_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 4;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_5 );
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        tmp_name_name_4 = const_str_plain_operator;
        tmp_globals_name_4 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = const_tuple_8291ba4d3b501c7d6047aff9c84147fc_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 5;
        tmp_assign_source_6 = IMPORT_MODULE4( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4 );
        assert( !(tmp_assign_source_6 == NULL) );
        assert( tmp_import_from_1__module == NULL );
        tmp_import_from_1__module = tmp_assign_source_6;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_import_name_from_3;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_3 = tmp_import_from_1__module;
        tmp_assign_source_7 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain___eq__ );
        assert( !(tmp_assign_source_7 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___eq__, tmp_assign_source_7 );
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_import_name_from_4;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_4 = tmp_import_from_1__module;
        tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain___ne__ );
        assert( !(tmp_assign_source_8 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ne__, tmp_assign_source_8 );
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_import_name_from_5;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_5 = tmp_import_from_1__module;
        tmp_assign_source_9 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain___lt__ );
        assert( !(tmp_assign_source_9 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___lt__, tmp_assign_source_9 );
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_import_name_from_6;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_6 = tmp_import_from_1__module;
        tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain___le__ );
        assert( !(tmp_assign_source_10 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___le__, tmp_assign_source_10 );
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_import_name_from_7;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_7 = tmp_import_from_1__module;
        tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain___gt__ );
        assert( !(tmp_assign_source_11 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___gt__, tmp_assign_source_11 );
    }
    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_import_name_from_8;
        CHECK_OBJECT( tmp_import_from_1__module );
        tmp_import_name_from_8 = tmp_import_from_1__module;
        tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain___ge__ );
        assert( !(tmp_assign_source_12 == NULL) );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ge__, tmp_assign_source_12 );
    }
    CHECK_OBJECT( (PyObject *)tmp_import_from_1__module );
    Py_DECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        tmp_name_name_5 = const_str_plain_six;
        tmp_globals_name_5 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = const_tuple_str_plain_integer_types_str_plain_text_type_str_plain_PY3_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 7;
        tmp_assign_source_13 = IMPORT_MODULE4( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5 );
        if ( tmp_assign_source_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 7;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_2__module == NULL );
        tmp_import_from_2__module = tmp_assign_source_13;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_import_name_from_9;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_9 = tmp_import_from_2__module;
        tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_integer_types );
        if ( tmp_assign_source_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 7;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__integer_types, tmp_assign_source_14 );
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_import_name_from_10;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_10 = tmp_import_from_2__module;
        tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_text_type );
        if ( tmp_assign_source_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 7;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_type, tmp_assign_source_15 );
    }
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_import_name_from_11;
        CHECK_OBJECT( tmp_import_from_2__module );
        tmp_import_name_from_11 = tmp_import_from_2__module;
        tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_11, const_str_plain_PY3 );
        if ( tmp_assign_source_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 7;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PY3, tmp_assign_source_16 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_2__module );
    Py_DECREF( tmp_import_from_2__module );
    tmp_import_from_2__module = NULL;

    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_import_name_from_12;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        tmp_name_name_6 = const_str_plain_cryptography;
        tmp_globals_name_6 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = const_tuple_str_plain_x509_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 12;
        tmp_import_name_from_12 = IMPORT_MODULE4( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6 );
        if ( tmp_import_name_from_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 12;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_12, const_str_plain_x509 );
        Py_DECREF( tmp_import_name_from_12 );
        if ( tmp_assign_source_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 12;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_x509, tmp_assign_source_17 );
    }
    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        tmp_name_name_7 = const_str_digest_426349c7e201b358f2086eb3f7fb6f47;
        tmp_globals_name_7 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = const_tuple_str_plain_dsa_str_plain_rsa_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 13;
        tmp_assign_source_18 = IMPORT_MODULE4( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7 );
        if ( tmp_assign_source_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 13;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_3__module == NULL );
        tmp_import_from_3__module = tmp_assign_source_18;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_19;
        PyObject *tmp_import_name_from_13;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_13 = tmp_import_from_3__module;
        tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_13, const_str_plain_dsa );
        if ( tmp_assign_source_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 13;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dsa, tmp_assign_source_19 );
    }
    {
        PyObject *tmp_assign_source_20;
        PyObject *tmp_import_name_from_14;
        CHECK_OBJECT( tmp_import_from_3__module );
        tmp_import_name_from_14 = tmp_import_from_3__module;
        tmp_assign_source_20 = IMPORT_NAME( tmp_import_name_from_14, const_str_plain_rsa );
        if ( tmp_assign_source_20 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 13;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_rsa, tmp_assign_source_20 );
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_3__module );
    Py_DECREF( tmp_import_from_3__module );
    tmp_import_from_3__module = NULL;

    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_import_name_from_15;
        PyObject *tmp_name_name_8;
        PyObject *tmp_globals_name_8;
        PyObject *tmp_locals_name_8;
        PyObject *tmp_fromlist_name_8;
        tmp_name_name_8 = const_str_digest_8b0e1374dcc590bdb16ac8ec2446b5d1;
        tmp_globals_name_8 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_8 = Py_None;
        tmp_fromlist_name_8 = const_tuple_str_plain_deprecated_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 14;
        tmp_import_name_from_15 = IMPORT_MODULE4( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8 );
        if ( tmp_import_name_from_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_21 = IMPORT_NAME( tmp_import_name_from_15, const_str_plain_deprecated );
        Py_DECREF( tmp_import_name_from_15 );
        if ( tmp_assign_source_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 14;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated, tmp_assign_source_21 );
    }
    {
        PyObject *tmp_assign_source_22;
        PyObject *tmp_name_name_9;
        PyObject *tmp_globals_name_9;
        PyObject *tmp_locals_name_9;
        PyObject *tmp_fromlist_name_9;
        tmp_name_name_9 = const_str_digest_2c0accc407028fbaba46fefdee9c6c06;
        tmp_globals_name_9 = (PyObject *)moduledict_OpenSSL$crypto;
        tmp_locals_name_9 = Py_None;
        tmp_fromlist_name_9 = const_tuple_5b465d0345e9fe836325135a03b6a86e_tuple;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 16;
        tmp_assign_source_22 = IMPORT_MODULE4( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9 );
        if ( tmp_assign_source_22 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto frame_exception_exit_1;
        }
        assert( tmp_import_from_4__module == NULL );
        tmp_import_from_4__module = tmp_assign_source_22;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_import_name_from_16;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_16 = tmp_import_from_4__module;
        tmp_assign_source_23 = IMPORT_NAME( tmp_import_name_from_16, const_str_plain_ffi );
        if ( tmp_assign_source_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__ffi, tmp_assign_source_23 );
    }
    {
        PyObject *tmp_assign_source_24;
        PyObject *tmp_import_name_from_17;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_17 = tmp_import_from_4__module;
        tmp_assign_source_24 = IMPORT_NAME( tmp_import_name_from_17, const_str_plain_lib );
        if ( tmp_assign_source_24 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib, tmp_assign_source_24 );
    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_import_name_from_18;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_18 = tmp_import_from_4__module;
        tmp_assign_source_25 = IMPORT_NAME( tmp_import_name_from_18, const_str_plain_exception_from_error_queue );
        if ( tmp_assign_source_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue, tmp_assign_source_25 );
    }
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_import_name_from_19;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_19 = tmp_import_from_4__module;
        tmp_assign_source_26 = IMPORT_NAME( tmp_import_name_from_19, const_str_plain_byte_string );
        if ( tmp_assign_source_26 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__byte_string, tmp_assign_source_26 );
    }
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_import_name_from_20;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_20 = tmp_import_from_4__module;
        tmp_assign_source_27 = IMPORT_NAME( tmp_import_name_from_20, const_str_plain_native );
        if ( tmp_assign_source_27 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__native, tmp_assign_source_27 );
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_import_name_from_21;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_21 = tmp_import_from_4__module;
        tmp_assign_source_28 = IMPORT_NAME( tmp_import_name_from_21, const_str_plain_UNSPECIFIED );
        if ( tmp_assign_source_28 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED, tmp_assign_source_28 );
    }
    {
        PyObject *tmp_assign_source_29;
        PyObject *tmp_import_name_from_22;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_22 = tmp_import_from_4__module;
        tmp_assign_source_29 = IMPORT_NAME( tmp_import_name_from_22, const_str_plain_text_to_bytes_and_warn );
        if ( tmp_assign_source_29 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__text_to_bytes_and_warn, tmp_assign_source_29 );
    }
    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_import_name_from_23;
        CHECK_OBJECT( tmp_import_from_4__module );
        tmp_import_name_from_23 = tmp_import_from_4__module;
        tmp_assign_source_30 = IMPORT_NAME( tmp_import_name_from_23, const_str_plain_make_assert );
        if ( tmp_assign_source_30 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 16;

            goto try_except_handler_3;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__make_assert, tmp_assign_source_30 );
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_import_from_4__module );
    Py_DECREF( tmp_import_from_4__module );
    tmp_import_from_4__module = NULL;

    {
        PyObject *tmp_assign_source_31;
        tmp_assign_source_31 = LIST_COPY( const_list_b8e29824b436479d358fd3771a611e70_list );
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_31 );
    }
    {
        PyObject *tmp_assign_source_32;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 66;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_assign_source_32 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_SSL_FILETYPE_PEM );
        if ( tmp_assign_source_32 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 66;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM, tmp_assign_source_32 );
    }
    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 67;

            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_assign_source_33 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SSL_FILETYPE_ASN1 );
        if ( tmp_assign_source_33 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 67;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_ASN1, tmp_assign_source_33 );
    }
    {
        PyObject *tmp_assign_source_34;
        tmp_assign_source_34 = const_int_pos_65535;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_TEXT, tmp_assign_source_34 );
    }
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 72;

            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_assign_source_35 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EVP_PKEY_RSA );
        if ( tmp_assign_source_35 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 72;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_RSA, tmp_assign_source_35 );
    }
    {
        PyObject *tmp_assign_source_36;
        PyObject *tmp_source_name_4;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 73;

            goto frame_exception_exit_1;
        }

        tmp_source_name_4 = tmp_mvar_value_4;
        tmp_assign_source_36 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_EVP_PKEY_DSA );
        if ( tmp_assign_source_36 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 73;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DSA, tmp_assign_source_36 );
    }
    {
        PyObject *tmp_assign_source_37;
        PyObject *tmp_source_name_5;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 74;

            goto frame_exception_exit_1;
        }

        tmp_source_name_5 = tmp_mvar_value_5;
        tmp_assign_source_37 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_EVP_PKEY_DH );
        if ( tmp_assign_source_37 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 74;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_DH, tmp_assign_source_37 );
    }
    {
        PyObject *tmp_assign_source_38;
        PyObject *tmp_source_name_6;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 75;

            goto frame_exception_exit_1;
        }

        tmp_source_name_6 = tmp_mvar_value_6;
        tmp_assign_source_38 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_EVP_PKEY_EC );
        if ( tmp_assign_source_38 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 75;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_TYPE_EC, tmp_assign_source_38 );
    }
    {
        PyObject *tmp_assign_source_39;
        tmp_assign_source_39 = PyDict_Copy( const_dict_5608fce8424ef5aca22387357d834999 );
        assert( tmp_class_creation_1__class_dict == NULL );
        tmp_class_creation_1__class_dict = tmp_assign_source_39;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_40;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_dict_name_1 = tmp_class_creation_1__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_4;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_dict_name_2 = tmp_class_creation_1__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_40 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
        if ( tmp_assign_source_40 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_4;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_assign_source_40 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_40 );
        condexpr_end_1:;
        assert( tmp_class_creation_1__metaclass == NULL );
        tmp_class_creation_1__metaclass = tmp_assign_source_40;
    }
    {
        PyObject *tmp_assign_source_41;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( tmp_class_creation_1__metaclass );
        tmp_called_name_1 = tmp_class_creation_1__metaclass;
        tmp_args_element_name_1 = const_str_plain_Error;
        tmp_args_element_name_2 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_args_element_name_3 = tmp_class_creation_1__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 78;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_41 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_41 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 78;

            goto try_except_handler_4;
        }
        assert( tmp_class_creation_1__class == NULL );
        tmp_class_creation_1__class = tmp_assign_source_41;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        PyObject *tmp_assign_source_42;
        CHECK_OBJECT( tmp_class_creation_1__class );
        tmp_assign_source_42 = tmp_class_creation_1__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error, tmp_assign_source_42 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    {
        PyObject *tmp_assign_source_43;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_partial );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
        }

        if ( tmp_mvar_value_7 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "partial" );
            exception_tb = NULL;

            exception_lineno = 84;

            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_7;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__exception_from_error_queue );
        }

        if ( tmp_mvar_value_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_exception_from_error_queue" );
            exception_tb = NULL;

            exception_lineno = 84;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_4 = tmp_mvar_value_8;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 84;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_5 = tmp_mvar_value_9;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 84;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_43 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_43 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 84;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__raise_current_error, tmp_assign_source_43 );
    }
    {
        PyObject *tmp_assign_source_44;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__make_assert );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__make_assert );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_make_assert" );
            exception_tb = NULL;

            exception_lineno = 85;

            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_10;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
            exception_tb = NULL;

            exception_lineno = 85;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_6 = tmp_mvar_value_11;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 85;
        {
            PyObject *call_args[] = { tmp_args_element_name_6 };
            tmp_assign_source_44 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_44 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 85;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__openssl_assert, tmp_assign_source_44 );
    }
    {
        PyObject *tmp_assign_source_45;
        tmp_assign_source_45 = MAKE_FUNCTION_OpenSSL$crypto$$$function_1__get_backend(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_backend, tmp_assign_source_45 );
    }
    {
        PyObject *tmp_assign_source_46;
        tmp_assign_source_46 = MAKE_FUNCTION_OpenSSL$crypto$$$function_2__untested_error(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__untested_error, tmp_assign_source_46 );
    }
    {
        PyObject *tmp_assign_source_47;
        PyObject *tmp_defaults_1;
        tmp_defaults_1 = const_tuple_none_tuple;
        Py_INCREF( tmp_defaults_1 );
        tmp_assign_source_47 = MAKE_FUNCTION_OpenSSL$crypto$$$function_3__new_mem_buf( tmp_defaults_1 );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__new_mem_buf, tmp_assign_source_47 );
    }
    {
        PyObject *tmp_assign_source_48;
        tmp_assign_source_48 = MAKE_FUNCTION_OpenSSL$crypto$$$function_4__bio_to_string(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__bio_to_string, tmp_assign_source_48 );
    }
    {
        PyObject *tmp_assign_source_49;
        tmp_assign_source_49 = MAKE_FUNCTION_OpenSSL$crypto$$$function_5__set_asn1_time(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__set_asn1_time, tmp_assign_source_49 );
    }
    {
        PyObject *tmp_assign_source_50;
        tmp_assign_source_50 = MAKE_FUNCTION_OpenSSL$crypto$$$function_6__get_asn1_time(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__get_asn1_time, tmp_assign_source_50 );
    }
    {
        PyObject *tmp_assign_source_51;
        {
            PyObject *tmp_assign_source_52;
            tmp_assign_source_52 = MAKE_FUNCTION_OpenSSL$crypto$$$function_7___init__(  );



            assert( tmp_locals_OpenSSL$crypto_206_key___init__ == NULL );
            tmp_locals_OpenSSL$crypto_206_key___init__ = tmp_assign_source_52;
        }
        {
            PyObject *tmp_assign_source_53;
            tmp_assign_source_53 = MAKE_FUNCTION_OpenSSL$crypto$$$function_8_add(  );



            assert( tmp_locals_OpenSSL$crypto_206_key_add == NULL );
            tmp_locals_OpenSSL$crypto_206_key_add = tmp_assign_source_53;
        }
        {
            PyObject *tmp_assign_source_54;
            tmp_assign_source_54 = MAKE_FUNCTION_OpenSSL$crypto$$$function_9_clear(  );



            assert( tmp_locals_OpenSSL$crypto_206_key_clear == NULL );
            tmp_locals_OpenSSL$crypto_206_key_clear = tmp_assign_source_54;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            PyObject *tmp_dict_key_4;
            PyObject *tmp_dict_value_4;
            tmp_dict_value_1 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_51 = _PyDict_NewPresized( 4 );
            tmp_res = PyDict_SetItem( tmp_assign_source_51, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_206_key___init__ );
            tmp_dict_value_2 = tmp_locals_OpenSSL$crypto_206_key___init__;
            tmp_dict_key_2 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_51, tmp_dict_key_2, tmp_dict_value_2 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_206_key_add );
            tmp_dict_value_3 = tmp_locals_OpenSSL$crypto_206_key_add;
            tmp_dict_key_3 = const_str_plain_add;
            tmp_res = PyDict_SetItem( tmp_assign_source_51, tmp_dict_key_3, tmp_dict_value_3 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_206_key_clear );
            tmp_dict_value_4 = tmp_locals_OpenSSL$crypto_206_key_clear;
            tmp_dict_key_4 = const_str_plain_clear;
            tmp_res = PyDict_SetItem( tmp_assign_source_51, tmp_dict_key_4, tmp_dict_value_4 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_5;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_5:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_206_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$crypto_206_key___init__ );
        tmp_locals_OpenSSL$crypto_206_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_206_key_add );
        Py_DECREF( tmp_locals_OpenSSL$crypto_206_key_add );
        tmp_locals_OpenSSL$crypto_206_key_add = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_206_key_clear );
        Py_DECREF( tmp_locals_OpenSSL$crypto_206_key_clear );
        tmp_locals_OpenSSL$crypto_206_key_clear = NULL;

        goto outline_result_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_1:;
        assert( tmp_class_creation_2__class_dict == NULL );
        tmp_class_creation_2__class_dict = tmp_assign_source_51;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_55;
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_key_name_4;
        tmp_key_name_3 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_3 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_3, tmp_key_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 206;

            goto try_except_handler_6;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_2;
        }
        else
        {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_4 = tmp_class_creation_2__class_dict;
        tmp_key_name_4 = const_str_plain___metaclass__;
        tmp_assign_source_55 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
        if ( tmp_assign_source_55 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 206;

            goto try_except_handler_6;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_assign_source_55 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_55 );
        condexpr_end_2:;
        assert( tmp_class_creation_2__metaclass == NULL );
        tmp_class_creation_2__metaclass = tmp_assign_source_55;
    }
    {
        PyObject *tmp_assign_source_56;
        PyObject *tmp_called_name_4;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT( tmp_class_creation_2__metaclass );
        tmp_called_name_4 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_7 = const_str_plain__X509NameInvalidator;
        tmp_args_element_name_8 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_args_element_name_9 = tmp_class_creation_2__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 206;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_assign_source_56 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
        }

        if ( tmp_assign_source_56 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 206;

            goto try_except_handler_6;
        }
        assert( tmp_class_creation_2__class == NULL );
        tmp_class_creation_2__class = tmp_assign_source_56;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    {
        PyObject *tmp_assign_source_57;
        CHECK_OBJECT( tmp_class_creation_2__class );
        tmp_assign_source_57 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__X509NameInvalidator, tmp_assign_source_57 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_58;
        {
            PyObject *tmp_set_locals_1;
            tmp_set_locals_1 = PyDict_New();
            locals_OpenSSL$crypto_219 = tmp_set_locals_1;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_5997506aef8ffc5e12c453030416acc6;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = Py_False;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain__only_public, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = Py_True;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain__initialized, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_10___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_11_to_cryptography_key(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain_to_cryptography_key, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_746bb3fa3035767ed3cd36b6784141e9_2, codeobj_746bb3fa3035767ed3cd36b6784141e9, module_OpenSSL$crypto, 0 );
        frame_746bb3fa3035767ed3cd36b6784141e9_2 = cache_frame_746bb3fa3035767ed3cd36b6784141e9_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_746bb3fa3035767ed3cd36b6784141e9_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_746bb3fa3035767ed3cd36b6784141e9_2 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_1;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_OpenSSL$crypto$$$function_12_from_cryptography_key(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_1 );
            Py_DECREF( tmp_classmethod_arg_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 248;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain_from_cryptography_key, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 248;

                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_746bb3fa3035767ed3cd36b6784141e9_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_746bb3fa3035767ed3cd36b6784141e9_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_746bb3fa3035767ed3cd36b6784141e9_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_746bb3fa3035767ed3cd36b6784141e9_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_746bb3fa3035767ed3cd36b6784141e9_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_746bb3fa3035767ed3cd36b6784141e9_2,
            type_description_2
        );


        // Release cached frame.
        if ( frame_746bb3fa3035767ed3cd36b6784141e9_2 == cache_frame_746bb3fa3035767ed3cd36b6784141e9_2 )
        {
            Py_DECREF( frame_746bb3fa3035767ed3cd36b6784141e9_2 );
        }
        cache_frame_746bb3fa3035767ed3cd36b6784141e9_2 = NULL;

        assertFrameObject( frame_746bb3fa3035767ed3cd36b6784141e9_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_8;
        skip_nested_handling_1:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_13_generate_key(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain_generate_key, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_14_check(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain_check, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_15_type(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain_type, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_16_bits(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_219, const_str_plain_bits, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_58 = locals_OpenSSL$crypto_219;
        Py_INCREF( tmp_assign_source_58 );
        goto try_return_handler_8;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_8:;
        Py_DECREF( locals_OpenSSL$crypto_219 );
        locals_OpenSSL$crypto_219 = NULL;
        goto outline_result_2;
        // Exception handler code:
        try_except_handler_8:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_219 );
        locals_OpenSSL$crypto_219 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_6;
        exception_value = exception_keeper_value_6;
        exception_tb = exception_keeper_tb_6;
        exception_lineno = exception_keeper_lineno_6;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_1:;
        exception_lineno = 219;
        goto try_except_handler_7;
        outline_result_2:;
        assert( tmp_class_creation_3__class_dict == NULL );
        tmp_class_creation_3__class_dict = tmp_assign_source_58;
    }
    {
        PyObject *tmp_assign_source_59;
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_5;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_dict_name_6;
        PyObject *tmp_key_name_6;
        tmp_key_name_5 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_5 = tmp_class_creation_3__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_5, tmp_key_name_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 219;

            goto try_except_handler_7;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_3;
        }
        else
        {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_6 = tmp_class_creation_3__class_dict;
        tmp_key_name_6 = const_str_plain___metaclass__;
        tmp_assign_source_59 = DICT_GET_ITEM( tmp_dict_name_6, tmp_key_name_6 );
        if ( tmp_assign_source_59 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 219;

            goto try_except_handler_7;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        tmp_assign_source_59 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_59 );
        condexpr_end_3:;
        assert( tmp_class_creation_3__metaclass == NULL );
        tmp_class_creation_3__metaclass = tmp_assign_source_59;
    }
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_called_name_5;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        CHECK_OBJECT( tmp_class_creation_3__metaclass );
        tmp_called_name_5 = tmp_class_creation_3__metaclass;
        tmp_args_element_name_10 = const_str_plain_PKey;
        tmp_args_element_name_11 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_args_element_name_12 = tmp_class_creation_3__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 219;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_assign_source_60 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
        }

        if ( tmp_assign_source_60 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 219;

            goto try_except_handler_7;
        }
        assert( tmp_class_creation_3__class == NULL );
        tmp_class_creation_3__class = tmp_assign_source_60;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    {
        PyObject *tmp_assign_source_61;
        CHECK_OBJECT( tmp_class_creation_3__class );
        tmp_assign_source_61 = tmp_class_creation_3__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey, tmp_assign_source_61 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    {
        PyObject *tmp_assign_source_62;
        PyObject *tmp_called_name_6;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 370;

            goto frame_exception_exit_1;
        }

        tmp_called_name_6 = tmp_mvar_value_12;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKey );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKey );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PKey" );
            exception_tb = NULL;

            exception_lineno = 371;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_13 = tmp_mvar_value_13;
        tmp_args_element_name_14 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_15 = const_str_digest_989a9acfa289de1c2c451525451533c9;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 373;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_16 = tmp_mvar_value_14;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 370;
        {
            PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16 };
            tmp_assign_source_62 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_6, call_args );
        }

        if ( tmp_assign_source_62 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 370;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKeyType, tmp_assign_source_62 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_63;
        {
            PyObject *tmp_set_locals_2;
            tmp_set_locals_2 = PyDict_New();
            locals_OpenSSL$crypto_377 = tmp_set_locals_2;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_4a193fbd1ccf06765e0cb44620b7d74a;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = Py_None;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain__curves, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_815faf1bae776438a2806f882aa20cdb_3, codeobj_815faf1bae776438a2806f882aa20cdb, module_OpenSSL$crypto, 0 );
        frame_815faf1bae776438a2806f882aa20cdb_3 = cache_frame_815faf1bae776438a2806f882aa20cdb_3;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_815faf1bae776438a2806f882aa20cdb_3 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_815faf1bae776438a2806f882aa20cdb_3 ) == 2 ); // Frame stack

        // Framed code:
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_mvar_value_15;
            int tmp_truth_name_1;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PY3 );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PY3 );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_PY3" );
                exception_tb = NULL;

                exception_lineno = 388;

                goto frame_exception_exit_3;
            }

            tmp_truth_name_1 = CHECK_IF_TRUE( tmp_mvar_value_15 );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 388;

                goto frame_exception_exit_3;
            }
            tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_1;
            }
            else
            {
                goto branch_no_1;
            }
            branch_yes_1:;
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_17___ne__(  );



            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain___ne__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
            branch_no_1:;
        }
        {
            PyObject *tmp_classmethod_arg_2;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_OpenSSL$crypto$$$function_18__load_elliptic_curves(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_2 );
            Py_DECREF( tmp_classmethod_arg_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 401;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain__load_elliptic_curves, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 401;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_classmethod_arg_3;
            tmp_classmethod_arg_3 = MAKE_FUNCTION_OpenSSL$crypto$$$function_19__get_elliptic_curves(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_3 );
            Py_DECREF( tmp_classmethod_arg_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 421;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain__get_elliptic_curves, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 421;

                goto frame_exception_exit_3;
            }
        }
        {
            PyObject *tmp_classmethod_arg_4;
            tmp_classmethod_arg_4 = MAKE_FUNCTION_OpenSSL$crypto$$$function_20_from_nid(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_4 );
            Py_DECREF( tmp_classmethod_arg_4 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 435;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain_from_nid, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 435;

                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_815faf1bae776438a2806f882aa20cdb_3 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_815faf1bae776438a2806f882aa20cdb_3 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_815faf1bae776438a2806f882aa20cdb_3, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_815faf1bae776438a2806f882aa20cdb_3->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_815faf1bae776438a2806f882aa20cdb_3, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_815faf1bae776438a2806f882aa20cdb_3,
            type_description_2
        );


        // Release cached frame.
        if ( frame_815faf1bae776438a2806f882aa20cdb_3 == cache_frame_815faf1bae776438a2806f882aa20cdb_3 )
        {
            Py_DECREF( frame_815faf1bae776438a2806f882aa20cdb_3 );
        }
        cache_frame_815faf1bae776438a2806f882aa20cdb_3 = NULL;

        assertFrameObject( frame_815faf1bae776438a2806f882aa20cdb_3 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_10;
        skip_nested_handling_2:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_21___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_22___repr__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain___repr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_23__to_EC_KEY(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_377, const_str_plain__to_EC_KEY, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_63 = locals_OpenSSL$crypto_377;
        Py_INCREF( tmp_assign_source_63 );
        goto try_return_handler_10;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_10:;
        Py_DECREF( locals_OpenSSL$crypto_377 );
        locals_OpenSSL$crypto_377 = NULL;
        goto outline_result_3;
        // Exception handler code:
        try_except_handler_10:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_377 );
        locals_OpenSSL$crypto_377 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_8;
        exception_value = exception_keeper_value_8;
        exception_tb = exception_keeper_tb_8;
        exception_lineno = exception_keeper_lineno_8;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_2:;
        exception_lineno = 377;
        goto try_except_handler_9;
        outline_result_3:;
        assert( tmp_class_creation_4__class_dict == NULL );
        tmp_class_creation_4__class_dict = tmp_assign_source_63;
    }
    {
        PyObject *tmp_assign_source_64;
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        tmp_key_name_7 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_7 = tmp_class_creation_4__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_7, tmp_key_name_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 377;

            goto try_except_handler_9;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_4;
        }
        else
        {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_8 = tmp_class_creation_4__class_dict;
        tmp_key_name_8 = const_str_plain___metaclass__;
        tmp_assign_source_64 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
        if ( tmp_assign_source_64 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 377;

            goto try_except_handler_9;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        tmp_assign_source_64 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_64 );
        condexpr_end_4:;
        assert( tmp_class_creation_4__metaclass == NULL );
        tmp_class_creation_4__metaclass = tmp_assign_source_64;
    }
    {
        PyObject *tmp_assign_source_65;
        PyObject *tmp_called_name_7;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        CHECK_OBJECT( tmp_class_creation_4__metaclass );
        tmp_called_name_7 = tmp_class_creation_4__metaclass;
        tmp_args_element_name_17 = const_str_plain__EllipticCurve;
        tmp_args_element_name_18 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_args_element_name_19 = tmp_class_creation_4__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 377;
        {
            PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19 };
            tmp_assign_source_65 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, call_args );
        }

        if ( tmp_assign_source_65 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 377;

            goto try_except_handler_9;
        }
        assert( tmp_class_creation_4__class == NULL );
        tmp_class_creation_4__class = tmp_assign_source_65;
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_66;
        CHECK_OBJECT( tmp_class_creation_4__class );
        tmp_assign_source_66 = tmp_class_creation_4__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__EllipticCurve, tmp_assign_source_66 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    {
        PyObject *tmp_assign_source_67;
        tmp_assign_source_67 = MAKE_FUNCTION_OpenSSL$crypto$$$function_24_get_elliptic_curves(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curves, tmp_assign_source_67 );
    }
    {
        PyObject *tmp_assign_source_68;
        tmp_assign_source_68 = MAKE_FUNCTION_OpenSSL$crypto$$$function_25_get_elliptic_curve(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_get_elliptic_curve, tmp_assign_source_68 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_69;
        {
            PyObject *tmp_set_locals_3;
            tmp_set_locals_3 = PyDict_New();
            locals_OpenSSL$crypto_516 = tmp_set_locals_3;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_5a3f7f69104a4ed1267a21c950d94463;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_26___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_27___setattr__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___setattr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_28___getattr__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___getattr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_29__cmp(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain__cmp, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_282c2f71fc2cfcb78842aae5c1418e1a_4, codeobj_282c2f71fc2cfcb78842aae5c1418e1a, module_OpenSSL$crypto, 0 );
        frame_282c2f71fc2cfcb78842aae5c1418e1a_4 = cache_frame_282c2f71fc2cfcb78842aae5c1418e1a_4;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_282c2f71fc2cfcb78842aae5c1418e1a_4 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_282c2f71fc2cfcb78842aae5c1418e1a_4 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_8;
            PyObject *tmp_args_element_name_20;
            PyObject *tmp_mvar_value_16;
            tmp_called_name_8 = PyDict_GetItem( locals_OpenSSL$crypto_516, const_str_plain__cmp );

            if ( tmp_called_name_8 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
                exception_tb = NULL;

                exception_lineno = 635;

                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 635;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___eq__ );

            if (unlikely( tmp_mvar_value_16 == NULL ))
            {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___eq__ );
            }

            if ( tmp_mvar_value_16 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__eq__" );
                exception_tb = NULL;

                exception_lineno = 635;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_20 = tmp_mvar_value_16;
            frame_282c2f71fc2cfcb78842aae5c1418e1a_4->m_frame.f_lineno = 635;
            {
                PyObject *call_args[] = { tmp_args_element_name_20 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 635;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___eq__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 635;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_9;
            PyObject *tmp_args_element_name_21;
            PyObject *tmp_mvar_value_17;
            tmp_called_name_9 = PyDict_GetItem( locals_OpenSSL$crypto_516, const_str_plain__cmp );

            if ( tmp_called_name_9 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
                exception_tb = NULL;

                exception_lineno = 636;

                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 636;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ne__ );

            if (unlikely( tmp_mvar_value_17 == NULL ))
            {
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___ne__ );
            }

            if ( tmp_mvar_value_17 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__ne__" );
                exception_tb = NULL;

                exception_lineno = 636;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_21 = tmp_mvar_value_17;
            frame_282c2f71fc2cfcb78842aae5c1418e1a_4->m_frame.f_lineno = 636;
            {
                PyObject *call_args[] = { tmp_args_element_name_21 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 636;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___ne__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 636;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_10;
            PyObject *tmp_args_element_name_22;
            PyObject *tmp_mvar_value_18;
            tmp_called_name_10 = PyDict_GetItem( locals_OpenSSL$crypto_516, const_str_plain__cmp );

            if ( tmp_called_name_10 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
                exception_tb = NULL;

                exception_lineno = 638;

                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 638;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___lt__ );

            if (unlikely( tmp_mvar_value_18 == NULL ))
            {
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___lt__ );
            }

            if ( tmp_mvar_value_18 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__lt__" );
                exception_tb = NULL;

                exception_lineno = 638;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_22 = tmp_mvar_value_18;
            frame_282c2f71fc2cfcb78842aae5c1418e1a_4->m_frame.f_lineno = 638;
            {
                PyObject *call_args[] = { tmp_args_element_name_22 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 638;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___lt__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 638;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_11;
            PyObject *tmp_args_element_name_23;
            PyObject *tmp_mvar_value_19;
            tmp_called_name_11 = PyDict_GetItem( locals_OpenSSL$crypto_516, const_str_plain__cmp );

            if ( tmp_called_name_11 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
                exception_tb = NULL;

                exception_lineno = 639;

                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 639;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___le__ );

            if (unlikely( tmp_mvar_value_19 == NULL ))
            {
                tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___le__ );
            }

            if ( tmp_mvar_value_19 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__le__" );
                exception_tb = NULL;

                exception_lineno = 639;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_23 = tmp_mvar_value_19;
            frame_282c2f71fc2cfcb78842aae5c1418e1a_4->m_frame.f_lineno = 639;
            {
                PyObject *call_args[] = { tmp_args_element_name_23 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 639;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___le__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 639;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_12;
            PyObject *tmp_args_element_name_24;
            PyObject *tmp_mvar_value_20;
            tmp_called_name_12 = PyDict_GetItem( locals_OpenSSL$crypto_516, const_str_plain__cmp );

            if ( tmp_called_name_12 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
                exception_tb = NULL;

                exception_lineno = 641;

                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 641;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___gt__ );

            if (unlikely( tmp_mvar_value_20 == NULL ))
            {
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___gt__ );
            }

            if ( tmp_mvar_value_20 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__gt__" );
                exception_tb = NULL;

                exception_lineno = 641;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_24 = tmp_mvar_value_20;
            frame_282c2f71fc2cfcb78842aae5c1418e1a_4->m_frame.f_lineno = 641;
            {
                PyObject *call_args[] = { tmp_args_element_name_24 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 641;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___gt__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 641;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_called_name_13;
            PyObject *tmp_args_element_name_25;
            PyObject *tmp_mvar_value_21;
            tmp_called_name_13 = PyDict_GetItem( locals_OpenSSL$crypto_516, const_str_plain__cmp );

            if ( tmp_called_name_13 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_cmp" );
                exception_tb = NULL;

                exception_lineno = 642;

                goto frame_exception_exit_4;
            }

            if ( tmp_called_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 642;

                goto frame_exception_exit_4;
            }
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___ge__ );

            if (unlikely( tmp_mvar_value_21 == NULL ))
            {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___ge__ );
            }

            if ( tmp_mvar_value_21 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "__ge__" );
                exception_tb = NULL;

                exception_lineno = 642;

                goto frame_exception_exit_4;
            }

            tmp_args_element_name_25 = tmp_mvar_value_21;
            frame_282c2f71fc2cfcb78842aae5c1418e1a_4->m_frame.f_lineno = 642;
            {
                PyObject *call_args[] = { tmp_args_element_name_25 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 642;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___ge__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 642;

                goto frame_exception_exit_4;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_282c2f71fc2cfcb78842aae5c1418e1a_4 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_282c2f71fc2cfcb78842aae5c1418e1a_4 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_282c2f71fc2cfcb78842aae5c1418e1a_4, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_282c2f71fc2cfcb78842aae5c1418e1a_4->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_282c2f71fc2cfcb78842aae5c1418e1a_4, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_282c2f71fc2cfcb78842aae5c1418e1a_4,
            type_description_2
        );


        // Release cached frame.
        if ( frame_282c2f71fc2cfcb78842aae5c1418e1a_4 == cache_frame_282c2f71fc2cfcb78842aae5c1418e1a_4 )
        {
            Py_DECREF( frame_282c2f71fc2cfcb78842aae5c1418e1a_4 );
        }
        cache_frame_282c2f71fc2cfcb78842aae5c1418e1a_4 = NULL;

        assertFrameObject( frame_282c2f71fc2cfcb78842aae5c1418e1a_4 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_12;
        skip_nested_handling_3:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_30___repr__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain___repr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_31_hash(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain_hash, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_32_der(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain_der, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_33_get_components(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_516, const_str_plain_get_components, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_69 = locals_OpenSSL$crypto_516;
        Py_INCREF( tmp_assign_source_69 );
        goto try_return_handler_12;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_12:;
        Py_DECREF( locals_OpenSSL$crypto_516 );
        locals_OpenSSL$crypto_516 = NULL;
        goto outline_result_4;
        // Exception handler code:
        try_except_handler_12:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_516 );
        locals_OpenSSL$crypto_516 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_10;
        exception_value = exception_keeper_value_10;
        exception_tb = exception_keeper_tb_10;
        exception_lineno = exception_keeper_lineno_10;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_3:;
        exception_lineno = 516;
        goto try_except_handler_11;
        outline_result_4:;
        assert( tmp_class_creation_5__class_dict == NULL );
        tmp_class_creation_5__class_dict = tmp_assign_source_69;
    }
    {
        PyObject *tmp_assign_source_70;
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_key_name_10;
        tmp_key_name_9 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_9 = tmp_class_creation_5__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_9, tmp_key_name_9 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 516;

            goto try_except_handler_11;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_5;
        }
        else
        {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_10 = tmp_class_creation_5__class_dict;
        tmp_key_name_10 = const_str_plain___metaclass__;
        tmp_assign_source_70 = DICT_GET_ITEM( tmp_dict_name_10, tmp_key_name_10 );
        if ( tmp_assign_source_70 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 516;

            goto try_except_handler_11;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        tmp_assign_source_70 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_70 );
        condexpr_end_5:;
        assert( tmp_class_creation_5__metaclass == NULL );
        tmp_class_creation_5__metaclass = tmp_assign_source_70;
    }
    {
        PyObject *tmp_assign_source_71;
        PyObject *tmp_called_name_14;
        PyObject *tmp_args_element_name_26;
        PyObject *tmp_args_element_name_27;
        PyObject *tmp_args_element_name_28;
        CHECK_OBJECT( tmp_class_creation_5__metaclass );
        tmp_called_name_14 = tmp_class_creation_5__metaclass;
        tmp_args_element_name_26 = const_str_plain_X509Name;
        tmp_args_element_name_27 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_args_element_name_28 = tmp_class_creation_5__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 516;
        {
            PyObject *call_args[] = { tmp_args_element_name_26, tmp_args_element_name_27, tmp_args_element_name_28 };
            tmp_assign_source_71 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_14, call_args );
        }

        if ( tmp_assign_source_71 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 516;

            goto try_except_handler_11;
        }
        assert( tmp_class_creation_5__class == NULL );
        tmp_class_creation_5__class = tmp_assign_source_71;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_11:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    {
        PyObject *tmp_assign_source_72;
        CHECK_OBJECT( tmp_class_creation_5__class );
        tmp_assign_source_72 = tmp_class_creation_5__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name, tmp_assign_source_72 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class );
    Py_DECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_dict );
    Py_DECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    {
        PyObject *tmp_assign_source_73;
        PyObject *tmp_called_name_15;
        PyObject *tmp_mvar_value_22;
        PyObject *tmp_args_element_name_29;
        PyObject *tmp_mvar_value_23;
        PyObject *tmp_args_element_name_30;
        PyObject *tmp_args_element_name_31;
        PyObject *tmp_args_element_name_32;
        PyObject *tmp_mvar_value_24;
        tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_22 == NULL ))
        {
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_22 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 709;

            goto frame_exception_exit_1;
        }

        tmp_called_name_15 = tmp_mvar_value_22;
        tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Name );

        if (unlikely( tmp_mvar_value_23 == NULL ))
        {
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Name );
        }

        if ( tmp_mvar_value_23 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "X509Name" );
            exception_tb = NULL;

            exception_lineno = 710;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_29 = tmp_mvar_value_23;
        tmp_args_element_name_30 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_31 = const_str_digest_ee89bc744832ab3afc27c4e7a4a73b66;
        tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_24 == NULL ))
        {
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_24 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 712;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_32 = tmp_mvar_value_24;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 709;
        {
            PyObject *call_args[] = { tmp_args_element_name_29, tmp_args_element_name_30, tmp_args_element_name_31, tmp_args_element_name_32 };
            tmp_assign_source_73 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_15, call_args );
        }

        if ( tmp_assign_source_73 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 709;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509NameType, tmp_assign_source_73 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_74;
        {
            PyObject *tmp_set_locals_4;
            tmp_set_locals_4 = PyDict_New();
            locals_OpenSSL$crypto_716 = tmp_set_locals_4;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_b52a484c26b348bfec0a17217a58ad7e;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_none_none_tuple;
            Py_INCREF( tmp_defaults_2 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_34___init__( tmp_defaults_2 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_e115d65213e4a52485ea15b6051b88e9_5, codeobj_e115d65213e4a52485ea15b6051b88e9, module_OpenSSL$crypto, 0 );
        frame_e115d65213e4a52485ea15b6051b88e9_5 = cache_frame_e115d65213e4a52485ea15b6051b88e9_5;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_e115d65213e4a52485ea15b6051b88e9_5 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_e115d65213e4a52485ea15b6051b88e9_5 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_16;
            PyObject *tmp_args_element_name_33;
            tmp_called_name_16 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_33 = MAKE_FUNCTION_OpenSSL$crypto$$$function_35__nid(  );



            frame_e115d65213e4a52485ea15b6051b88e9_5->m_frame.f_lineno = 782;
            {
                PyObject *call_args[] = { tmp_args_element_name_33 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
            }

            Py_DECREF( tmp_args_element_name_33 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 782;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain__nid, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 782;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_source_name_7;
            PyObject *tmp_mvar_value_25;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_source_name_8;
            PyObject *tmp_mvar_value_26;
            PyObject *tmp_dict_key_7;
            PyObject *tmp_dict_value_7;
            PyObject *tmp_source_name_9;
            PyObject *tmp_mvar_value_27;
            tmp_dict_value_5 = const_str_plain_email;
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_25 == NULL ))
            {
                tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_25 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 789;

                goto frame_exception_exit_5;
            }

            tmp_source_name_7 = tmp_mvar_value_25;
            tmp_dict_key_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_GEN_EMAIL );
            if ( tmp_dict_key_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 789;

                goto frame_exception_exit_5;
            }
            tmp_dictset_value = _PyDict_NewPresized( 3 );
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_5, tmp_dict_value_5 );
            Py_DECREF( tmp_dict_key_5 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
            tmp_dict_value_6 = const_str_plain_DNS;
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_26 == NULL ))
            {
                tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_26 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 790;

                goto frame_exception_exit_5;
            }

            tmp_source_name_8 = tmp_mvar_value_26;
            tmp_dict_key_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_GEN_DNS );
            if ( tmp_dict_key_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 790;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_6, tmp_dict_value_6 );
            Py_DECREF( tmp_dict_key_6 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
            tmp_dict_value_7 = const_str_plain_URI;
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_27 == NULL ))
            {
                tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_27 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 791;

                goto frame_exception_exit_5;
            }

            tmp_source_name_9 = tmp_mvar_value_27;
            tmp_dict_key_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_GEN_URI );
            if ( tmp_dict_key_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 791;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_7, tmp_dict_value_7 );
            Py_DECREF( tmp_dict_key_7 );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain__prefixes, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 788;

                goto frame_exception_exit_5;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_e115d65213e4a52485ea15b6051b88e9_5 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_e115d65213e4a52485ea15b6051b88e9_5 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_e115d65213e4a52485ea15b6051b88e9_5, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_e115d65213e4a52485ea15b6051b88e9_5->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_e115d65213e4a52485ea15b6051b88e9_5, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_e115d65213e4a52485ea15b6051b88e9_5,
            type_description_2
        );


        // Release cached frame.
        if ( frame_e115d65213e4a52485ea15b6051b88e9_5 == cache_frame_e115d65213e4a52485ea15b6051b88e9_5 )
        {
            Py_DECREF( frame_e115d65213e4a52485ea15b6051b88e9_5 );
        }
        cache_frame_e115d65213e4a52485ea15b6051b88e9_5 = NULL;

        assertFrameObject( frame_e115d65213e4a52485ea15b6051b88e9_5 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_14;
        skip_nested_handling_4:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_36__subjectAltNameString(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain__subjectAltNameString, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_37___str__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain___str__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_38_get_critical(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain_get_critical, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_39_get_short_name(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain_get_short_name, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_40_get_data(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_716, const_str_plain_get_data, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_74 = locals_OpenSSL$crypto_716;
        Py_INCREF( tmp_assign_source_74 );
        goto try_return_handler_14;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_14:;
        Py_DECREF( locals_OpenSSL$crypto_716 );
        locals_OpenSSL$crypto_716 = NULL;
        goto outline_result_5;
        // Exception handler code:
        try_except_handler_14:;
        exception_keeper_type_12 = exception_type;
        exception_keeper_value_12 = exception_value;
        exception_keeper_tb_12 = exception_tb;
        exception_keeper_lineno_12 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_716 );
        locals_OpenSSL$crypto_716 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_12;
        exception_value = exception_keeper_value_12;
        exception_tb = exception_keeper_tb_12;
        exception_lineno = exception_keeper_lineno_12;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_4:;
        exception_lineno = 716;
        goto try_except_handler_13;
        outline_result_5:;
        assert( tmp_class_creation_6__class_dict == NULL );
        tmp_class_creation_6__class_dict = tmp_assign_source_74;
    }
    {
        PyObject *tmp_assign_source_75;
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_key_name_11;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_dict_name_12;
        PyObject *tmp_key_name_12;
        tmp_key_name_11 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_11 = tmp_class_creation_6__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_11, tmp_key_name_11 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 716;

            goto try_except_handler_13;
        }
        tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_6;
        }
        else
        {
            goto condexpr_false_6;
        }
        condexpr_true_6:;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_12 = tmp_class_creation_6__class_dict;
        tmp_key_name_12 = const_str_plain___metaclass__;
        tmp_assign_source_75 = DICT_GET_ITEM( tmp_dict_name_12, tmp_key_name_12 );
        if ( tmp_assign_source_75 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 716;

            goto try_except_handler_13;
        }
        goto condexpr_end_6;
        condexpr_false_6:;
        tmp_assign_source_75 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_75 );
        condexpr_end_6:;
        assert( tmp_class_creation_6__metaclass == NULL );
        tmp_class_creation_6__metaclass = tmp_assign_source_75;
    }
    {
        PyObject *tmp_assign_source_76;
        PyObject *tmp_called_name_17;
        PyObject *tmp_args_element_name_34;
        PyObject *tmp_args_element_name_35;
        PyObject *tmp_args_element_name_36;
        CHECK_OBJECT( tmp_class_creation_6__metaclass );
        tmp_called_name_17 = tmp_class_creation_6__metaclass;
        tmp_args_element_name_34 = const_str_plain_X509Extension;
        tmp_args_element_name_35 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_args_element_name_36 = tmp_class_creation_6__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 716;
        {
            PyObject *call_args[] = { tmp_args_element_name_34, tmp_args_element_name_35, tmp_args_element_name_36 };
            tmp_assign_source_76 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_17, call_args );
        }

        if ( tmp_assign_source_76 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 716;

            goto try_except_handler_13;
        }
        assert( tmp_class_creation_6__class == NULL );
        tmp_class_creation_6__class = tmp_assign_source_76;
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_13 = exception_type;
    exception_keeper_value_13 = exception_value;
    exception_keeper_tb_13 = exception_tb;
    exception_keeper_lineno_13 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_13;
    exception_value = exception_keeper_value_13;
    exception_tb = exception_keeper_tb_13;
    exception_lineno = exception_keeper_lineno_13;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    {
        PyObject *tmp_assign_source_77;
        CHECK_OBJECT( tmp_class_creation_6__class );
        tmp_assign_source_77 = tmp_class_creation_6__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension, tmp_assign_source_77 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class );
    Py_DECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    {
        PyObject *tmp_assign_source_78;
        PyObject *tmp_called_name_18;
        PyObject *tmp_mvar_value_28;
        PyObject *tmp_args_element_name_37;
        PyObject *tmp_mvar_value_29;
        PyObject *tmp_args_element_name_38;
        PyObject *tmp_args_element_name_39;
        PyObject *tmp_args_element_name_40;
        PyObject *tmp_mvar_value_30;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_28 == NULL ))
        {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_28 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 867;

            goto frame_exception_exit_1;
        }

        tmp_called_name_18 = tmp_mvar_value_28;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Extension );

        if (unlikely( tmp_mvar_value_29 == NULL ))
        {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Extension );
        }

        if ( tmp_mvar_value_29 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "X509Extension" );
            exception_tb = NULL;

            exception_lineno = 868;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_37 = tmp_mvar_value_29;
        tmp_args_element_name_38 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_39 = const_str_digest_3918253e50729a002fea544312970ff5;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_30 == NULL ))
        {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_30 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 870;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_40 = tmp_mvar_value_30;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 867;
        {
            PyObject *call_args[] = { tmp_args_element_name_37, tmp_args_element_name_38, tmp_args_element_name_39, tmp_args_element_name_40 };
            tmp_assign_source_78 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_18, call_args );
        }

        if ( tmp_assign_source_78 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 867;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509ExtensionType, tmp_assign_source_78 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_79;
        {
            PyObject *tmp_set_locals_5;
            tmp_set_locals_5 = PyDict_New();
            locals_OpenSSL$crypto_874 = tmp_set_locals_5;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_9226325aac109a91f8326c1a26ede065;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_41___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_42_to_cryptography(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_to_cryptography, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_1642adfffc73b068bfa3ff06f1921759_6, codeobj_1642adfffc73b068bfa3ff06f1921759, module_OpenSSL$crypto, 0 );
        frame_1642adfffc73b068bfa3ff06f1921759_6 = cache_frame_1642adfffc73b068bfa3ff06f1921759_6;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_1642adfffc73b068bfa3ff06f1921759_6 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_1642adfffc73b068bfa3ff06f1921759_6 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_5;
            tmp_classmethod_arg_5 = MAKE_FUNCTION_OpenSSL$crypto$$$function_43_from_cryptography(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_5 );
            Py_DECREF( tmp_classmethod_arg_5 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 899;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_from_cryptography, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 899;

                goto frame_exception_exit_6;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1642adfffc73b068bfa3ff06f1921759_6 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_1642adfffc73b068bfa3ff06f1921759_6 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_1642adfffc73b068bfa3ff06f1921759_6, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_1642adfffc73b068bfa3ff06f1921759_6->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_1642adfffc73b068bfa3ff06f1921759_6, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_1642adfffc73b068bfa3ff06f1921759_6,
            type_description_2
        );


        // Release cached frame.
        if ( frame_1642adfffc73b068bfa3ff06f1921759_6 == cache_frame_1642adfffc73b068bfa3ff06f1921759_6 )
        {
            Py_DECREF( frame_1642adfffc73b068bfa3ff06f1921759_6 );
        }
        cache_frame_1642adfffc73b068bfa3ff06f1921759_6 = NULL;

        assertFrameObject( frame_1642adfffc73b068bfa3ff06f1921759_6 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_16;
        skip_nested_handling_5:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_44_set_pubkey(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_set_pubkey, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_45_get_pubkey(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_get_pubkey, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_46_set_version(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_set_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_47_get_version(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_get_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_48_get_subject(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_get_subject, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_49_add_extensions(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_add_extensions, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_50_get_extensions(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_get_extensions, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_51_sign(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_sign, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_52_verify(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_874, const_str_plain_verify, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_79 = locals_OpenSSL$crypto_874;
        Py_INCREF( tmp_assign_source_79 );
        goto try_return_handler_16;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_16:;
        Py_DECREF( locals_OpenSSL$crypto_874 );
        locals_OpenSSL$crypto_874 = NULL;
        goto outline_result_6;
        // Exception handler code:
        try_except_handler_16:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_874 );
        locals_OpenSSL$crypto_874 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_14;
        exception_value = exception_keeper_value_14;
        exception_tb = exception_keeper_tb_14;
        exception_lineno = exception_keeper_lineno_14;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_5:;
        exception_lineno = 874;
        goto try_except_handler_15;
        outline_result_6:;
        assert( tmp_class_creation_7__class_dict == NULL );
        tmp_class_creation_7__class_dict = tmp_assign_source_79;
    }
    {
        PyObject *tmp_assign_source_80;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        tmp_key_name_13 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_13 = tmp_class_creation_7__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_13, tmp_key_name_13 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 874;

            goto try_except_handler_15;
        }
        tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_7;
        }
        else
        {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_14 = tmp_class_creation_7__class_dict;
        tmp_key_name_14 = const_str_plain___metaclass__;
        tmp_assign_source_80 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
        if ( tmp_assign_source_80 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 874;

            goto try_except_handler_15;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        tmp_assign_source_80 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_80 );
        condexpr_end_7:;
        assert( tmp_class_creation_7__metaclass == NULL );
        tmp_class_creation_7__metaclass = tmp_assign_source_80;
    }
    {
        PyObject *tmp_assign_source_81;
        PyObject *tmp_called_name_19;
        PyObject *tmp_args_element_name_41;
        PyObject *tmp_args_element_name_42;
        PyObject *tmp_args_element_name_43;
        CHECK_OBJECT( tmp_class_creation_7__metaclass );
        tmp_called_name_19 = tmp_class_creation_7__metaclass;
        tmp_args_element_name_41 = const_str_plain_X509Req;
        tmp_args_element_name_42 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_args_element_name_43 = tmp_class_creation_7__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 874;
        {
            PyObject *call_args[] = { tmp_args_element_name_41, tmp_args_element_name_42, tmp_args_element_name_43 };
            tmp_assign_source_81 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_19, call_args );
        }

        if ( tmp_assign_source_81 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 874;

            goto try_except_handler_15;
        }
        assert( tmp_class_creation_7__class == NULL );
        tmp_class_creation_7__class = tmp_assign_source_81;
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_15:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    {
        PyObject *tmp_assign_source_82;
        CHECK_OBJECT( tmp_class_creation_7__class );
        tmp_assign_source_82 = tmp_class_creation_7__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req, tmp_assign_source_82 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class );
    Py_DECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_dict );
    Py_DECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    {
        PyObject *tmp_assign_source_83;
        PyObject *tmp_called_name_20;
        PyObject *tmp_mvar_value_31;
        PyObject *tmp_args_element_name_44;
        PyObject *tmp_mvar_value_32;
        PyObject *tmp_args_element_name_45;
        PyObject *tmp_args_element_name_46;
        PyObject *tmp_args_element_name_47;
        PyObject *tmp_mvar_value_33;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_31 == NULL ))
        {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_31 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 1073;

            goto frame_exception_exit_1;
        }

        tmp_called_name_20 = tmp_mvar_value_31;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Req );

        if (unlikely( tmp_mvar_value_32 == NULL ))
        {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Req );
        }

        if ( tmp_mvar_value_32 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "X509Req" );
            exception_tb = NULL;

            exception_lineno = 1074;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_44 = tmp_mvar_value_32;
        tmp_args_element_name_45 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_46 = const_str_digest_4d148c7b7c1bc2fec101962dc1ce2c2f;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_33 == NULL ))
        {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_33 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 1076;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_47 = tmp_mvar_value_33;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1073;
        {
            PyObject *call_args[] = { tmp_args_element_name_44, tmp_args_element_name_45, tmp_args_element_name_46, tmp_args_element_name_47 };
            tmp_assign_source_83 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_20, call_args );
        }

        if ( tmp_assign_source_83 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1073;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509ReqType, tmp_assign_source_83 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_84;
        {
            PyObject *tmp_set_locals_6;
            tmp_set_locals_6 = PyDict_New();
            locals_OpenSSL$crypto_1080 = tmp_set_locals_6;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_2cf9e4c7f607857df636a128997ff3fc;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_53___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_053b533781a7f6d764fff943a8c7efe9_7, codeobj_053b533781a7f6d764fff943a8c7efe9, module_OpenSSL$crypto, 0 );
        frame_053b533781a7f6d764fff943a8c7efe9_7 = cache_frame_053b533781a7f6d764fff943a8c7efe9_7;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_053b533781a7f6d764fff943a8c7efe9_7 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_053b533781a7f6d764fff943a8c7efe9_7 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_6;
            tmp_classmethod_arg_6 = MAKE_FUNCTION_OpenSSL$crypto$$$function_54__from_raw_x509_ptr(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_6 );
            Py_DECREF( tmp_classmethod_arg_6 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1092;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain__from_raw_x509_ptr, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1092;

                goto frame_exception_exit_7;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_55_to_cryptography(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_to_cryptography, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_classmethod_arg_7;
            tmp_classmethod_arg_7 = MAKE_FUNCTION_OpenSSL$crypto$$$function_56_from_cryptography(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_7 );
            Py_DECREF( tmp_classmethod_arg_7 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1112;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_from_cryptography, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1112;

                goto frame_exception_exit_7;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_053b533781a7f6d764fff943a8c7efe9_7 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_053b533781a7f6d764fff943a8c7efe9_7 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_053b533781a7f6d764fff943a8c7efe9_7, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_053b533781a7f6d764fff943a8c7efe9_7->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_053b533781a7f6d764fff943a8c7efe9_7, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_053b533781a7f6d764fff943a8c7efe9_7,
            type_description_2
        );


        // Release cached frame.
        if ( frame_053b533781a7f6d764fff943a8c7efe9_7 == cache_frame_053b533781a7f6d764fff943a8c7efe9_7 )
        {
            Py_DECREF( frame_053b533781a7f6d764fff943a8c7efe9_7 );
        }
        cache_frame_053b533781a7f6d764fff943a8c7efe9_7 = NULL;

        assertFrameObject( frame_053b533781a7f6d764fff943a8c7efe9_7 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_18;
        skip_nested_handling_6:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_57_set_version(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_set_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_58_get_version(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_59_get_pubkey(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_pubkey, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_60_set_pubkey(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_set_pubkey, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_61_sign(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_sign, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_62_get_signature_algorithm(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_signature_algorithm, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_63_digest(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_digest, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_64_subject_name_hash(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_subject_name_hash, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_65_set_serial_number(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_set_serial_number, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_66_get_serial_number(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_serial_number, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_67_gmtime_adj_notAfter(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_gmtime_adj_notAfter, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_68_gmtime_adj_notBefore(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_gmtime_adj_notBefore, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_69_has_expired(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_has_expired, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_70__get_boundary_time(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain__get_boundary_time, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_71_get_notBefore(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_notBefore, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_72__set_boundary_time(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain__set_boundary_time, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_73_set_notBefore(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_set_notBefore, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_74_get_notAfter(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_notAfter, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_75_set_notAfter(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_set_notAfter, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_76__get_name(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain__get_name, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_77__set_name(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain__set_name, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_78_get_issuer(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_issuer, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_79_set_issuer(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_set_issuer, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_80_get_subject(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_subject, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_81_set_subject(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_set_subject, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_82_get_extension_count(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_extension_count, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_83_add_extensions(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_add_extensions, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_84_get_extension(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1080, const_str_plain_get_extension, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_84 = locals_OpenSSL$crypto_1080;
        Py_INCREF( tmp_assign_source_84 );
        goto try_return_handler_18;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_18:;
        Py_DECREF( locals_OpenSSL$crypto_1080 );
        locals_OpenSSL$crypto_1080 = NULL;
        goto outline_result_7;
        // Exception handler code:
        try_except_handler_18:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_1080 );
        locals_OpenSSL$crypto_1080 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_16;
        exception_value = exception_keeper_value_16;
        exception_tb = exception_keeper_tb_16;
        exception_lineno = exception_keeper_lineno_16;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_6:;
        exception_lineno = 1080;
        goto try_except_handler_17;
        outline_result_7:;
        assert( tmp_class_creation_8__class_dict == NULL );
        tmp_class_creation_8__class_dict = tmp_assign_source_84;
    }
    {
        PyObject *tmp_assign_source_85;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_key_name_16;
        tmp_key_name_15 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_15 = tmp_class_creation_8__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_15, tmp_key_name_15 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1080;

            goto try_except_handler_17;
        }
        tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_8;
        }
        else
        {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_16 = tmp_class_creation_8__class_dict;
        tmp_key_name_16 = const_str_plain___metaclass__;
        tmp_assign_source_85 = DICT_GET_ITEM( tmp_dict_name_16, tmp_key_name_16 );
        if ( tmp_assign_source_85 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1080;

            goto try_except_handler_17;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        tmp_assign_source_85 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_85 );
        condexpr_end_8:;
        assert( tmp_class_creation_8__metaclass == NULL );
        tmp_class_creation_8__metaclass = tmp_assign_source_85;
    }
    {
        PyObject *tmp_assign_source_86;
        PyObject *tmp_called_name_21;
        PyObject *tmp_args_element_name_48;
        PyObject *tmp_args_element_name_49;
        PyObject *tmp_args_element_name_50;
        CHECK_OBJECT( tmp_class_creation_8__metaclass );
        tmp_called_name_21 = tmp_class_creation_8__metaclass;
        tmp_args_element_name_48 = const_str_plain_X509;
        tmp_args_element_name_49 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_args_element_name_50 = tmp_class_creation_8__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1080;
        {
            PyObject *call_args[] = { tmp_args_element_name_48, tmp_args_element_name_49, tmp_args_element_name_50 };
            tmp_assign_source_86 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_21, call_args );
        }

        if ( tmp_assign_source_86 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1080;

            goto try_except_handler_17;
        }
        assert( tmp_class_creation_8__class == NULL );
        tmp_class_creation_8__class = tmp_assign_source_86;
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_17:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    {
        PyObject *tmp_assign_source_87;
        CHECK_OBJECT( tmp_class_creation_8__class );
        tmp_assign_source_87 = tmp_class_creation_8__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509, tmp_assign_source_87 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class );
    Py_DECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    {
        PyObject *tmp_assign_source_88;
        PyObject *tmp_called_name_22;
        PyObject *tmp_mvar_value_34;
        PyObject *tmp_args_element_name_51;
        PyObject *tmp_mvar_value_35;
        PyObject *tmp_args_element_name_52;
        PyObject *tmp_args_element_name_53;
        PyObject *tmp_args_element_name_54;
        PyObject *tmp_mvar_value_36;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_34 == NULL ))
        {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_34 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 1546;

            goto frame_exception_exit_1;
        }

        tmp_called_name_22 = tmp_mvar_value_34;
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509 );

        if (unlikely( tmp_mvar_value_35 == NULL ))
        {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509 );
        }

        if ( tmp_mvar_value_35 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "X509" );
            exception_tb = NULL;

            exception_lineno = 1547;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_51 = tmp_mvar_value_35;
        tmp_args_element_name_52 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_53 = const_str_digest_5194c46decfddbd64da780c8c0e4faa3;
        tmp_mvar_value_36 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_36 == NULL ))
        {
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_36 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 1549;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_54 = tmp_mvar_value_36;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1546;
        {
            PyObject *call_args[] = { tmp_args_element_name_51, tmp_args_element_name_52, tmp_args_element_name_53, tmp_args_element_name_54 };
            tmp_assign_source_88 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_22, call_args );
        }

        if ( tmp_assign_source_88 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1546;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Type, tmp_assign_source_88 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_89;
        {
            PyObject *tmp_set_locals_7;
            tmp_set_locals_7 = PyDict_New();
            locals_OpenSSL$crypto_1553 = tmp_set_locals_7;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_6ef28169edd3cfe530885f6f9d09c390;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8, codeobj_f18fafe32e9e502bfe9ab12ad38f5cd3, module_OpenSSL$crypto, 0 );
        frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 = cache_frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_source_name_10;
            PyObject *tmp_mvar_value_37;
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_37 == NULL ))
            {
                tmp_mvar_value_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_37 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1563;

                goto frame_exception_exit_8;
            }

            tmp_source_name_10 = tmp_mvar_value_37;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_X509_V_FLAG_CRL_CHECK );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1563;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_CRL_CHECK, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1563;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_11;
            PyObject *tmp_mvar_value_38;
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_38 == NULL ))
            {
                tmp_mvar_value_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_38 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1564;

                goto frame_exception_exit_8;
            }

            tmp_source_name_11 = tmp_mvar_value_38;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_X509_V_FLAG_CRL_CHECK_ALL );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1564;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_CRL_CHECK_ALL, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1564;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_12;
            PyObject *tmp_mvar_value_39;
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_39 == NULL ))
            {
                tmp_mvar_value_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_39 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1565;

                goto frame_exception_exit_8;
            }

            tmp_source_name_12 = tmp_mvar_value_39;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_X509_V_FLAG_IGNORE_CRITICAL );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1565;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_IGNORE_CRITICAL, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1565;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_13;
            PyObject *tmp_mvar_value_40;
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_40 == NULL ))
            {
                tmp_mvar_value_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_40 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1566;

                goto frame_exception_exit_8;
            }

            tmp_source_name_13 = tmp_mvar_value_40;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_X509_V_FLAG_X509_STRICT );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1566;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_X509_STRICT, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1566;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_14;
            PyObject *tmp_mvar_value_41;
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_41 == NULL ))
            {
                tmp_mvar_value_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_41 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1567;

                goto frame_exception_exit_8;
            }

            tmp_source_name_14 = tmp_mvar_value_41;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_X509_V_FLAG_ALLOW_PROXY_CERTS );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1567;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_ALLOW_PROXY_CERTS, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1567;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_15;
            PyObject *tmp_mvar_value_42;
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_42 == NULL ))
            {
                tmp_mvar_value_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_42 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1568;

                goto frame_exception_exit_8;
            }

            tmp_source_name_15 = tmp_mvar_value_42;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_X509_V_FLAG_POLICY_CHECK );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1568;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_POLICY_CHECK, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1568;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_16;
            PyObject *tmp_mvar_value_43;
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_43 == NULL ))
            {
                tmp_mvar_value_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_43 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1569;

                goto frame_exception_exit_8;
            }

            tmp_source_name_16 = tmp_mvar_value_43;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_X509_V_FLAG_EXPLICIT_POLICY );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1569;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_EXPLICIT_POLICY, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1569;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_17;
            PyObject *tmp_mvar_value_44;
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_44 == NULL ))
            {
                tmp_mvar_value_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_44 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1570;

                goto frame_exception_exit_8;
            }

            tmp_source_name_17 = tmp_mvar_value_44;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_X509_V_FLAG_INHIBIT_MAP );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1570;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_INHIBIT_MAP, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1570;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_18;
            PyObject *tmp_mvar_value_45;
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_45 == NULL ))
            {
                tmp_mvar_value_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_45 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1571;

                goto frame_exception_exit_8;
            }

            tmp_source_name_18 = tmp_mvar_value_45;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_X509_V_FLAG_NOTIFY_POLICY );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1571;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_NOTIFY_POLICY, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1571;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_19;
            PyObject *tmp_mvar_value_46;
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_46 == NULL ))
            {
                tmp_mvar_value_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_46 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1572;

                goto frame_exception_exit_8;
            }

            tmp_source_name_19 = tmp_mvar_value_46;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_X509_V_FLAG_CHECK_SS_SIGNATURE );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1572;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_CHECK_SS_SIGNATURE, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1572;

                goto frame_exception_exit_8;
            }
        }
        {
            PyObject *tmp_source_name_20;
            PyObject *tmp_mvar_value_47;
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

            if (unlikely( tmp_mvar_value_47 == NULL ))
            {
                tmp_mvar_value_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
            }

            if ( tmp_mvar_value_47 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
                exception_tb = NULL;

                exception_lineno = 1573;

                goto frame_exception_exit_8;
            }

            tmp_source_name_20 = tmp_mvar_value_47;
            tmp_dictset_value = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_X509_V_FLAG_CB_ISSUER_CHECK );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1573;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_1553, const_str_plain_CB_ISSUER_CHECK, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1573;

                goto frame_exception_exit_8;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8,
            type_description_2
        );


        // Release cached frame.
        if ( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 == cache_frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 )
        {
            Py_DECREF( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 );
        }
        cache_frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 = NULL;

        assertFrameObject( frame_f18fafe32e9e502bfe9ab12ad38f5cd3_8 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_20;
        skip_nested_handling_7:;
        tmp_assign_source_89 = locals_OpenSSL$crypto_1553;
        Py_INCREF( tmp_assign_source_89 );
        goto try_return_handler_20;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_20:;
        Py_DECREF( locals_OpenSSL$crypto_1553 );
        locals_OpenSSL$crypto_1553 = NULL;
        goto outline_result_8;
        // Exception handler code:
        try_except_handler_20:;
        exception_keeper_type_18 = exception_type;
        exception_keeper_value_18 = exception_value;
        exception_keeper_tb_18 = exception_tb;
        exception_keeper_lineno_18 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_1553 );
        locals_OpenSSL$crypto_1553 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_18;
        exception_value = exception_keeper_value_18;
        exception_tb = exception_keeper_tb_18;
        exception_lineno = exception_keeper_lineno_18;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_7:;
        exception_lineno = 1553;
        goto try_except_handler_19;
        outline_result_8:;
        assert( tmp_class_creation_9__class_dict == NULL );
        tmp_class_creation_9__class_dict = tmp_assign_source_89;
    }
    {
        PyObject *tmp_assign_source_90;
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_17;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_dict_name_18;
        PyObject *tmp_key_name_18;
        tmp_key_name_17 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_17 = tmp_class_creation_9__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_17, tmp_key_name_17 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1553;

            goto try_except_handler_19;
        }
        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_9;
        }
        else
        {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_18 = tmp_class_creation_9__class_dict;
        tmp_key_name_18 = const_str_plain___metaclass__;
        tmp_assign_source_90 = DICT_GET_ITEM( tmp_dict_name_18, tmp_key_name_18 );
        if ( tmp_assign_source_90 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1553;

            goto try_except_handler_19;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        tmp_assign_source_90 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_90 );
        condexpr_end_9:;
        assert( tmp_class_creation_9__metaclass == NULL );
        tmp_class_creation_9__metaclass = tmp_assign_source_90;
    }
    {
        PyObject *tmp_assign_source_91;
        PyObject *tmp_called_name_23;
        PyObject *tmp_args_element_name_55;
        PyObject *tmp_args_element_name_56;
        PyObject *tmp_args_element_name_57;
        CHECK_OBJECT( tmp_class_creation_9__metaclass );
        tmp_called_name_23 = tmp_class_creation_9__metaclass;
        tmp_args_element_name_55 = const_str_plain_X509StoreFlags;
        tmp_args_element_name_56 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_args_element_name_57 = tmp_class_creation_9__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1553;
        {
            PyObject *call_args[] = { tmp_args_element_name_55, tmp_args_element_name_56, tmp_args_element_name_57 };
            tmp_assign_source_91 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_23, call_args );
        }

        if ( tmp_assign_source_91 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1553;

            goto try_except_handler_19;
        }
        assert( tmp_class_creation_9__class == NULL );
        tmp_class_creation_9__class = tmp_assign_source_91;
    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    {
        PyObject *tmp_assign_source_92;
        CHECK_OBJECT( tmp_class_creation_9__class );
        tmp_assign_source_92 = tmp_class_creation_9__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreFlags, tmp_assign_source_92 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class );
    Py_DECREF( tmp_class_creation_9__class );
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_dict );
    Py_DECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    {
        PyObject *tmp_assign_source_93;
        {
            PyObject *tmp_assign_source_94;
            tmp_assign_source_94 = MAKE_FUNCTION_OpenSSL$crypto$$$function_85___init__(  );



            assert( tmp_locals_OpenSSL$crypto_1576_key___init__ == NULL );
            tmp_locals_OpenSSL$crypto_1576_key___init__ = tmp_assign_source_94;
        }
        {
            PyObject *tmp_assign_source_95;
            tmp_assign_source_95 = MAKE_FUNCTION_OpenSSL$crypto$$$function_86_add_cert(  );



            assert( tmp_locals_OpenSSL$crypto_1576_key_add_cert == NULL );
            tmp_locals_OpenSSL$crypto_1576_key_add_cert = tmp_assign_source_95;
        }
        {
            PyObject *tmp_assign_source_96;
            tmp_assign_source_96 = MAKE_FUNCTION_OpenSSL$crypto$$$function_87_add_crl(  );



            assert( tmp_locals_OpenSSL$crypto_1576_key_add_crl == NULL );
            tmp_locals_OpenSSL$crypto_1576_key_add_crl = tmp_assign_source_96;
        }
        {
            PyObject *tmp_assign_source_97;
            tmp_assign_source_97 = MAKE_FUNCTION_OpenSSL$crypto$$$function_88_set_flags(  );



            assert( tmp_locals_OpenSSL$crypto_1576_key_set_flags == NULL );
            tmp_locals_OpenSSL$crypto_1576_key_set_flags = tmp_assign_source_97;
        }
        {
            PyObject *tmp_assign_source_98;
            tmp_assign_source_98 = MAKE_FUNCTION_OpenSSL$crypto$$$function_89_set_time(  );



            assert( tmp_locals_OpenSSL$crypto_1576_key_set_time == NULL );
            tmp_locals_OpenSSL$crypto_1576_key_set_time = tmp_assign_source_98;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_8;
            PyObject *tmp_dict_value_8;
            PyObject *tmp_dict_key_9;
            PyObject *tmp_dict_value_9;
            PyObject *tmp_dict_key_10;
            PyObject *tmp_dict_value_10;
            PyObject *tmp_dict_key_11;
            PyObject *tmp_dict_value_11;
            PyObject *tmp_dict_key_12;
            PyObject *tmp_dict_value_12;
            PyObject *tmp_dict_key_13;
            PyObject *tmp_dict_value_13;
            PyObject *tmp_dict_key_14;
            PyObject *tmp_dict_value_14;
            tmp_dict_value_8 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_8 = const_str_plain___module__;
            tmp_assign_source_93 = _PyDict_NewPresized( 7 );
            tmp_res = PyDict_SetItem( tmp_assign_source_93, tmp_dict_key_8, tmp_dict_value_8 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_9 = const_str_digest_6a19008e8f9a834793cf38dcba68883a;
            tmp_dict_key_9 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_93, tmp_dict_key_9, tmp_dict_value_9 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1576_key___init__ );
            tmp_dict_value_10 = tmp_locals_OpenSSL$crypto_1576_key___init__;
            tmp_dict_key_10 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_93, tmp_dict_key_10, tmp_dict_value_10 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1576_key_add_cert );
            tmp_dict_value_11 = tmp_locals_OpenSSL$crypto_1576_key_add_cert;
            tmp_dict_key_11 = const_str_plain_add_cert;
            tmp_res = PyDict_SetItem( tmp_assign_source_93, tmp_dict_key_11, tmp_dict_value_11 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1576_key_add_crl );
            tmp_dict_value_12 = tmp_locals_OpenSSL$crypto_1576_key_add_crl;
            tmp_dict_key_12 = const_str_plain_add_crl;
            tmp_res = PyDict_SetItem( tmp_assign_source_93, tmp_dict_key_12, tmp_dict_value_12 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1576_key_set_flags );
            tmp_dict_value_13 = tmp_locals_OpenSSL$crypto_1576_key_set_flags;
            tmp_dict_key_13 = const_str_plain_set_flags;
            tmp_res = PyDict_SetItem( tmp_assign_source_93, tmp_dict_key_13, tmp_dict_value_13 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1576_key_set_time );
            tmp_dict_value_14 = tmp_locals_OpenSSL$crypto_1576_key_set_time;
            tmp_dict_key_14 = const_str_plain_set_time;
            tmp_res = PyDict_SetItem( tmp_assign_source_93, tmp_dict_key_14, tmp_dict_value_14 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_21;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_21:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1576_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1576_key___init__ );
        tmp_locals_OpenSSL$crypto_1576_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1576_key_add_cert );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1576_key_add_cert );
        tmp_locals_OpenSSL$crypto_1576_key_add_cert = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1576_key_add_crl );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1576_key_add_crl );
        tmp_locals_OpenSSL$crypto_1576_key_add_crl = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1576_key_set_flags );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1576_key_set_flags );
        tmp_locals_OpenSSL$crypto_1576_key_set_flags = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1576_key_set_time );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1576_key_set_time );
        tmp_locals_OpenSSL$crypto_1576_key_set_time = NULL;

        goto outline_result_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_9:;
        assert( tmp_class_creation_10__class_dict == NULL );
        tmp_class_creation_10__class_dict = tmp_assign_source_93;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_99;
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        tmp_key_name_19 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_19 = tmp_class_creation_10__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_19, tmp_key_name_19 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1576;

            goto try_except_handler_22;
        }
        tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_10;
        }
        else
        {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_20 = tmp_class_creation_10__class_dict;
        tmp_key_name_20 = const_str_plain___metaclass__;
        tmp_assign_source_99 = DICT_GET_ITEM( tmp_dict_name_20, tmp_key_name_20 );
        if ( tmp_assign_source_99 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1576;

            goto try_except_handler_22;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        tmp_assign_source_99 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_99 );
        condexpr_end_10:;
        assert( tmp_class_creation_10__metaclass == NULL );
        tmp_class_creation_10__metaclass = tmp_assign_source_99;
    }
    {
        PyObject *tmp_assign_source_100;
        PyObject *tmp_called_name_24;
        PyObject *tmp_args_element_name_58;
        PyObject *tmp_args_element_name_59;
        PyObject *tmp_args_element_name_60;
        CHECK_OBJECT( tmp_class_creation_10__metaclass );
        tmp_called_name_24 = tmp_class_creation_10__metaclass;
        tmp_args_element_name_58 = const_str_plain_X509Store;
        tmp_args_element_name_59 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_args_element_name_60 = tmp_class_creation_10__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1576;
        {
            PyObject *call_args[] = { tmp_args_element_name_58, tmp_args_element_name_59, tmp_args_element_name_60 };
            tmp_assign_source_100 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_24, call_args );
        }

        if ( tmp_assign_source_100 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1576;

            goto try_except_handler_22;
        }
        assert( tmp_class_creation_10__class == NULL );
        tmp_class_creation_10__class = tmp_assign_source_100;
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_20 = exception_type;
    exception_keeper_value_20 = exception_value;
    exception_keeper_tb_20 = exception_tb;
    exception_keeper_lineno_20 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_20;
    exception_value = exception_keeper_value_20;
    exception_tb = exception_keeper_tb_20;
    exception_lineno = exception_keeper_lineno_20;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    {
        PyObject *tmp_assign_source_101;
        CHECK_OBJECT( tmp_class_creation_10__class );
        tmp_assign_source_101 = tmp_class_creation_10__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Store, tmp_assign_source_101 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class );
    Py_DECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    {
        PyObject *tmp_assign_source_102;
        PyObject *tmp_called_name_25;
        PyObject *tmp_mvar_value_48;
        PyObject *tmp_args_element_name_61;
        PyObject *tmp_mvar_value_49;
        PyObject *tmp_args_element_name_62;
        PyObject *tmp_args_element_name_63;
        PyObject *tmp_args_element_name_64;
        PyObject *tmp_mvar_value_50;
        tmp_mvar_value_48 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_48 == NULL ))
        {
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_48 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 1687;

            goto frame_exception_exit_1;
        }

        tmp_called_name_25 = tmp_mvar_value_48;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509Store );

        if (unlikely( tmp_mvar_value_49 == NULL ))
        {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_X509Store );
        }

        if ( tmp_mvar_value_49 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "X509Store" );
            exception_tb = NULL;

            exception_lineno = 1688;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_61 = tmp_mvar_value_49;
        tmp_args_element_name_62 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_63 = const_str_digest_aca114104f73a7934675fb06a5336647;
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_50 == NULL ))
        {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_50 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 1690;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_64 = tmp_mvar_value_50;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1687;
        {
            PyObject *call_args[] = { tmp_args_element_name_61, tmp_args_element_name_62, tmp_args_element_name_63, tmp_args_element_name_64 };
            tmp_assign_source_102 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_25, call_args );
        }

        if ( tmp_assign_source_102 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1687;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreType, tmp_assign_source_102 );
    }
    {
        PyObject *tmp_assign_source_103;
        {
            PyObject *tmp_assign_source_104;
            tmp_assign_source_104 = MAKE_FUNCTION_OpenSSL$crypto$$$function_90___init__(  );



            assert( tmp_locals_OpenSSL$crypto_1694_key___init__ == NULL );
            tmp_locals_OpenSSL$crypto_1694_key___init__ = tmp_assign_source_104;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_15;
            PyObject *tmp_dict_value_15;
            PyObject *tmp_dict_key_16;
            PyObject *tmp_dict_value_16;
            PyObject *tmp_dict_key_17;
            PyObject *tmp_dict_value_17;
            tmp_dict_value_15 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_15 = const_str_plain___module__;
            tmp_assign_source_103 = _PyDict_NewPresized( 3 );
            tmp_res = PyDict_SetItem( tmp_assign_source_103, tmp_dict_key_15, tmp_dict_value_15 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_16 = const_str_digest_a9fcf3ea8b3ff05d45964d00ac386113;
            tmp_dict_key_16 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_103, tmp_dict_key_16, tmp_dict_value_16 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1694_key___init__ );
            tmp_dict_value_17 = tmp_locals_OpenSSL$crypto_1694_key___init__;
            tmp_dict_key_17 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_103, tmp_dict_key_17, tmp_dict_value_17 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_23;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_23:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1694_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1694_key___init__ );
        tmp_locals_OpenSSL$crypto_1694_key___init__ = NULL;

        goto outline_result_10;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_10:;
        assert( tmp_class_creation_11__class_dict == NULL );
        tmp_class_creation_11__class_dict = tmp_assign_source_103;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_105;
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_key_name_22;
        tmp_key_name_21 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_21 = tmp_class_creation_11__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_21, tmp_key_name_21 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1694;

            goto try_except_handler_24;
        }
        tmp_condition_result_12 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_11;
        }
        else
        {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_22 = tmp_class_creation_11__class_dict;
        tmp_key_name_22 = const_str_plain___metaclass__;
        tmp_assign_source_105 = DICT_GET_ITEM( tmp_dict_name_22, tmp_key_name_22 );
        if ( tmp_assign_source_105 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1694;

            goto try_except_handler_24;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        tmp_assign_source_105 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_105 );
        condexpr_end_11:;
        assert( tmp_class_creation_11__metaclass == NULL );
        tmp_class_creation_11__metaclass = tmp_assign_source_105;
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_called_name_26;
        PyObject *tmp_args_element_name_65;
        PyObject *tmp_args_element_name_66;
        PyObject *tmp_args_element_name_67;
        CHECK_OBJECT( tmp_class_creation_11__metaclass );
        tmp_called_name_26 = tmp_class_creation_11__metaclass;
        tmp_args_element_name_65 = const_str_plain_X509StoreContextError;
        tmp_args_element_name_66 = const_tuple_type_Exception_tuple;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_args_element_name_67 = tmp_class_creation_11__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1694;
        {
            PyObject *call_args[] = { tmp_args_element_name_65, tmp_args_element_name_66, tmp_args_element_name_67 };
            tmp_assign_source_106 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_26, call_args );
        }

        if ( tmp_assign_source_106 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1694;

            goto try_except_handler_24;
        }
        assert( tmp_class_creation_11__class == NULL );
        tmp_class_creation_11__class = tmp_assign_source_106;
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_24:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    {
        PyObject *tmp_assign_source_107;
        CHECK_OBJECT( tmp_class_creation_11__class );
        tmp_assign_source_107 = tmp_class_creation_11__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContextError, tmp_assign_source_107 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class );
    Py_DECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    {
        PyObject *tmp_assign_source_108;
        {
            PyObject *tmp_assign_source_109;
            tmp_assign_source_109 = MAKE_FUNCTION_OpenSSL$crypto$$$function_91___init__(  );



            assert( tmp_locals_OpenSSL$crypto_1708_key___init__ == NULL );
            tmp_locals_OpenSSL$crypto_1708_key___init__ = tmp_assign_source_109;
        }
        {
            PyObject *tmp_assign_source_110;
            tmp_assign_source_110 = MAKE_FUNCTION_OpenSSL$crypto$$$function_92__init(  );



            assert( tmp_locals_OpenSSL$crypto_1708_key__init == NULL );
            tmp_locals_OpenSSL$crypto_1708_key__init = tmp_assign_source_110;
        }
        {
            PyObject *tmp_assign_source_111;
            tmp_assign_source_111 = MAKE_FUNCTION_OpenSSL$crypto$$$function_93__cleanup(  );



            assert( tmp_locals_OpenSSL$crypto_1708_key__cleanup == NULL );
            tmp_locals_OpenSSL$crypto_1708_key__cleanup = tmp_assign_source_111;
        }
        {
            PyObject *tmp_assign_source_112;
            tmp_assign_source_112 = MAKE_FUNCTION_OpenSSL$crypto$$$function_94__exception_from_context(  );



            assert( tmp_locals_OpenSSL$crypto_1708_key__exception_from_context == NULL );
            tmp_locals_OpenSSL$crypto_1708_key__exception_from_context = tmp_assign_source_112;
        }
        {
            PyObject *tmp_assign_source_113;
            tmp_assign_source_113 = MAKE_FUNCTION_OpenSSL$crypto$$$function_95_set_store(  );



            assert( tmp_locals_OpenSSL$crypto_1708_key_set_store == NULL );
            tmp_locals_OpenSSL$crypto_1708_key_set_store = tmp_assign_source_113;
        }
        {
            PyObject *tmp_assign_source_114;
            tmp_assign_source_114 = MAKE_FUNCTION_OpenSSL$crypto$$$function_96_verify_certificate(  );



            assert( tmp_locals_OpenSSL$crypto_1708_key_verify_certificate == NULL );
            tmp_locals_OpenSSL$crypto_1708_key_verify_certificate = tmp_assign_source_114;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_18;
            PyObject *tmp_dict_value_18;
            PyObject *tmp_dict_key_19;
            PyObject *tmp_dict_value_19;
            PyObject *tmp_dict_key_20;
            PyObject *tmp_dict_value_20;
            PyObject *tmp_dict_key_21;
            PyObject *tmp_dict_value_21;
            PyObject *tmp_dict_key_22;
            PyObject *tmp_dict_value_22;
            PyObject *tmp_dict_key_23;
            PyObject *tmp_dict_value_23;
            PyObject *tmp_dict_key_24;
            PyObject *tmp_dict_value_24;
            PyObject *tmp_dict_key_25;
            PyObject *tmp_dict_value_25;
            tmp_dict_value_18 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_18 = const_str_plain___module__;
            tmp_assign_source_108 = _PyDict_NewPresized( 8 );
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_18, tmp_dict_value_18 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_19 = const_str_digest_bd5b7ac1c36a2ac4b448366689be109e;
            tmp_dict_key_19 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_19, tmp_dict_value_19 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1708_key___init__ );
            tmp_dict_value_20 = tmp_locals_OpenSSL$crypto_1708_key___init__;
            tmp_dict_key_20 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_20, tmp_dict_value_20 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1708_key__init );
            tmp_dict_value_21 = tmp_locals_OpenSSL$crypto_1708_key__init;
            tmp_dict_key_21 = const_str_plain__init;
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_21, tmp_dict_value_21 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1708_key__cleanup );
            tmp_dict_value_22 = tmp_locals_OpenSSL$crypto_1708_key__cleanup;
            tmp_dict_key_22 = const_str_plain__cleanup;
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_22, tmp_dict_value_22 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1708_key__exception_from_context );
            tmp_dict_value_23 = tmp_locals_OpenSSL$crypto_1708_key__exception_from_context;
            tmp_dict_key_23 = const_str_plain__exception_from_context;
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_23, tmp_dict_value_23 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1708_key_set_store );
            tmp_dict_value_24 = tmp_locals_OpenSSL$crypto_1708_key_set_store;
            tmp_dict_key_24 = const_str_plain_set_store;
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_24, tmp_dict_value_24 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1708_key_verify_certificate );
            tmp_dict_value_25 = tmp_locals_OpenSSL$crypto_1708_key_verify_certificate;
            tmp_dict_key_25 = const_str_plain_verify_certificate;
            tmp_res = PyDict_SetItem( tmp_assign_source_108, tmp_dict_key_25, tmp_dict_value_25 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_25;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_25:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1708_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1708_key___init__ );
        tmp_locals_OpenSSL$crypto_1708_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1708_key__init );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1708_key__init );
        tmp_locals_OpenSSL$crypto_1708_key__init = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1708_key__cleanup );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1708_key__cleanup );
        tmp_locals_OpenSSL$crypto_1708_key__cleanup = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1708_key__exception_from_context );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1708_key__exception_from_context );
        tmp_locals_OpenSSL$crypto_1708_key__exception_from_context = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1708_key_set_store );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1708_key_set_store );
        tmp_locals_OpenSSL$crypto_1708_key_set_store = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1708_key_verify_certificate );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1708_key_verify_certificate );
        tmp_locals_OpenSSL$crypto_1708_key_verify_certificate = NULL;

        goto outline_result_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_11:;
        assert( tmp_class_creation_12__class_dict == NULL );
        tmp_class_creation_12__class_dict = tmp_assign_source_108;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_115;
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_key_name_23;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_dict_name_24;
        PyObject *tmp_key_name_24;
        tmp_key_name_23 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_23 = tmp_class_creation_12__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_23, tmp_key_name_23 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1708;

            goto try_except_handler_26;
        }
        tmp_condition_result_13 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_12;
        }
        else
        {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_24 = tmp_class_creation_12__class_dict;
        tmp_key_name_24 = const_str_plain___metaclass__;
        tmp_assign_source_115 = DICT_GET_ITEM( tmp_dict_name_24, tmp_key_name_24 );
        if ( tmp_assign_source_115 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1708;

            goto try_except_handler_26;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        tmp_assign_source_115 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_115 );
        condexpr_end_12:;
        assert( tmp_class_creation_12__metaclass == NULL );
        tmp_class_creation_12__metaclass = tmp_assign_source_115;
    }
    {
        PyObject *tmp_assign_source_116;
        PyObject *tmp_called_name_27;
        PyObject *tmp_args_element_name_68;
        PyObject *tmp_args_element_name_69;
        PyObject *tmp_args_element_name_70;
        CHECK_OBJECT( tmp_class_creation_12__metaclass );
        tmp_called_name_27 = tmp_class_creation_12__metaclass;
        tmp_args_element_name_68 = const_str_plain_X509StoreContext;
        tmp_args_element_name_69 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_args_element_name_70 = tmp_class_creation_12__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1708;
        {
            PyObject *call_args[] = { tmp_args_element_name_68, tmp_args_element_name_69, tmp_args_element_name_70 };
            tmp_assign_source_116 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_27, call_args );
        }

        if ( tmp_assign_source_116 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1708;

            goto try_except_handler_26;
        }
        assert( tmp_class_creation_12__class == NULL );
        tmp_class_creation_12__class = tmp_assign_source_116;
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_26:;
    exception_keeper_type_22 = exception_type;
    exception_keeper_value_22 = exception_value;
    exception_keeper_tb_22 = exception_tb;
    exception_keeper_lineno_22 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_22;
    exception_value = exception_keeper_value_22;
    exception_tb = exception_keeper_tb_22;
    exception_lineno = exception_keeper_lineno_22;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    {
        PyObject *tmp_assign_source_117;
        CHECK_OBJECT( tmp_class_creation_12__class );
        tmp_assign_source_117 = tmp_class_creation_12__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_X509StoreContext, tmp_assign_source_117 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class );
    Py_DECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    {
        PyObject *tmp_assign_source_118;
        tmp_assign_source_118 = MAKE_FUNCTION_OpenSSL$crypto$$$function_97_load_certificate(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_certificate, tmp_assign_source_118 );
    }
    {
        PyObject *tmp_assign_source_119;
        tmp_assign_source_119 = MAKE_FUNCTION_OpenSSL$crypto$$$function_98_dump_certificate(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_certificate, tmp_assign_source_119 );
    }
    {
        PyObject *tmp_assign_source_120;
        tmp_assign_source_120 = MAKE_FUNCTION_OpenSSL$crypto$$$function_99_dump_publickey(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_publickey, tmp_assign_source_120 );
    }
    {
        PyObject *tmp_assign_source_121;
        PyObject *tmp_defaults_3;
        tmp_defaults_3 = const_tuple_none_none_tuple;
        Py_INCREF( tmp_defaults_3 );
        tmp_assign_source_121 = MAKE_FUNCTION_OpenSSL$crypto$$$function_100_dump_privatekey( tmp_defaults_3 );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_privatekey, tmp_assign_source_121 );
    }
    {
        PyObject *tmp_assign_source_122;
        {
            PyObject *tmp_assign_source_123;
            tmp_assign_source_123 = LIST_COPY( const_list_298f4a46a008df82aecc87d37443e76b_list );
            assert( tmp_locals_OpenSSL$crypto_1953_key__crl_reasons == NULL );
            tmp_locals_OpenSSL$crypto_1953_key__crl_reasons = tmp_assign_source_123;
        }
        {
            PyObject *tmp_assign_source_124;
            tmp_assign_source_124 = MAKE_FUNCTION_OpenSSL$crypto$$$function_101___init__(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key___init__ == NULL );
            tmp_locals_OpenSSL$crypto_1953_key___init__ = tmp_assign_source_124;
        }
        {
            PyObject *tmp_assign_source_125;
            tmp_assign_source_125 = MAKE_FUNCTION_OpenSSL$crypto$$$function_102_set_serial(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key_set_serial == NULL );
            tmp_locals_OpenSSL$crypto_1953_key_set_serial = tmp_assign_source_125;
        }
        {
            PyObject *tmp_assign_source_126;
            tmp_assign_source_126 = MAKE_FUNCTION_OpenSSL$crypto$$$function_103_get_serial(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key_get_serial == NULL );
            tmp_locals_OpenSSL$crypto_1953_key_get_serial = tmp_assign_source_126;
        }
        {
            PyObject *tmp_assign_source_127;
            tmp_assign_source_127 = MAKE_FUNCTION_OpenSSL$crypto$$$function_104__delete_reason(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key__delete_reason == NULL );
            tmp_locals_OpenSSL$crypto_1953_key__delete_reason = tmp_assign_source_127;
        }
        {
            PyObject *tmp_assign_source_128;
            tmp_assign_source_128 = MAKE_FUNCTION_OpenSSL$crypto$$$function_105_set_reason(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key_set_reason == NULL );
            tmp_locals_OpenSSL$crypto_1953_key_set_reason = tmp_assign_source_128;
        }
        {
            PyObject *tmp_assign_source_129;
            tmp_assign_source_129 = MAKE_FUNCTION_OpenSSL$crypto$$$function_106_get_reason(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key_get_reason == NULL );
            tmp_locals_OpenSSL$crypto_1953_key_get_reason = tmp_assign_source_129;
        }
        {
            PyObject *tmp_assign_source_130;
            tmp_assign_source_130 = MAKE_FUNCTION_OpenSSL$crypto$$$function_107_all_reasons(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key_all_reasons == NULL );
            tmp_locals_OpenSSL$crypto_1953_key_all_reasons = tmp_assign_source_130;
        }
        {
            PyObject *tmp_assign_source_131;
            tmp_assign_source_131 = MAKE_FUNCTION_OpenSSL$crypto$$$function_108_set_rev_date(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key_set_rev_date == NULL );
            tmp_locals_OpenSSL$crypto_1953_key_set_rev_date = tmp_assign_source_131;
        }
        {
            PyObject *tmp_assign_source_132;
            tmp_assign_source_132 = MAKE_FUNCTION_OpenSSL$crypto$$$function_109_get_rev_date(  );



            assert( tmp_locals_OpenSSL$crypto_1953_key_get_rev_date == NULL );
            tmp_locals_OpenSSL$crypto_1953_key_get_rev_date = tmp_assign_source_132;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_26;
            PyObject *tmp_dict_value_26;
            PyObject *tmp_dict_key_27;
            PyObject *tmp_dict_value_27;
            PyObject *tmp_dict_key_28;
            PyObject *tmp_dict_value_28;
            PyObject *tmp_dict_key_29;
            PyObject *tmp_dict_value_29;
            PyObject *tmp_dict_key_30;
            PyObject *tmp_dict_value_30;
            PyObject *tmp_dict_key_31;
            PyObject *tmp_dict_value_31;
            PyObject *tmp_dict_key_32;
            PyObject *tmp_dict_value_32;
            PyObject *tmp_dict_key_33;
            PyObject *tmp_dict_value_33;
            PyObject *tmp_dict_key_34;
            PyObject *tmp_dict_value_34;
            PyObject *tmp_dict_key_35;
            PyObject *tmp_dict_value_35;
            PyObject *tmp_dict_key_36;
            PyObject *tmp_dict_value_36;
            PyObject *tmp_dict_key_37;
            PyObject *tmp_dict_value_37;
            tmp_dict_value_26 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_26 = const_str_plain___module__;
            tmp_assign_source_122 = _PyDict_NewPresized( 12 );
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_26, tmp_dict_value_26 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_27 = const_str_digest_6b975dcb77568b31c2312e045b6c638c;
            tmp_dict_key_27 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_27, tmp_dict_value_27 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key__crl_reasons );
            tmp_dict_value_28 = tmp_locals_OpenSSL$crypto_1953_key__crl_reasons;
            tmp_dict_key_28 = const_str_plain__crl_reasons;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_28, tmp_dict_value_28 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key___init__ );
            tmp_dict_value_29 = tmp_locals_OpenSSL$crypto_1953_key___init__;
            tmp_dict_key_29 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_29, tmp_dict_value_29 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key_set_serial );
            tmp_dict_value_30 = tmp_locals_OpenSSL$crypto_1953_key_set_serial;
            tmp_dict_key_30 = const_str_plain_set_serial;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_30, tmp_dict_value_30 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key_get_serial );
            tmp_dict_value_31 = tmp_locals_OpenSSL$crypto_1953_key_get_serial;
            tmp_dict_key_31 = const_str_plain_get_serial;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_31, tmp_dict_value_31 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key__delete_reason );
            tmp_dict_value_32 = tmp_locals_OpenSSL$crypto_1953_key__delete_reason;
            tmp_dict_key_32 = const_str_plain__delete_reason;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_32, tmp_dict_value_32 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key_set_reason );
            tmp_dict_value_33 = tmp_locals_OpenSSL$crypto_1953_key_set_reason;
            tmp_dict_key_33 = const_str_plain_set_reason;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_33, tmp_dict_value_33 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key_get_reason );
            tmp_dict_value_34 = tmp_locals_OpenSSL$crypto_1953_key_get_reason;
            tmp_dict_key_34 = const_str_plain_get_reason;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_34, tmp_dict_value_34 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key_all_reasons );
            tmp_dict_value_35 = tmp_locals_OpenSSL$crypto_1953_key_all_reasons;
            tmp_dict_key_35 = const_str_plain_all_reasons;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_35, tmp_dict_value_35 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key_set_rev_date );
            tmp_dict_value_36 = tmp_locals_OpenSSL$crypto_1953_key_set_rev_date;
            tmp_dict_key_36 = const_str_plain_set_rev_date;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_36, tmp_dict_value_36 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_1953_key_get_rev_date );
            tmp_dict_value_37 = tmp_locals_OpenSSL$crypto_1953_key_get_rev_date;
            tmp_dict_key_37 = const_str_plain_get_rev_date;
            tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_37, tmp_dict_value_37 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_27;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_27:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key__crl_reasons );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key__crl_reasons );
        tmp_locals_OpenSSL$crypto_1953_key__crl_reasons = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key___init__ );
        tmp_locals_OpenSSL$crypto_1953_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key_set_serial );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key_set_serial );
        tmp_locals_OpenSSL$crypto_1953_key_set_serial = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key_get_serial );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key_get_serial );
        tmp_locals_OpenSSL$crypto_1953_key_get_serial = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key__delete_reason );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key__delete_reason );
        tmp_locals_OpenSSL$crypto_1953_key__delete_reason = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key_set_reason );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key_set_reason );
        tmp_locals_OpenSSL$crypto_1953_key_set_reason = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key_get_reason );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key_get_reason );
        tmp_locals_OpenSSL$crypto_1953_key_get_reason = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key_all_reasons );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key_all_reasons );
        tmp_locals_OpenSSL$crypto_1953_key_all_reasons = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key_set_rev_date );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key_set_rev_date );
        tmp_locals_OpenSSL$crypto_1953_key_set_rev_date = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_1953_key_get_rev_date );
        Py_DECREF( tmp_locals_OpenSSL$crypto_1953_key_get_rev_date );
        tmp_locals_OpenSSL$crypto_1953_key_get_rev_date = NULL;

        goto outline_result_12;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_12:;
        assert( tmp_class_creation_13__class_dict == NULL );
        tmp_class_creation_13__class_dict = tmp_assign_source_122;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_133;
        nuitka_bool tmp_condition_result_14;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        tmp_key_name_25 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_25 = tmp_class_creation_13__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_25, tmp_key_name_25 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1953;

            goto try_except_handler_28;
        }
        tmp_condition_result_14 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_13;
        }
        else
        {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_26 = tmp_class_creation_13__class_dict;
        tmp_key_name_26 = const_str_plain___metaclass__;
        tmp_assign_source_133 = DICT_GET_ITEM( tmp_dict_name_26, tmp_key_name_26 );
        if ( tmp_assign_source_133 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1953;

            goto try_except_handler_28;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        tmp_assign_source_133 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_133 );
        condexpr_end_13:;
        assert( tmp_class_creation_13__metaclass == NULL );
        tmp_class_creation_13__metaclass = tmp_assign_source_133;
    }
    {
        PyObject *tmp_assign_source_134;
        PyObject *tmp_called_name_28;
        PyObject *tmp_args_element_name_71;
        PyObject *tmp_args_element_name_72;
        PyObject *tmp_args_element_name_73;
        CHECK_OBJECT( tmp_class_creation_13__metaclass );
        tmp_called_name_28 = tmp_class_creation_13__metaclass;
        tmp_args_element_name_71 = const_str_plain_Revoked;
        tmp_args_element_name_72 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_args_element_name_73 = tmp_class_creation_13__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 1953;
        {
            PyObject *call_args[] = { tmp_args_element_name_71, tmp_args_element_name_72, tmp_args_element_name_73 };
            tmp_assign_source_134 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_28, call_args );
        }

        if ( tmp_assign_source_134 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1953;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_13__class == NULL );
        tmp_class_creation_13__class = tmp_assign_source_134;
    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    {
        PyObject *tmp_assign_source_135;
        CHECK_OBJECT( tmp_class_creation_13__class );
        tmp_assign_source_135 = tmp_class_creation_13__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Revoked, tmp_assign_source_135 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class );
    Py_DECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_136;
        {
            PyObject *tmp_set_locals_8;
            tmp_set_locals_8 = PyDict_New();
            locals_OpenSSL$crypto_2123 = tmp_set_locals_8;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_6b6b180b644052fa34c3e81151f6ea0a;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_110___init__(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain___init__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_111_to_cryptography(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_to_cryptography, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_762cff70b659b0b1614f9749662cbdb5_9, codeobj_762cff70b659b0b1614f9749662cbdb5, module_OpenSSL$crypto, 0 );
        frame_762cff70b659b0b1614f9749662cbdb5_9 = cache_frame_762cff70b659b0b1614f9749662cbdb5_9;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_762cff70b659b0b1614f9749662cbdb5_9 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_762cff70b659b0b1614f9749662cbdb5_9 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_8;
            tmp_classmethod_arg_8 = MAKE_FUNCTION_OpenSSL$crypto$$$function_112_from_cryptography(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_8 );
            Py_DECREF( tmp_classmethod_arg_8 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2146;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_from_cryptography, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2146;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_113_get_revoked(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_get_revoked, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_114_add_revoked(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_add_revoked, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_115_get_issuer(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_get_issuer, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_116_set_version(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_set_version, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_117__set_boundary_time(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain__set_boundary_time, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_118_set_lastUpdate(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_set_lastUpdate, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_119_set_nextUpdate(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_set_nextUpdate, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_120_sign(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_sign, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_4;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_mvar_value_51;
            PyObject *tmp_mvar_value_52;
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );

            if (unlikely( tmp_mvar_value_51 == NULL ))
            {
                tmp_mvar_value_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_FILETYPE_PEM );
            }

            if ( tmp_mvar_value_51 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "FILETYPE_PEM" );
                exception_tb = NULL;

                exception_lineno = 2287;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_1 = tmp_mvar_value_51;
            tmp_defaults_4 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_defaults_4, 0, tmp_tuple_element_1 );
            tmp_tuple_element_1 = const_int_pos_100;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_defaults_4, 1, tmp_tuple_element_1 );
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );

            if (unlikely( tmp_mvar_value_52 == NULL ))
            {
                tmp_mvar_value_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__UNSPECIFIED );
            }

            if ( tmp_mvar_value_52 == NULL )
            {
                Py_DECREF( tmp_defaults_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_UNSPECIFIED" );
                exception_tb = NULL;

                exception_lineno = 2288;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_1 = tmp_mvar_value_52;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_defaults_4, 2, tmp_tuple_element_1 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_121_export( tmp_defaults_4 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2123, const_str_plain_export, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2287;

                goto frame_exception_exit_9;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_762cff70b659b0b1614f9749662cbdb5_9 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_8;

        frame_exception_exit_9:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_762cff70b659b0b1614f9749662cbdb5_9 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_762cff70b659b0b1614f9749662cbdb5_9, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_762cff70b659b0b1614f9749662cbdb5_9->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_762cff70b659b0b1614f9749662cbdb5_9, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_762cff70b659b0b1614f9749662cbdb5_9,
            type_description_2
        );


        // Release cached frame.
        if ( frame_762cff70b659b0b1614f9749662cbdb5_9 == cache_frame_762cff70b659b0b1614f9749662cbdb5_9 )
        {
            Py_DECREF( frame_762cff70b659b0b1614f9749662cbdb5_9 );
        }
        cache_frame_762cff70b659b0b1614f9749662cbdb5_9 = NULL;

        assertFrameObject( frame_762cff70b659b0b1614f9749662cbdb5_9 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_8;

        frame_no_exception_8:;
        goto skip_nested_handling_8;
        nested_frame_exit_8:;

        goto try_except_handler_30;
        skip_nested_handling_8:;
        tmp_assign_source_136 = locals_OpenSSL$crypto_2123;
        Py_INCREF( tmp_assign_source_136 );
        goto try_return_handler_30;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_30:;
        Py_DECREF( locals_OpenSSL$crypto_2123 );
        locals_OpenSSL$crypto_2123 = NULL;
        goto outline_result_13;
        // Exception handler code:
        try_except_handler_30:;
        exception_keeper_type_24 = exception_type;
        exception_keeper_value_24 = exception_value;
        exception_keeper_tb_24 = exception_tb;
        exception_keeper_lineno_24 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_2123 );
        locals_OpenSSL$crypto_2123 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_24;
        exception_value = exception_keeper_value_24;
        exception_tb = exception_keeper_tb_24;
        exception_lineno = exception_keeper_lineno_24;

        goto outline_exception_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_8:;
        exception_lineno = 2123;
        goto try_except_handler_29;
        outline_result_13:;
        assert( tmp_class_creation_14__class_dict == NULL );
        tmp_class_creation_14__class_dict = tmp_assign_source_136;
    }
    {
        PyObject *tmp_assign_source_137;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_key_name_28;
        tmp_key_name_27 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_27 = tmp_class_creation_14__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_27, tmp_key_name_27 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2123;

            goto try_except_handler_29;
        }
        tmp_condition_result_15 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_14;
        }
        else
        {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_28 = tmp_class_creation_14__class_dict;
        tmp_key_name_28 = const_str_plain___metaclass__;
        tmp_assign_source_137 = DICT_GET_ITEM( tmp_dict_name_28, tmp_key_name_28 );
        if ( tmp_assign_source_137 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2123;

            goto try_except_handler_29;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        tmp_assign_source_137 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_137 );
        condexpr_end_14:;
        assert( tmp_class_creation_14__metaclass == NULL );
        tmp_class_creation_14__metaclass = tmp_assign_source_137;
    }
    {
        PyObject *tmp_assign_source_138;
        PyObject *tmp_called_name_29;
        PyObject *tmp_args_element_name_74;
        PyObject *tmp_args_element_name_75;
        PyObject *tmp_args_element_name_76;
        CHECK_OBJECT( tmp_class_creation_14__metaclass );
        tmp_called_name_29 = tmp_class_creation_14__metaclass;
        tmp_args_element_name_74 = const_str_plain_CRL;
        tmp_args_element_name_75 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_args_element_name_76 = tmp_class_creation_14__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2123;
        {
            PyObject *call_args[] = { tmp_args_element_name_74, tmp_args_element_name_75, tmp_args_element_name_76 };
            tmp_assign_source_138 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_29, call_args );
        }

        if ( tmp_assign_source_138 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2123;

            goto try_except_handler_29;
        }
        assert( tmp_class_creation_14__class == NULL );
        tmp_class_creation_14__class = tmp_assign_source_138;
    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_29:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    {
        PyObject *tmp_assign_source_139;
        CHECK_OBJECT( tmp_class_creation_14__class );
        tmp_assign_source_139 = tmp_class_creation_14__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL, tmp_assign_source_139 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class );
    Py_DECREF( tmp_class_creation_14__class );
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_dict );
    Py_DECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    {
        PyObject *tmp_assign_source_140;
        PyObject *tmp_called_name_30;
        PyObject *tmp_mvar_value_53;
        PyObject *tmp_args_element_name_77;
        PyObject *tmp_mvar_value_54;
        PyObject *tmp_args_element_name_78;
        PyObject *tmp_args_element_name_79;
        PyObject *tmp_args_element_name_80;
        PyObject *tmp_mvar_value_55;
        tmp_mvar_value_53 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_53 == NULL ))
        {
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_53 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 2341;

            goto frame_exception_exit_1;
        }

        tmp_called_name_30 = tmp_mvar_value_53;
        tmp_mvar_value_54 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRL );

        if (unlikely( tmp_mvar_value_54 == NULL ))
        {
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CRL );
        }

        if ( tmp_mvar_value_54 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "CRL" );
            exception_tb = NULL;

            exception_lineno = 2342;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_77 = tmp_mvar_value_54;
        tmp_args_element_name_78 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_79 = const_str_digest_08a0d510acdd77f37b666a4668538f96;
        tmp_mvar_value_55 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_55 == NULL ))
        {
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_55 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 2344;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_80 = tmp_mvar_value_55;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2341;
        {
            PyObject *call_args[] = { tmp_args_element_name_77, tmp_args_element_name_78, tmp_args_element_name_79, tmp_args_element_name_80 };
            tmp_assign_source_140 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_30, call_args );
        }

        if ( tmp_assign_source_140 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2341;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_CRLType, tmp_assign_source_140 );
    }
    {
        PyObject *tmp_assign_source_141;
        {
            PyObject *tmp_assign_source_142;
            tmp_assign_source_142 = MAKE_FUNCTION_OpenSSL$crypto$$$function_122_type_is_signed(  );



            assert( tmp_locals_OpenSSL$crypto_2348_key_type_is_signed == NULL );
            tmp_locals_OpenSSL$crypto_2348_key_type_is_signed = tmp_assign_source_142;
        }
        {
            PyObject *tmp_assign_source_143;
            tmp_assign_source_143 = MAKE_FUNCTION_OpenSSL$crypto$$$function_123_type_is_enveloped(  );



            assert( tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped == NULL );
            tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped = tmp_assign_source_143;
        }
        {
            PyObject *tmp_assign_source_144;
            tmp_assign_source_144 = MAKE_FUNCTION_OpenSSL$crypto$$$function_124_type_is_signedAndEnveloped(  );



            assert( tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped == NULL );
            tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped = tmp_assign_source_144;
        }
        {
            PyObject *tmp_assign_source_145;
            tmp_assign_source_145 = MAKE_FUNCTION_OpenSSL$crypto$$$function_125_type_is_data(  );



            assert( tmp_locals_OpenSSL$crypto_2348_key_type_is_data == NULL );
            tmp_locals_OpenSSL$crypto_2348_key_type_is_data = tmp_assign_source_145;
        }
        {
            PyObject *tmp_assign_source_146;
            tmp_assign_source_146 = MAKE_FUNCTION_OpenSSL$crypto$$$function_126_get_type_name(  );



            assert( tmp_locals_OpenSSL$crypto_2348_key_get_type_name == NULL );
            tmp_locals_OpenSSL$crypto_2348_key_get_type_name = tmp_assign_source_146;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_38;
            PyObject *tmp_dict_value_38;
            PyObject *tmp_dict_key_39;
            PyObject *tmp_dict_value_39;
            PyObject *tmp_dict_key_40;
            PyObject *tmp_dict_value_40;
            PyObject *tmp_dict_key_41;
            PyObject *tmp_dict_value_41;
            PyObject *tmp_dict_key_42;
            PyObject *tmp_dict_value_42;
            PyObject *tmp_dict_key_43;
            PyObject *tmp_dict_value_43;
            tmp_dict_value_38 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_38 = const_str_plain___module__;
            tmp_assign_source_141 = _PyDict_NewPresized( 6 );
            tmp_res = PyDict_SetItem( tmp_assign_source_141, tmp_dict_key_38, tmp_dict_value_38 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2348_key_type_is_signed );
            tmp_dict_value_39 = tmp_locals_OpenSSL$crypto_2348_key_type_is_signed;
            tmp_dict_key_39 = const_str_plain_type_is_signed;
            tmp_res = PyDict_SetItem( tmp_assign_source_141, tmp_dict_key_39, tmp_dict_value_39 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped );
            tmp_dict_value_40 = tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped;
            tmp_dict_key_40 = const_str_plain_type_is_enveloped;
            tmp_res = PyDict_SetItem( tmp_assign_source_141, tmp_dict_key_40, tmp_dict_value_40 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped );
            tmp_dict_value_41 = tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped;
            tmp_dict_key_41 = const_str_plain_type_is_signedAndEnveloped;
            tmp_res = PyDict_SetItem( tmp_assign_source_141, tmp_dict_key_41, tmp_dict_value_41 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2348_key_type_is_data );
            tmp_dict_value_42 = tmp_locals_OpenSSL$crypto_2348_key_type_is_data;
            tmp_dict_key_42 = const_str_plain_type_is_data;
            tmp_res = PyDict_SetItem( tmp_assign_source_141, tmp_dict_key_42, tmp_dict_value_42 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2348_key_get_type_name );
            tmp_dict_value_43 = tmp_locals_OpenSSL$crypto_2348_key_get_type_name;
            tmp_dict_key_43 = const_str_plain_get_type_name;
            tmp_res = PyDict_SetItem( tmp_assign_source_141, tmp_dict_key_43, tmp_dict_value_43 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_31;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_31:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_signed );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2348_key_type_is_signed );
        tmp_locals_OpenSSL$crypto_2348_key_type_is_signed = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped );
        tmp_locals_OpenSSL$crypto_2348_key_type_is_enveloped = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped );
        tmp_locals_OpenSSL$crypto_2348_key_type_is_signedAndEnveloped = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2348_key_type_is_data );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2348_key_type_is_data );
        tmp_locals_OpenSSL$crypto_2348_key_type_is_data = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2348_key_get_type_name );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2348_key_get_type_name );
        tmp_locals_OpenSSL$crypto_2348_key_get_type_name = NULL;

        goto outline_result_14;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_14:;
        assert( tmp_class_creation_15__class_dict == NULL );
        tmp_class_creation_15__class_dict = tmp_assign_source_141;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_147;
        nuitka_bool tmp_condition_result_16;
        PyObject *tmp_key_name_29;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_dict_name_30;
        PyObject *tmp_key_name_30;
        tmp_key_name_29 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_29 = tmp_class_creation_15__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_29, tmp_key_name_29 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2348;

            goto try_except_handler_32;
        }
        tmp_condition_result_16 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_15;
        }
        else
        {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_30 = tmp_class_creation_15__class_dict;
        tmp_key_name_30 = const_str_plain___metaclass__;
        tmp_assign_source_147 = DICT_GET_ITEM( tmp_dict_name_30, tmp_key_name_30 );
        if ( tmp_assign_source_147 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2348;

            goto try_except_handler_32;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        tmp_assign_source_147 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_147 );
        condexpr_end_15:;
        assert( tmp_class_creation_15__metaclass == NULL );
        tmp_class_creation_15__metaclass = tmp_assign_source_147;
    }
    {
        PyObject *tmp_assign_source_148;
        PyObject *tmp_called_name_31;
        PyObject *tmp_args_element_name_81;
        PyObject *tmp_args_element_name_82;
        PyObject *tmp_args_element_name_83;
        CHECK_OBJECT( tmp_class_creation_15__metaclass );
        tmp_called_name_31 = tmp_class_creation_15__metaclass;
        tmp_args_element_name_81 = const_str_plain_PKCS7;
        tmp_args_element_name_82 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_args_element_name_83 = tmp_class_creation_15__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2348;
        {
            PyObject *call_args[] = { tmp_args_element_name_81, tmp_args_element_name_82, tmp_args_element_name_83 };
            tmp_assign_source_148 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_31, call_args );
        }

        if ( tmp_assign_source_148 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2348;

            goto try_except_handler_32;
        }
        assert( tmp_class_creation_15__class == NULL );
        tmp_class_creation_15__class = tmp_assign_source_148;
    }
    goto try_end_18;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_26 = exception_type;
    exception_keeper_value_26 = exception_value;
    exception_keeper_tb_26 = exception_tb;
    exception_keeper_lineno_26 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_26;
    exception_value = exception_keeper_value_26;
    exception_tb = exception_keeper_tb_26;
    exception_lineno = exception_keeper_lineno_26;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    {
        PyObject *tmp_assign_source_149;
        CHECK_OBJECT( tmp_class_creation_15__class );
        tmp_assign_source_149 = tmp_class_creation_15__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7, tmp_assign_source_149 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class );
    Py_DECREF( tmp_class_creation_15__class );
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    {
        PyObject *tmp_assign_source_150;
        PyObject *tmp_called_name_32;
        PyObject *tmp_mvar_value_56;
        PyObject *tmp_args_element_name_84;
        PyObject *tmp_mvar_value_57;
        PyObject *tmp_args_element_name_85;
        PyObject *tmp_args_element_name_86;
        PyObject *tmp_args_element_name_87;
        PyObject *tmp_mvar_value_58;
        tmp_mvar_value_56 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_56 == NULL ))
        {
            tmp_mvar_value_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_56 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 2392;

            goto frame_exception_exit_1;
        }

        tmp_called_name_32 = tmp_mvar_value_56;
        tmp_mvar_value_57 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7 );

        if (unlikely( tmp_mvar_value_57 == NULL ))
        {
            tmp_mvar_value_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS7 );
        }

        if ( tmp_mvar_value_57 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PKCS7" );
            exception_tb = NULL;

            exception_lineno = 2393;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_84 = tmp_mvar_value_57;
        tmp_args_element_name_85 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_86 = const_str_digest_1cf455235163a6978480cc7b12198a27;
        tmp_mvar_value_58 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_58 == NULL ))
        {
            tmp_mvar_value_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_58 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 2395;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_87 = tmp_mvar_value_58;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2392;
        {
            PyObject *call_args[] = { tmp_args_element_name_84, tmp_args_element_name_85, tmp_args_element_name_86, tmp_args_element_name_87 };
            tmp_assign_source_150 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_32, call_args );
        }

        if ( tmp_assign_source_150 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2392;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS7Type, tmp_assign_source_150 );
    }
    {
        PyObject *tmp_assign_source_151;
        {
            PyObject *tmp_assign_source_152;
            tmp_assign_source_152 = MAKE_FUNCTION_OpenSSL$crypto$$$function_127___init__(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key___init__ == NULL );
            tmp_locals_OpenSSL$crypto_2399_key___init__ = tmp_assign_source_152;
        }
        {
            PyObject *tmp_assign_source_153;
            tmp_assign_source_153 = MAKE_FUNCTION_OpenSSL$crypto$$$function_128_get_certificate(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_get_certificate == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_get_certificate = tmp_assign_source_153;
        }
        {
            PyObject *tmp_assign_source_154;
            tmp_assign_source_154 = MAKE_FUNCTION_OpenSSL$crypto$$$function_129_set_certificate(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_set_certificate == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_set_certificate = tmp_assign_source_154;
        }
        {
            PyObject *tmp_assign_source_155;
            tmp_assign_source_155 = MAKE_FUNCTION_OpenSSL$crypto$$$function_130_get_privatekey(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_get_privatekey == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_get_privatekey = tmp_assign_source_155;
        }
        {
            PyObject *tmp_assign_source_156;
            tmp_assign_source_156 = MAKE_FUNCTION_OpenSSL$crypto$$$function_131_set_privatekey(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_set_privatekey == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_set_privatekey = tmp_assign_source_156;
        }
        {
            PyObject *tmp_assign_source_157;
            tmp_assign_source_157 = MAKE_FUNCTION_OpenSSL$crypto$$$function_132_get_ca_certificates(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates = tmp_assign_source_157;
        }
        {
            PyObject *tmp_assign_source_158;
            tmp_assign_source_158 = MAKE_FUNCTION_OpenSSL$crypto$$$function_133_set_ca_certificates(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates = tmp_assign_source_158;
        }
        {
            PyObject *tmp_assign_source_159;
            tmp_assign_source_159 = MAKE_FUNCTION_OpenSSL$crypto$$$function_134_set_friendlyname(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname = tmp_assign_source_159;
        }
        {
            PyObject *tmp_assign_source_160;
            tmp_assign_source_160 = MAKE_FUNCTION_OpenSSL$crypto$$$function_135_get_friendlyname(  );



            assert( tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname = tmp_assign_source_160;
        }
        {
            PyObject *tmp_assign_source_161;
            PyObject *tmp_defaults_5;
            tmp_defaults_5 = const_tuple_none_int_pos_2048_int_pos_1_tuple;
            Py_INCREF( tmp_defaults_5 );
            tmp_assign_source_161 = MAKE_FUNCTION_OpenSSL$crypto$$$function_136_export( tmp_defaults_5 );



            assert( tmp_locals_OpenSSL$crypto_2399_key_export == NULL );
            tmp_locals_OpenSSL$crypto_2399_key_export = tmp_assign_source_161;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_44;
            PyObject *tmp_dict_value_44;
            PyObject *tmp_dict_key_45;
            PyObject *tmp_dict_value_45;
            PyObject *tmp_dict_key_46;
            PyObject *tmp_dict_value_46;
            PyObject *tmp_dict_key_47;
            PyObject *tmp_dict_value_47;
            PyObject *tmp_dict_key_48;
            PyObject *tmp_dict_value_48;
            PyObject *tmp_dict_key_49;
            PyObject *tmp_dict_value_49;
            PyObject *tmp_dict_key_50;
            PyObject *tmp_dict_value_50;
            PyObject *tmp_dict_key_51;
            PyObject *tmp_dict_value_51;
            PyObject *tmp_dict_key_52;
            PyObject *tmp_dict_value_52;
            PyObject *tmp_dict_key_53;
            PyObject *tmp_dict_value_53;
            PyObject *tmp_dict_key_54;
            PyObject *tmp_dict_value_54;
            PyObject *tmp_dict_key_55;
            PyObject *tmp_dict_value_55;
            tmp_dict_value_44 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_44 = const_str_plain___module__;
            tmp_assign_source_151 = _PyDict_NewPresized( 12 );
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_44, tmp_dict_value_44 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_45 = const_str_digest_4b3673d04a6e4a628e29457d54d43c0d;
            tmp_dict_key_45 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_45, tmp_dict_value_45 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key___init__ );
            tmp_dict_value_46 = tmp_locals_OpenSSL$crypto_2399_key___init__;
            tmp_dict_key_46 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_46, tmp_dict_value_46 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_get_certificate );
            tmp_dict_value_47 = tmp_locals_OpenSSL$crypto_2399_key_get_certificate;
            tmp_dict_key_47 = const_str_plain_get_certificate;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_47, tmp_dict_value_47 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_set_certificate );
            tmp_dict_value_48 = tmp_locals_OpenSSL$crypto_2399_key_set_certificate;
            tmp_dict_key_48 = const_str_plain_set_certificate;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_48, tmp_dict_value_48 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_get_privatekey );
            tmp_dict_value_49 = tmp_locals_OpenSSL$crypto_2399_key_get_privatekey;
            tmp_dict_key_49 = const_str_plain_get_privatekey;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_49, tmp_dict_value_49 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_set_privatekey );
            tmp_dict_value_50 = tmp_locals_OpenSSL$crypto_2399_key_set_privatekey;
            tmp_dict_key_50 = const_str_plain_set_privatekey;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_50, tmp_dict_value_50 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates );
            tmp_dict_value_51 = tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates;
            tmp_dict_key_51 = const_str_plain_get_ca_certificates;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_51, tmp_dict_value_51 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates );
            tmp_dict_value_52 = tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates;
            tmp_dict_key_52 = const_str_plain_set_ca_certificates;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_52, tmp_dict_value_52 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname );
            tmp_dict_value_53 = tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname;
            tmp_dict_key_53 = const_str_plain_set_friendlyname;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_53, tmp_dict_value_53 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname );
            tmp_dict_value_54 = tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname;
            tmp_dict_key_54 = const_str_plain_get_friendlyname;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_54, tmp_dict_value_54 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2399_key_export );
            tmp_dict_value_55 = tmp_locals_OpenSSL$crypto_2399_key_export;
            tmp_dict_key_55 = const_str_plain_export;
            tmp_res = PyDict_SetItem( tmp_assign_source_151, tmp_dict_key_55, tmp_dict_value_55 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_33;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_33:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key___init__ );
        tmp_locals_OpenSSL$crypto_2399_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_certificate );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_get_certificate );
        tmp_locals_OpenSSL$crypto_2399_key_get_certificate = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_certificate );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_set_certificate );
        tmp_locals_OpenSSL$crypto_2399_key_set_certificate = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_privatekey );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_get_privatekey );
        tmp_locals_OpenSSL$crypto_2399_key_get_privatekey = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_privatekey );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_set_privatekey );
        tmp_locals_OpenSSL$crypto_2399_key_set_privatekey = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates );
        tmp_locals_OpenSSL$crypto_2399_key_get_ca_certificates = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates );
        tmp_locals_OpenSSL$crypto_2399_key_set_ca_certificates = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname );
        tmp_locals_OpenSSL$crypto_2399_key_set_friendlyname = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname );
        tmp_locals_OpenSSL$crypto_2399_key_get_friendlyname = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2399_key_export );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2399_key_export );
        tmp_locals_OpenSSL$crypto_2399_key_export = NULL;

        goto outline_result_15;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_15:;
        assert( tmp_class_creation_16__class_dict == NULL );
        tmp_class_creation_16__class_dict = tmp_assign_source_151;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_162;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        tmp_key_name_31 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_31 = tmp_class_creation_16__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_31, tmp_key_name_31 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2399;

            goto try_except_handler_34;
        }
        tmp_condition_result_17 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_16;
        }
        else
        {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_32 = tmp_class_creation_16__class_dict;
        tmp_key_name_32 = const_str_plain___metaclass__;
        tmp_assign_source_162 = DICT_GET_ITEM( tmp_dict_name_32, tmp_key_name_32 );
        if ( tmp_assign_source_162 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2399;

            goto try_except_handler_34;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        tmp_assign_source_162 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_162 );
        condexpr_end_16:;
        assert( tmp_class_creation_16__metaclass == NULL );
        tmp_class_creation_16__metaclass = tmp_assign_source_162;
    }
    {
        PyObject *tmp_assign_source_163;
        PyObject *tmp_called_name_33;
        PyObject *tmp_args_element_name_88;
        PyObject *tmp_args_element_name_89;
        PyObject *tmp_args_element_name_90;
        CHECK_OBJECT( tmp_class_creation_16__metaclass );
        tmp_called_name_33 = tmp_class_creation_16__metaclass;
        tmp_args_element_name_88 = const_str_plain_PKCS12;
        tmp_args_element_name_89 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_args_element_name_90 = tmp_class_creation_16__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2399;
        {
            PyObject *call_args[] = { tmp_args_element_name_88, tmp_args_element_name_89, tmp_args_element_name_90 };
            tmp_assign_source_163 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_33, call_args );
        }

        if ( tmp_assign_source_163 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2399;

            goto try_except_handler_34;
        }
        assert( tmp_class_creation_16__class == NULL );
        tmp_class_creation_16__class = tmp_assign_source_163;
    }
    goto try_end_19;
    // Exception handler code:
    try_except_handler_34:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    {
        PyObject *tmp_assign_source_164;
        CHECK_OBJECT( tmp_class_creation_16__class );
        tmp_assign_source_164 = tmp_class_creation_16__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12, tmp_assign_source_164 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class );
    Py_DECREF( tmp_class_creation_16__class );
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__metaclass );
    Py_DECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    {
        PyObject *tmp_assign_source_165;
        PyObject *tmp_called_name_34;
        PyObject *tmp_mvar_value_59;
        PyObject *tmp_args_element_name_91;
        PyObject *tmp_mvar_value_60;
        PyObject *tmp_args_element_name_92;
        PyObject *tmp_args_element_name_93;
        PyObject *tmp_args_element_name_94;
        PyObject *tmp_mvar_value_61;
        tmp_mvar_value_59 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_59 == NULL ))
        {
            tmp_mvar_value_59 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_59 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 2573;

            goto frame_exception_exit_1;
        }

        tmp_called_name_34 = tmp_mvar_value_59;
        tmp_mvar_value_60 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12 );

        if (unlikely( tmp_mvar_value_60 == NULL ))
        {
            tmp_mvar_value_60 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PKCS12 );
        }

        if ( tmp_mvar_value_60 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PKCS12" );
            exception_tb = NULL;

            exception_lineno = 2574;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_91 = tmp_mvar_value_60;
        tmp_args_element_name_92 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_93 = const_str_digest_3c7878f9f14c822b0ae6ebb3dbe0804c;
        tmp_mvar_value_61 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_61 == NULL ))
        {
            tmp_mvar_value_61 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_61 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 2576;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_94 = tmp_mvar_value_61;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2573;
        {
            PyObject *call_args[] = { tmp_args_element_name_91, tmp_args_element_name_92, tmp_args_element_name_93, tmp_args_element_name_94 };
            tmp_assign_source_165 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_34, call_args );
        }

        if ( tmp_assign_source_165 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2573;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_PKCS12Type, tmp_assign_source_165 );
    }
    {
        PyObject *tmp_assign_source_166;
        {
            PyObject *tmp_assign_source_167;
            tmp_assign_source_167 = MAKE_FUNCTION_OpenSSL$crypto$$$function_137___init__(  );



            assert( tmp_locals_OpenSSL$crypto_2580_key___init__ == NULL );
            tmp_locals_OpenSSL$crypto_2580_key___init__ = tmp_assign_source_167;
        }
        {
            PyObject *tmp_assign_source_168;
            tmp_assign_source_168 = MAKE_FUNCTION_OpenSSL$crypto$$$function_138_sign(  );



            assert( tmp_locals_OpenSSL$crypto_2580_key_sign == NULL );
            tmp_locals_OpenSSL$crypto_2580_key_sign = tmp_assign_source_168;
        }
        {
            PyObject *tmp_assign_source_169;
            tmp_assign_source_169 = MAKE_FUNCTION_OpenSSL$crypto$$$function_139_verify(  );



            assert( tmp_locals_OpenSSL$crypto_2580_key_verify == NULL );
            tmp_locals_OpenSSL$crypto_2580_key_verify = tmp_assign_source_169;
        }
        {
            PyObject *tmp_assign_source_170;
            tmp_assign_source_170 = MAKE_FUNCTION_OpenSSL$crypto$$$function_140_b64_encode(  );



            assert( tmp_locals_OpenSSL$crypto_2580_key_b64_encode == NULL );
            tmp_locals_OpenSSL$crypto_2580_key_b64_encode = tmp_assign_source_170;
        }
        {
            PyObject *tmp_assign_source_171;
            tmp_assign_source_171 = MAKE_FUNCTION_OpenSSL$crypto$$$function_141_get_pubkey(  );



            assert( tmp_locals_OpenSSL$crypto_2580_key_get_pubkey == NULL );
            tmp_locals_OpenSSL$crypto_2580_key_get_pubkey = tmp_assign_source_171;
        }
        {
            PyObject *tmp_assign_source_172;
            tmp_assign_source_172 = MAKE_FUNCTION_OpenSSL$crypto$$$function_142_set_pubkey(  );



            assert( tmp_locals_OpenSSL$crypto_2580_key_set_pubkey == NULL );
            tmp_locals_OpenSSL$crypto_2580_key_set_pubkey = tmp_assign_source_172;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_56;
            PyObject *tmp_dict_value_56;
            PyObject *tmp_dict_key_57;
            PyObject *tmp_dict_value_57;
            PyObject *tmp_dict_key_58;
            PyObject *tmp_dict_value_58;
            PyObject *tmp_dict_key_59;
            PyObject *tmp_dict_value_59;
            PyObject *tmp_dict_key_60;
            PyObject *tmp_dict_value_60;
            PyObject *tmp_dict_key_61;
            PyObject *tmp_dict_value_61;
            PyObject *tmp_dict_key_62;
            PyObject *tmp_dict_value_62;
            PyObject *tmp_dict_key_63;
            PyObject *tmp_dict_value_63;
            tmp_dict_value_56 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
            tmp_dict_key_56 = const_str_plain___module__;
            tmp_assign_source_166 = _PyDict_NewPresized( 8 );
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_56, tmp_dict_value_56 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_57 = const_str_digest_713d8c2afef94db133cda1bff1cb496f;
            tmp_dict_key_57 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_57, tmp_dict_value_57 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2580_key___init__ );
            tmp_dict_value_58 = tmp_locals_OpenSSL$crypto_2580_key___init__;
            tmp_dict_key_58 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_58, tmp_dict_value_58 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2580_key_sign );
            tmp_dict_value_59 = tmp_locals_OpenSSL$crypto_2580_key_sign;
            tmp_dict_key_59 = const_str_plain_sign;
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_59, tmp_dict_value_59 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2580_key_verify );
            tmp_dict_value_60 = tmp_locals_OpenSSL$crypto_2580_key_verify;
            tmp_dict_key_60 = const_str_plain_verify;
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_60, tmp_dict_value_60 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2580_key_b64_encode );
            tmp_dict_value_61 = tmp_locals_OpenSSL$crypto_2580_key_b64_encode;
            tmp_dict_key_61 = const_str_plain_b64_encode;
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_61, tmp_dict_value_61 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2580_key_get_pubkey );
            tmp_dict_value_62 = tmp_locals_OpenSSL$crypto_2580_key_get_pubkey;
            tmp_dict_key_62 = const_str_plain_get_pubkey;
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_62, tmp_dict_value_62 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_OpenSSL$crypto_2580_key_set_pubkey );
            tmp_dict_value_63 = tmp_locals_OpenSSL$crypto_2580_key_set_pubkey;
            tmp_dict_key_63 = const_str_plain_set_pubkey;
            tmp_res = PyDict_SetItem( tmp_assign_source_166, tmp_dict_key_63, tmp_dict_value_63 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_35;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_35:;
        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2580_key___init__ );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2580_key___init__ );
        tmp_locals_OpenSSL$crypto_2580_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2580_key_sign );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2580_key_sign );
        tmp_locals_OpenSSL$crypto_2580_key_sign = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2580_key_verify );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2580_key_verify );
        tmp_locals_OpenSSL$crypto_2580_key_verify = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2580_key_b64_encode );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2580_key_b64_encode );
        tmp_locals_OpenSSL$crypto_2580_key_b64_encode = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2580_key_get_pubkey );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2580_key_get_pubkey );
        tmp_locals_OpenSSL$crypto_2580_key_get_pubkey = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_OpenSSL$crypto_2580_key_set_pubkey );
        Py_DECREF( tmp_locals_OpenSSL$crypto_2580_key_set_pubkey );
        tmp_locals_OpenSSL$crypto_2580_key_set_pubkey = NULL;

        goto outline_result_16;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_result_16:;
        assert( tmp_class_creation_17__class_dict == NULL );
        tmp_class_creation_17__class_dict = tmp_assign_source_166;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_173;
        nuitka_bool tmp_condition_result_18;
        PyObject *tmp_key_name_33;
        PyObject *tmp_dict_name_33;
        PyObject *tmp_dict_name_34;
        PyObject *tmp_key_name_34;
        tmp_key_name_33 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_dict_name_33 = tmp_class_creation_17__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_33, tmp_key_name_33 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2580;

            goto try_except_handler_36;
        }
        tmp_condition_result_18 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_18 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_17;
        }
        else
        {
            goto condexpr_false_17;
        }
        condexpr_true_17:;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_dict_name_34 = tmp_class_creation_17__class_dict;
        tmp_key_name_34 = const_str_plain___metaclass__;
        tmp_assign_source_173 = DICT_GET_ITEM( tmp_dict_name_34, tmp_key_name_34 );
        if ( tmp_assign_source_173 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2580;

            goto try_except_handler_36;
        }
        goto condexpr_end_17;
        condexpr_false_17:;
        tmp_assign_source_173 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_173 );
        condexpr_end_17:;
        assert( tmp_class_creation_17__metaclass == NULL );
        tmp_class_creation_17__metaclass = tmp_assign_source_173;
    }
    {
        PyObject *tmp_assign_source_174;
        PyObject *tmp_called_name_35;
        PyObject *tmp_args_element_name_95;
        PyObject *tmp_args_element_name_96;
        PyObject *tmp_args_element_name_97;
        CHECK_OBJECT( tmp_class_creation_17__metaclass );
        tmp_called_name_35 = tmp_class_creation_17__metaclass;
        tmp_args_element_name_95 = const_str_plain_NetscapeSPKI;
        tmp_args_element_name_96 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_args_element_name_97 = tmp_class_creation_17__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2580;
        {
            PyObject *call_args[] = { tmp_args_element_name_95, tmp_args_element_name_96, tmp_args_element_name_97 };
            tmp_assign_source_174 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_35, call_args );
        }

        if ( tmp_assign_source_174 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2580;

            goto try_except_handler_36;
        }
        assert( tmp_class_creation_17__class == NULL );
        tmp_class_creation_17__class = tmp_assign_source_174;
    }
    goto try_end_20;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_28 = exception_type;
    exception_keeper_value_28 = exception_value;
    exception_keeper_tb_28 = exception_tb;
    exception_keeper_lineno_28 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_dict );
    Py_DECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_28;
    exception_value = exception_keeper_value_28;
    exception_tb = exception_keeper_tb_28;
    exception_lineno = exception_keeper_lineno_28;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    {
        PyObject *tmp_assign_source_175;
        CHECK_OBJECT( tmp_class_creation_17__class );
        tmp_assign_source_175 = tmp_class_creation_17__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_NetscapeSPKI, tmp_assign_source_175 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class );
    Py_DECREF( tmp_class_creation_17__class );
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_dict );
    Py_DECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__metaclass );
    Py_DECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    {
        PyObject *tmp_assign_source_176;
        PyObject *tmp_called_name_36;
        PyObject *tmp_mvar_value_62;
        PyObject *tmp_args_element_name_98;
        PyObject *tmp_mvar_value_63;
        PyObject *tmp_args_element_name_99;
        PyObject *tmp_args_element_name_100;
        PyObject *tmp_args_element_name_101;
        PyObject *tmp_mvar_value_64;
        tmp_mvar_value_62 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_deprecated );

        if (unlikely( tmp_mvar_value_62 == NULL ))
        {
            tmp_mvar_value_62 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deprecated );
        }

        if ( tmp_mvar_value_62 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "deprecated" );
            exception_tb = NULL;

            exception_lineno = 2670;

            goto frame_exception_exit_1;
        }

        tmp_called_name_36 = tmp_mvar_value_62;
        tmp_mvar_value_63 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_NetscapeSPKI );

        if (unlikely( tmp_mvar_value_63 == NULL ))
        {
            tmp_mvar_value_63 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NetscapeSPKI );
        }

        if ( tmp_mvar_value_63 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "NetscapeSPKI" );
            exception_tb = NULL;

            exception_lineno = 2671;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_98 = tmp_mvar_value_63;
        tmp_args_element_name_99 = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_args_element_name_100 = const_str_digest_fdf1281f34921aa68eda346883bb972d;
        tmp_mvar_value_64 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

        if (unlikely( tmp_mvar_value_64 == NULL ))
        {
            tmp_mvar_value_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
        }

        if ( tmp_mvar_value_64 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "DeprecationWarning" );
            exception_tb = NULL;

            exception_lineno = 2673;

            goto frame_exception_exit_1;
        }

        tmp_args_element_name_101 = tmp_mvar_value_64;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2670;
        {
            PyObject *call_args[] = { tmp_args_element_name_98, tmp_args_element_name_99, tmp_args_element_name_100, tmp_args_element_name_101 };
            tmp_assign_source_176 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_36, call_args );
        }

        if ( tmp_assign_source_176 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2670;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_NetscapeSPKIType, tmp_assign_source_176 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_177;
        {
            PyObject *tmp_set_locals_9;
            tmp_set_locals_9 = PyDict_New();
            locals_OpenSSL$crypto_2677 = tmp_set_locals_9;
        }
        tmp_dictset_value = const_str_digest_6d237a1253b74549ee18fb0e488e3cf9;
        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2677, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_6;
            tmp_defaults_6 = const_tuple_false_false_tuple;
            Py_INCREF( tmp_defaults_6 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_143___init__( tmp_defaults_6 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2677, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_cf6295d0383197dc8a74dbef60884f33_10, codeobj_cf6295d0383197dc8a74dbef60884f33, module_OpenSSL$crypto, 0 );
        frame_cf6295d0383197dc8a74dbef60884f33_10 = cache_frame_cf6295d0383197dc8a74dbef60884f33_10;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_cf6295d0383197dc8a74dbef60884f33_10 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_cf6295d0383197dc8a74dbef60884f33_10 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_37;
            PyObject *tmp_args_element_name_102;
            tmp_called_name_37 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_102 = MAKE_FUNCTION_OpenSSL$crypto$$$function_144_callback(  );



            frame_cf6295d0383197dc8a74dbef60884f33_10->m_frame.f_lineno = 2688;
            {
                PyObject *call_args[] = { tmp_args_element_name_102 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_37, call_args );
            }

            Py_DECREF( tmp_args_element_name_102 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2688;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2677, const_str_plain_callback, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2688;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_called_name_38;
            PyObject *tmp_args_element_name_103;
            tmp_called_name_38 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_103 = MAKE_FUNCTION_OpenSSL$crypto$$$function_145_callback_args(  );



            frame_cf6295d0383197dc8a74dbef60884f33_10->m_frame.f_lineno = 2701;
            {
                PyObject *call_args[] = { tmp_args_element_name_103 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_38, call_args );
            }

            Py_DECREF( tmp_args_element_name_103 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2701;

                goto frame_exception_exit_10;
            }
            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2677, const_str_plain_callback_args, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2701;

                goto frame_exception_exit_10;
            }
        }
        {
            PyObject *tmp_defaults_7;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_mvar_value_65;
            tmp_mvar_value_65 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_Error );

            if (unlikely( tmp_mvar_value_65 == NULL ))
            {
                tmp_mvar_value_65 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Error );
            }

            if ( tmp_mvar_value_65 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "Error" );
                exception_tb = NULL;

                exception_lineno = 2714;

                goto frame_exception_exit_10;
            }

            tmp_tuple_element_2 = tmp_mvar_value_65;
            tmp_defaults_7 = PyTuple_New( 1 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_defaults_7, 0, tmp_tuple_element_2 );
            tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_146_raise_if_problem( tmp_defaults_7 );



            tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2677, const_str_plain_raise_if_problem, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 2714;

                goto frame_exception_exit_10;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_cf6295d0383197dc8a74dbef60884f33_10 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_9;

        frame_exception_exit_10:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_cf6295d0383197dc8a74dbef60884f33_10 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_cf6295d0383197dc8a74dbef60884f33_10, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_cf6295d0383197dc8a74dbef60884f33_10->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_cf6295d0383197dc8a74dbef60884f33_10, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_cf6295d0383197dc8a74dbef60884f33_10,
            type_description_2
        );


        // Release cached frame.
        if ( frame_cf6295d0383197dc8a74dbef60884f33_10 == cache_frame_cf6295d0383197dc8a74dbef60884f33_10 )
        {
            Py_DECREF( frame_cf6295d0383197dc8a74dbef60884f33_10 );
        }
        cache_frame_cf6295d0383197dc8a74dbef60884f33_10 = NULL;

        assertFrameObject( frame_cf6295d0383197dc8a74dbef60884f33_10 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_9;

        frame_no_exception_9:;
        goto skip_nested_handling_9;
        nested_frame_exit_9:;

        goto try_except_handler_38;
        skip_nested_handling_9:;
        tmp_dictset_value = MAKE_FUNCTION_OpenSSL$crypto$$$function_147__read_passphrase(  );



        tmp_res = PyDict_SetItem( locals_OpenSSL$crypto_2677, const_str_plain__read_passphrase, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_177 = locals_OpenSSL$crypto_2677;
        Py_INCREF( tmp_assign_source_177 );
        goto try_return_handler_38;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_38:;
        Py_DECREF( locals_OpenSSL$crypto_2677 );
        locals_OpenSSL$crypto_2677 = NULL;
        goto outline_result_17;
        // Exception handler code:
        try_except_handler_38:;
        exception_keeper_type_29 = exception_type;
        exception_keeper_value_29 = exception_value;
        exception_keeper_tb_29 = exception_tb;
        exception_keeper_lineno_29 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_OpenSSL$crypto_2677 );
        locals_OpenSSL$crypto_2677 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_29;
        exception_value = exception_keeper_value_29;
        exception_tb = exception_keeper_tb_29;
        exception_lineno = exception_keeper_lineno_29;

        goto outline_exception_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( OpenSSL$crypto );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_9:;
        exception_lineno = 2677;
        goto try_except_handler_37;
        outline_result_17:;
        assert( tmp_class_creation_18__class_dict == NULL );
        tmp_class_creation_18__class_dict = tmp_assign_source_177;
    }
    {
        PyObject *tmp_assign_source_178;
        nuitka_bool tmp_condition_result_19;
        PyObject *tmp_key_name_35;
        PyObject *tmp_dict_name_35;
        PyObject *tmp_dict_name_36;
        PyObject *tmp_key_name_36;
        tmp_key_name_35 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_18__class_dict );
        tmp_dict_name_35 = tmp_class_creation_18__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_35, tmp_key_name_35 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2677;

            goto try_except_handler_37;
        }
        tmp_condition_result_19 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_19 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_18;
        }
        else
        {
            goto condexpr_false_18;
        }
        condexpr_true_18:;
        CHECK_OBJECT( tmp_class_creation_18__class_dict );
        tmp_dict_name_36 = tmp_class_creation_18__class_dict;
        tmp_key_name_36 = const_str_plain___metaclass__;
        tmp_assign_source_178 = DICT_GET_ITEM( tmp_dict_name_36, tmp_key_name_36 );
        if ( tmp_assign_source_178 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2677;

            goto try_except_handler_37;
        }
        goto condexpr_end_18;
        condexpr_false_18:;
        tmp_assign_source_178 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_178 );
        condexpr_end_18:;
        assert( tmp_class_creation_18__metaclass == NULL );
        tmp_class_creation_18__metaclass = tmp_assign_source_178;
    }
    {
        PyObject *tmp_assign_source_179;
        PyObject *tmp_called_name_39;
        PyObject *tmp_args_element_name_104;
        PyObject *tmp_args_element_name_105;
        PyObject *tmp_args_element_name_106;
        CHECK_OBJECT( tmp_class_creation_18__metaclass );
        tmp_called_name_39 = tmp_class_creation_18__metaclass;
        tmp_args_element_name_104 = const_str_plain__PassphraseHelper;
        tmp_args_element_name_105 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_18__class_dict );
        tmp_args_element_name_106 = tmp_class_creation_18__class_dict;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 2677;
        {
            PyObject *call_args[] = { tmp_args_element_name_104, tmp_args_element_name_105, tmp_args_element_name_106 };
            tmp_assign_source_179 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_39, call_args );
        }

        if ( tmp_assign_source_179 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 2677;

            goto try_except_handler_37;
        }
        assert( tmp_class_creation_18__class == NULL );
        tmp_class_creation_18__class = tmp_assign_source_179;
    }
    goto try_end_21;
    // Exception handler code:
    try_except_handler_37:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_21:;
    {
        PyObject *tmp_assign_source_180;
        CHECK_OBJECT( tmp_class_creation_18__class );
        tmp_assign_source_180 = tmp_class_creation_18__class;
        UPDATE_STRING_DICT0( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__PassphraseHelper, tmp_assign_source_180 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class );
    Py_DECREF( tmp_class_creation_18__class );
    tmp_class_creation_18__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class_dict );
    Py_DECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__metaclass );
    Py_DECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    {
        PyObject *tmp_assign_source_181;
        tmp_assign_source_181 = MAKE_FUNCTION_OpenSSL$crypto$$$function_148_load_publickey(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_publickey, tmp_assign_source_181 );
    }
    {
        PyObject *tmp_assign_source_182;
        PyObject *tmp_defaults_8;
        tmp_defaults_8 = const_tuple_none_tuple;
        Py_INCREF( tmp_defaults_8 );
        tmp_assign_source_182 = MAKE_FUNCTION_OpenSSL$crypto$$$function_149_load_privatekey( tmp_defaults_8 );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_privatekey, tmp_assign_source_182 );
    }
    {
        PyObject *tmp_assign_source_183;
        tmp_assign_source_183 = MAKE_FUNCTION_OpenSSL$crypto$$$function_150_dump_certificate_request(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_certificate_request, tmp_assign_source_183 );
    }
    {
        PyObject *tmp_assign_source_184;
        tmp_assign_source_184 = MAKE_FUNCTION_OpenSSL$crypto$$$function_151_load_certificate_request(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_certificate_request, tmp_assign_source_184 );
    }
    {
        PyObject *tmp_assign_source_185;
        tmp_assign_source_185 = MAKE_FUNCTION_OpenSSL$crypto$$$function_152_sign(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_sign, tmp_assign_source_185 );
    }
    {
        PyObject *tmp_assign_source_186;
        tmp_assign_source_186 = MAKE_FUNCTION_OpenSSL$crypto$$$function_153_verify(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_verify, tmp_assign_source_186 );
    }
    {
        PyObject *tmp_assign_source_187;
        tmp_assign_source_187 = MAKE_FUNCTION_OpenSSL$crypto$$$function_154_dump_crl(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_dump_crl, tmp_assign_source_187 );
    }
    {
        PyObject *tmp_assign_source_188;
        tmp_assign_source_188 = MAKE_FUNCTION_OpenSSL$crypto$$$function_155_load_crl(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_crl, tmp_assign_source_188 );
    }
    {
        PyObject *tmp_assign_source_189;
        tmp_assign_source_189 = MAKE_FUNCTION_OpenSSL$crypto$$$function_156_load_pkcs7_data(  );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs7_data, tmp_assign_source_189 );
    }
    {
        PyObject *tmp_assign_source_190;
        PyObject *tmp_defaults_9;
        tmp_defaults_9 = const_tuple_none_tuple;
        Py_INCREF( tmp_defaults_9 );
        tmp_assign_source_190 = MAKE_FUNCTION_OpenSSL$crypto$$$function_157_load_pkcs12( tmp_defaults_9 );



        UPDATE_STRING_DICT1( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain_load_pkcs12, tmp_assign_source_190 );
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_66;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_66 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_66 == NULL ))
        {
            tmp_mvar_value_66 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_66 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3126;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_66;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 3126;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_OpenSSL_add_all_algorithms );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3126;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_67;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_67 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_67 == NULL ))
        {
            tmp_mvar_value_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_67 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3130;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_67;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 3130;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_SSL_load_error_strings );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3130;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_68;
        PyObject *tmp_call_result_3;
        tmp_mvar_value_68 = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain__lib );

        if (unlikely( tmp_mvar_value_68 == NULL ))
        {
            tmp_mvar_value_68 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__lib );
        }

        if ( tmp_mvar_value_68 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_lib" );
            exception_tb = NULL;

            exception_lineno = 3135;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_68;
        frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame.f_lineno = 3135;
        tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_ASN1_STRING_set_default_mask_asc, &PyTuple_GET_ITEM( const_tuple_str_plain_utf8only_tuple, 0 ) );

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 3135;

            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_57aaabf758aa7c8c4a6e68a7dcea7c0c );
#endif
    popFrameStack();

    assertFrameObject( frame_57aaabf758aa7c8c4a6e68a7dcea7c0c );

    goto frame_no_exception_10;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_57aaabf758aa7c8c4a6e68a7dcea7c0c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_57aaabf758aa7c8c4a6e68a7dcea7c0c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_57aaabf758aa7c8c4a6e68a7dcea7c0c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_57aaabf758aa7c8c4a6e68a7dcea7c0c, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_10:;

#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_OpenSSL$crypto, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_OpenSSL$crypto );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
