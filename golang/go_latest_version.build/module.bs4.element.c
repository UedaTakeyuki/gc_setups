/* Generated code for Python module 'bs4.element'
 * created by Nuitka version 0.6.1.1
 *
 * This code is in part copyright 2018 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_bs4$element" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_bs4$element;
PyDictObject *moduledict_bs4$element;

/* The declarations of module constants used, if any. */
extern PyObject *const_str_plain_Doctype;
extern PyObject *const_str_plain_get;
static PyObject *const_tuple_str_plain_self_str_plain_source_str_plain_result_tuple;
extern PyObject *const_str_plain_script;
static PyObject *const_str_digest_7f21154356114069eea0623d81bf7f58;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
static PyObject *const_str_digest_dc7919f5f97ce613232f3cbd32e183ff;
extern PyObject *const_str_plain_found;
static PyObject *const_str_digest_9a553da68e37fc2c9e871cef1f9a938f;
static PyObject *const_str_digest_7db7fe37da3c09f0b3a2e370ca362f20;
extern PyObject *const_str_plain_output;
static PyObject *const_str_digest_74e818919ccc285c3d53c12c016e25d0;
extern PyObject *const_str_plain_startswith;
static PyObject *const_str_plain_indentLevel;
extern PyObject *const_str_plain_wrap;
static PyObject *const_tuple_str_digest_2717a74e8094c62311bf53472f4de0ca_tuple;
static PyObject *const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple;
extern PyObject *const_str_plain_warn;
static PyObject *const_str_digest_e457b16160571c2a0063096a0b61fed9;
static PyObject *const_str_plain_indent_contents;
static PyObject *const_str_digest_fb2a771a9c1c9339fad2ef3c863c3219;
static PyObject *const_str_digest_d39d95c610172b34eb52fa6d59d5835e;
static PyObject *const_set_13fb6c8ad2f041fc4071c1ba6487ab4e;
static PyObject *const_str_plain_last_child;
static PyObject *const_str_digest_b0c38f7df4c7a5de79b4700d224aa3b6;
static PyObject *const_tuple_ffd90e373011fadf040497abe3c9ca62_tuple;
extern PyObject *const_str_plain_children;
extern PyObject *const_str_plain__replace_cdata_list_attribute_values;
extern PyObject *const_str_digest_c075052d723d6707083e869a0e3659bb;
static PyObject *const_str_digest_3001d417e4f50c846776bdf1db22299b;
static PyObject *const_tuple_str_plain_self_str_plain_tag_str_plain_tag_name_tuple;
static PyObject *const_str_digest_e1e9a7d7419bad7afb9206c02e4c795d;
extern PyObject *const_str_plain_warnings;
extern PyObject *const_str_plain_search;
static PyObject *const_str_plain_previousSibling;
extern PyObject *const_str_plain_args;
static PyObject *const_str_plain_stripped_strings;
extern PyObject *const_str_plain_prefix;
extern PyObject *const_str_plain_class_;
static PyObject *const_str_plain_nextGenerator;
static PyObject *const_tuple_str_plain_previous_sibling_tuple;
extern PyObject *const_unicode_chr_62;
static PyObject *const_str_plain_attribute_string;
extern PyObject *const_int_neg_1;
extern PyObject *const_str_plain_Comment;
extern PyObject *const_str_plain_sorted;
extern PyObject *const_str_plain_c;
static PyObject *const_str_plain_decompose;
extern PyObject *const_str_plain_system_id;
extern PyObject *const_str_plain_results;
static PyObject *const_str_digest_91a4593114737d6b7d9b775dc212ec2f;
static PyObject *const_tuple_str_digest_8896f8bf9a99a51797228d5d40f8f021_tuple;
extern PyObject *const_tuple_str_chr_58_tuple;
extern PyObject *const_str_plain_CharsetMetaAttributeValue;
static PyObject *const_str_digest_a5e29131f13d71b6ec2d6ad90d15151c;
static PyObject *const_str_digest_12efe66a592585182310e41465bc3228;
static PyObject *const_str_digest_f217e48ed4c26f47ac3e1db2e35e3868;
extern PyObject *const_str_plain_find;
static PyObject *const_str_digest_5b172c0b3f4a4b2fa095be9f536d19f3;
static PyObject *const_str_plain_textarea;
static PyObject *const_str_digest_edf143d4f0a652982e578c671c8f527f;
extern PyObject *const_str_plain_encoding;
extern PyObject *const_str_plain_u;
static PyObject *const_str_digest_1017197213f46afeb9536ec49b2f35a5;
static PyObject *const_str_digest_a808f721500ff0677501bf21de1894f0;
static PyObject *const_str_plain_previous_child;
static PyObject *const_str_plain_closeTag;
static PyObject *const_str_plain_wrap_inside;
extern PyObject *const_tuple_type_list_tuple;
static PyObject *const_str_digest_a6d3c5dc186607b5d9991e1833ca2d3a;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_digest_5806791943ce856d9cfa3df6f3256880;
static PyObject *const_tuple_str_plain_cls_str_plain_ns_tuple;
static PyObject *const_str_plain_find_previous;
static PyObject *const_str_digest_c42ac5a4d6fe5208c6039fd3f7e8b4d1;
extern PyObject *const_str_plain_items;
static PyObject *const_str_plain_MinimalHTMLFormatter;
extern PyObject *const_str_plain_minimal;
static PyObject *const_str_plain_format_string;
extern PyObject *const_str_plain_decoded;
extern PyObject *const_str_plain_Formatter;
extern PyObject *const_str_plain_style;
extern PyObject *const_str_plain_Declaration;
static PyObject *const_str_plain_searchTag;
static PyObject *const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple;
extern PyObject *const_str_plain___nonzero__;
extern PyObject *const_str_angle_genexpr;
extern PyObject *const_str_plain_kwargs;
extern PyObject *const_str_plain___name__;
extern PyObject *const_tuple_str_plain_self_str_plain_tag_tuple;
static PyObject *const_unicode_digest_42aaa86f3155a0ac9064d3ba1116a0c9;
extern PyObject *const_str_plain_formatter;
extern PyObject *const_tuple_str_plain_self_str_plain_x_tuple;
extern PyObject *const_tuple_str_plain_utf8_tuple;
static PyObject *const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple;
static PyObject *const_str_plain_find_previous_siblings;
extern PyObject *const_str_plain_add;
extern PyObject *const_str_plain_clone;
static PyObject *const_str_plain_strings;
static PyObject *const_tuple_3b64fb04a63013587f4e717b6d88d2c3_tuple;
static PyObject *const_str_plain_find_parent;
extern PyObject *const_str_plain_pre;
static PyObject *const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple;
extern PyObject *const_str_plain_group;
static PyObject *const_str_plain_substitute;
extern PyObject *const_str_plain_match;
static PyObject *const_str_plain_void_element_close_prefix;
extern PyObject *const_tuple_2e13f6f79f96adf3ed42b174b19b3d28_tuple;
static PyObject *const_str_digest_750906c63df60c8f9857f2595e15aebc;
extern PyObject *const_str_plain_XMLProcessingInstruction;
static PyObject *const_tuple_str_plain_self_str_plain_encoding_str_plain_rewrite_tuple;
extern PyObject *const_str_plain_clear;
static PyObject *const_str_digest_d72d114df8db0ba64be9f314fb3d10ea;
static PyObject *const_str_plain_stopNode;
static PyObject *const_str_plain_get_attribute_list;
extern PyObject *const_tuple_str_plain_BeautifulSoup_tuple;
extern PyObject *const_str_plain_False;
static PyObject *const_tuple_6fabcf46d88fc62d9aaf37d94ef18c6e_tuple;
extern PyObject *const_str_plain_ProcessingInstruction;
static PyObject *const_str_digest_0ffd0fc42335dceae8efe9c6f5089d15;
extern PyObject *const_str_plain_sys;
static PyObject *const_str_plain_markup_attr_map;
extern PyObject *const_str_plain_setup;
static PyObject *const_str_plain_HTMLXMLFormatter;
static PyObject *const_str_digest_0335416823e683d1ebbe424bdd45a2ca;
extern PyObject *const_str_plain___unicode__;
static PyObject *const_str_plain_predecessor;
static PyObject *const_str_digest_3a6a8193326a0cc096673b1c1e043757;
static PyObject *const_str_plain_old_parent;
static PyObject *const_str_plain_findNextSiblings;
static PyObject *const_str_digest_996dd8adec957dee57886c3b180eb10e;
static PyObject *const_str_digest_5972be3d2e0ae5cffa0313f94447abdb;
extern PyObject *const_str_digest_dc6974bae1533a27ce9599cdf14ca60e;
extern PyObject *const_str_plain_bool;
extern PyObject *const_str_plain_source;
static PyObject *const_str_digest_a9c30e8b7efc851a52b36f9f117da2a2;
static PyObject *const_str_plain_next_child;
static PyObject *const_str_digest_d1ef6bd6894bac52c44d6c442c9cf379;
static PyObject *const_str_plain_findPrevious;
extern PyObject *const_str_plain_PageElement;
static PyObject *const_tuple_str_plain_self_str_plain_tags_str_plain_tag_tuple;
static PyObject *const_unicode_digest_28f2d46bf240bc75f671359bf185105d;
static PyObject *const_set_6e20dab302bdf7555943e6e98a3c0a93;
extern PyObject *const_str_plain_x;
extern PyObject *const_str_plain_list;
static PyObject *const_str_plain_CHARSET_RE;
static PyObject *const_str_plain__alias;
static PyObject *const_tuple_str_plain_match_str_plain_encoding_tuple;
extern PyObject *const_str_plain_get_text;
extern PyObject *const_str_plain_preserve_whitespace_tags;
extern PyObject *const_str_plain_parents;
extern PyObject *const_tuple_str_plain_self_str_plain_i_tuple;
extern PyObject *const_str_plain_encode;
static PyObject *const_str_plain__matches;
static PyObject *const_str_digest_1c3b497b8a4a3c183134674c43de9ce2;
static PyObject *const_tuple_str_plain_self_str_plain_formatter_str_plain_output_tuple;
extern PyObject *const_str_plain_bs4;
extern PyObject *const_str_plain_set_up_substitutions;
static PyObject *const_str_plain_indent_space;
static PyObject *const_str_plain_findAllNext;
static PyObject *const_str_plain_fetchPreviousSiblings;
extern PyObject *const_tuple_empty;
extern PyObject *const_str_digest_e2405d39d6d616d1c5a0beb6aaa8ef8f;
static PyObject *const_tuple_type_unicode_tuple;
static PyObject *const_str_digest_b246a21da0bf0d1ecd21a222430c1e19;
static PyObject *const_str_digest_2717a74e8094c62311bf53472f4de0ca;
static PyObject *const_str_plain_replace_with_children;
extern PyObject *const_str_plain_tag_name;
static PyObject *const_str_digest_688f06597223eaae9df5adffcac1b5da;
static PyObject *const_str_digest_b08f55921cd8c7f8cc8a2534d60adbcd;
extern PyObject *const_str_plain_re;
extern PyObject *const_str_plain___iter__;
static PyObject *const_str_digest_5e8296b08c7275b6e9b059066a53a1cb;
static PyObject *const_str_plain_call_function_with_tag_data;
extern PyObject *const_str_plain_limit;
static PyObject *const_str_digest_f71329a7fdb204c7f3cb9c7636f075d9;
extern PyObject *const_str_plain___eq__;
extern PyObject *const_str_plain_method;
extern PyObject *const_str_plain_new_value;
extern PyObject *const_str_plain___debug__;
static PyObject *const_str_plain_original_markup;
static PyObject *const_str_digest_a8642630e4859aa7595db413203bd4d1;
static PyObject *const_tuple_d0434168675df957da575746d9fec873_tuple;
static PyObject *const_str_plain_previousSiblingGenerator;
static PyObject *const_str_plain__formatter_for_name;
static PyObject *const_str_digest_687f64809c4be828c127c356e1b6ed7c;
static PyObject *const_str_plain_find_previous_sibling;
static PyObject *const_str_digest_2723f6e7179adb3f95d6ef44f1805134;
extern PyObject *const_str_plain_contents;
static PyObject *const_tuple_true_true_tuple;
static PyObject *const_str_plain_fetchPrevious;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_plain_rewrite;
static PyObject *const_tuple_e852ed76cabcde48e8c638757ba9055c_tuple;
static PyObject *const_unicode_digest_ce081481423abca80d01dc6b2ce9e9ea;
extern PyObject *const_str_plain_update;
extern PyObject *const_str_plain_position;
extern PyObject *const_str_plain_html5;
static PyObject *const_set_c4437c08c2c2846750c8f9786cb91cc1;
extern PyObject *const_str_plain_str;
extern PyObject *const_tuple_true_tuple;
extern PyObject *const_str_plain___getitem__;
static PyObject *const_str_plain_parents_next_sibling;
static PyObject *const_str_digest_b42292186816115aadac41c6428c2b70;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_str_plain_find_all_next;
static PyObject *const_tuple_str_plain_next_sibling_tuple;
static PyObject *const_str_plain_prettify;
static PyObject *const_str_digest_c658d19634e753d4f72ac98fd801f3f1;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_digest_de65d084d97cebdd56daaf35cf257c00;
extern PyObject *const_str_plain_text;
static PyObject *const_str_plain_normalized_attrs;
extern PyObject *const_str_plain_MIT;
extern PyObject *const_str_chr_47;
extern PyObject *const_str_plain_setter;
static PyObject *const_str_plain_AttributeValueWithCharsetSubstitution;
extern PyObject *const_tuple_str_newline_tuple;
static PyObject *const_str_plain_findParents;
extern PyObject *const_str_plain_value;
extern PyObject *const_str_plain_descendant;
extern PyObject *const_str_plain___new__;
extern PyObject *const_tuple_str_plain_self_str_plain_key_str_plain_default_tuple;
static PyObject *const_str_plain_cdata_containing_tags;
extern PyObject *const_str_plain_is_empty_element;
extern PyObject *const_unicode_empty;
static PyObject *const_str_digest_3efbf8635fb02c14f734f6fa1f903d94;
static PyObject *const_tuple_str_plain_EntitySubstitution_tuple;
static PyObject *const_str_plain_strainer;
extern PyObject *const_str_plain_name;
static PyObject *const_str_plain_parser_class;
static PyObject *const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple;
static PyObject *const_str_digest_5dde75ea46d316ab5ab5d75080f755c4;
extern PyObject *const_str_plain_collections;
static PyObject *const_str_plain_recursiveChildGenerator;
static PyObject *const_str_plain__lastRecursiveChild;
extern PyObject *const_str_plain_tuple;
extern PyObject *const_str_plain_HTMLAwareEntitySubstitution;
extern PyObject *const_str_plain_append;
static PyObject *const_str_plain_new_childs_last_element;
static PyObject *const_str_digest_44cc79d8ae47795db54dfcb36a03ec10;
extern PyObject *const_str_plain_SoupStrainer;
static PyObject *const_str_plain_my_child;
extern PyObject *const_str_plain_next_sibling;
static PyObject *const_str_plain_childGenerator;
static PyObject *const_str_plain__find_all;
extern PyObject *const_str_plain_ns;
static PyObject *const_tuple_228af158dcd68f83b463bc2269dd782f_tuple;
extern PyObject *const_str_plain_search_tag;
extern PyObject *const_str_plain_successor;
extern PyObject *const_str_plain___copy__;
static PyObject *const_str_digest_a6aafb5565cda3049a1405989036800d;
static PyObject *const_str_digest_c5639168a5cbc5c4d0956b93b3eb2792;
static PyObject *const_str_digest_a3d9d833894395d6536a0b717d3a6231;
static PyObject *const_str_plain_separator;
extern PyObject *const_str_plain_insert;
static PyObject *const_str_plain_parentGenerator;
extern PyObject *const_str_plain_hidden;
static PyObject *const_str_plain_subchild;
extern PyObject *const_str_plain_namespaces;
extern PyObject *const_str_plain_types;
extern PyObject *const_tuple_int_pos_1_tuple;
static PyObject *const_str_digest_f425bee58e499399e7174ce48229bf9d;
static PyObject *const_str_plain_parserClass;
static PyObject *const_str_digest_9e0202f20825ee6726af59eda1c982e0;
extern PyObject *const_str_plain_pop;
static PyObject *const_str_plain_findPreviousSibling;
extern PyObject *const_str_plain_namespace;
extern PyObject *const_str_plain_NavigableString;
static PyObject *const_str_plain_pub_id;
static PyObject *const_str_plain_xmlcharrefreplace;
static PyObject *const_unicode_digest_08c55f7436746dfbed837b418ea65a70;
extern PyObject *const_str_plain___call__;
static PyObject *const_tuple_str_digest_688f06597223eaae9df5adffcac1b5da_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_formatter_tuple;
static PyObject *const_str_digest_150a3ddd6f980f74b974d699bb653243;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_attr_tuple;
extern PyObject *const_str_plain_previous_sibling;
static PyObject *const_str_plain_markup_attrs;
static PyObject *const_str_digest_e284352cda9140f58b06ed689c06ac6a;
extern PyObject *const_str_plain_type;
static PyObject *const_str_digest_28fcfa6b905769882ab971e07fe72510;
static PyObject *const_str_digest_2c574a663a96a37e80240aa8a1c13e67;
extern PyObject *const_str_plain_decode;
static PyObject *const_str_plain_find_all;
extern PyObject *const_str_plain_offset;
extern PyObject *const_str_plain_replace_with;
extern PyObject *const_str_plain_cls;
static PyObject *const_str_digest_966b532e2f3ba00ecd4d1fb36c023539;
static PyObject *const_str_plain_me;
extern PyObject *const_str_plain_builder;
extern PyObject *const_str_plain__last_descendant;
extern PyObject *const_str_plain_generator;
extern PyObject *const_str_plain_Callable;
extern PyObject *const_str_plain_known_xml;
static PyObject *const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple;
extern PyObject *const_str_plain_key;
extern PyObject *const_str_plain_object;
static PyObject *const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple;
static PyObject *const_tuple_3da16538fbd197083cd091a6f193427d_tuple;
extern PyObject *const_str_plain___ne__;
static PyObject *const_dict_ac1eba801ee59541af7075d340bfcec6;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_unwrap;
static PyObject *const_tuple_bfb3dc918e2c3822cf026cb5a5888d9d_tuple;
extern PyObject *const_str_plain_val;
static PyObject *const_str_plain_new_child;
extern PyObject *const_str_plain_selector;
static PyObject *const_str_plain_encode_contents;
static PyObject *const_str_plain_previous_elements;
static PyObject *const_str_plain_nextSiblingGenerator;
static PyObject *const_str_digest_73e3f65a5e6a0e231abfd780063ee2b0;
extern PyObject *const_str_plain_extract;
static PyObject *const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple;
static PyObject *const_str_plain_output_ready;
static PyObject *const_tuple_5d973f0bbc887f462db71b319acd6172_tuple;
static PyObject *const_str_digest_74605c90f126dd9a5280fd0d6380988e;
static PyObject *const_unicode_digest_bdc18e346a4949f889a922a59c59687c;
extern PyObject *const_str_plain_sub;
static PyObject *const_unicode_digest_10b0cc8d52dbda6d37909d215669cae2;
static PyObject *const_str_plain_fetchNextSiblings;
extern PyObject *const_str_plain___setitem__;
extern PyObject *const_str_plain_min;
static PyObject *const_tuple_str_plain_self_str_plain_indent_level_tuple;
static PyObject *const_str_digest_caa1311fbee6a780f68a9bf663ab8344;
extern PyObject *const_str_plain_pretty_print;
extern PyObject *const_str_plain_indent_level;
static PyObject *const_str_plain_find_next;
static PyObject *const_str_plain_match_against;
extern PyObject *const_tuple_str_plain_self_tuple;
extern PyObject *const_str_plain__namespaces;
extern PyObject *const_str_plain_cdata_list_attributes;
static PyObject *const_str_digest_16a272a1ac84aa8c964578a8dee1c6dd;
extern PyObject *const_str_plain_select;
extern PyObject *const_str_plain_strip;
extern PyObject *const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
static PyObject *const_str_plain_whitespace_re;
extern PyObject *const_str_plain_quoted_attribute_value;
static PyObject *const_str_plain__find_one;
static PyObject *const_tuple_str_plain_minimal_tuple;
static PyObject *const_str_digest_530dbdb9b402b3f07d411a938927f2b3;
extern PyObject *const_str_plain_errors;
static PyObject *const_tuple_str_plain_self_str_plain_element_str_plain_i_str_plain_child_tuple;
extern PyObject *const_str_plain___getattr__;
extern PyObject *const_int_pos_2;
extern PyObject *const_int_pos_3;
extern PyObject *const_int_pos_1;
extern PyObject *const_str_plain_nextSibling;
extern PyObject *const_str_plain_current;
static PyObject *const_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c;
static PyObject *const_str_plain_class;
static PyObject *const_str_plain_substitute_entities;
extern PyObject *const_str_plain_item;
static PyObject *const_str_digest_a0f6e9f5acfe56723fdae36afe1e77fb;
static PyObject *const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple;
static PyObject *const_str_plain__substitute_if_appropriate;
static PyObject *const_tuple_str_plain_self_str_plain_child_tuple;
extern PyObject *const_str_plain_recursive;
static PyObject *const_tuple_str_plain_cls_str_plain_ns_str_plain_f_tuple;
static PyObject *const_str_plain_current_index;
static PyObject *const_str_plain_find_all_previous;
static PyObject *const_str_digest_789a2a1ab5c730365a2961867d62159f;
static PyObject *const_str_plain_previous_siblings;
extern PyObject *const_str_plain_basestring;
static PyObject *const_str_plain_preformatted_tags;
static PyObject *const_str_digest_66fede51f6d2599d31cae6b2824d49fe;
static PyObject *const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple;
extern PyObject *const_str_plain_space;
static PyObject *const_str_plain_findAllPrevious;
extern PyObject *const_str_plain_NamespacedAttribute;
extern PyObject *const_str_plain_child;
static PyObject *const_str_digest_74feb09b4e7b5c98ea28f927cc7ad7ec;
extern PyObject *const_str_plain___hash__;
static PyObject *const_str_digest_b63f4abf4c20ed95c5280f099ca7f649;
static PyObject *const_str_digest_51f97402dd7101c57c82d9e47530321c;
static PyObject *const_str_digest_a1252b58837909ad9dc1fcca1e9295d3;
extern PyObject *const_str_plain_element;
static PyObject *const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple;
static PyObject *const_str_digest_7367bb348cc3e8e5398ecf366526fd9f;
extern PyObject *const_str_plain_attr;
static PyObject *const_tuple_str_plain_self_str_plain_current_str_plain_stopNode_tuple;
extern PyObject *const_str_plain_None;
static PyObject *const_tuple_str_plain_cls_str_plain_value_str_plain_u_tuple;
extern PyObject *const_str_plain_M;
extern PyObject *const_str_plain__is_xml;
extern PyObject *const_str_chr_58;
static PyObject *const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_digest_29649a9de50f1b949dd54bb0ed0bf2bf;
static PyObject *const_str_plain_find_next_siblings;
static PyObject *const_str_plain_findChildren;
static PyObject *const_tuple_str_plain_self_str_plain_last_child_str_plain_next_element_tuple;
static PyObject *const_tuple_2db4dbe516092df2db3de6cea5c71cab_tuple;
extern PyObject *const_str_plain_l;
extern PyObject *const_str_plain_endswith;
static PyObject *const_str_plain_findNextSibling;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain_attr_value;
static PyObject *const_str_plain_replaceWithChildren;
extern PyObject *const_str_plain_e;
extern PyObject *const_str_plain_f;
extern PyObject *const_str_plain___getnewargs__;
static PyObject *const_str_plain_has_attr;
extern PyObject *const_str_plain_ContentMetaAttributeValue;
extern PyObject *const_str_plain_soupsieve;
extern PyObject *const_str_plain___contains__;
static PyObject *const_str_digest_2fb35f5b371e4357763cfefa063b5165;
static PyObject *const_str_plain_HTML_FORMATTERS;
extern PyObject *const_str_plain_v;
extern PyObject *const_str_plain_CData;
extern PyObject *const_str_plain_r;
extern PyObject *const_str_plain_s;
static PyObject *const_str_plain_findChild;
static PyObject *const_str_plain_XMLFormatter;
extern PyObject *const_str_plain_substitute_html;
static PyObject *const_tuple_e78b94ed7a6cf112858126b31788598d_tuple;
extern PyObject *const_str_plain_next;
static PyObject *const_str_plain_prettyPrint;
extern PyObject *const_str_plain_EntitySubstitution;
static PyObject *const_str_plain_my_parent;
extern PyObject *const_str_plain_parser;
static PyObject *const_str_digest_683058e4e72e5e683458d44dcd762604;
extern PyObject *const_str_plain_html;
extern PyObject *const_int_0;
extern PyObject *const_tuple_str_plain_self_str_plain_key_str_plain_value_tuple;
extern PyObject *const_str_plain_previous_element;
static PyObject *const_str_digest_c9d2da40f15d12241238636e3ea4b960;
static PyObject *const_tuple_str_plain_attr_str_plain_alias_tuple;
static PyObject *const_str_plain_SUFFIX;
static PyObject *const_tuple_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c_tuple;
extern PyObject *const_str_plain_BeautifulSoup;
static PyObject *const_str_digest_16edbedf290760e205b7c3d404645ec6;
static PyObject *const_str_plain_find_parents;
extern PyObject *const_tuple_str_plain_Callable_tuple;
static PyObject *const_str_plain_has_key;
static PyObject *const_str_digest_9a607885277141d349d6d92be27c1d04;
static PyObject *const_str_digest_2eb78fd35de0c552fcd9f4234a3e2fee;
static PyObject *const_str_digest_38aa4d1e4b90e4783d9d90e8dfcb74d9;
extern PyObject *const_str_plain_compile;
static PyObject *const_str_plain_fetchParents;
static PyObject *const_str_plain_my_index;
static PyObject *const_str_plain_next_elements;
static PyObject *const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple;
static PyObject *const_unicode_digest_c58e033f1c5c7944b6670af092f11d09;
extern PyObject *const_str_plain_copy;
static PyObject *const_str_plain_original_value;
extern PyObject *const_str_plain_k;
static PyObject *const_str_digest_427ece6c74a8f7bed9c0a0f9f58768bf;
static PyObject *const_str_digest_9e3fe7ba8804c2b496a30c099deb767f;
static PyObject *const_str_digest_2301ed3ad80a75315314e7e55d580eb4;
static PyObject *const_str_plain_markup_name;
static PyObject *const_str_digest_6c6b5a57155bef64d81c4e3930a40571;
extern PyObject *const_str_plain_markup;
static PyObject *const_tuple_272dbd16728ffeefb84651713f277746_tuple;
extern PyObject *const_str_plain_property;
static PyObject *const_str_plain_previousGenerator;
extern PyObject *const_str_plain_count;
extern PyObject *const_str_plain_insert_after;
extern PyObject *const_tuple_none_none_none_none_none_none_none_none_none_tuple;
static PyObject *const_str_digest_4a104383ff48e621ad8c417548c98ea1;
static PyObject *const_tuple_c8ced635d07e13a82f7bd15383636794_tuple;
static PyObject *const_str_digest_fa9ac21a1aecbae9bb5a3c4a16e70ffe;
extern PyObject *const_str_plain___repr__;
static PyObject *const_str_digest_6fafb2efdc26996459dc0ccdbcddbdf7;
static PyObject *const_str_digest_345cf92f17033766f082736e15d759aa;
extern PyObject *const_str_plain_unicode;
extern PyObject *const_str_plain_tags;
static PyObject *const_tuple_str_plain_cls_str_plain_original_value_str_plain_obj_tuple;
static PyObject *const_str_digest_2c354f1221e3e09909d06a3dc3c259cb;
extern PyObject *const_str_plain___license__;
extern PyObject *const_str_plain_nonwhitespace_re;
static PyObject *const_str_plain_getText;
static PyObject *const_str_plain_find_next_sibling;
extern PyObject *const_str_plain_eventual_encoding;
static PyObject *const_str_digest_d73614277c6d61645b151d81f183d780;
static PyObject *const_str_digest_a635dc2cd109c09bc1bdcdd8ac24874a;
extern PyObject *const_str_plain_close;
extern PyObject *const_tuple_str_chr_58_int_pos_1_tuple;
extern PyObject *const_str_plain___str__;
static PyObject *const_tuple_str_plain_self_str_plain_i_str_plain_next_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_encoding_tuple;
static PyObject *const_str_plain_findAll;
static PyObject *const_tuple_58568bf8b42125104a536219253716ea_tuple;
static PyObject *const_str_plain_HTMLFormatter;
static PyObject *const_str_digest_d30c1fec201318981ba659c44f450ce9;
static PyObject *const_str_plain_findNext;
static PyObject *const_str_plain_renderContents;
extern PyObject *const_tuple_tuple_empty_tuple;
extern PyObject *const_str_plain_default;
extern PyObject *const_str_plain_split;
static PyObject *const_tuple_str_plain_self_str_plain_decompose_str_plain_element_tuple;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
static PyObject *const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple;
extern PyObject *const_str_plain_tag;
extern PyObject *const_str_plain_join;
static PyObject *const_str_digest_6e71b18f4f00a0af73d97ee880b369b1;
extern PyObject *const_str_plain_version_info;
static PyObject *const_str_digest_979b3c48ae5244d26d6c51e2422468ee;
extern PyObject *const_str_digest_a694a1497725bd5d49805e1c282892b9;
static PyObject *const_str_digest_7b88dc5ab83916f8d7010fa0bb999fa3;
static PyObject *const_str_plain_findPreviousSiblings;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain_can_be_empty_element;
extern PyObject *const_str_plain_insert_before;
static PyObject *const_str_digest_6e295b76c4b27f5a846f1bb005613354;
static PyObject *const_tuple_str_plain_self_str_plain_encoding_str_plain_formatter_tuple;
static PyObject *const_str_digest_8896f8bf9a99a51797228d5d40f8f021;
static PyObject *const_str_digest_cb7f043884ff2a2610043d53506bac64;
static PyObject *const_str_plain_HTML5Formatter;
extern PyObject *const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple;
extern PyObject *const_str_plain_utf8;
static PyObject *const_str_digest_8ca5f0d3f3d0b766a3f4cdd946dfac3b;
static PyObject *const_str_digest_dba4300913f590ab70dd3a55a3c580d8;
static PyObject *const_str_plain_is_initialized;
extern PyObject *const_str_plain_string;
static PyObject *const_str_digest_5019a3250d7d4e2e305907c7346453e1;
extern PyObject *const_tuple_str_plain_self_str_plain_key_tuple;
static PyObject *const_str_plain_PreformattedString;
static PyObject *const_str_digest_f6bcba6ba3fa9e79445ecc6dd89d522b;
extern PyObject *const_str_plain_enumerate;
static PyObject *const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple;
static PyObject *const_str_digest_fd3697fca90f8714408b4dfe42e76cb5;
static PyObject *const_str_plain_decode_contents;
extern PyObject *const_str_plain_reversed;
extern PyObject *const_str_plain_select_one;
extern PyObject *const_str_plain_is_xml;
static PyObject *const_str_plain_local_name;
static PyObject *const_tuple_none_str_plain_minimal_tuple;
extern PyObject *const_str_plain_other;
static PyObject *const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple;
extern PyObject *const_str_plain_dict;
extern PyObject *const_str_newline;
static PyObject *const_str_plain_XML_FORMATTERS;
static PyObject *const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple;
static PyObject *const_tuple_str_plain_parser_class_tuple;
static PyObject *const_str_plain_next_siblings;
static PyObject *const_str_plain__all_strings;
extern PyObject *const_str_plain_parent;
extern PyObject *const_str_plain_obj;
static PyObject *const_tuple_d45c60811e98eaafb444e77942903dcf_tuple;
extern PyObject *const_str_plain_next_element;
static PyObject *const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple;
extern PyObject *const_str_plain_attrs;
extern PyObject *const_str_plain___delitem__;
static PyObject *const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple;
static PyObject *const_str_plain_already_tried;
static PyObject *const_str_plain__normalize_search_value;
extern PyObject *const_str_space;
extern PyObject *const_tuple_str_plain_self_str_plain_string_tuple;
static PyObject *const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
static PyObject *const_str_digest_43f42e221dbc99e7846a13559b986b53;
static PyObject *const_str_digest_d8274aeb344d2374500ebe6784747ede;
extern PyObject *const_str_chr_61;
extern PyObject *const_str_plain_descendants;
static PyObject *const_tuple_str_plain_self_str_plain_wrap_inside_str_plain_me_tuple;
extern PyObject *const_str_plain_previous;
static PyObject *const_tuple_str_plain____tuple;
extern PyObject *const_str_plain_Tag;
extern PyObject *const_str_plain_substitute_xml;
static PyObject *const_str_plain_accept_self;
extern PyObject *const_str_plain_alias;
static PyObject *const_tuple_none_none_none_none_none_tuple;
extern PyObject *const_str_plain_any;
extern PyObject *const_str_plain_ResultSet;
static PyObject *const_str_plain_isSelfClosing;
static PyObject *const_str_plain__should_pretty_print;
extern PyObject *const_str_plain___;
extern PyObject *const_str_plain_index;
extern PyObject *const_str_plain___doc__;
extern PyObject *const_str_plain_DEFAULT_OUTPUT_ENCODING;
static PyObject *const_str_plain_PREFIX;
static PyObject *const_tuple_str_plain_Tag_tuple;
static PyObject *const_str_plain_PY3K;
extern PyObject *const_str_plain___len__;
static PyObject *const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple;
static PyObject *const_unicode_digest_6fd0b05522159f98d6181ab8bfabc7f6;
static PyObject *const_tuple_3a1a822c776686c398d8079a14774929_tuple;
extern PyObject *const_str_empty;
static PyObject *const_tuple_str_plain_can_be_empty_element_str_plain_hidden_tuple;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain_findParent;
extern PyObject *const_tuple_15847381bc67e44c74cc6010c7c7f848_tuple;
static PyObject *const_str_digest_40d1280f0aef3f3bf11313c57370733c;
extern PyObject *const_str_plain_result;
extern PyObject *const_tuple_false_tuple;
extern PyObject *const_str_plain_for_name_and_ids;
static PyObject *const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple;
static PyObject *const_str_plain_replaceWith;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_tuple_str_plain_self_str_plain_source_str_plain_result_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_source_str_plain_result_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_source_str_plain_result_tuple, 1, const_str_plain_source ); Py_INCREF( const_str_plain_source );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_source_str_plain_result_tuple, 2, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_digest_7f21154356114069eea0623d81bf7f58 = UNSTREAM_STRING( &constant_bin[ 204158 ], 77, 0 );
    const_str_digest_dc7919f5f97ce613232f3cbd32e183ff = UNSTREAM_STRING( &constant_bin[ 204235 ], 60, 0 );
    const_str_digest_9a553da68e37fc2c9e871cef1f9a938f = UNSTREAM_STRING( &constant_bin[ 204295 ], 124, 0 );
    const_str_digest_7db7fe37da3c09f0b3a2e370ca362f20 = UNSTREAM_STRING( &constant_bin[ 204419 ], 98, 0 );
    const_str_digest_74e818919ccc285c3d53c12c016e25d0 = UNSTREAM_STRING( &constant_bin[ 204517 ], 188, 0 );
    const_str_plain_indentLevel = UNSTREAM_STRING( &constant_bin[ 204705 ], 11, 1 );
    const_tuple_str_digest_2717a74e8094c62311bf53472f4de0ca_tuple = PyTuple_New( 1 );
    const_str_digest_2717a74e8094c62311bf53472f4de0ca = UNSTREAM_STRING( &constant_bin[ 191974 ], 3, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_2717a74e8094c62311bf53472f4de0ca_tuple, 0, const_str_digest_2717a74e8094c62311bf53472f4de0ca ); Py_INCREF( const_str_digest_2717a74e8094c62311bf53472f4de0ca );
    const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 1, const_str_plain_method ); Py_INCREF( const_str_plain_method );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 3, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 4, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 5, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 6, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 7, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    const_str_digest_e457b16160571c2a0063096a0b61fed9 = UNSTREAM_STRING( &constant_bin[ 204716 ], 213, 0 );
    const_str_plain_indent_contents = UNSTREAM_STRING( &constant_bin[ 204929 ], 15, 1 );
    const_str_digest_fb2a771a9c1c9339fad2ef3c863c3219 = UNSTREAM_STRING( &constant_bin[ 204944 ], 301, 0 );
    const_str_digest_d39d95c610172b34eb52fa6d59d5835e = UNSTREAM_STRING( &constant_bin[ 205245 ], 70, 0 );
    const_set_13fb6c8ad2f041fc4071c1ba6487ab4e = PySet_New( NULL );
    PySet_Add( const_set_13fb6c8ad2f041fc4071c1ba6487ab4e, const_str_plain_style );
    PySet_Add( const_set_13fb6c8ad2f041fc4071c1ba6487ab4e, const_str_plain_script );
    assert( PySet_Size( const_set_13fb6c8ad2f041fc4071c1ba6487ab4e ) == 2 );
    const_str_plain_last_child = UNSTREAM_STRING( &constant_bin[ 190596 ], 10, 1 );
    const_str_digest_b0c38f7df4c7a5de79b4700d224aa3b6 = UNSTREAM_STRING( &constant_bin[ 205315 ], 10, 0 );
    const_tuple_ffd90e373011fadf040497abe3c9ca62_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_ffd90e373011fadf040497abe3c9ca62_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_ffd90e373011fadf040497abe3c9ca62_tuple, 1, const_str_plain_markup ); Py_INCREF( const_str_plain_markup );
    PyTuple_SET_ITEM( const_tuple_ffd90e373011fadf040497abe3c9ca62_tuple, 2, const_str_plain_found ); Py_INCREF( const_str_plain_found );
    PyTuple_SET_ITEM( const_tuple_ffd90e373011fadf040497abe3c9ca62_tuple, 3, const_str_plain_element ); Py_INCREF( const_str_plain_element );
    const_str_digest_3001d417e4f50c846776bdf1db22299b = UNSTREAM_STRING( &constant_bin[ 205325 ], 262, 0 );
    const_tuple_str_plain_self_str_plain_tag_str_plain_tag_name_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tag_str_plain_tag_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tag_str_plain_tag_name_tuple, 1, const_str_plain_tag ); Py_INCREF( const_str_plain_tag );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tag_str_plain_tag_name_tuple, 2, const_str_plain_tag_name ); Py_INCREF( const_str_plain_tag_name );
    const_str_digest_e1e9a7d7419bad7afb9206c02e4c795d = UNSTREAM_STRING( &constant_bin[ 205587 ], 30, 0 );
    const_str_plain_previousSibling = UNSTREAM_STRING( &constant_bin[ 205617 ], 15, 1 );
    const_str_plain_stripped_strings = UNSTREAM_STRING( &constant_bin[ 205632 ], 16, 1 );
    const_str_plain_nextGenerator = UNSTREAM_STRING( &constant_bin[ 205648 ], 13, 1 );
    const_tuple_str_plain_previous_sibling_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_previous_sibling_tuple, 0, const_str_plain_previous_sibling ); Py_INCREF( const_str_plain_previous_sibling );
    const_str_plain_attribute_string = UNSTREAM_STRING( &constant_bin[ 205661 ], 16, 1 );
    const_str_plain_decompose = UNSTREAM_STRING( &constant_bin[ 205677 ], 9, 1 );
    const_str_digest_91a4593114737d6b7d9b775dc212ec2f = UNSTREAM_STRING( &constant_bin[ 205686 ], 37, 0 );
    const_tuple_str_digest_8896f8bf9a99a51797228d5d40f8f021_tuple = PyTuple_New( 1 );
    const_str_digest_8896f8bf9a99a51797228d5d40f8f021 = UNSTREAM_STRING( &constant_bin[ 205723 ], 69, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_8896f8bf9a99a51797228d5d40f8f021_tuple, 0, const_str_digest_8896f8bf9a99a51797228d5d40f8f021 ); Py_INCREF( const_str_digest_8896f8bf9a99a51797228d5d40f8f021 );
    const_str_digest_a5e29131f13d71b6ec2d6ad90d15151c = UNSTREAM_STRING( &constant_bin[ 205792 ], 56, 0 );
    const_str_digest_12efe66a592585182310e41465bc3228 = UNSTREAM_STRING( &constant_bin[ 205848 ], 45, 0 );
    const_str_digest_f217e48ed4c26f47ac3e1db2e35e3868 = UNSTREAM_STRING( &constant_bin[ 205893 ], 80, 0 );
    const_str_digest_5b172c0b3f4a4b2fa095be9f536d19f3 = UNSTREAM_STRING( &constant_bin[ 205973 ], 37, 0 );
    const_str_plain_textarea = UNSTREAM_STRING( &constant_bin[ 206010 ], 8, 1 );
    const_str_digest_edf143d4f0a652982e578c671c8f527f = UNSTREAM_STRING( &constant_bin[ 206018 ], 123, 0 );
    const_str_digest_1017197213f46afeb9536ec49b2f35a5 = UNSTREAM_STRING( &constant_bin[ 206141 ], 293, 0 );
    const_str_digest_a808f721500ff0677501bf21de1894f0 = UNSTREAM_STRING( &constant_bin[ 206434 ], 61, 0 );
    const_str_plain_previous_child = UNSTREAM_STRING( &constant_bin[ 206495 ], 14, 1 );
    const_str_plain_closeTag = UNSTREAM_STRING( &constant_bin[ 206509 ], 8, 1 );
    const_str_plain_wrap_inside = UNSTREAM_STRING( &constant_bin[ 206517 ], 11, 1 );
    const_str_digest_a6d3c5dc186607b5d9991e1833ca2d3a = UNSTREAM_STRING( &constant_bin[ 206528 ], 113, 0 );
    const_str_digest_5806791943ce856d9cfa3df6f3256880 = UNSTREAM_STRING( &constant_bin[ 206641 ], 170, 0 );
    const_tuple_str_plain_cls_str_plain_ns_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ns_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ns_tuple, 1, const_str_plain_ns ); Py_INCREF( const_str_plain_ns );
    const_str_plain_find_previous = UNSTREAM_STRING( &constant_bin[ 206811 ], 13, 1 );
    const_str_digest_c42ac5a4d6fe5208c6039fd3f7e8b4d1 = UNSTREAM_STRING( &constant_bin[ 206824 ], 107, 0 );
    const_str_plain_MinimalHTMLFormatter = UNSTREAM_STRING( &constant_bin[ 206931 ], 20, 1 );
    const_str_plain_format_string = UNSTREAM_STRING( &constant_bin[ 206951 ], 13, 1 );
    const_str_plain_searchTag = UNSTREAM_STRING( &constant_bin[ 206964 ], 9, 1 );
    const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 3, const_str_plain_recursive ); Py_INCREF( const_str_plain_recursive );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 4, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 5, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 6, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 7, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    const_unicode_digest_42aaa86f3155a0ac9064d3ba1116a0c9 = UNSTREAM_UNICODE( &constant_bin[ 42145 ], 2 );
    const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple, 1, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    const_str_plain_predecessor = UNSTREAM_STRING( &constant_bin[ 206973 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple, 2, const_str_plain_predecessor ); Py_INCREF( const_str_plain_predecessor );
    PyTuple_SET_ITEM( const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple, 3, const_str_plain_index ); Py_INCREF( const_str_plain_index );
    PyTuple_SET_ITEM( const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple, 4, const_str_plain_parent ); Py_INCREF( const_str_plain_parent );
    const_str_plain_find_previous_siblings = UNSTREAM_STRING( &constant_bin[ 206984 ], 22, 1 );
    const_str_plain_strings = UNSTREAM_STRING( &constant_bin[ 15264 ], 7, 1 );
    const_tuple_3b64fb04a63013587f4e717b6d88d2c3_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_3b64fb04a63013587f4e717b6d88d2c3_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_is_initialized = UNSTREAM_STRING( &constant_bin[ 207006 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_3b64fb04a63013587f4e717b6d88d2c3_tuple, 1, const_str_plain_is_initialized ); Py_INCREF( const_str_plain_is_initialized );
    const_str_plain_accept_self = UNSTREAM_STRING( &constant_bin[ 207020 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_3b64fb04a63013587f4e717b6d88d2c3_tuple, 2, const_str_plain_accept_self ); Py_INCREF( const_str_plain_accept_self );
    PyTuple_SET_ITEM( const_tuple_3b64fb04a63013587f4e717b6d88d2c3_tuple, 3, const_str_plain_last_child ); Py_INCREF( const_str_plain_last_child );
    const_str_plain_find_parent = UNSTREAM_STRING( &constant_bin[ 207031 ], 11, 1 );
    const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple, 1, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple, 2, const_str_plain_index ); Py_INCREF( const_str_plain_index );
    PyTuple_SET_ITEM( const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple, 3, const_str_plain_parent ); Py_INCREF( const_str_plain_parent );
    PyTuple_SET_ITEM( const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple, 4, const_str_plain_offset ); Py_INCREF( const_str_plain_offset );
    PyTuple_SET_ITEM( const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple, 5, const_str_plain_successor ); Py_INCREF( const_str_plain_successor );
    const_str_plain_substitute = UNSTREAM_STRING( &constant_bin[ 197207 ], 10, 1 );
    const_str_plain_void_element_close_prefix = UNSTREAM_STRING( &constant_bin[ 207042 ], 25, 1 );
    const_str_digest_750906c63df60c8f9857f2595e15aebc = UNSTREAM_STRING( &constant_bin[ 207067 ], 50, 0 );
    const_tuple_str_plain_self_str_plain_encoding_str_plain_rewrite_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoding_str_plain_rewrite_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoding_str_plain_rewrite_tuple, 1, const_str_plain_encoding ); Py_INCREF( const_str_plain_encoding );
    const_str_plain_rewrite = UNSTREAM_STRING( &constant_bin[ 200266 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoding_str_plain_rewrite_tuple, 2, const_str_plain_rewrite ); Py_INCREF( const_str_plain_rewrite );
    const_str_digest_d72d114df8db0ba64be9f314fb3d10ea = UNSTREAM_STRING( &constant_bin[ 207117 ], 113, 0 );
    const_str_plain_stopNode = UNSTREAM_STRING( &constant_bin[ 207230 ], 8, 1 );
    const_str_plain_get_attribute_list = UNSTREAM_STRING( &constant_bin[ 207238 ], 18, 1 );
    const_tuple_6fabcf46d88fc62d9aaf37d94ef18c6e_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_6fabcf46d88fc62d9aaf37d94ef18c6e_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    const_str_plain_original_value = UNSTREAM_STRING( &constant_bin[ 131010 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_6fabcf46d88fc62d9aaf37d94ef18c6e_tuple, 1, const_str_plain_original_value ); Py_INCREF( const_str_plain_original_value );
    PyTuple_SET_ITEM( const_tuple_6fabcf46d88fc62d9aaf37d94ef18c6e_tuple, 2, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    PyTuple_SET_ITEM( const_tuple_6fabcf46d88fc62d9aaf37d94ef18c6e_tuple, 3, const_str_plain_match ); Py_INCREF( const_str_plain_match );
    const_str_digest_0ffd0fc42335dceae8efe9c6f5089d15 = UNSTREAM_STRING( &constant_bin[ 207256 ], 30, 0 );
    const_str_plain_markup_attr_map = UNSTREAM_STRING( &constant_bin[ 207286 ], 15, 1 );
    const_str_plain_HTMLXMLFormatter = UNSTREAM_STRING( &constant_bin[ 207301 ], 16, 1 );
    const_str_digest_0335416823e683d1ebbe424bdd45a2ca = UNSTREAM_STRING( &constant_bin[ 207317 ], 85, 0 );
    const_str_digest_3a6a8193326a0cc096673b1c1e043757 = UNSTREAM_STRING( &constant_bin[ 207402 ], 37, 0 );
    const_str_plain_old_parent = UNSTREAM_STRING( &constant_bin[ 207439 ], 10, 1 );
    const_str_plain_findNextSiblings = UNSTREAM_STRING( &constant_bin[ 207449 ], 16, 1 );
    const_str_digest_996dd8adec957dee57886c3b180eb10e = UNSTREAM_STRING( &constant_bin[ 207465 ], 75, 0 );
    const_str_digest_5972be3d2e0ae5cffa0313f94447abdb = UNSTREAM_STRING( &constant_bin[ 207540 ], 155, 0 );
    const_str_digest_a9c30e8b7efc851a52b36f9f117da2a2 = UNSTREAM_STRING( &constant_bin[ 207695 ], 12, 0 );
    const_str_plain_next_child = UNSTREAM_STRING( &constant_bin[ 207707 ], 10, 1 );
    const_str_digest_d1ef6bd6894bac52c44d6c442c9cf379 = UNSTREAM_STRING( &constant_bin[ 207717 ], 83, 0 );
    const_str_plain_findPrevious = UNSTREAM_STRING( &constant_bin[ 207800 ], 12, 1 );
    const_tuple_str_plain_self_str_plain_tags_str_plain_tag_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tags_str_plain_tag_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tags_str_plain_tag_tuple, 1, const_str_plain_tags ); Py_INCREF( const_str_plain_tags );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_tags_str_plain_tag_tuple, 2, const_str_plain_tag ); Py_INCREF( const_str_plain_tag );
    const_unicode_digest_28f2d46bf240bc75f671359bf185105d = UNSTREAM_UNICODE( &constant_bin[ 182509 ], 2 );
    const_set_6e20dab302bdf7555943e6e98a3c0a93 = PySet_New( NULL );
    PySet_Add( const_set_6e20dab302bdf7555943e6e98a3c0a93, const_str_plain_pre );
    PySet_Add( const_set_6e20dab302bdf7555943e6e98a3c0a93, const_str_plain_textarea );
    assert( PySet_Size( const_set_6e20dab302bdf7555943e6e98a3c0a93 ) == 2 );
    const_str_plain_CHARSET_RE = UNSTREAM_STRING( &constant_bin[ 207812 ], 10, 1 );
    const_str_plain__alias = UNSTREAM_STRING( &constant_bin[ 82690 ], 6, 1 );
    const_tuple_str_plain_match_str_plain_encoding_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_match_str_plain_encoding_tuple, 0, const_str_plain_match ); Py_INCREF( const_str_plain_match );
    PyTuple_SET_ITEM( const_tuple_str_plain_match_str_plain_encoding_tuple, 1, const_str_plain_encoding ); Py_INCREF( const_str_plain_encoding );
    const_str_plain__matches = UNSTREAM_STRING( &constant_bin[ 207822 ], 8, 1 );
    const_str_digest_1c3b497b8a4a3c183134674c43de9ce2 = UNSTREAM_STRING( &constant_bin[ 207830 ], 49, 0 );
    const_tuple_str_plain_self_str_plain_formatter_str_plain_output_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_formatter_str_plain_output_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_formatter_str_plain_output_tuple, 1, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_formatter_str_plain_output_tuple, 2, const_str_plain_output ); Py_INCREF( const_str_plain_output );
    const_str_plain_indent_space = UNSTREAM_STRING( &constant_bin[ 207879 ], 12, 1 );
    const_str_plain_findAllNext = UNSTREAM_STRING( &constant_bin[ 207891 ], 11, 1 );
    const_str_plain_fetchPreviousSiblings = UNSTREAM_STRING( &constant_bin[ 207902 ], 21, 1 );
    const_tuple_type_unicode_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_type_unicode_tuple, 0, (PyObject *)&PyUnicode_Type ); Py_INCREF( (PyObject *)&PyUnicode_Type );
    const_str_digest_b246a21da0bf0d1ecd21a222430c1e19 = UNSTREAM_STRING( &constant_bin[ 207923 ], 25, 0 );
    const_str_plain_replace_with_children = UNSTREAM_STRING( &constant_bin[ 207948 ], 21, 1 );
    const_str_digest_688f06597223eaae9df5adffcac1b5da = UNSTREAM_STRING( &constant_bin[ 207969 ], 14, 0 );
    const_str_digest_b08f55921cd8c7f8cc8a2534d60adbcd = UNSTREAM_STRING( &constant_bin[ 100912 ], 5, 0 );
    const_str_digest_5e8296b08c7275b6e9b059066a53a1cb = UNSTREAM_STRING( &constant_bin[ 207983 ], 114, 0 );
    const_str_plain_call_function_with_tag_data = UNSTREAM_STRING( &constant_bin[ 208097 ], 27, 1 );
    const_str_digest_f71329a7fdb204c7f3cb9c7636f075d9 = UNSTREAM_STRING( &constant_bin[ 208124 ], 140, 0 );
    const_str_plain_original_markup = UNSTREAM_STRING( &constant_bin[ 208264 ], 15, 1 );
    const_str_digest_a8642630e4859aa7595db413203bd4d1 = UNSTREAM_STRING( &constant_bin[ 208279 ], 127, 0 );
    const_tuple_d0434168675df957da575746d9fec873_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_d0434168675df957da575746d9fec873_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_d0434168675df957da575746d9fec873_tuple, 1, const_str_plain_encoding ); Py_INCREF( const_str_plain_encoding );
    const_str_plain_prettyPrint = UNSTREAM_STRING( &constant_bin[ 208406 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_d0434168675df957da575746d9fec873_tuple, 2, const_str_plain_prettyPrint ); Py_INCREF( const_str_plain_prettyPrint );
    PyTuple_SET_ITEM( const_tuple_d0434168675df957da575746d9fec873_tuple, 3, const_str_plain_indentLevel ); Py_INCREF( const_str_plain_indentLevel );
    const_str_plain_previousSiblingGenerator = UNSTREAM_STRING( &constant_bin[ 208417 ], 24, 1 );
    const_str_plain__formatter_for_name = UNSTREAM_STRING( &constant_bin[ 208441 ], 19, 1 );
    const_str_digest_687f64809c4be828c127c356e1b6ed7c = UNSTREAM_STRING( &constant_bin[ 208460 ], 99, 0 );
    const_str_plain_find_previous_sibling = UNSTREAM_STRING( &constant_bin[ 206984 ], 21, 1 );
    const_str_digest_2723f6e7179adb3f95d6ef44f1805134 = UNSTREAM_STRING( &constant_bin[ 208559 ], 50, 0 );
    const_tuple_true_true_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_true_true_tuple, 0, Py_True ); Py_INCREF( Py_True );
    PyTuple_SET_ITEM( const_tuple_true_true_tuple, 1, Py_True ); Py_INCREF( Py_True );
    const_str_plain_fetchPrevious = UNSTREAM_STRING( &constant_bin[ 207902 ], 13, 1 );
    const_tuple_e852ed76cabcde48e8c638757ba9055c_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_e852ed76cabcde48e8c638757ba9055c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e852ed76cabcde48e8c638757ba9055c_tuple, 1, const_str_plain_child ); Py_INCREF( const_str_plain_child );
    PyTuple_SET_ITEM( const_tuple_e852ed76cabcde48e8c638757ba9055c_tuple, 2, const_str_plain_clone ); Py_INCREF( const_str_plain_clone );
    PyTuple_SET_ITEM( const_tuple_e852ed76cabcde48e8c638757ba9055c_tuple, 3, const_str_plain_attr ); Py_INCREF( const_str_plain_attr );
    const_unicode_digest_ce081481423abca80d01dc6b2ce9e9ea = UNSTREAM_UNICODE( &constant_bin[ 182488 ], 2 );
    const_set_c4437c08c2c2846750c8f9786cb91cc1 = PySet_New( NULL );
    PySet_Add( const_set_c4437c08c2c2846750c8f9786cb91cc1, const_str_plain_pre );
    assert( PySet_Size( const_set_c4437c08c2c2846750c8f9786cb91cc1 ) == 1 );
    const_str_plain_parents_next_sibling = UNSTREAM_STRING( &constant_bin[ 208609 ], 20, 1 );
    const_str_digest_b42292186816115aadac41c6428c2b70 = UNSTREAM_STRING( &constant_bin[ 208629 ], 160, 0 );
    const_str_plain_find_all_next = UNSTREAM_STRING( &constant_bin[ 208789 ], 13, 1 );
    const_tuple_str_plain_next_sibling_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_next_sibling_tuple, 0, const_str_plain_next_sibling ); Py_INCREF( const_str_plain_next_sibling );
    const_str_plain_prettify = UNSTREAM_STRING( &constant_bin[ 208802 ], 8, 1 );
    const_str_digest_c658d19634e753d4f72ac98fd801f3f1 = UNSTREAM_STRING( &constant_bin[ 208810 ], 28, 0 );
    const_str_digest_de65d084d97cebdd56daaf35cf257c00 = UNSTREAM_STRING( &constant_bin[ 208838 ], 49, 0 );
    const_str_plain_normalized_attrs = UNSTREAM_STRING( &constant_bin[ 208887 ], 16, 1 );
    const_str_plain_AttributeValueWithCharsetSubstitution = UNSTREAM_STRING( &constant_bin[ 208903 ], 37, 1 );
    const_str_plain_findParents = UNSTREAM_STRING( &constant_bin[ 208940 ], 11, 1 );
    const_str_plain_cdata_containing_tags = UNSTREAM_STRING( &constant_bin[ 208951 ], 21, 1 );
    const_str_digest_3efbf8635fb02c14f734f6fa1f903d94 = UNSTREAM_STRING( &constant_bin[ 208972 ], 58, 0 );
    const_tuple_str_plain_EntitySubstitution_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_EntitySubstitution_tuple, 0, const_str_plain_EntitySubstitution ); Py_INCREF( const_str_plain_EntitySubstitution );
    const_str_plain_strainer = UNSTREAM_STRING( &constant_bin[ 209030 ], 8, 1 );
    const_str_plain_parser_class = UNSTREAM_STRING( &constant_bin[ 209038 ], 12, 1 );
    const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple, 3, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple, 4, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple, 5, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    const_str_digest_5dde75ea46d316ab5ab5d75080f755c4 = UNSTREAM_STRING( &constant_bin[ 209050 ], 193, 0 );
    const_str_plain_recursiveChildGenerator = UNSTREAM_STRING( &constant_bin[ 209243 ], 23, 1 );
    const_str_plain__lastRecursiveChild = UNSTREAM_STRING( &constant_bin[ 209266 ], 19, 1 );
    const_str_plain_new_childs_last_element = UNSTREAM_STRING( &constant_bin[ 209285 ], 23, 1 );
    const_str_digest_44cc79d8ae47795db54dfcb36a03ec10 = UNSTREAM_STRING( &constant_bin[ 209308 ], 570, 0 );
    const_str_plain_my_child = UNSTREAM_STRING( &constant_bin[ 209878 ], 8, 1 );
    const_str_plain_childGenerator = UNSTREAM_STRING( &constant_bin[ 209886 ], 14, 1 );
    const_str_plain__find_all = UNSTREAM_STRING( &constant_bin[ 209900 ], 9, 1 );
    const_tuple_228af158dcd68f83b463bc2269dd782f_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_228af158dcd68f83b463bc2269dd782f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_228af158dcd68f83b463bc2269dd782f_tuple, 1, const_str_plain_encoding ); Py_INCREF( const_str_plain_encoding );
    PyTuple_SET_ITEM( const_tuple_228af158dcd68f83b463bc2269dd782f_tuple, 2, const_str_plain_indent_level ); Py_INCREF( const_str_plain_indent_level );
    PyTuple_SET_ITEM( const_tuple_228af158dcd68f83b463bc2269dd782f_tuple, 3, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    PyTuple_SET_ITEM( const_tuple_228af158dcd68f83b463bc2269dd782f_tuple, 4, const_str_plain_errors ); Py_INCREF( const_str_plain_errors );
    PyTuple_SET_ITEM( const_tuple_228af158dcd68f83b463bc2269dd782f_tuple, 5, const_str_plain_u ); Py_INCREF( const_str_plain_u );
    const_str_digest_a6aafb5565cda3049a1405989036800d = UNSTREAM_STRING( &constant_bin[ 209308 ], 57, 0 );
    const_str_digest_c5639168a5cbc5c4d0956b93b3eb2792 = UNSTREAM_STRING( &constant_bin[ 209909 ], 47, 0 );
    const_str_digest_a3d9d833894395d6536a0b717d3a6231 = UNSTREAM_STRING( &constant_bin[ 209956 ], 84, 0 );
    const_str_plain_separator = UNSTREAM_STRING( &constant_bin[ 177414 ], 9, 1 );
    const_str_plain_parentGenerator = UNSTREAM_STRING( &constant_bin[ 210040 ], 15, 1 );
    const_str_plain_subchild = UNSTREAM_STRING( &constant_bin[ 210055 ], 8, 1 );
    const_str_digest_f425bee58e499399e7174ce48229bf9d = UNSTREAM_STRING( &constant_bin[ 210063 ], 51, 0 );
    const_str_plain_parserClass = UNSTREAM_STRING( &constant_bin[ 210114 ], 11, 1 );
    const_str_digest_9e0202f20825ee6726af59eda1c982e0 = UNSTREAM_STRING( &constant_bin[ 210125 ], 32, 0 );
    const_str_plain_findPreviousSibling = UNSTREAM_STRING( &constant_bin[ 210157 ], 19, 1 );
    const_str_plain_pub_id = UNSTREAM_STRING( &constant_bin[ 210176 ], 6, 1 );
    const_str_plain_xmlcharrefreplace = UNSTREAM_STRING( &constant_bin[ 202893 ], 17, 1 );
    const_unicode_digest_08c55f7436746dfbed837b418ea65a70 = UNSTREAM_UNICODE( &constant_bin[ 191125 ], 3 );
    const_tuple_str_digest_688f06597223eaae9df5adffcac1b5da_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_688f06597223eaae9df5adffcac1b5da_tuple, 0, const_str_digest_688f06597223eaae9df5adffcac1b5da ); Py_INCREF( const_str_digest_688f06597223eaae9df5adffcac1b5da );
    const_tuple_str_plain_self_str_plain_formatter_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_formatter_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_formatter_tuple, 1, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    const_str_digest_150a3ddd6f980f74b974d699bb653243 = UNSTREAM_STRING( &constant_bin[ 210182 ], 128, 0 );
    const_tuple_str_plain_self_str_plain_attr_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_attr_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_attr_tuple, 1, const_str_plain_attr ); Py_INCREF( const_str_plain_attr );
    const_str_plain_markup_attrs = UNSTREAM_STRING( &constant_bin[ 210310 ], 12, 1 );
    const_str_digest_e284352cda9140f58b06ed689c06ac6a = UNSTREAM_STRING( &constant_bin[ 210322 ], 50, 0 );
    const_str_digest_28fcfa6b905769882ab971e07fe72510 = UNSTREAM_STRING( &constant_bin[ 210372 ], 151, 0 );
    const_str_digest_2c574a663a96a37e80240aa8a1c13e67 = UNSTREAM_STRING( &constant_bin[ 210523 ], 191, 0 );
    const_str_plain_find_all = UNSTREAM_STRING( &constant_bin[ 207654 ], 8, 1 );
    const_str_digest_966b532e2f3ba00ecd4d1fb36c023539 = UNSTREAM_STRING( &constant_bin[ 210714 ], 93, 0 );
    const_str_plain_me = UNSTREAM_STRING( &constant_bin[ 383 ], 2, 1 );
    const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple = PyTuple_New( 14 );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 3, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 4, const_str_plain_limit ); Py_INCREF( const_str_plain_limit );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 5, const_str_plain_generator ); Py_INCREF( const_str_plain_generator );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 6, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 7, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_str_plain_local_name = UNSTREAM_STRING( &constant_bin[ 210807 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 8, const_str_plain_local_name ); Py_INCREF( const_str_plain_local_name );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 9, const_str_plain_results ); Py_INCREF( const_str_plain_results );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 10, const_str_plain_prefix ); Py_INCREF( const_str_plain_prefix );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 11, const_str_plain_found ); Py_INCREF( const_str_plain_found );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 12, const_str_plain_strainer ); Py_INCREF( const_str_plain_strainer );
    PyTuple_SET_ITEM( const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 13, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 3, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 4, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 5, const_str_plain_normalized_attrs ); Py_INCREF( const_str_plain_normalized_attrs );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 6, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 7, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    const_tuple_3da16538fbd197083cd091a6f193427d_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_3da16538fbd197083cd091a6f193427d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3da16538fbd197083cd091a6f193427d_tuple, 1, const_str_plain_strip ); Py_INCREF( const_str_plain_strip );
    PyTuple_SET_ITEM( const_tuple_3da16538fbd197083cd091a6f193427d_tuple, 2, const_str_plain_types ); Py_INCREF( const_str_plain_types );
    PyTuple_SET_ITEM( const_tuple_3da16538fbd197083cd091a6f193427d_tuple, 3, const_str_plain_descendant ); Py_INCREF( const_str_plain_descendant );
    const_dict_ac1eba801ee59541af7075d340bfcec6 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_ac1eba801ee59541af7075d340bfcec6, const_str_plain___module__, const_str_digest_a694a1497725bd5d49805e1c282892b9 );
    PyDict_SetItem( const_dict_ac1eba801ee59541af7075d340bfcec6, const_str_plain___doc__, const_str_digest_a808f721500ff0677501bf21de1894f0 );
    assert( PyDict_Size( const_dict_ac1eba801ee59541af7075d340bfcec6 ) == 2 );
    const_tuple_bfb3dc918e2c3822cf026cb5a5888d9d_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_bfb3dc918e2c3822cf026cb5a5888d9d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_bfb3dc918e2c3822cf026cb5a5888d9d_tuple, 1, const_str_plain_child ); Py_INCREF( const_str_plain_child );
    const_str_plain_my_parent = UNSTREAM_STRING( &constant_bin[ 210817 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_bfb3dc918e2c3822cf026cb5a5888d9d_tuple, 2, const_str_plain_my_parent ); Py_INCREF( const_str_plain_my_parent );
    const_str_plain_my_index = UNSTREAM_STRING( &constant_bin[ 210826 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_bfb3dc918e2c3822cf026cb5a5888d9d_tuple, 3, const_str_plain_my_index ); Py_INCREF( const_str_plain_my_index );
    const_str_plain_new_child = UNSTREAM_STRING( &constant_bin[ 209285 ], 9, 1 );
    const_str_plain_encode_contents = UNSTREAM_STRING( &constant_bin[ 210834 ], 15, 1 );
    const_str_plain_previous_elements = UNSTREAM_STRING( &constant_bin[ 210849 ], 17, 1 );
    const_str_plain_nextSiblingGenerator = UNSTREAM_STRING( &constant_bin[ 210866 ], 20, 1 );
    const_str_digest_73e3f65a5e6a0e231abfd780063ee2b0 = UNSTREAM_STRING( &constant_bin[ 210886 ], 59, 0 );
    const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 1, const_str_plain_indent_level ); Py_INCREF( const_str_plain_indent_level );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 2, const_str_plain_eventual_encoding ); Py_INCREF( const_str_plain_eventual_encoding );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 3, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 4, const_str_plain_c ); Py_INCREF( const_str_plain_c );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 5, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 6, const_str_plain_pretty_print ); Py_INCREF( const_str_plain_pretty_print );
    PyTuple_SET_ITEM( const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 7, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    const_str_plain_output_ready = UNSTREAM_STRING( &constant_bin[ 210945 ], 12, 1 );
    const_tuple_5d973f0bbc887f462db71b319acd6172_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_5d973f0bbc887f462db71b319acd6172_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5d973f0bbc887f462db71b319acd6172_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_5d973f0bbc887f462db71b319acd6172_tuple, 2, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_5d973f0bbc887f462db71b319acd6172_tuple, 3, const_str_plain_my_child ); Py_INCREF( const_str_plain_my_child );
    const_str_digest_74605c90f126dd9a5280fd0d6380988e = UNSTREAM_STRING( &constant_bin[ 210957 ], 47, 0 );
    const_unicode_digest_bdc18e346a4949f889a922a59c59687c = UNSTREAM_UNICODE( &constant_bin[ 211004 ], 3 );
    const_unicode_digest_10b0cc8d52dbda6d37909d215669cae2 = UNSTREAM_UNICODE( &constant_bin[ 191117 ], 4 );
    const_str_plain_fetchNextSiblings = UNSTREAM_STRING( &constant_bin[ 211007 ], 17, 1 );
    const_tuple_str_plain_self_str_plain_indent_level_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_indent_level_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_indent_level_tuple, 1, const_str_plain_indent_level ); Py_INCREF( const_str_plain_indent_level );
    const_str_digest_caa1311fbee6a780f68a9bf663ab8344 = UNSTREAM_STRING( &constant_bin[ 211024 ], 30, 0 );
    const_str_plain_find_next = UNSTREAM_STRING( &constant_bin[ 211054 ], 9, 1 );
    const_str_plain_match_against = UNSTREAM_STRING( &constant_bin[ 211063 ], 13, 1 );
    const_str_digest_16a272a1ac84aa8c964578a8dee1c6dd = UNSTREAM_STRING( &constant_bin[ 211076 ], 76, 0 );
    const_str_plain_whitespace_re = UNSTREAM_STRING( &constant_bin[ 211152 ], 13, 1 );
    const_str_plain__find_one = UNSTREAM_STRING( &constant_bin[ 211165 ], 9, 1 );
    const_tuple_str_plain_minimal_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_minimal_tuple, 0, const_str_plain_minimal ); Py_INCREF( const_str_plain_minimal );
    const_str_digest_530dbdb9b402b3f07d411a938927f2b3 = UNSTREAM_STRING( &constant_bin[ 211174 ], 137, 0 );
    const_tuple_str_plain_self_str_plain_element_str_plain_i_str_plain_child_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_element_str_plain_i_str_plain_child_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_element_str_plain_i_str_plain_child_tuple, 1, const_str_plain_element ); Py_INCREF( const_str_plain_element );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_element_str_plain_i_str_plain_child_tuple, 2, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_element_str_plain_i_str_plain_child_tuple, 3, const_str_plain_child ); Py_INCREF( const_str_plain_child );
    const_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c = UNSTREAM_STRING( &constant_bin[ 211311 ], 3, 0 );
    const_str_plain_class = UNSTREAM_STRING( &constant_bin[ 2861 ], 5, 1 );
    const_str_plain_substitute_entities = UNSTREAM_STRING( &constant_bin[ 211314 ], 19, 1 );
    const_str_digest_a0f6e9f5acfe56723fdae36afe1e77fb = UNSTREAM_STRING( &constant_bin[ 211333 ], 76, 0 );
    const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 3, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 4, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    const_str_plain__substitute_if_appropriate = UNSTREAM_STRING( &constant_bin[ 211409 ], 26, 1 );
    const_tuple_str_plain_self_str_plain_child_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_child_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_child_tuple, 1, const_str_plain_child ); Py_INCREF( const_str_plain_child );
    const_tuple_str_plain_cls_str_plain_ns_str_plain_f_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ns_str_plain_f_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ns_str_plain_f_tuple, 1, const_str_plain_ns ); Py_INCREF( const_str_plain_ns );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_ns_str_plain_f_tuple, 2, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    const_str_plain_current_index = UNSTREAM_STRING( &constant_bin[ 211435 ], 13, 1 );
    const_str_plain_find_all_previous = UNSTREAM_STRING( &constant_bin[ 211448 ], 17, 1 );
    const_str_digest_789a2a1ab5c730365a2961867d62159f = UNSTREAM_STRING( &constant_bin[ 211465 ], 185, 0 );
    const_str_plain_previous_siblings = UNSTREAM_STRING( &constant_bin[ 206989 ], 17, 1 );
    const_str_plain_preformatted_tags = UNSTREAM_STRING( &constant_bin[ 211650 ], 17, 1 );
    const_str_digest_66fede51f6d2599d31cae6b2824d49fe = UNSTREAM_STRING( &constant_bin[ 211667 ], 25, 0 );
    const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple, 1, const_str_plain_indent_level ); Py_INCREF( const_str_plain_indent_level );
    PyTuple_SET_ITEM( const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple, 2, const_str_plain_encoding ); Py_INCREF( const_str_plain_encoding );
    PyTuple_SET_ITEM( const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple, 3, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    PyTuple_SET_ITEM( const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple, 4, const_str_plain_contents ); Py_INCREF( const_str_plain_contents );
    const_str_plain_findAllPrevious = UNSTREAM_STRING( &constant_bin[ 211692 ], 15, 1 );
    const_str_digest_74feb09b4e7b5c98ea28f927cc7ad7ec = UNSTREAM_STRING( &constant_bin[ 211707 ], 355, 0 );
    const_str_digest_b63f4abf4c20ed95c5280f099ca7f649 = UNSTREAM_STRING( &constant_bin[ 212062 ], 7, 0 );
    const_str_digest_51f97402dd7101c57c82d9e47530321c = UNSTREAM_STRING( &constant_bin[ 212069 ], 90, 0 );
    const_str_digest_a1252b58837909ad9dc1fcca1e9295d3 = UNSTREAM_STRING( &constant_bin[ 212159 ], 48, 0 );
    const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 3, const_str_plain_recursive ); Py_INCREF( const_str_plain_recursive );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 4, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 5, const_str_plain_limit ); Py_INCREF( const_str_plain_limit );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 6, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 7, const_str_plain_generator ); Py_INCREF( const_str_plain_generator );
    const_str_digest_7367bb348cc3e8e5398ecf366526fd9f = UNSTREAM_STRING( &constant_bin[ 212207 ], 61, 0 );
    const_tuple_str_plain_self_str_plain_current_str_plain_stopNode_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_current_str_plain_stopNode_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_current_str_plain_stopNode_tuple, 1, const_str_plain_current ); Py_INCREF( const_str_plain_current );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_current_str_plain_stopNode_tuple, 2, const_str_plain_stopNode ); Py_INCREF( const_str_plain_stopNode );
    const_tuple_str_plain_cls_str_plain_value_str_plain_u_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_value_str_plain_u_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_value_str_plain_u_tuple, 1, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_value_str_plain_u_tuple, 2, const_str_plain_u ); Py_INCREF( const_str_plain_u );
    const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple, 1, const_str_plain_prefix ); Py_INCREF( const_str_plain_prefix );
    PyTuple_SET_ITEM( const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple, 2, const_str_plain_local_name ); Py_INCREF( const_str_plain_local_name );
    PyTuple_SET_ITEM( const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple, 3, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple, 4, const_str_plain_element ); Py_INCREF( const_str_plain_element );
    const_str_digest_29649a9de50f1b949dd54bb0ed0bf2bf = UNSTREAM_STRING( &constant_bin[ 212268 ], 29, 0 );
    const_str_plain_find_next_siblings = UNSTREAM_STRING( &constant_bin[ 212297 ], 18, 1 );
    const_str_plain_findChildren = UNSTREAM_STRING( &constant_bin[ 212315 ], 12, 1 );
    const_tuple_str_plain_self_str_plain_last_child_str_plain_next_element_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_last_child_str_plain_next_element_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_last_child_str_plain_next_element_tuple, 1, const_str_plain_last_child ); Py_INCREF( const_str_plain_last_child );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_last_child_str_plain_next_element_tuple, 2, const_str_plain_next_element ); Py_INCREF( const_str_plain_next_element );
    const_tuple_2db4dbe516092df2db3de6cea5c71cab_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_2db4dbe516092df2db3de6cea5c71cab_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_2db4dbe516092df2db3de6cea5c71cab_tuple, 1, const_str_plain_element ); Py_INCREF( const_str_plain_element );
    const_str_plain_findNextSibling = UNSTREAM_STRING( &constant_bin[ 207449 ], 15, 1 );
    const_str_plain_replaceWithChildren = UNSTREAM_STRING( &constant_bin[ 212327 ], 19, 1 );
    const_str_plain_has_attr = UNSTREAM_STRING( &constant_bin[ 208586 ], 8, 1 );
    const_str_digest_2fb35f5b371e4357763cfefa063b5165 = UNSTREAM_STRING( &constant_bin[ 212346 ], 5, 0 );
    const_str_plain_HTML_FORMATTERS = UNSTREAM_STRING( &constant_bin[ 212351 ], 15, 1 );
    const_str_plain_findChild = UNSTREAM_STRING( &constant_bin[ 212315 ], 9, 1 );
    const_str_plain_XMLFormatter = UNSTREAM_STRING( &constant_bin[ 207305 ], 12, 1 );
    const_tuple_e78b94ed7a6cf112858126b31788598d_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_e78b94ed7a6cf112858126b31788598d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e78b94ed7a6cf112858126b31788598d_tuple, 1, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_e78b94ed7a6cf112858126b31788598d_tuple, 2, const_str_plain_new_value ); Py_INCREF( const_str_plain_new_value );
    PyTuple_SET_ITEM( const_tuple_e78b94ed7a6cf112858126b31788598d_tuple, 3, const_str_plain_v ); Py_INCREF( const_str_plain_v );
    const_str_digest_683058e4e72e5e683458d44dcd762604 = UNSTREAM_STRING( &constant_bin[ 212366 ], 27, 0 );
    const_str_digest_c9d2da40f15d12241238636e3ea4b960 = UNSTREAM_STRING( &constant_bin[ 212393 ], 136, 0 );
    const_tuple_str_plain_attr_str_plain_alias_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_attr_str_plain_alias_tuple, 0, const_str_plain_attr ); Py_INCREF( const_str_plain_attr );
    PyTuple_SET_ITEM( const_tuple_str_plain_attr_str_plain_alias_tuple, 1, const_str_plain_alias ); Py_INCREF( const_str_plain_alias );
    const_str_plain_SUFFIX = UNSTREAM_STRING( &constant_bin[ 212529 ], 6, 1 );
    const_tuple_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c_tuple, 0, const_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c ); Py_INCREF( const_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c );
    const_str_digest_16edbedf290760e205b7c3d404645ec6 = UNSTREAM_STRING( &constant_bin[ 212535 ], 54, 0 );
    const_str_plain_find_parents = UNSTREAM_STRING( &constant_bin[ 212589 ], 12, 1 );
    const_str_plain_has_key = UNSTREAM_STRING( &constant_bin[ 208559 ], 7, 1 );
    const_str_digest_9a607885277141d349d6d92be27c1d04 = UNSTREAM_STRING( &constant_bin[ 212601 ], 159, 0 );
    const_str_digest_2eb78fd35de0c552fcd9f4234a3e2fee = UNSTREAM_STRING( &constant_bin[ 212760 ], 29, 0 );
    const_str_digest_38aa4d1e4b90e4783d9d90e8dfcb74d9 = UNSTREAM_STRING( &constant_bin[ 212789 ], 20, 0 );
    const_str_plain_fetchParents = UNSTREAM_STRING( &constant_bin[ 212809 ], 12, 1 );
    const_str_plain_next_elements = UNSTREAM_STRING( &constant_bin[ 212821 ], 13, 1 );
    const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple, 3, const_str_plain_limit ); Py_INCREF( const_str_plain_limit );
    PyTuple_SET_ITEM( const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple, 4, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    const_unicode_digest_c58e033f1c5c7944b6670af092f11d09 = UNSTREAM_UNICODE( &constant_bin[ 190882 ], 10 );
    const_str_digest_427ece6c74a8f7bed9c0a0f9f58768bf = UNSTREAM_STRING( &constant_bin[ 212834 ], 41, 0 );
    const_str_digest_9e3fe7ba8804c2b496a30c099deb767f = UNSTREAM_STRING( &constant_bin[ 212875 ], 35, 0 );
    const_str_digest_2301ed3ad80a75315314e7e55d580eb4 = UNSTREAM_STRING( &constant_bin[ 212910 ], 45, 0 );
    const_str_plain_markup_name = UNSTREAM_STRING( &constant_bin[ 212955 ], 11, 1 );
    const_str_digest_6c6b5a57155bef64d81c4e3930a40571 = UNSTREAM_STRING( &constant_bin[ 212966 ], 38, 0 );
    const_tuple_272dbd16728ffeefb84651713f277746_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_272dbd16728ffeefb84651713f277746_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_272dbd16728ffeefb84651713f277746_tuple, 1, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    PyTuple_SET_ITEM( const_tuple_272dbd16728ffeefb84651713f277746_tuple, 2, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    PyTuple_SET_ITEM( const_tuple_272dbd16728ffeefb84651713f277746_tuple, 3, const_str_plain_output ); Py_INCREF( const_str_plain_output );
    const_str_plain_previousGenerator = UNSTREAM_STRING( &constant_bin[ 213004 ], 17, 1 );
    const_str_digest_4a104383ff48e621ad8c417548c98ea1 = UNSTREAM_STRING( &constant_bin[ 213021 ], 50, 0 );
    const_tuple_c8ced635d07e13a82f7bd15383636794_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_c8ced635d07e13a82f7bd15383636794_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c8ced635d07e13a82f7bd15383636794_tuple, 1, const_str_plain_replace_with ); Py_INCREF( const_str_plain_replace_with );
    PyTuple_SET_ITEM( const_tuple_c8ced635d07e13a82f7bd15383636794_tuple, 2, const_str_plain_old_parent ); Py_INCREF( const_str_plain_old_parent );
    PyTuple_SET_ITEM( const_tuple_c8ced635d07e13a82f7bd15383636794_tuple, 3, const_str_plain_my_index ); Py_INCREF( const_str_plain_my_index );
    const_str_digest_fa9ac21a1aecbae9bb5a3c4a16e70ffe = UNSTREAM_STRING( &constant_bin[ 213071 ], 330, 0 );
    const_str_digest_6fafb2efdc26996459dc0ccdbcddbdf7 = UNSTREAM_STRING( &constant_bin[ 213401 ], 43, 0 );
    const_str_digest_345cf92f17033766f082736e15d759aa = UNSTREAM_STRING( &constant_bin[ 213444 ], 469, 0 );
    const_tuple_str_plain_cls_str_plain_original_value_str_plain_obj_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_original_value_str_plain_obj_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_original_value_str_plain_obj_tuple, 1, const_str_plain_original_value ); Py_INCREF( const_str_plain_original_value );
    PyTuple_SET_ITEM( const_tuple_str_plain_cls_str_plain_original_value_str_plain_obj_tuple, 2, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    const_str_digest_2c354f1221e3e09909d06a3dc3c259cb = UNSTREAM_STRING( &constant_bin[ 213913 ], 369, 0 );
    const_str_plain_getText = UNSTREAM_STRING( &constant_bin[ 214282 ], 7, 1 );
    const_str_plain_find_next_sibling = UNSTREAM_STRING( &constant_bin[ 212297 ], 17, 1 );
    const_str_digest_d73614277c6d61645b151d81f183d780 = UNSTREAM_STRING( &constant_bin[ 214289 ], 101, 0 );
    const_str_digest_a635dc2cd109c09bc1bdcdd8ac24874a = UNSTREAM_STRING( &constant_bin[ 214390 ], 38, 0 );
    const_tuple_str_plain_self_str_plain_i_str_plain_next_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_next_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_next_tuple, 1, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_i_str_plain_next_tuple, 2, const_str_plain_next ); Py_INCREF( const_str_plain_next );
    const_str_plain_findAll = UNSTREAM_STRING( &constant_bin[ 207891 ], 7, 1 );
    const_tuple_58568bf8b42125104a536219253716ea_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_58568bf8b42125104a536219253716ea_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_58568bf8b42125104a536219253716ea_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_58568bf8b42125104a536219253716ea_tuple, 2, const_str_plain_pub_id ); Py_INCREF( const_str_plain_pub_id );
    PyTuple_SET_ITEM( const_tuple_58568bf8b42125104a536219253716ea_tuple, 3, const_str_plain_system_id ); Py_INCREF( const_str_plain_system_id );
    PyTuple_SET_ITEM( const_tuple_58568bf8b42125104a536219253716ea_tuple, 4, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    const_str_plain_HTMLFormatter = UNSTREAM_STRING( &constant_bin[ 206938 ], 13, 1 );
    const_str_digest_d30c1fec201318981ba659c44f450ce9 = UNSTREAM_STRING( &constant_bin[ 214428 ], 78, 0 );
    const_str_plain_findNext = UNSTREAM_STRING( &constant_bin[ 207449 ], 8, 1 );
    const_str_plain_renderContents = UNSTREAM_STRING( &constant_bin[ 214506 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_decompose_str_plain_element_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_decompose_str_plain_element_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_decompose_str_plain_element_tuple, 1, const_str_plain_decompose ); Py_INCREF( const_str_plain_decompose );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_decompose_str_plain_element_tuple, 2, const_str_plain_element ); Py_INCREF( const_str_plain_element );
    const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple = PyTuple_New( 13 );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 1, const_str_plain_markup_name ); Py_INCREF( const_str_plain_markup_name );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 2, const_str_plain_markup_attrs ); Py_INCREF( const_str_plain_markup_attrs );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 3, const_str_plain_markup ); Py_INCREF( const_str_plain_markup );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 4, const_str_plain_match_against ); Py_INCREF( const_str_plain_match_against );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 5, const_str_plain_k ); Py_INCREF( const_str_plain_k );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 6, const_str_plain_markup_attr_map ); Py_INCREF( const_str_plain_markup_attr_map );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 7, const_str_plain_attr_value ); Py_INCREF( const_str_plain_attr_value );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 8, const_str_plain_v ); Py_INCREF( const_str_plain_v );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 9, const_str_plain_found ); Py_INCREF( const_str_plain_found );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 10, const_str_plain_call_function_with_tag_data ); Py_INCREF( const_str_plain_call_function_with_tag_data );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 11, const_str_plain_match ); Py_INCREF( const_str_plain_match );
    PyTuple_SET_ITEM( const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 12, const_str_plain_attr ); Py_INCREF( const_str_plain_attr );
    const_str_digest_6e71b18f4f00a0af73d97ee880b369b1 = UNSTREAM_STRING( &constant_bin[ 214520 ], 12, 0 );
    const_str_digest_979b3c48ae5244d26d6c51e2422468ee = UNSTREAM_STRING( &constant_bin[ 214532 ], 80, 0 );
    const_str_digest_7b88dc5ab83916f8d7010fa0bb999fa3 = UNSTREAM_STRING( &constant_bin[ 214612 ], 567, 0 );
    const_str_plain_findPreviousSiblings = UNSTREAM_STRING( &constant_bin[ 215179 ], 20, 1 );
    const_str_digest_6e295b76c4b27f5a846f1bb005613354 = UNSTREAM_STRING( &constant_bin[ 215199 ], 418, 0 );
    const_tuple_str_plain_self_str_plain_encoding_str_plain_formatter_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoding_str_plain_formatter_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoding_str_plain_formatter_tuple, 1, const_str_plain_encoding ); Py_INCREF( const_str_plain_encoding );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_encoding_str_plain_formatter_tuple, 2, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    const_str_digest_cb7f043884ff2a2610043d53506bac64 = UNSTREAM_STRING( &constant_bin[ 215617 ], 34, 0 );
    const_str_plain_HTML5Formatter = UNSTREAM_STRING( &constant_bin[ 215651 ], 14, 1 );
    const_str_digest_8ca5f0d3f3d0b766a3f4cdd946dfac3b = UNSTREAM_STRING( &constant_bin[ 215665 ], 106, 0 );
    const_str_digest_dba4300913f590ab70dd3a55a3c580d8 = UNSTREAM_STRING( &constant_bin[ 215771 ], 56, 0 );
    const_str_digest_5019a3250d7d4e2e305907c7346453e1 = UNSTREAM_STRING( &constant_bin[ 215827 ], 48, 0 );
    const_str_plain_PreformattedString = UNSTREAM_STRING( &constant_bin[ 215875 ], 18, 1 );
    const_str_digest_f6bcba6ba3fa9e79445ecc6dd89d522b = UNSTREAM_STRING( &constant_bin[ 215893 ], 53, 0 );
    const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 1, const_str_plain_markup ); Py_INCREF( const_str_plain_markup );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 2, const_str_plain_match_against ); Py_INCREF( const_str_plain_match_against );
    const_str_plain_already_tried = UNSTREAM_STRING( &constant_bin[ 215946 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 3, const_str_plain_already_tried ); Py_INCREF( const_str_plain_already_tried );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 4, const_str_plain_original_markup ); Py_INCREF( const_str_plain_original_markup );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 5, const_str_plain_item ); Py_INCREF( const_str_plain_item );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 6, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 7, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 8, const_str_plain_match ); Py_INCREF( const_str_plain_match );
    const_str_digest_fd3697fca90f8714408b4dfe42e76cb5 = UNSTREAM_STRING( &constant_bin[ 215959 ], 79, 0 );
    const_str_plain_decode_contents = UNSTREAM_STRING( &constant_bin[ 216038 ], 15, 1 );
    const_tuple_none_str_plain_minimal_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_none_str_plain_minimal_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_str_plain_minimal_tuple, 1, const_str_plain_minimal ); Py_INCREF( const_str_plain_minimal );
    const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple, 1, const_str_plain_selector ); Py_INCREF( const_str_plain_selector );
    PyTuple_SET_ITEM( const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple, 2, const_str_plain_namespaces ); Py_INCREF( const_str_plain_namespaces );
    PyTuple_SET_ITEM( const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple, 3, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple, 4, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    const_str_plain_XML_FORMATTERS = UNSTREAM_STRING( &constant_bin[ 216053 ], 14, 1 );
    const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 1, const_str_plain_position ); Py_INCREF( const_str_plain_position );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 2, const_str_plain_new_child ); Py_INCREF( const_str_plain_new_child );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 3, const_str_plain_subchild ); Py_INCREF( const_str_plain_subchild );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 4, const_str_plain_parents_next_sibling ); Py_INCREF( const_str_plain_parents_next_sibling );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 5, const_str_plain_parent ); Py_INCREF( const_str_plain_parent );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 6, const_str_plain_next_child ); Py_INCREF( const_str_plain_next_child );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 7, const_str_plain_new_childs_last_element ); Py_INCREF( const_str_plain_new_childs_last_element );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 8, const_str_plain_BeautifulSoup ); Py_INCREF( const_str_plain_BeautifulSoup );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 9, const_str_plain_current_index ); Py_INCREF( const_str_plain_current_index );
    PyTuple_SET_ITEM( const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 10, const_str_plain_previous_child ); Py_INCREF( const_str_plain_previous_child );
    const_tuple_str_plain_parser_class_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_parser_class_tuple, 0, const_str_plain_parser_class ); Py_INCREF( const_str_plain_parser_class );
    const_str_plain_next_siblings = UNSTREAM_STRING( &constant_bin[ 212302 ], 13, 1 );
    const_str_plain__all_strings = UNSTREAM_STRING( &constant_bin[ 216067 ], 12, 1 );
    const_tuple_d45c60811e98eaafb444e77942903dcf_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_d45c60811e98eaafb444e77942903dcf_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_d45c60811e98eaafb444e77942903dcf_tuple, 1, const_str_plain_separator ); Py_INCREF( const_str_plain_separator );
    PyTuple_SET_ITEM( const_tuple_d45c60811e98eaafb444e77942903dcf_tuple, 2, const_str_plain_strip ); Py_INCREF( const_str_plain_strip );
    PyTuple_SET_ITEM( const_tuple_d45c60811e98eaafb444e77942903dcf_tuple, 3, const_str_plain_types ); Py_INCREF( const_str_plain_types );
    PyTuple_SET_ITEM( const_tuple_d45c60811e98eaafb444e77942903dcf_tuple, 4, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple, 1, const_str_plain_selector ); Py_INCREF( const_str_plain_selector );
    PyTuple_SET_ITEM( const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple, 2, const_str_plain_namespaces ); Py_INCREF( const_str_plain_namespaces );
    PyTuple_SET_ITEM( const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple, 3, const_str_plain_limit ); Py_INCREF( const_str_plain_limit );
    PyTuple_SET_ITEM( const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple, 4, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 1, const_str_plain_parser ); Py_INCREF( const_str_plain_parser );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 2, const_str_plain_builder ); Py_INCREF( const_str_plain_builder );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 3, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 4, const_str_plain_namespace ); Py_INCREF( const_str_plain_namespace );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 5, const_str_plain_prefix ); Py_INCREF( const_str_plain_prefix );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 6, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 7, const_str_plain_parent ); Py_INCREF( const_str_plain_parent );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 8, const_str_plain_previous ); Py_INCREF( const_str_plain_previous );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 9, const_str_plain_is_xml ); Py_INCREF( const_str_plain_is_xml );
    PyTuple_SET_ITEM( const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 10, const_str_plain_preserve_whitespace_tags ); Py_INCREF( const_str_plain_preserve_whitespace_tags );
    const_str_plain__normalize_search_value = UNSTREAM_STRING( &constant_bin[ 216079 ], 23, 1 );
    const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple, 1, const_str_plain_prefix ); Py_INCREF( const_str_plain_prefix );
    PyTuple_SET_ITEM( const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple, 3, const_str_plain_namespace ); Py_INCREF( const_str_plain_namespace );
    PyTuple_SET_ITEM( const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple, 4, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    const_str_digest_43f42e221dbc99e7846a13559b986b53 = UNSTREAM_STRING( &constant_bin[ 216102 ], 630, 0 );
    const_str_digest_d8274aeb344d2374500ebe6784747ede = UNSTREAM_STRING( &constant_bin[ 216732 ], 18, 0 );
    const_tuple_str_plain_self_str_plain_wrap_inside_str_plain_me_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_wrap_inside_str_plain_me_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_wrap_inside_str_plain_me_tuple, 1, const_str_plain_wrap_inside ); Py_INCREF( const_str_plain_wrap_inside );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_wrap_inside_str_plain_me_tuple, 2, const_str_plain_me ); Py_INCREF( const_str_plain_me );
    const_tuple_str_plain____tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain____tuple, 0, const_str_plain___ ); Py_INCREF( const_str_plain___ );
    const_tuple_none_none_none_none_none_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_tuple, 2, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_tuple, 4, Py_None ); Py_INCREF( Py_None );
    const_str_plain_isSelfClosing = UNSTREAM_STRING( &constant_bin[ 216750 ], 13, 1 );
    const_str_plain__should_pretty_print = UNSTREAM_STRING( &constant_bin[ 216763 ], 20, 1 );
    const_str_plain_PREFIX = UNSTREAM_STRING( &constant_bin[ 216783 ], 6, 1 );
    const_tuple_str_plain_Tag_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_Tag_tuple, 0, const_str_plain_Tag ); Py_INCREF( const_str_plain_Tag );
    const_str_plain_PY3K = UNSTREAM_STRING( &constant_bin[ 216789 ], 4, 1 );
    const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple, 1, const_str_plain_parent ); Py_INCREF( const_str_plain_parent );
    PyTuple_SET_ITEM( const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple, 2, const_str_plain_previous_element ); Py_INCREF( const_str_plain_previous_element );
    PyTuple_SET_ITEM( const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple, 3, const_str_plain_next_element ); Py_INCREF( const_str_plain_next_element );
    PyTuple_SET_ITEM( const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple, 4, const_str_plain_previous_sibling ); Py_INCREF( const_str_plain_previous_sibling );
    PyTuple_SET_ITEM( const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple, 5, const_str_plain_next_sibling ); Py_INCREF( const_str_plain_next_sibling );
    const_unicode_digest_6fd0b05522159f98d6181ab8bfabc7f6 = UNSTREAM_UNICODE( &constant_bin[ 216793 ], 9 );
    const_tuple_3a1a822c776686c398d8079a14774929_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_3a1a822c776686c398d8079a14774929_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3a1a822c776686c398d8079a14774929_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_3a1a822c776686c398d8079a14774929_tuple, 2, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_3a1a822c776686c398d8079a14774929_tuple, 3, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_3a1a822c776686c398d8079a14774929_tuple, 4, const_str_plain_limit ); Py_INCREF( const_str_plain_limit );
    PyTuple_SET_ITEM( const_tuple_3a1a822c776686c398d8079a14774929_tuple, 5, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    const_tuple_str_plain_can_be_empty_element_str_plain_hidden_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_can_be_empty_element_str_plain_hidden_tuple, 0, const_str_plain_can_be_empty_element ); Py_INCREF( const_str_plain_can_be_empty_element );
    PyTuple_SET_ITEM( const_tuple_str_plain_can_be_empty_element_str_plain_hidden_tuple, 1, const_str_plain_hidden ); Py_INCREF( const_str_plain_hidden );
    const_str_plain_findParent = UNSTREAM_STRING( &constant_bin[ 208940 ], 10, 1 );
    const_str_digest_40d1280f0aef3f3bf11313c57370733c = UNSTREAM_STRING( &constant_bin[ 216802 ], 62, 0 );
    const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple = PyTuple_New( 19 );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 1, const_str_plain_indent_level ); Py_INCREF( const_str_plain_indent_level );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 2, const_str_plain_eventual_encoding ); Py_INCREF( const_str_plain_eventual_encoding );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 3, const_str_plain_formatter ); Py_INCREF( const_str_plain_formatter );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 4, const_str_plain_indent_contents ); Py_INCREF( const_str_plain_indent_contents );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 5, const_str_plain_decoded ); Py_INCREF( const_str_plain_decoded );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 6, const_str_plain_contents ); Py_INCREF( const_str_plain_contents );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 7, const_str_plain_val ); Py_INCREF( const_str_plain_val );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 8, const_str_plain_space ); Py_INCREF( const_str_plain_space );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 9, const_str_plain_pretty_print ); Py_INCREF( const_str_plain_pretty_print );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 10, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 11, const_str_plain_closeTag ); Py_INCREF( const_str_plain_closeTag );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 12, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 13, const_str_plain_prefix ); Py_INCREF( const_str_plain_prefix );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 14, const_str_plain_attrs ); Py_INCREF( const_str_plain_attrs );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 15, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 16, const_str_plain_close ); Py_INCREF( const_str_plain_close );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 17, const_str_plain_indent_space ); Py_INCREF( const_str_plain_indent_space );
    PyTuple_SET_ITEM( const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 18, const_str_plain_attribute_string ); Py_INCREF( const_str_plain_attribute_string );
    const_str_plain_replaceWith = UNSTREAM_STRING( &constant_bin[ 212327 ], 11, 1 );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_bs4$element( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_6ab36e15dbfb5ac3c50a9a40b572a61e;
static PyCodeObject *codeobj_0c917b25026b6e4ab770ad078decf301;
static PyCodeObject *codeobj_f82a295a662e8886705acead8db7eae2;
static PyCodeObject *codeobj_feea27494a1468bad8c92211b86b996d;
static PyCodeObject *codeobj_e5c9f68c83b74cb2baea83eeeaa3cdfd;
static PyCodeObject *codeobj_f1bdb48699f20645f690a022d5e2c172;
static PyCodeObject *codeobj_203f19c7266c2e913c49a142834bbcfc;
static PyCodeObject *codeobj_873a41d8549c3eae2ceb236f16fe8da3;
static PyCodeObject *codeobj_88c1f00bd461942e207810ba94d1fa55;
static PyCodeObject *codeobj_dfd0b236e1e38e11663e9e5414aa850a;
static PyCodeObject *codeobj_3877e7ba57fb85f72eb8eaa734d3dbe4;
static PyCodeObject *codeobj_9d17cb8081dcccefd359db453c9db698;
static PyCodeObject *codeobj_9d2b28a2d5efc66db477b9157d5d71f4;
static PyCodeObject *codeobj_14c9ca35b08857b494d3b34d6a24c792;
static PyCodeObject *codeobj_d06555feeb0f99a8946ae79358eebe14;
static PyCodeObject *codeobj_36b2c8d556861624aae77de0a07304d0;
static PyCodeObject *codeobj_28dae34448982e5cb647814084cb47ed;
static PyCodeObject *codeobj_18dce61cea9fc7c55052b8072b93f4ef;
static PyCodeObject *codeobj_0f121366c6314e05c4e94b4ba4f281db;
static PyCodeObject *codeobj_fc41c2ad8dbe85f71981b8bba617eec6;
static PyCodeObject *codeobj_b69ca57a2878fd3ed8c2fa69b9943835;
static PyCodeObject *codeobj_4e556ab3367f8156c1378d33dcbc493b;
static PyCodeObject *codeobj_d67dc5583d9735364a2e7eb7aa2f4f9f;
static PyCodeObject *codeobj_c07331a2a0ef212bddc2df31da1b3830;
static PyCodeObject *codeobj_1d647466fb145e14671911abb2f457d6;
static PyCodeObject *codeobj_5258e8cca0a1d712e5493a4091af0ee6;
static PyCodeObject *codeobj_0659d3a8834673b2723e32a986aab130;
static PyCodeObject *codeobj_6260960175210d1d930251866ab9fdd7;
static PyCodeObject *codeobj_f8ede56649c9acbcf3e4d1611cbd7bf1;
static PyCodeObject *codeobj_df689961d1889b2bc63517aeff723192;
static PyCodeObject *codeobj_47e271e4323d4ffe193e3efd217220e8;
static PyCodeObject *codeobj_840dfde127c7948681f68bac0997b15f;
static PyCodeObject *codeobj_d20cd7ff19281f391bdb48bbc6615087;
static PyCodeObject *codeobj_50849ac5284d4f3ccb4a11f07fe777db;
static PyCodeObject *codeobj_b85adaa470e25a69858dfde85e7c078a;
static PyCodeObject *codeobj_876387fdd220214a20731241696fa347;
static PyCodeObject *codeobj_7ae4d0ab18c86a7b052b0c944ba8bd65;
static PyCodeObject *codeobj_e799db36c7ac958aeacbc8d3fbdfd7c6;
static PyCodeObject *codeobj_099aaa80f69d337732d9b444d82bacd1;
static PyCodeObject *codeobj_285a3a357c7e6df9e65ab69b915876e0;
static PyCodeObject *codeobj_9c1c3b549a0cf791cb178533927bbf79;
static PyCodeObject *codeobj_a5e2638464fefd2818be3fcd0d829caf;
static PyCodeObject *codeobj_30b570e03eb3cc558516ab120ff84408;
static PyCodeObject *codeobj_74e0b40b40a8bd05233067bcf4acb342;
static PyCodeObject *codeobj_d650e4d8a3ab64c145624f43bf0229a6;
static PyCodeObject *codeobj_2c3ff2cae6e04e9ec244d1a23dd1cba7;
static PyCodeObject *codeobj_76183d666b6fe52239c562ee299269f3;
static PyCodeObject *codeobj_0d9096af853ae8895db328ea28d3cd9a;
static PyCodeObject *codeobj_2f876307bed7434c370747ea48135869;
static PyCodeObject *codeobj_20cb79926d5c997e0fc30883874ed8c5;
static PyCodeObject *codeobj_2cb78b1700e9c5a78e9a9931b71ffd39;
static PyCodeObject *codeobj_7a87a787dc98c0e8040744cc9c67fa9c;
static PyCodeObject *codeobj_55a270db2583d977babd95a54894be1a;
static PyCodeObject *codeobj_d7959c1f6a1efaa5a744b36b9cfd8c7b;
static PyCodeObject *codeobj_fc15a6c52943040a99d66eb74afa26d4;
static PyCodeObject *codeobj_a0696e67cb1c97143c8c36692ffcc165;
static PyCodeObject *codeobj_6ffb6f921d156ce8415ba690c7511991;
static PyCodeObject *codeobj_7707ae06690f1d6d8642fa5203e1fb8c;
static PyCodeObject *codeobj_7e5ea0a96abd38fc63210a5d0436fdc4;
static PyCodeObject *codeobj_f80e94e61a5498e34db5e8bf04849743;
static PyCodeObject *codeobj_43f0e352fcabe0b721afedeac0d47b0b;
static PyCodeObject *codeobj_e2f97cb35361b509cf888ea2dba587ae;
static PyCodeObject *codeobj_c0b19e80631658ec74bb3e25429fd67f;
static PyCodeObject *codeobj_4cbc0d50c319b71db955e0ed001178e7;
static PyCodeObject *codeobj_8135d7ca17005947bac227662c113913;
static PyCodeObject *codeobj_ef22ab60bd4c83e9125fddfcee10b1a1;
static PyCodeObject *codeobj_783bb656bd248096fe5dff1b6735d020;
static PyCodeObject *codeobj_c703ca9bc738259b4324f501b5ecee93;
static PyCodeObject *codeobj_6df50eb59cc2c378df6c21e1c696f6a0;
static PyCodeObject *codeobj_984ee2fe2ba0922e4dd2853b23c0064e;
static PyCodeObject *codeobj_eda20f939454e2c4a84abc8a549d6b2c;
static PyCodeObject *codeobj_ebc3dc41d3b05d7a4f045cf17e6248c6;
static PyCodeObject *codeobj_9bd7632ac089adc376ecbbcb2f6dc690;
static PyCodeObject *codeobj_c58eed4264ebc40dcacae7730d18dcc1;
static PyCodeObject *codeobj_8498af97c4b561c649402a169426a52c;
static PyCodeObject *codeobj_493a1bcafa53978c92f68edb9700afc8;
static PyCodeObject *codeobj_c53dfbe39dd3a6e1884caed588a6e018;
static PyCodeObject *codeobj_5989077b2bed5d70168fdd512d1c6b58;
static PyCodeObject *codeobj_611a6e46dc9df08fc7bf62dc91c5fc9f;
static PyCodeObject *codeobj_65948314dd15ad5fa1518d4867d6d673;
static PyCodeObject *codeobj_c01b4cc490155bdf7d76523f4d2063da;
static PyCodeObject *codeobj_d9729a6df5eb5a5b7ae31f23e87064b3;
static PyCodeObject *codeobj_fcd1cb2a719ec8e30788d0fa79a3b2c6;
static PyCodeObject *codeobj_46e9c6ffef111ec7276e47293446caf3;
static PyCodeObject *codeobj_10e6028ad198a440f60e91ee9df066ba;
static PyCodeObject *codeobj_c11ea474ffae6c6476256a2a70014948;
static PyCodeObject *codeobj_5d5df9b0a86031ac8bf61af23f959ddb;
static PyCodeObject *codeobj_f0e649407f94da0d732748f63e73614d;
static PyCodeObject *codeobj_946ab5af3c25362849801c2db8c2098f;
static PyCodeObject *codeobj_87ceeefa37b5b79d65a252ac8de9f62d;
static PyCodeObject *codeobj_3c97804e638eb41eb1fba6e47726f3bb;
static PyCodeObject *codeobj_aa9ed37f4d2da439684924b28158708d;
static PyCodeObject *codeobj_d56f0c18f6036936cda6e2235379c39a;
static PyCodeObject *codeobj_363b9dadd23cca41333766adec78f9ef;
static PyCodeObject *codeobj_98b78ce301e50c61555c5e7b2c6faa12;
static PyCodeObject *codeobj_5d84c23d22e2c284d1e911e1df415815;
static PyCodeObject *codeobj_0104bb1a834c0db99dc949612ee9e530;
static PyCodeObject *codeobj_2ce30ad51f869b601f01107834b055c1;
static PyCodeObject *codeobj_96d5c0615e56d061f1a75be0898d3893;
static PyCodeObject *codeobj_be712631c87fcbe3bc2bb6dcb0fd15ab;
static PyCodeObject *codeobj_f4cab256fd83a2e1d0fcdc2f34349723;
static PyCodeObject *codeobj_6bbdfb85b0c1bb816d1a814b3fcd7b62;
static PyCodeObject *codeobj_2389c2d402cbef9638c4531890382b4c;
static PyCodeObject *codeobj_7e3e5722d1e42f7d6ddb1bbecd61c01f;
static PyCodeObject *codeobj_43344189d34fada79b0c4b1db6aa313e;
static PyCodeObject *codeobj_6b8832c71060328b0d13cb2fbbebfc80;
static PyCodeObject *codeobj_793293dba737101c30c17c8b35d070dc;
static PyCodeObject *codeobj_30fec37bac69a968b531d72f50d1eab0;
static PyCodeObject *codeobj_101279b401d05ad5c4ab4058c37f2e3a;
static PyCodeObject *codeobj_d46550f1626ed88f6f7e24f94e3481b3;
static PyCodeObject *codeobj_6aa072799d86fee962e5df98aa577a0b;
static PyCodeObject *codeobj_95ffa881c992b41a09b640bdd993138a;
static PyCodeObject *codeobj_d3162c8595b383cfcf9beeb61084282b;
static PyCodeObject *codeobj_7ad6e7a72b48702f9e5b43452fda84eb;
static PyCodeObject *codeobj_9eb6ed3effa667fc4260fde143db8cce;
static PyCodeObject *codeobj_72b4cacabb8769a6ac882f9fe6ea574e;
static PyCodeObject *codeobj_3d28736148c648faaf499826a4bcee28;
static PyCodeObject *codeobj_c84480da8086d95f36164f584c21f6ab;
static PyCodeObject *codeobj_b70a4906c97184e98518c95aaa529398;
static PyCodeObject *codeobj_5548f114506669f9d9e933fd7df4510b;
static PyCodeObject *codeobj_3d5f44d2cf135a3c60072595cf5a7ac9;
static PyCodeObject *codeobj_c77abc76f4a0bef790a7c7a765758c82;
static PyCodeObject *codeobj_f35b594533211a40312bed4190bf81a5;
static PyCodeObject *codeobj_b0fc2c065017043970346a6bbad759bf;
static PyCodeObject *codeobj_9ba465c2f63a8015bb1bc81e3ff20eff;
static PyCodeObject *codeobj_a083b7678dd71fa50eecfbe77aeba7fd;
static PyCodeObject *codeobj_9cbfa9cd9bf3ad290e3f71543c5dfd6a;
static PyCodeObject *codeobj_2f58cf123329779cc61cb72a584cda0b;
static PyCodeObject *codeobj_68bc07cc376f7fe11e6f7be1682a6dbb;
static PyCodeObject *codeobj_05c0c723a3dc2a65077e569ed007a15a;

static void createModuleCodeObjects(void)
{
    module_filename_obj = const_str_digest_74605c90f126dd9a5280fd0d6380988e;
    codeobj_6ab36e15dbfb5ac3c50a9a40b572a61e = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 458, const_tuple_15847381bc67e44c74cc6010c7c7f848_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0c917b25026b6e4ab770ad078decf301 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 479, const_tuple_15847381bc67e44c74cc6010c7c7f848_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f82a295a662e8886705acead8db7eae2 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 607, const_tuple_2db4dbe516092df2db3de6cea5c71cab_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_feea27494a1468bad8c92211b86b996d = MAKE_CODEOBJ( module_filename_obj, const_str_angle_genexpr, 620, const_tuple_fda68d37af88e7baff5600e0e16cd565_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e5c9f68c83b74cb2baea83eeeaa3cdfd = MAKE_CODEOBJ( module_filename_obj, const_str_digest_38aa4d1e4b90e4783d9d90e8dfcb74d9, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_f1bdb48699f20645f690a022d5e2c172 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CharsetMetaAttributeValue, 60, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_203f19c7266c2e913c49a142834bbcfc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_ContentMetaAttributeValue, 76, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_873a41d8549c3eae2ceb236f16fe8da3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Doctype, 796, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_88c1f00bd461942e207810ba94d1fa55 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_HTMLAwareEntitySubstitution, 102, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_dfd0b236e1e38e11663e9e5414aa850a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_NamespacedAttribute, 42, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_3877e7ba57fb85f72eb8eaa734d3dbe4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_NavigableString, 699, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_9d17cb8081dcccefd359db453c9db698 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_PageElement, 174, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_9d2b28a2d5efc66db477b9157d5d71f4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Tag, 814, const_tuple_empty, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_14c9ca35b08857b494d3b34d6a24c792 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___call__, 1042, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_d06555feeb0f99a8946ae79358eebe14 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___contains__, 1026, const_tuple_str_plain_self_str_plain_x_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_36b2c8d556861624aae77de0a07304d0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___copy__, 724, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_28dae34448982e5cb647814084cb47ed = MAKE_CODEOBJ( module_filename_obj, const_str_plain___copy__, 873, const_tuple_e852ed76cabcde48e8c638757ba9055c_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_18dce61cea9fc7c55052b8072b93f4ef = MAKE_CODEOBJ( module_filename_obj, const_str_plain___delitem__, 1038, const_tuple_str_plain_self_str_plain_key_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0f121366c6314e05c4e94b4ba4f281db = MAKE_CODEOBJ( module_filename_obj, const_str_plain___eq__, 1065, const_tuple_5d973f0bbc887f462db71b319acd6172_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fc41c2ad8dbe85f71981b8bba617eec6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getattr__, 733, const_tuple_str_plain_self_str_plain_attr_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b69ca57a2878fd3ed8c2fa69b9943835 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getattr__, 1048, const_tuple_str_plain_self_str_plain_tag_str_plain_tag_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4e556ab3367f8156c1378d33dcbc493b = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getattr__, 1618, const_tuple_str_plain_self_str_plain_key_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d67dc5583d9735364a2e7eb7aa2f4f9f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getitem__, 1013, const_tuple_str_plain_self_str_plain_key_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c07331a2a0ef212bddc2df31da1b3830 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___getnewargs__, 730, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1d647466fb145e14671911abb2f457d6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___hash__, 1010, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5258e8cca0a1d712e5493a4091af0ee6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 818, const_tuple_f5b82b9541ca43f4cb37e5415f1808d7_tuple, 10, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0659d3a8834673b2723e32a986aab130 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1398, const_tuple_63ad449372e43e2b9b45ac599f588b60_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_6260960175210d1d930251866ab9fdd7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1614, const_tuple_str_plain_self_str_plain_source_str_plain_result_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f8ede56649c9acbcf3e4d1611cbd7bf1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___iter__, 1018, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_df689961d1889b2bc63517aeff723192 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___len__, 1022, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_47e271e4323d4ffe193e3efd217220e8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___ne__, 1082, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_840dfde127c7948681f68bac0997b15f = MAKE_CODEOBJ( module_filename_obj, const_str_plain___new__, 44, const_tuple_eee4bda2a1ff56b33f0ca94cb124c1fc_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d20cd7ff19281f391bdb48bbc6615087 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___new__, 67, const_tuple_str_plain_cls_str_plain_original_value_str_plain_obj_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_50849ac5284d4f3ccb4a11f07fe777db = MAKE_CODEOBJ( module_filename_obj, const_str_plain___new__, 87, const_tuple_6fabcf46d88fc62d9aaf37d94ef18c6e_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b85adaa470e25a69858dfde85e7c078a = MAKE_CODEOBJ( module_filename_obj, const_str_plain___new__, 709, const_tuple_str_plain_cls_str_plain_value_str_plain_u_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_876387fdd220214a20731241696fa347 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___nonzero__, 1029, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7ae4d0ab18c86a7b052b0c944ba8bd65 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 1087, const_tuple_str_plain_self_str_plain_encoding_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e799db36c7ac958aeacbc8d3fbdfd7c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___setitem__, 1033, const_tuple_str_plain_self_str_plain_key_str_plain_value_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_099aaa80f69d337732d9b444d82bacd1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 1101, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_285a3a357c7e6df9e65ab69b915876e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 1455, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9c1c3b549a0cf791cb178533927bbf79 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___unicode__, 1098, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a5e2638464fefd2818be3fcd0d829caf = MAKE_CODEOBJ( module_filename_obj, const_str_plain__alias, 30, const_tuple_str_plain_attr_str_plain_alias_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_30b570e03eb3cc558516ab120ff84408 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__all_strings, 925, const_tuple_3da16538fbd197083cd091a6f193427d_tuple, 3, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_74e0b40b40a8bd05233067bcf4acb342 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__find_all, 592, const_tuple_363409a0fe91e7050b75e5ada05535f6_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_d650e4d8a3ab64c145624f43bf0229a6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__find_one, 585, const_tuple_d5b07772a2b24fb83d9d7a8a2e093299_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_2c3ff2cae6e04e9ec244d1a23dd1cba7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__formatter_for_name, 251, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_76183d666b6fe52239c562ee299269f3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__is_xml, 227, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0d9096af853ae8895db328ea28d3cd9a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__last_descendant, 351, const_tuple_3b64fb04a63013587f4e717b6d88d2c3_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f876307bed7434c370747ea48135869 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__matches, 1528, const_tuple_e2339b69ddbb55c50d9acbcf590a4fea_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_20cb79926d5c997e0fc30883874ed8c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__normalize_search_value, 1425, const_tuple_e78b94ed7a6cf112858126b31788598d_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2cb78b1700e9c5a78e9a9931b71ffd39 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__should_pretty_print, 1118, const_tuple_str_plain_self_str_plain_indent_level_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7a87a787dc98c0e8040744cc9c67fa9c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__substitute_if_appropriate, 119, const_tuple_str_plain_cls_str_plain_ns_str_plain_f_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_55a270db2583d977babd95a54894be1a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_alias, 32, const_tuple_str_plain_self_str_plain_attr_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_d7959c1f6a1efaa5a744b36b9cfd8c7b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_alias, 36, const_tuple_str_plain_self_str_plain_attr_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_fc15a6c52943040a99d66eb74afa26d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_append, 439, const_tuple_str_plain_self_str_plain_tag_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a0696e67cb1c97143c8c36692ffcc165 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_childGenerator, 1379, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6ffb6f921d156ce8415ba690c7511991 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_children, 1326, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7707ae06690f1d6d8642fa5203e1fb8c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_clear, 970, const_tuple_str_plain_self_str_plain_decompose_str_plain_element_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7e5ea0a96abd38fc63210a5d0436fdc4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_decode, 1126, const_tuple_7863bf506c9685283d823cc9f4d854f6_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f80e94e61a5498e34db5e8bf04849743 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_decode_contents, 1226, const_tuple_6dc0b67a5f9357e64ecf1fa69810a44c_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_43f0e352fcabe0b721afedeac0d47b0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_decompose, 960, const_tuple_str_plain_self_str_plain_i_str_plain_next_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e2f97cb35361b509cf888ea2dba587ae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_descendants, 1331, const_tuple_str_plain_self_str_plain_current_str_plain_stopNode_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c0b19e80631658ec74bb3e25429fd67f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_encode, 72, const_tuple_str_plain_self_str_plain_encoding_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4cbc0d50c319b71db955e0ed001178e7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_encode, 97, const_tuple_str_plain_self_str_plain_encoding_str_plain_rewrite_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8135d7ca17005947bac227662c113913 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_encode, 1110, const_tuple_228af158dcd68f83b463bc2269dd782f_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ef22ab60bd4c83e9125fddfcee10b1a1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_encode_contents, 1268, const_tuple_10d2142d95e2a4c8e5148840f9fc6abb_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_783bb656bd248096fe5dff1b6735d020 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_extend, 443, const_tuple_str_plain_self_str_plain_tags_str_plain_tag_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c703ca9bc738259b4324f501b5ecee93 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_extract, 322, const_tuple_str_plain_self_str_plain_last_child_str_plain_next_element_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6df50eb59cc2c378df6c21e1c696f6a0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find, 1295, const_tuple_78be8a3ae4374cac4916ac458cac3534_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_984ee2fe2ba0922e4dd2853b23c0064e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_all, 1306, const_tuple_65604e2dc480b192d22d38f58a38ee21_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_eda20f939454e2c4a84abc8a549d6b2c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_all_next, 498, const_tuple_3a1a822c776686c398d8079a14774929_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_ebc3dc41d3b05d7a4f045cf17e6248c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_all_previous, 529, const_tuple_3a1a822c776686c398d8079a14774929_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_9bd7632ac089adc376ecbbcb2f6dc690 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_next, 492, const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_c58eed4264ebc40dcacae7730d18dcc1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_next_sibling, 506, const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_8498af97c4b561c649402a169426a52c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_next_siblings, 513, const_tuple_3a1a822c776686c398d8079a14774929_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_493a1bcafa53978c92f68edb9700afc8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_parent, 554, const_tuple_5dc4a75e49d6c8094ee2f41ff858d310_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_c53dfbe39dd3a6e1884caed588a6e018 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_parents, 566, const_tuple_320cbb4df0ff07646e62c91f2eed2f25_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_5989077b2bed5d70168fdd512d1c6b58 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_previous, 522, const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_611a6e46dc9df08fc7bf62dc91c5fc9f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_previous_sibling, 538, const_tuple_46b86a7582592112004d3e48fcc1ce1f_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_65948314dd15ad5fa1518d4867d6d673 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_find_previous_siblings, 545, const_tuple_3a1a822c776686c398d8079a14774929_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_c01b4cc490155bdf7d76523f4d2063da = MAKE_CODEOBJ( module_filename_obj, const_str_plain_for_name_and_ids, 798, const_tuple_58568bf8b42125104a536219253716ea_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d9729a6df5eb5a5b7ae31f23e87064b3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_format_string, 213, const_tuple_272dbd16728ffeefb84651713f277746_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fcd1cb2a719ec8e30788d0fa79a3b2c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get, 994, const_tuple_str_plain_self_str_plain_key_str_plain_default_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_46e9c6ffef111ec7276e47293446caf3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_attribute_list, 1000, const_tuple_2e13f6f79f96adf3ed42b174b19b3d28_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_10e6028ad198a440f60e91ee9df066ba = MAKE_CODEOBJ( module_filename_obj, const_str_plain_get_text, 950, const_tuple_d45c60811e98eaafb444e77942903dcf_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c11ea474ffae6c6476256a2a70014948 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_has_attr, 1007, const_tuple_str_plain_self_str_plain_key_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5d5df9b0a86031ac8bf61af23f959ddb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_has_key, 1385, const_tuple_str_plain_self_str_plain_key_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f0e649407f94da0d732748f63e73614d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_index, 984, const_tuple_str_plain_self_str_plain_element_str_plain_i_str_plain_child_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_946ab5af3c25362849801c2db8c2098f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_insert, 365, const_tuple_e3e4f22c792bc199d5c0bf326aa2e166_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_87ceeefa37b5b79d65a252ac8de9f62d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_insert_after, 468, const_tuple_9da16f245f216ceceb04626a12f0f29f_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_3c97804e638eb41eb1fba6e47726f3bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_insert_before, 448, const_tuple_68b05a5f3133e2a2e9f0895b61310f41_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_aa9ed37f4d2da439684924b28158708d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_is_empty_element, 885, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d56f0c18f6036936cda6e2235379c39a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_name, 748, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_363b9dadd23cca41333766adec78f9ef = MAKE_CODEOBJ( module_filename_obj, const_str_plain_name, 752, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_98b78ce301e50c61555c5e7b2c6faa12 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_next, 575, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5d84c23d22e2c284d1e911e1df415815 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_nextGenerator, 683, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0104bb1a834c0db99dc949612ee9e530 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_nextSiblingGenerator, 686, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2ce30ad51f869b601f01107834b055c1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_next_elements, 646, const_tuple_str_plain_self_str_plain_i_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_96d5c0615e56d061f1a75be0898d3893 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_next_siblings, 653, const_tuple_str_plain_self_str_plain_i_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_be712631c87fcbe3bc2bb6dcb0fd15ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_output_ready, 744, const_tuple_str_plain_self_str_plain_formatter_str_plain_output_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f4cab256fd83a2e1d0fcdc2f34349723 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_output_ready, 763, const_tuple_str_plain_self_str_plain_formatter_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6bbdfb85b0c1bb816d1a814b3fcd7b62 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_parentGenerator, 695, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2389c2d402cbef9638c4531890382b4c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_parents, 674, const_tuple_str_plain_self_str_plain_i_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7e3e5722d1e42f7d6ddb1bbecd61c01f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_prettify, 1220, const_tuple_str_plain_self_str_plain_encoding_str_plain_formatter_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_43344189d34fada79b0c4b1db6aa313e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_previous, 579, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6b8832c71060328b0d13cb2fbbebfc80 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_previousGenerator, 689, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_793293dba737101c30c17c8b35d070dc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_previousSiblingGenerator, 692, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_30fec37bac69a968b531d72f50d1eab0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_previous_elements, 660, const_tuple_str_plain_self_str_plain_i_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_101279b401d05ad5c4ab4058c37f2e3a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_previous_siblings, 667, const_tuple_str_plain_self_str_plain_i_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d46550f1626ed88f6f7e24f94e3481b3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_recursiveChildGenerator, 1382, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6aa072799d86fee962e5df98aa577a0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_renderContents, 1286, const_tuple_d0434168675df957da575746d9fec873_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_95ffa881c992b41a09b640bdd993138a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_replace_with, 287, const_tuple_c8ced635d07e13a82f7bd15383636794_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d3162c8595b383cfcf9beeb61084282b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_rewrite, 98, const_tuple_str_plain_match_str_plain_encoding_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_7ad6e7a72b48702f9e5b43452fda84eb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_search, 1502, const_tuple_ffd90e373011fadf040497abe3c9ca62_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9eb6ed3effa667fc4260fde143db8cce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_search_tag, 1461, const_tuple_3f2f60be320b3b5027a1ca99d3d9f397_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_72b4cacabb8769a6ac882f9fe6ea574e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_select, 1349, const_tuple_c4047b4cb3d0709adb19086551ddcc3b_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_3d28736148c648faaf499826a4bcee28 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_select_one, 1342, const_tuple_beecdf0bc8474726ab234a4e88e54f57_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_c84480da8086d95f36164f584c21f6ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setup, 258, const_tuple_c0ce3b782b25edd0417c8e92b23a545f_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b70a4906c97184e98518c95aaa529398 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_string, 903, const_tuple_str_plain_self_str_plain_child_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5548f114506669f9d9e933fd7df4510b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_string, 920, const_tuple_str_plain_self_str_plain_string_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3d5f44d2cf135a3c60072595cf5a7ac9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_stripped_strings, 945, const_tuple_str_plain_self_str_plain_string_tuple, 1, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c77abc76f4a0bef790a7c7a765758c82 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_substitute, 151, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_f35b594533211a40312bed4190bf81a5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_substitute, 156, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_b0fc2c065017043970346a6bbad759bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_substitute, 165, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_9ba465c2f63a8015bb1bc81e3ff20eff = MAKE_CODEOBJ( module_filename_obj, const_str_plain_substitute, 170, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_a083b7678dd71fa50eecfbe77aeba7fd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_substitute_entities, 145, const_tuple_str_plain_self_str_plain_args_str_plain_kwargs_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_9cbfa9cd9bf3ad290e3f71543c5dfd6a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_substitute_html, 129, const_tuple_str_plain_cls_str_plain_ns_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f58cf123329779cc61cb72a584cda0b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_substitute_xml, 134, const_tuple_str_plain_cls_str_plain_ns_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_68bc07cc376f7fe11e6f7be1682a6dbb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_unwrap, 303, const_tuple_bfb3dc918e2c3822cf026cb5a5888d9d_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_05c0c723a3dc2a65077e569ed007a15a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_wrap, 317, const_tuple_str_plain_self_str_plain_wrap_inside_str_plain_me_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
static PyObject *bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_maker( void );


static PyObject *bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_maker( void );


static PyObject *bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_maker( void );


static PyObject *bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_maker( void );


static PyObject *bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_maker( void );


static PyObject *bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_maker( void );


static PyObject *bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_maker( void );


static PyObject *bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_maker( void );


static PyObject *bs4$element$$$function_47_parents$$$genobj_1_parents_maker( void );


static PyObject *bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_maker( void );


static PyObject *bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_maker( void );


static PyObject *bs4$element$$$function_101_descendants$$$genobj_1_descendants_maker( void );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_4_complex_call_helper_pos_star_dict( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_100_children(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_101_descendants(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_102_select_one( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_103_select( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_104_childGenerator(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_105_recursiveChildGenerator(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_106_has_key(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_107___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_108__normalize_search_value(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_109___str__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_10_substitute_entities(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_110_search_tag( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_111_search(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_112__matches( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_113___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_114___getattr__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_11_substitute(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_12_substitute(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_13_substitute(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_14_substitute(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_15_format_string( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_16__is_xml(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_17__formatter_for_name(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_18_setup( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_19_replace_with(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_1__alias(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_1__alias$$$function_1_alias(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_1__alias$$$function_2_alias(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_20_unwrap(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_21_wrap(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_22_extract(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_23__last_descendant( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_24_insert(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_25_append(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_26_extend(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_27_insert_before(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_28_insert_after(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_29_find_next( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_2___new__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_30_find_all_next( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_31_find_next_sibling( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_32_find_next_siblings( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_33_find_previous( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_34_find_all_previous( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_35_find_previous_sibling( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_36_find_previous_siblings( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_37_find_parent( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_38_find_parents( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_39_next(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_3___new__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_40_previous(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_41__find_one(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_42__find_all(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_43_next_elements(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_44_next_siblings(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_45_previous_elements(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_46_previous_siblings(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_47_parents(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_48_nextGenerator(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_49_nextSiblingGenerator(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_4_encode(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_50_previousGenerator(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_51_previousSiblingGenerator(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_52_parentGenerator(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_53___new__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_54___copy__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_55___getnewargs__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_56___getattr__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_57_output_ready( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_58_name(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_59_name(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_5___new__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_60_output_ready( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_61_for_name_and_ids(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_62___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_63___copy__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_64_is_empty_element(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_65_string(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_66_string(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_67__all_strings( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_68_stripped_strings(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_69_get_text( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_6_encode(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_6_encode$$$function_1_rewrite(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_70_decompose(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_71_clear( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_72_index(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_73_get( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_74_get_attribute_list( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_75_has_attr(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_76___hash__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_77___getitem__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_78___iter__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_79___len__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_7__substitute_if_appropriate(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_80___contains__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_81___nonzero__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_82___setitem__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_83___delitem__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_84___call__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_85___getattr__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_86___eq__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_87___ne__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_88___repr__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_89___unicode__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_8_substitute_html(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_90___str__(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_91_encode( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_92__should_pretty_print(  );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_93_decode( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_94_prettify( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_95_decode_contents( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_96_encode_contents( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_97_renderContents( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_98_find( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_99_find_all( PyObject *defaults );


static PyObject *MAKE_FUNCTION_bs4$element$$$function_9_substitute_xml(  );


// The module function definitions.
static PyObject *impl_bs4$element$$$function_1__alias( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_attr = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_alias = NULL;
    struct Nuitka_FrameObject *frame_a5e2638464fefd2818be3fcd0d829caf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a5e2638464fefd2818be3fcd0d829caf = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a5e2638464fefd2818be3fcd0d829caf, codeobj_a5e2638464fefd2818be3fcd0d829caf, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_a5e2638464fefd2818be3fcd0d829caf = cache_frame_a5e2638464fefd2818be3fcd0d829caf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a5e2638464fefd2818be3fcd0d829caf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a5e2638464fefd2818be3fcd0d829caf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_called_name_1 = (PyObject *)&PyProperty_Type;
        tmp_args_element_name_1 = MAKE_FUNCTION_bs4$element$$$function_1__alias$$$function_1_alias(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_1)->m_closure[0] = par_attr;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_1)->m_closure[0] );


        frame_a5e2638464fefd2818be3fcd0d829caf->m_frame.f_lineno = 32;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 32;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( var_alias == NULL );
        var_alias = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_alias );
        tmp_called_instance_1 = var_alias;
        tmp_args_element_name_2 = MAKE_FUNCTION_bs4$element$$$function_1__alias$$$function_2_alias(  );

        ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] = par_attr;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_args_element_name_2)->m_closure[0] );


        frame_a5e2638464fefd2818be3fcd0d829caf->m_frame.f_lineno = 36;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_setter, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 36;
            type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_alias;
            assert( old != NULL );
            var_alias = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5e2638464fefd2818be3fcd0d829caf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a5e2638464fefd2818be3fcd0d829caf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a5e2638464fefd2818be3fcd0d829caf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a5e2638464fefd2818be3fcd0d829caf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a5e2638464fefd2818be3fcd0d829caf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a5e2638464fefd2818be3fcd0d829caf,
        type_description_1,
        par_attr,
        var_alias
    );


    // Release cached frame.
    if ( frame_a5e2638464fefd2818be3fcd0d829caf == cache_frame_a5e2638464fefd2818be3fcd0d829caf )
    {
        Py_DECREF( frame_a5e2638464fefd2818be3fcd0d829caf );
    }
    cache_frame_a5e2638464fefd2818be3fcd0d829caf = NULL;

    assertFrameObject( frame_a5e2638464fefd2818be3fcd0d829caf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_alias );
    tmp_return_value = var_alias;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_1__alias );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_alias );
    Py_DECREF( var_alias );
    var_alias = NULL;

    CHECK_OBJECT( (PyObject *)par_attr );
    Py_DECREF( par_attr );
    par_attr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_alias );
    var_alias = NULL;

    CHECK_OBJECT( (PyObject *)par_attr );
    Py_DECREF( par_attr );
    par_attr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_1__alias );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_1__alias$$$function_1_alias( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_55a270db2583d977babd95a54894be1a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_55a270db2583d977babd95a54894be1a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_55a270db2583d977babd95a54894be1a, codeobj_55a270db2583d977babd95a54894be1a, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_55a270db2583d977babd95a54894be1a = cache_frame_55a270db2583d977babd95a54894be1a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_55a270db2583d977babd95a54894be1a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_55a270db2583d977babd95a54894be1a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_getattr_attr_1;
        CHECK_OBJECT( par_self );
        tmp_getattr_target_1 = par_self;
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "attr" );
            exception_tb = NULL;

            exception_lineno = 34;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_getattr_attr_1 = PyCell_GET( self->m_closure[0] );
        tmp_return_value = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 34;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55a270db2583d977babd95a54894be1a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_55a270db2583d977babd95a54894be1a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55a270db2583d977babd95a54894be1a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_55a270db2583d977babd95a54894be1a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_55a270db2583d977babd95a54894be1a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_55a270db2583d977babd95a54894be1a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_55a270db2583d977babd95a54894be1a,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_55a270db2583d977babd95a54894be1a == cache_frame_55a270db2583d977babd95a54894be1a )
    {
        Py_DECREF( frame_55a270db2583d977babd95a54894be1a );
    }
    cache_frame_55a270db2583d977babd95a54894be1a = NULL;

    assertFrameObject( frame_55a270db2583d977babd95a54894be1a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_1__alias$$$function_1_alias );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_1__alias$$$function_1_alias );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_1__alias$$$function_2_alias( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d7959c1f6a1efaa5a744b36b9cfd8c7b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d7959c1f6a1efaa5a744b36b9cfd8c7b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d7959c1f6a1efaa5a744b36b9cfd8c7b, codeobj_d7959c1f6a1efaa5a744b36b9cfd8c7b, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_d7959c1f6a1efaa5a744b36b9cfd8c7b = cache_frame_d7959c1f6a1efaa5a744b36b9cfd8c7b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b ) == 2 ); // Frame stack

    // Framed code:
    if ( PyCell_GET( self->m_closure[0] ) == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "attr" );
        exception_tb = NULL;

        exception_lineno = 38;
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }

    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_raise_value_1;
        tmp_raise_type_1 = PyExc_TypeError;
        tmp_raise_value_1 = const_str_digest_9e3fe7ba8804c2b496a30c099deb767f;
        exception_type = tmp_raise_type_1;
        Py_INCREF( tmp_raise_type_1 );
        exception_value = tmp_raise_value_1;
        Py_INCREF( tmp_raise_value_1 );
        exception_lineno = 38;
        RAISE_EXCEPTION_IMPLICIT( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oc";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d7959c1f6a1efaa5a744b36b9cfd8c7b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d7959c1f6a1efaa5a744b36b9cfd8c7b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d7959c1f6a1efaa5a744b36b9cfd8c7b,
        type_description_1,
        par_self,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b == cache_frame_d7959c1f6a1efaa5a744b36b9cfd8c7b )
    {
        Py_DECREF( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b );
    }
    cache_frame_d7959c1f6a1efaa5a744b36b9cfd8c7b = NULL;

    assertFrameObject( frame_d7959c1f6a1efaa5a744b36b9cfd8c7b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_1__alias$$$function_2_alias );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_1__alias$$$function_2_alias );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_bs4$element$$$function_2___new__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_prefix = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *par_namespace = python_pars[ 3 ];
    PyObject *var_obj = NULL;
    struct Nuitka_FrameObject *frame_840dfde127c7948681f68bac0997b15f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_840dfde127c7948681f68bac0997b15f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_840dfde127c7948681f68bac0997b15f, codeobj_840dfde127c7948681f68bac0997b15f, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_840dfde127c7948681f68bac0997b15f = cache_frame_840dfde127c7948681f68bac0997b15f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_840dfde127c7948681f68bac0997b15f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_840dfde127c7948681f68bac0997b15f ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_name );
        tmp_compexpr_left_1 = par_name;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_called_instance_1 = (PyObject *)&PyUnicode_Type;
            CHECK_OBJECT( par_cls );
            tmp_args_element_name_1 = par_cls;
            CHECK_OBJECT( par_prefix );
            tmp_args_element_name_2 = par_prefix;
            frame_840dfde127c7948681f68bac0997b15f->m_frame.f_lineno = 46;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___new__, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 46;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            assert( var_obj == NULL );
            var_obj = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_prefix );
            tmp_compexpr_left_2 = par_prefix;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_args_element_name_4;
                tmp_called_instance_2 = (PyObject *)&PyUnicode_Type;
                CHECK_OBJECT( par_cls );
                tmp_args_element_name_3 = par_cls;
                CHECK_OBJECT( par_name );
                tmp_args_element_name_4 = par_name;
                frame_840dfde127c7948681f68bac0997b15f->m_frame.f_lineno = 49;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain___new__, call_args );
                }

                if ( tmp_assign_source_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 49;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_obj == NULL );
                var_obj = tmp_assign_source_2;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_1;
                PyObject *tmp_source_name_1;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_args_element_name_6;
                PyObject *tmp_left_name_1;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_1;
                PyObject *tmp_right_name_2;
                tmp_source_name_1 = (PyObject *)&PyUnicode_Type;
                tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
                assert( !(tmp_called_name_1 == NULL) );
                CHECK_OBJECT( par_cls );
                tmp_args_element_name_5 = par_cls;
                CHECK_OBJECT( par_prefix );
                tmp_left_name_2 = par_prefix;
                tmp_right_name_1 = const_str_chr_58;
                tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_STR( tmp_left_name_2, tmp_right_name_1 );
                if ( tmp_left_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );

                    exception_lineno = 51;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_name );
                tmp_right_name_2 = par_name;
                tmp_args_element_name_6 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
                Py_DECREF( tmp_left_name_1 );
                if ( tmp_args_element_name_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );

                    exception_lineno = 51;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                frame_840dfde127c7948681f68bac0997b15f->m_frame.f_lineno = 51;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_args_element_name_6 );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 51;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_obj == NULL );
                var_obj = tmp_assign_source_3;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_prefix );
        tmp_assattr_name_1 = par_prefix;
        if ( var_obj == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
            exception_tb = NULL;

            exception_lineno = 52;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_assattr_target_1 = var_obj;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_prefix, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 52;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_name );
        tmp_assattr_name_2 = par_name;
        if ( var_obj == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
            exception_tb = NULL;

            exception_lineno = 53;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_assattr_target_2 = var_obj;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_name, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 53;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_namespace );
        tmp_assattr_name_3 = par_namespace;
        if ( var_obj == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
            exception_tb = NULL;

            exception_lineno = 54;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_assattr_target_3 = var_obj;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_namespace, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 54;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
    }
    if ( var_obj == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "obj" );
        exception_tb = NULL;

        exception_lineno = 55;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_obj;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_840dfde127c7948681f68bac0997b15f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_840dfde127c7948681f68bac0997b15f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_840dfde127c7948681f68bac0997b15f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_840dfde127c7948681f68bac0997b15f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_840dfde127c7948681f68bac0997b15f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_840dfde127c7948681f68bac0997b15f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_840dfde127c7948681f68bac0997b15f,
        type_description_1,
        par_cls,
        par_prefix,
        par_name,
        par_namespace,
        var_obj
    );


    // Release cached frame.
    if ( frame_840dfde127c7948681f68bac0997b15f == cache_frame_840dfde127c7948681f68bac0997b15f )
    {
        Py_DECREF( frame_840dfde127c7948681f68bac0997b15f );
    }
    cache_frame_840dfde127c7948681f68bac0997b15f = NULL;

    assertFrameObject( frame_840dfde127c7948681f68bac0997b15f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_2___new__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_prefix );
    Py_DECREF( par_prefix );
    par_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_namespace );
    Py_DECREF( par_namespace );
    par_namespace = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_prefix );
    Py_DECREF( par_prefix );
    par_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_namespace );
    Py_DECREF( par_namespace );
    par_namespace = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_2___new__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_3___new__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_original_value = python_pars[ 1 ];
    PyObject *var_obj = NULL;
    struct Nuitka_FrameObject *frame_d20cd7ff19281f391bdb48bbc6615087;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_d20cd7ff19281f391bdb48bbc6615087 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d20cd7ff19281f391bdb48bbc6615087, codeobj_d20cd7ff19281f391bdb48bbc6615087, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d20cd7ff19281f391bdb48bbc6615087 = cache_frame_d20cd7ff19281f391bdb48bbc6615087;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d20cd7ff19281f391bdb48bbc6615087 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d20cd7ff19281f391bdb48bbc6615087 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_called_instance_1 = (PyObject *)&PyUnicode_Type;
        CHECK_OBJECT( par_cls );
        tmp_args_element_name_1 = par_cls;
        CHECK_OBJECT( par_original_value );
        tmp_args_element_name_2 = par_original_value;
        frame_d20cd7ff19281f391bdb48bbc6615087->m_frame.f_lineno = 68;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___new__, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 68;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_obj == NULL );
        var_obj = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_original_value );
        tmp_assattr_name_1 = par_original_value;
        CHECK_OBJECT( var_obj );
        tmp_assattr_target_1 = var_obj;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_original_value, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 69;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d20cd7ff19281f391bdb48bbc6615087 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d20cd7ff19281f391bdb48bbc6615087 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d20cd7ff19281f391bdb48bbc6615087, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d20cd7ff19281f391bdb48bbc6615087->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d20cd7ff19281f391bdb48bbc6615087, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d20cd7ff19281f391bdb48bbc6615087,
        type_description_1,
        par_cls,
        par_original_value,
        var_obj
    );


    // Release cached frame.
    if ( frame_d20cd7ff19281f391bdb48bbc6615087 == cache_frame_d20cd7ff19281f391bdb48bbc6615087 )
    {
        Py_DECREF( frame_d20cd7ff19281f391bdb48bbc6615087 );
    }
    cache_frame_d20cd7ff19281f391bdb48bbc6615087 = NULL;

    assertFrameObject( frame_d20cd7ff19281f391bdb48bbc6615087 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_obj );
    tmp_return_value = var_obj;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_3___new__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_obj );
    Py_DECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_original_value );
    Py_DECREF( par_original_value );
    par_original_value = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_original_value );
    Py_DECREF( par_original_value );
    par_original_value = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_3___new__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_4_encode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_encoding = python_pars[ 1 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    CHECK_OBJECT( par_encoding );
    tmp_return_value = par_encoding;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_4_encode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_4_encode );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_5___new__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_original_value = python_pars[ 1 ];
    PyObject *var_obj = NULL;
    PyObject *var_match = NULL;
    struct Nuitka_FrameObject *frame_50849ac5284d4f3ccb4a11f07fe777db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_50849ac5284d4f3ccb4a11f07fe777db = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_50849ac5284d4f3ccb4a11f07fe777db, codeobj_50849ac5284d4f3ccb4a11f07fe777db, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_50849ac5284d4f3ccb4a11f07fe777db = cache_frame_50849ac5284d4f3ccb4a11f07fe777db;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_50849ac5284d4f3ccb4a11f07fe777db );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_50849ac5284d4f3ccb4a11f07fe777db ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_CHARSET_RE );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 88;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_original_value );
        tmp_args_element_name_1 = par_original_value;
        frame_50849ac5284d4f3ccb4a11f07fe777db->m_frame.f_lineno = 88;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_search, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 88;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_match == NULL );
        var_match = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_match );
        tmp_compexpr_left_1 = var_match;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            tmp_called_instance_2 = (PyObject *)&PyUnicode_Type;
            tmp_args_element_name_2 = (PyObject *)&PyUnicode_Type;
            CHECK_OBJECT( par_original_value );
            tmp_args_element_name_3 = par_original_value;
            frame_50849ac5284d4f3ccb4a11f07fe777db->m_frame.f_lineno = 91;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain___new__, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 91;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        tmp_called_instance_3 = (PyObject *)&PyUnicode_Type;
        CHECK_OBJECT( par_cls );
        tmp_args_element_name_4 = par_cls;
        CHECK_OBJECT( par_original_value );
        tmp_args_element_name_5 = par_original_value;
        frame_50849ac5284d4f3ccb4a11f07fe777db->m_frame.f_lineno = 93;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain___new__, call_args );
        }

        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 93;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_obj == NULL );
        var_obj = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_original_value );
        tmp_assattr_name_1 = par_original_value;
        CHECK_OBJECT( var_obj );
        tmp_assattr_target_1 = var_obj;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_original_value, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 94;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_50849ac5284d4f3ccb4a11f07fe777db );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_50849ac5284d4f3ccb4a11f07fe777db );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_50849ac5284d4f3ccb4a11f07fe777db );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_50849ac5284d4f3ccb4a11f07fe777db, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_50849ac5284d4f3ccb4a11f07fe777db->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_50849ac5284d4f3ccb4a11f07fe777db, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_50849ac5284d4f3ccb4a11f07fe777db,
        type_description_1,
        par_cls,
        par_original_value,
        var_obj,
        var_match
    );


    // Release cached frame.
    if ( frame_50849ac5284d4f3ccb4a11f07fe777db == cache_frame_50849ac5284d4f3ccb4a11f07fe777db )
    {
        Py_DECREF( frame_50849ac5284d4f3ccb4a11f07fe777db );
    }
    cache_frame_50849ac5284d4f3ccb4a11f07fe777db = NULL;

    assertFrameObject( frame_50849ac5284d4f3ccb4a11f07fe777db );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_obj );
    tmp_return_value = var_obj;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_5___new__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_original_value );
    Py_DECREF( par_original_value );
    par_original_value = NULL;

    CHECK_OBJECT( (PyObject *)var_match );
    Py_DECREF( var_match );
    var_match = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_original_value );
    Py_DECREF( par_original_value );
    par_original_value = NULL;

    Py_XDECREF( var_match );
    var_match = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_5___new__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_6_encode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_encoding = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *var_rewrite = NULL;
    struct Nuitka_FrameObject *frame_4cbc0d50c319b71db955e0ed001178e7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4cbc0d50c319b71db955e0ed001178e7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = MAKE_FUNCTION_bs4$element$$$function_6_encode$$$function_1_rewrite(  );

        ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] = par_encoding;
        Py_INCREF( ((struct Nuitka_FunctionObject *)tmp_assign_source_1)->m_closure[0] );


        assert( var_rewrite == NULL );
        var_rewrite = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4cbc0d50c319b71db955e0ed001178e7, codeobj_4cbc0d50c319b71db955e0ed001178e7, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_4cbc0d50c319b71db955e0ed001178e7 = cache_frame_4cbc0d50c319b71db955e0ed001178e7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4cbc0d50c319b71db955e0ed001178e7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4cbc0d50c319b71db955e0ed001178e7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_CHARSET_RE );
        if ( tmp_source_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sub );
        Py_DECREF( tmp_source_name_1 );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_rewrite );
        tmp_args_element_name_1 = var_rewrite;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_original_value );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 100;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        frame_4cbc0d50c319b71db955e0ed001178e7->m_frame.f_lineno = 100;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 100;
            type_description_1 = "oco";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4cbc0d50c319b71db955e0ed001178e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4cbc0d50c319b71db955e0ed001178e7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4cbc0d50c319b71db955e0ed001178e7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4cbc0d50c319b71db955e0ed001178e7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4cbc0d50c319b71db955e0ed001178e7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4cbc0d50c319b71db955e0ed001178e7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4cbc0d50c319b71db955e0ed001178e7,
        type_description_1,
        par_self,
        par_encoding,
        var_rewrite
    );


    // Release cached frame.
    if ( frame_4cbc0d50c319b71db955e0ed001178e7 == cache_frame_4cbc0d50c319b71db955e0ed001178e7 )
    {
        Py_DECREF( frame_4cbc0d50c319b71db955e0ed001178e7 );
    }
    cache_frame_4cbc0d50c319b71db955e0ed001178e7 = NULL;

    assertFrameObject( frame_4cbc0d50c319b71db955e0ed001178e7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_6_encode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_rewrite );
    Py_DECREF( var_rewrite );
    var_rewrite = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_rewrite );
    Py_DECREF( var_rewrite );
    var_rewrite = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_6_encode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_6_encode$$$function_1_rewrite( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_match = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d3162c8595b383cfcf9beeb61084282b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d3162c8595b383cfcf9beeb61084282b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d3162c8595b383cfcf9beeb61084282b, codeobj_d3162c8595b383cfcf9beeb61084282b, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_d3162c8595b383cfcf9beeb61084282b = cache_frame_d3162c8595b383cfcf9beeb61084282b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d3162c8595b383cfcf9beeb61084282b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d3162c8595b383cfcf9beeb61084282b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_match );
        tmp_called_instance_1 = par_match;
        frame_d3162c8595b383cfcf9beeb61084282b->m_frame.f_lineno = 99;
        tmp_left_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_group, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 99;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if ( PyCell_GET( self->m_closure[0] ) == NULL )
        {
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "encoding" );
            exception_tb = NULL;

            exception_lineno = 99;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_right_name_1 = PyCell_GET( self->m_closure[0] );
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 99;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d3162c8595b383cfcf9beeb61084282b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d3162c8595b383cfcf9beeb61084282b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d3162c8595b383cfcf9beeb61084282b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d3162c8595b383cfcf9beeb61084282b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d3162c8595b383cfcf9beeb61084282b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d3162c8595b383cfcf9beeb61084282b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d3162c8595b383cfcf9beeb61084282b,
        type_description_1,
        par_match,
        self->m_closure[0]
    );


    // Release cached frame.
    if ( frame_d3162c8595b383cfcf9beeb61084282b == cache_frame_d3162c8595b383cfcf9beeb61084282b )
    {
        Py_DECREF( frame_d3162c8595b383cfcf9beeb61084282b );
    }
    cache_frame_d3162c8595b383cfcf9beeb61084282b = NULL;

    assertFrameObject( frame_d3162c8595b383cfcf9beeb61084282b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_6_encode$$$function_1_rewrite );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_match );
    Py_DECREF( par_match );
    par_match = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_match );
    Py_DECREF( par_match );
    par_match = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_6_encode$$$function_1_rewrite );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_7__substitute_if_appropriate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ns = python_pars[ 1 ];
    PyObject *par_f = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_7a87a787dc98c0e8040744cc9c67fa9c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7a87a787dc98c0e8040744cc9c67fa9c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7a87a787dc98c0e8040744cc9c67fa9c, codeobj_7a87a787dc98c0e8040744cc9c67fa9c, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7a87a787dc98c0e8040744cc9c67fa9c = cache_frame_7a87a787dc98c0e8040744cc9c67fa9c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7a87a787dc98c0e8040744cc9c67fa9c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7a87a787dc98c0e8040744cc9c67fa9c ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_ns );
        tmp_isinstance_inst_1 = par_ns;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
            exception_tb = NULL;

            exception_lineno = 121;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 121;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_ns );
        tmp_source_name_1 = par_ns;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 122;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_2 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_ns );
        tmp_source_name_3 = par_ns;
        tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_parent );
        if ( tmp_source_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 123;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
        Py_DECREF( tmp_source_name_2 );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 123;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_cls );
        tmp_source_name_4 = par_cls;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_cdata_containing_tags );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 123;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_2, tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 123;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( par_ns );
        tmp_return_value = par_ns;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_f );
        tmp_called_name_1 = par_f;
        CHECK_OBJECT( par_ns );
        tmp_args_element_name_1 = par_ns;
        frame_7a87a787dc98c0e8040744cc9c67fa9c->m_frame.f_lineno = 127;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 127;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a87a787dc98c0e8040744cc9c67fa9c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a87a787dc98c0e8040744cc9c67fa9c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7a87a787dc98c0e8040744cc9c67fa9c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7a87a787dc98c0e8040744cc9c67fa9c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7a87a787dc98c0e8040744cc9c67fa9c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7a87a787dc98c0e8040744cc9c67fa9c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7a87a787dc98c0e8040744cc9c67fa9c,
        type_description_1,
        par_cls,
        par_ns,
        par_f
    );


    // Release cached frame.
    if ( frame_7a87a787dc98c0e8040744cc9c67fa9c == cache_frame_7a87a787dc98c0e8040744cc9c67fa9c )
    {
        Py_DECREF( frame_7a87a787dc98c0e8040744cc9c67fa9c );
    }
    cache_frame_7a87a787dc98c0e8040744cc9c67fa9c = NULL;

    assertFrameObject( frame_7a87a787dc98c0e8040744cc9c67fa9c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_7__substitute_if_appropriate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ns );
    Py_DECREF( par_ns );
    par_ns = NULL;

    CHECK_OBJECT( (PyObject *)par_f );
    Py_DECREF( par_f );
    par_f = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ns );
    Py_DECREF( par_ns );
    par_ns = NULL;

    CHECK_OBJECT( (PyObject *)par_f );
    Py_DECREF( par_f );
    par_f = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_7__substitute_if_appropriate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_8_substitute_html( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ns = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a, codeobj_9cbfa9cd9bf3ad290e3f71543c5dfd6a, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a = cache_frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__substitute_if_appropriate );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 131;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_ns );
        tmp_args_element_name_1 = par_ns;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "EntitySubstitution" );
            exception_tb = NULL;

            exception_lineno = 132;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_substitute_html );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 132;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a->m_frame.f_lineno = 131;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 131;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a,
        type_description_1,
        par_cls,
        par_ns
    );


    // Release cached frame.
    if ( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a == cache_frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a )
    {
        Py_DECREF( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a );
    }
    cache_frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a = NULL;

    assertFrameObject( frame_9cbfa9cd9bf3ad290e3f71543c5dfd6a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_8_substitute_html );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ns );
    Py_DECREF( par_ns );
    par_ns = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ns );
    Py_DECREF( par_ns );
    par_ns = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_8_substitute_html );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_9_substitute_xml( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_ns = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_2f58cf123329779cc61cb72a584cda0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2f58cf123329779cc61cb72a584cda0b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f58cf123329779cc61cb72a584cda0b, codeobj_2f58cf123329779cc61cb72a584cda0b, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_2f58cf123329779cc61cb72a584cda0b = cache_frame_2f58cf123329779cc61cb72a584cda0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f58cf123329779cc61cb72a584cda0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f58cf123329779cc61cb72a584cda0b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_cls );
        tmp_source_name_1 = par_cls;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__substitute_if_appropriate );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 136;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_ns );
        tmp_args_element_name_1 = par_ns;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );
        }

        if ( tmp_mvar_value_1 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "EntitySubstitution" );
            exception_tb = NULL;

            exception_lineno = 137;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_1;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_substitute_xml );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 137;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_2f58cf123329779cc61cb72a584cda0b->m_frame.f_lineno = 136;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 136;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f58cf123329779cc61cb72a584cda0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f58cf123329779cc61cb72a584cda0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f58cf123329779cc61cb72a584cda0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f58cf123329779cc61cb72a584cda0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f58cf123329779cc61cb72a584cda0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f58cf123329779cc61cb72a584cda0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f58cf123329779cc61cb72a584cda0b,
        type_description_1,
        par_cls,
        par_ns
    );


    // Release cached frame.
    if ( frame_2f58cf123329779cc61cb72a584cda0b == cache_frame_2f58cf123329779cc61cb72a584cda0b )
    {
        Py_DECREF( frame_2f58cf123329779cc61cb72a584cda0b );
    }
    cache_frame_2f58cf123329779cc61cb72a584cda0b = NULL;

    assertFrameObject( frame_2f58cf123329779cc61cb72a584cda0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_9_substitute_xml );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_ns );
    Py_DECREF( par_ns );
    par_ns = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_ns );
    Py_DECREF( par_ns );
    par_ns = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_9_substitute_xml );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_10_substitute_entities( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_a083b7678dd71fa50eecfbe77aeba7fd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a083b7678dd71fa50eecfbe77aeba7fd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a083b7678dd71fa50eecfbe77aeba7fd, codeobj_a083b7678dd71fa50eecfbe77aeba7fd, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_a083b7678dd71fa50eecfbe77aeba7fd = cache_frame_a083b7678dd71fa50eecfbe77aeba7fd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a083b7678dd71fa50eecfbe77aeba7fd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a083b7678dd71fa50eecfbe77aeba7fd ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        frame_a083b7678dd71fa50eecfbe77aeba7fd->m_frame.f_lineno = 147;
        tmp_raise_type_1 = CALL_FUNCTION_NO_ARGS( PyExc_NotImplementedError );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 147;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a083b7678dd71fa50eecfbe77aeba7fd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a083b7678dd71fa50eecfbe77aeba7fd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a083b7678dd71fa50eecfbe77aeba7fd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a083b7678dd71fa50eecfbe77aeba7fd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a083b7678dd71fa50eecfbe77aeba7fd, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a083b7678dd71fa50eecfbe77aeba7fd,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_a083b7678dd71fa50eecfbe77aeba7fd == cache_frame_a083b7678dd71fa50eecfbe77aeba7fd )
    {
        Py_DECREF( frame_a083b7678dd71fa50eecfbe77aeba7fd );
    }
    cache_frame_a083b7678dd71fa50eecfbe77aeba7fd = NULL;

    assertFrameObject( frame_a083b7678dd71fa50eecfbe77aeba7fd );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_10_substitute_entities );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_10_substitute_entities );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_bs4$element$$$function_11_substitute( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_c77abc76f4a0bef790a7c7a765758c82;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c77abc76f4a0bef790a7c7a765758c82 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c77abc76f4a0bef790a7c7a765758c82, codeobj_c77abc76f4a0bef790a7c7a765758c82, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c77abc76f4a0bef790a7c7a765758c82 = cache_frame_c77abc76f4a0bef790a7c7a765758c82;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c77abc76f4a0bef790a7c7a765758c82 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c77abc76f4a0bef790a7c7a765758c82 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "HTMLAwareEntitySubstitution" );
            exception_tb = NULL;

            exception_lineno = 152;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_substitute_html );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 152;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 152;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c77abc76f4a0bef790a7c7a765758c82 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c77abc76f4a0bef790a7c7a765758c82 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c77abc76f4a0bef790a7c7a765758c82 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c77abc76f4a0bef790a7c7a765758c82, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c77abc76f4a0bef790a7c7a765758c82->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c77abc76f4a0bef790a7c7a765758c82, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c77abc76f4a0bef790a7c7a765758c82,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_c77abc76f4a0bef790a7c7a765758c82 == cache_frame_c77abc76f4a0bef790a7c7a765758c82 )
    {
        Py_DECREF( frame_c77abc76f4a0bef790a7c7a765758c82 );
    }
    cache_frame_c77abc76f4a0bef790a7c7a765758c82 = NULL;

    assertFrameObject( frame_c77abc76f4a0bef790a7c7a765758c82 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_11_substitute );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_11_substitute );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_12_substitute( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_f35b594533211a40312bed4190bf81a5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f35b594533211a40312bed4190bf81a5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f35b594533211a40312bed4190bf81a5, codeobj_f35b594533211a40312bed4190bf81a5, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f35b594533211a40312bed4190bf81a5 = cache_frame_f35b594533211a40312bed4190bf81a5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f35b594533211a40312bed4190bf81a5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f35b594533211a40312bed4190bf81a5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "HTMLAwareEntitySubstitution" );
            exception_tb = NULL;

            exception_lineno = 157;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_substitute_xml );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 157;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 157;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f35b594533211a40312bed4190bf81a5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f35b594533211a40312bed4190bf81a5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f35b594533211a40312bed4190bf81a5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f35b594533211a40312bed4190bf81a5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f35b594533211a40312bed4190bf81a5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f35b594533211a40312bed4190bf81a5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f35b594533211a40312bed4190bf81a5,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_f35b594533211a40312bed4190bf81a5 == cache_frame_f35b594533211a40312bed4190bf81a5 )
    {
        Py_DECREF( frame_f35b594533211a40312bed4190bf81a5 );
    }
    cache_frame_f35b594533211a40312bed4190bf81a5 = NULL;

    assertFrameObject( frame_f35b594533211a40312bed4190bf81a5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_12_substitute );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_12_substitute );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_13_substitute( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_b0fc2c065017043970346a6bbad759bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b0fc2c065017043970346a6bbad759bf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b0fc2c065017043970346a6bbad759bf, codeobj_b0fc2c065017043970346a6bbad759bf, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b0fc2c065017043970346a6bbad759bf = cache_frame_b0fc2c065017043970346a6bbad759bf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b0fc2c065017043970346a6bbad759bf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b0fc2c065017043970346a6bbad759bf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "EntitySubstitution" );
            exception_tb = NULL;

            exception_lineno = 166;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_substitute_xml );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 166;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 166;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b0fc2c065017043970346a6bbad759bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b0fc2c065017043970346a6bbad759bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b0fc2c065017043970346a6bbad759bf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b0fc2c065017043970346a6bbad759bf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b0fc2c065017043970346a6bbad759bf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b0fc2c065017043970346a6bbad759bf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b0fc2c065017043970346a6bbad759bf,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_b0fc2c065017043970346a6bbad759bf == cache_frame_b0fc2c065017043970346a6bbad759bf )
    {
        Py_DECREF( frame_b0fc2c065017043970346a6bbad759bf );
    }
    cache_frame_b0fc2c065017043970346a6bbad759bf = NULL;

    assertFrameObject( frame_b0fc2c065017043970346a6bbad759bf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_13_substitute );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_13_substitute );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_14_substitute( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_9ba465c2f63a8015bb1bc81e3ff20eff;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9ba465c2f63a8015bb1bc81e3ff20eff = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9ba465c2f63a8015bb1bc81e3ff20eff, codeobj_9ba465c2f63a8015bb1bc81e3ff20eff, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9ba465c2f63a8015bb1bc81e3ff20eff = cache_frame_9ba465c2f63a8015bb1bc81e3ff20eff;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9ba465c2f63a8015bb1bc81e3ff20eff );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9ba465c2f63a8015bb1bc81e3ff20eff ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "HTMLAwareEntitySubstitution" );
            exception_tb = NULL;

            exception_lineno = 171;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_substitute_html );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 171;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ba465c2f63a8015bb1bc81e3ff20eff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ba465c2f63a8015bb1bc81e3ff20eff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ba465c2f63a8015bb1bc81e3ff20eff );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9ba465c2f63a8015bb1bc81e3ff20eff, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9ba465c2f63a8015bb1bc81e3ff20eff->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9ba465c2f63a8015bb1bc81e3ff20eff, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9ba465c2f63a8015bb1bc81e3ff20eff,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_9ba465c2f63a8015bb1bc81e3ff20eff == cache_frame_9ba465c2f63a8015bb1bc81e3ff20eff )
    {
        Py_DECREF( frame_9ba465c2f63a8015bb1bc81e3ff20eff );
    }
    cache_frame_9ba465c2f63a8015bb1bc81e3ff20eff = NULL;

    assertFrameObject( frame_9ba465c2f63a8015bb1bc81e3ff20eff );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_14_substitute );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_14_substitute );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_15_format_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_s = python_pars[ 1 ];
    PyObject *par_formatter = python_pars[ 2 ];
    PyObject *var_output = NULL;
    struct Nuitka_FrameObject *frame_d9729a6df5eb5a5b7ae31f23e87064b3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d9729a6df5eb5a5b7ae31f23e87064b3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d9729a6df5eb5a5b7ae31f23e87064b3, codeobj_d9729a6df5eb5a5b7ae31f23e87064b3, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d9729a6df5eb5a5b7ae31f23e87064b3 = cache_frame_d9729a6df5eb5a5b7ae31f23e87064b3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d9729a6df5eb5a5b7ae31f23e87064b3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d9729a6df5eb5a5b7ae31f23e87064b3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_formatter );
        tmp_isinstance_inst_1 = par_formatter;
        tmp_isinstance_cls_1 = (PyObject *)&PyBaseString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 215;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_formatter );
            tmp_args_element_name_1 = par_formatter;
            frame_d9729a6df5eb5a5b7ae31f23e87064b3->m_frame.f_lineno = 216;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__formatter_for_name, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 216;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_formatter;
                assert( old != NULL );
                par_formatter = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_formatter );
        tmp_compexpr_left_1 = par_formatter;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_2;
            CHECK_OBJECT( par_s );
            tmp_assign_source_2 = par_s;
            assert( var_output == NULL );
            Py_INCREF( tmp_assign_source_2 );
            var_output = tmp_assign_source_2;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( par_formatter );
            tmp_isinstance_inst_2 = par_formatter;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Callable );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Callable" );
                exception_tb = NULL;

                exception_lineno = 220;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_2 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 220;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_called_name_1;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT( par_formatter );
                tmp_called_name_1 = par_formatter;
                CHECK_OBJECT( par_s );
                tmp_args_element_name_2 = par_s;
                frame_d9729a6df5eb5a5b7ae31f23e87064b3->m_frame.f_lineno = 222;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 222;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert( var_output == NULL );
                var_output = tmp_assign_source_3;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_3;
                CHECK_OBJECT( par_formatter );
                tmp_called_instance_2 = par_formatter;
                CHECK_OBJECT( par_s );
                tmp_args_element_name_3 = par_s;
                frame_d9729a6df5eb5a5b7ae31f23e87064b3->m_frame.f_lineno = 224;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_substitute, call_args );
                }

                if ( tmp_assign_source_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 224;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                assert( var_output == NULL );
                var_output = tmp_assign_source_4;
            }
            branch_end_3:;
        }
        branch_end_2:;
    }
    if ( var_output == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "output" );
        exception_tb = NULL;

        exception_lineno = 225;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_output;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9729a6df5eb5a5b7ae31f23e87064b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9729a6df5eb5a5b7ae31f23e87064b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d9729a6df5eb5a5b7ae31f23e87064b3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d9729a6df5eb5a5b7ae31f23e87064b3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d9729a6df5eb5a5b7ae31f23e87064b3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d9729a6df5eb5a5b7ae31f23e87064b3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d9729a6df5eb5a5b7ae31f23e87064b3,
        type_description_1,
        par_self,
        par_s,
        par_formatter,
        var_output
    );


    // Release cached frame.
    if ( frame_d9729a6df5eb5a5b7ae31f23e87064b3 == cache_frame_d9729a6df5eb5a5b7ae31f23e87064b3 )
    {
        Py_DECREF( frame_d9729a6df5eb5a5b7ae31f23e87064b3 );
    }
    cache_frame_d9729a6df5eb5a5b7ae31f23e87064b3 = NULL;

    assertFrameObject( frame_d9729a6df5eb5a5b7ae31f23e87064b3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_15_format_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_output );
    var_output = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_output );
    var_output = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_15_format_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_16__is_xml( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_76183d666b6fe52239c562ee299269f3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_76183d666b6fe52239c562ee299269f3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_76183d666b6fe52239c562ee299269f3, codeobj_76183d666b6fe52239c562ee299269f3, module_bs4$element, sizeof(void *) );
    frame_76183d666b6fe52239c562ee299269f3 = cache_frame_76183d666b6fe52239c562ee299269f3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_76183d666b6fe52239c562ee299269f3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_76183d666b6fe52239c562ee299269f3 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_known_xml );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 236;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_known_xml );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 239;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_parent );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 244;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_2 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_getattr_target_1;
            PyObject *tmp_getattr_attr_1;
            PyObject *tmp_getattr_default_1;
            CHECK_OBJECT( par_self );
            tmp_getattr_target_1 = par_self;
            tmp_getattr_attr_1 = const_str_plain_is_xml;
            tmp_getattr_default_1 = Py_False;
            tmp_return_value = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 248;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_parent );
        if ( tmp_source_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 249;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__is_xml );
        Py_DECREF( tmp_source_name_4 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 249;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76183d666b6fe52239c562ee299269f3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_76183d666b6fe52239c562ee299269f3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_76183d666b6fe52239c562ee299269f3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_76183d666b6fe52239c562ee299269f3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_76183d666b6fe52239c562ee299269f3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_76183d666b6fe52239c562ee299269f3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_76183d666b6fe52239c562ee299269f3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_76183d666b6fe52239c562ee299269f3 == cache_frame_76183d666b6fe52239c562ee299269f3 )
    {
        Py_DECREF( frame_76183d666b6fe52239c562ee299269f3 );
    }
    cache_frame_76183d666b6fe52239c562ee299269f3 = NULL;

    assertFrameObject( frame_76183d666b6fe52239c562ee299269f3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_16__is_xml );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_16__is_xml );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_17__formatter_for_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_2c3ff2cae6e04e9ec244d1a23dd1cba7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2c3ff2cae6e04e9ec244d1a23dd1cba7, codeobj_2c3ff2cae6e04e9ec244d1a23dd1cba7, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 = cache_frame_2c3ff2cae6e04e9ec244d1a23dd1cba7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__is_xml );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 253;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 253;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_XML_FORMATTERS );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 254;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_get );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 254;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_name );
            tmp_args_element_name_1 = par_name;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_XMLFormatter );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_XMLFormatter );
            }

            if ( tmp_mvar_value_1 == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "XMLFormatter" );
                exception_tb = NULL;

                exception_lineno = 254;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_1;
            frame_2c3ff2cae6e04e9ec244d1a23dd1cba7->m_frame.f_lineno = 254;
            tmp_args_element_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 254;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_2c3ff2cae6e04e9ec244d1a23dd1cba7->m_frame.f_lineno = 254;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 254;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_4;
            PyObject *tmp_source_name_5;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_called_name_4;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_HTML_FORMATTERS );
            if ( tmp_source_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 256;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_get );
            Py_DECREF( tmp_source_name_4 );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 256;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_name );
            tmp_args_element_name_3 = par_name;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLFormatter );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLFormatter );
            }

            if ( tmp_mvar_value_2 == NULL )
            {
                Py_DECREF( tmp_called_name_3 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "HTMLFormatter" );
                exception_tb = NULL;

                exception_lineno = 256;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_4 = tmp_mvar_value_2;
            frame_2c3ff2cae6e04e9ec244d1a23dd1cba7->m_frame.f_lineno = 256;
            tmp_args_element_name_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
            if ( tmp_args_element_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 256;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_2c3ff2cae6e04e9ec244d1a23dd1cba7->m_frame.f_lineno = 256;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_4 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 256;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2c3ff2cae6e04e9ec244d1a23dd1cba7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2c3ff2cae6e04e9ec244d1a23dd1cba7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2c3ff2cae6e04e9ec244d1a23dd1cba7,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 == cache_frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 )
    {
        Py_DECREF( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 );
    }
    cache_frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 = NULL;

    assertFrameObject( frame_2c3ff2cae6e04e9ec244d1a23dd1cba7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_17__formatter_for_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_17__formatter_for_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_18_setup( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_parent = python_pars[ 1 ];
    PyObject *par_previous_element = python_pars[ 2 ];
    PyObject *par_next_element = python_pars[ 3 ];
    PyObject *par_previous_sibling = python_pars[ 4 ];
    PyObject *par_next_sibling = python_pars[ 5 ];
    struct Nuitka_FrameObject *frame_c84480da8086d95f36164f584c21f6ab;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c84480da8086d95f36164f584c21f6ab = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c84480da8086d95f36164f584c21f6ab, codeobj_c84480da8086d95f36164f584c21f6ab, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c84480da8086d95f36164f584c21f6ab = cache_frame_c84480da8086d95f36164f584c21f6ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c84480da8086d95f36164f584c21f6ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c84480da8086d95f36164f584c21f6ab ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_parent );
        tmp_assattr_name_1 = par_parent;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_parent, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 262;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( par_previous_element );
        tmp_assattr_name_2 = par_previous_element;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_previous_element, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 264;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_previous_element );
        tmp_compexpr_left_1 = par_previous_element;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_assattr_target_3;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( par_self );
            tmp_assattr_name_3 = par_self;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_assattr_target_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_previous_element );
            if ( tmp_assattr_target_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 266;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_next_element, tmp_assattr_name_3 );
            Py_DECREF( tmp_assattr_target_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 266;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT( par_next_element );
        tmp_assattr_name_4 = par_next_element;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_next_element, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 268;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_next_element );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 269;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_2 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_5;
            PyObject *tmp_assattr_target_5;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_assattr_name_5 = par_self;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_assattr_target_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_next_element );
            if ( tmp_assattr_target_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 270;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_previous_element, tmp_assattr_name_5 );
            Py_DECREF( tmp_assattr_target_5 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 270;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        CHECK_OBJECT( par_next_sibling );
        tmp_assattr_name_6 = par_next_sibling;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_next_sibling, tmp_assattr_name_6 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 272;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_next_sibling );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 273;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_3 );
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_assattr_target_7;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( par_self );
            tmp_assattr_name_7 = par_self;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_assattr_target_7 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_next_sibling );
            if ( tmp_assattr_target_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 274;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_previous_sibling, tmp_assattr_name_7 );
            Py_DECREF( tmp_assattr_target_7 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 274;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_3:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_source_name_8;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_previous_sibling );
        tmp_compexpr_left_4 = par_previous_sibling;
        tmp_compexpr_right_4 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_4 == tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_compexpr_left_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_parent );
        if ( tmp_compexpr_left_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 277;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_5 = Py_None;
        tmp_and_left_value_2 = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_5 );
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_parent );
        if ( tmp_source_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 277;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_contents );
        Py_DECREF( tmp_source_name_7 );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 277;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 277;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        tmp_and_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_and_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_condition_result_4 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_4 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_source_name_9;
            PyObject *tmp_source_name_10;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_10 = par_self;
            tmp_source_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_parent );
            if ( tmp_source_name_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 278;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_contents );
            Py_DECREF( tmp_source_name_9 );
            if ( tmp_subscribed_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 278;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_subscript_name_1 = const_int_neg_1;
            tmp_assign_source_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, -1 );
            Py_DECREF( tmp_subscribed_name_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 278;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_previous_sibling;
                assert( old != NULL );
                par_previous_sibling = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_4:;
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_assattr_target_8;
        CHECK_OBJECT( par_previous_sibling );
        tmp_assattr_name_8 = par_previous_sibling;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_previous_sibling, tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 280;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        CHECK_OBJECT( par_previous_sibling );
        tmp_compexpr_left_6 = par_previous_sibling;
        tmp_compexpr_right_6 = Py_None;
        tmp_condition_result_5 = ( tmp_compexpr_left_6 != tmp_compexpr_right_6 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assattr_name_9;
            PyObject *tmp_assattr_target_9;
            PyObject *tmp_source_name_11;
            CHECK_OBJECT( par_self );
            tmp_assattr_name_9 = par_self;
            CHECK_OBJECT( par_self );
            tmp_source_name_11 = par_self;
            tmp_assattr_target_9 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_previous_sibling );
            if ( tmp_assattr_target_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 282;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_next_sibling, tmp_assattr_name_9 );
            Py_DECREF( tmp_assattr_target_9 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 282;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_5:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c84480da8086d95f36164f584c21f6ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c84480da8086d95f36164f584c21f6ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c84480da8086d95f36164f584c21f6ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c84480da8086d95f36164f584c21f6ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c84480da8086d95f36164f584c21f6ab, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c84480da8086d95f36164f584c21f6ab,
        type_description_1,
        par_self,
        par_parent,
        par_previous_element,
        par_next_element,
        par_previous_sibling,
        par_next_sibling
    );


    // Release cached frame.
    if ( frame_c84480da8086d95f36164f584c21f6ab == cache_frame_c84480da8086d95f36164f584c21f6ab )
    {
        Py_DECREF( frame_c84480da8086d95f36164f584c21f6ab );
    }
    cache_frame_c84480da8086d95f36164f584c21f6ab = NULL;

    assertFrameObject( frame_c84480da8086d95f36164f584c21f6ab );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_18_setup );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_previous_element );
    Py_DECREF( par_previous_element );
    par_previous_element = NULL;

    CHECK_OBJECT( (PyObject *)par_next_sibling );
    Py_DECREF( par_next_sibling );
    par_next_sibling = NULL;

    CHECK_OBJECT( (PyObject *)par_parent );
    Py_DECREF( par_parent );
    par_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_previous_sibling );
    Py_DECREF( par_previous_sibling );
    par_previous_sibling = NULL;

    CHECK_OBJECT( (PyObject *)par_next_element );
    Py_DECREF( par_next_element );
    par_next_element = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_previous_element );
    Py_DECREF( par_previous_element );
    par_previous_element = NULL;

    CHECK_OBJECT( (PyObject *)par_next_sibling );
    Py_DECREF( par_next_sibling );
    par_next_sibling = NULL;

    CHECK_OBJECT( (PyObject *)par_parent );
    Py_DECREF( par_parent );
    par_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_previous_sibling );
    par_previous_sibling = NULL;

    CHECK_OBJECT( (PyObject *)par_next_element );
    Py_DECREF( par_next_element );
    par_next_element = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_18_setup );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_19_replace_with( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_replace_with = python_pars[ 1 ];
    PyObject *var_old_parent = NULL;
    PyObject *var_my_index = NULL;
    struct Nuitka_FrameObject *frame_95ffa881c992b41a09b640bdd993138a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_95ffa881c992b41a09b640bdd993138a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_95ffa881c992b41a09b640bdd993138a, codeobj_95ffa881c992b41a09b640bdd993138a, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_95ffa881c992b41a09b640bdd993138a = cache_frame_95ffa881c992b41a09b640bdd993138a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_95ffa881c992b41a09b640bdd993138a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_95ffa881c992b41a09b640bdd993138a ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 288;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_966b532e2f3ba00ecd4d1fb36c023539;
            frame_95ffa881c992b41a09b640bdd993138a->m_frame.f_lineno = 289;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 289;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_replace_with );
        tmp_compexpr_left_2 = par_replace_with;
        CHECK_OBJECT( par_self );
        tmp_compexpr_right_2 = par_self;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_replace_with );
        tmp_compexpr_left_3 = par_replace_with;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 294;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_3a6a8193326a0cc096673b1c1e043757;
            frame_95ffa881c992b41a09b640bdd993138a->m_frame.f_lineno = 295;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 295;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_parent );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 296;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_old_parent == NULL );
        var_old_parent = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_4;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_parent );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 297;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_95ffa881c992b41a09b640bdd993138a->m_frame.f_lineno = 297;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_index, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 297;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_my_index == NULL );
        var_my_index = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_95ffa881c992b41a09b640bdd993138a->m_frame.f_lineno = 298;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_extract );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 298;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( var_old_parent );
        tmp_called_instance_3 = var_old_parent;
        CHECK_OBJECT( var_my_index );
        tmp_args_element_name_2 = var_my_index;
        CHECK_OBJECT( par_replace_with );
        tmp_args_element_name_3 = par_replace_with;
        frame_95ffa881c992b41a09b640bdd993138a->m_frame.f_lineno = 299;
        {
            PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_insert, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 299;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95ffa881c992b41a09b640bdd993138a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_95ffa881c992b41a09b640bdd993138a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_95ffa881c992b41a09b640bdd993138a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_95ffa881c992b41a09b640bdd993138a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_95ffa881c992b41a09b640bdd993138a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_95ffa881c992b41a09b640bdd993138a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_95ffa881c992b41a09b640bdd993138a,
        type_description_1,
        par_self,
        par_replace_with,
        var_old_parent,
        var_my_index
    );


    // Release cached frame.
    if ( frame_95ffa881c992b41a09b640bdd993138a == cache_frame_95ffa881c992b41a09b640bdd993138a )
    {
        Py_DECREF( frame_95ffa881c992b41a09b640bdd993138a );
    }
    cache_frame_95ffa881c992b41a09b640bdd993138a = NULL;

    assertFrameObject( frame_95ffa881c992b41a09b640bdd993138a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( par_self );
    tmp_return_value = par_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_19_replace_with );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_old_parent );
    var_old_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_my_index );
    var_my_index = NULL;

    CHECK_OBJECT( (PyObject *)par_replace_with );
    Py_DECREF( par_replace_with );
    par_replace_with = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_old_parent );
    var_old_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_my_index );
    var_my_index = NULL;

    CHECK_OBJECT( (PyObject *)par_replace_with );
    Py_DECREF( par_replace_with );
    par_replace_with = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_19_replace_with );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_20_unwrap( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_child = NULL;
    PyObject *var_my_parent = NULL;
    PyObject *var_my_index = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_68bc07cc376f7fe11e6f7be1682a6dbb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_68bc07cc376f7fe11e6f7be1682a6dbb = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_68bc07cc376f7fe11e6f7be1682a6dbb, codeobj_68bc07cc376f7fe11e6f7be1682a6dbb, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_68bc07cc376f7fe11e6f7be1682a6dbb = cache_frame_68bc07cc376f7fe11e6f7be1682a6dbb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_68bc07cc376f7fe11e6f7be1682a6dbb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_68bc07cc376f7fe11e6f7be1682a6dbb ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 304;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_my_parent == NULL );
        var_my_parent = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 305;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_d1ef6bd6894bac52c44d6c442c9cf379;
            frame_68bc07cc376f7fe11e6f7be1682a6dbb->m_frame.f_lineno = 306;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 306;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_parent );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 309;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_68bc07cc376f7fe11e6f7be1682a6dbb->m_frame.f_lineno = 309;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_index, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 309;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_my_index == NULL );
        var_my_index = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_68bc07cc376f7fe11e6f7be1682a6dbb->m_frame.f_lineno = 310;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_extract );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 310;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_2;
        Py_ssize_t tmp_sliceslicedel_index_lower_1;
        Py_ssize_t tmp_slice_index_upper_1;
        PyObject *tmp_slice_source_1;
        PyObject *tmp_source_name_4;
        tmp_called_name_1 = (PyObject *)&PyReversed_Type;
        tmp_sliceslicedel_index_lower_1 = 0;
        tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_slice_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_contents );
        if ( tmp_slice_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
        Py_DECREF( tmp_slice_source_1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_68bc07cc376f7fe11e6f7be1682a6dbb->m_frame.f_lineno = 311;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 311;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 311;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_child;
            var_child = tmp_assign_source_5;
            Py_INCREF( var_child );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( var_my_parent );
        tmp_called_instance_3 = var_my_parent;
        CHECK_OBJECT( var_my_index );
        tmp_args_element_name_3 = var_my_index;
        CHECK_OBJECT( var_child );
        tmp_args_element_name_4 = var_child;
        frame_68bc07cc376f7fe11e6f7be1682a6dbb->m_frame.f_lineno = 312;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_insert, call_args );
        }

        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 312;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 311;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68bc07cc376f7fe11e6f7be1682a6dbb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_68bc07cc376f7fe11e6f7be1682a6dbb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_68bc07cc376f7fe11e6f7be1682a6dbb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_68bc07cc376f7fe11e6f7be1682a6dbb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_68bc07cc376f7fe11e6f7be1682a6dbb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_68bc07cc376f7fe11e6f7be1682a6dbb,
        type_description_1,
        par_self,
        var_child,
        var_my_parent,
        var_my_index
    );


    // Release cached frame.
    if ( frame_68bc07cc376f7fe11e6f7be1682a6dbb == cache_frame_68bc07cc376f7fe11e6f7be1682a6dbb )
    {
        Py_DECREF( frame_68bc07cc376f7fe11e6f7be1682a6dbb );
    }
    cache_frame_68bc07cc376f7fe11e6f7be1682a6dbb = NULL;

    assertFrameObject( frame_68bc07cc376f7fe11e6f7be1682a6dbb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( par_self );
    tmp_return_value = par_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_20_unwrap );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    CHECK_OBJECT( (PyObject *)var_my_parent );
    Py_DECREF( var_my_parent );
    var_my_parent = NULL;

    CHECK_OBJECT( (PyObject *)var_my_index );
    Py_DECREF( var_my_index );
    var_my_index = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    Py_XDECREF( var_my_parent );
    var_my_parent = NULL;

    Py_XDECREF( var_my_index );
    var_my_index = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_20_unwrap );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_21_wrap( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_wrap_inside = python_pars[ 1 ];
    PyObject *var_me = NULL;
    struct Nuitka_FrameObject *frame_05c0c723a3dc2a65077e569ed007a15a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_05c0c723a3dc2a65077e569ed007a15a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_05c0c723a3dc2a65077e569ed007a15a, codeobj_05c0c723a3dc2a65077e569ed007a15a, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_05c0c723a3dc2a65077e569ed007a15a = cache_frame_05c0c723a3dc2a65077e569ed007a15a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_05c0c723a3dc2a65077e569ed007a15a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_05c0c723a3dc2a65077e569ed007a15a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_wrap_inside );
        tmp_args_element_name_1 = par_wrap_inside;
        frame_05c0c723a3dc2a65077e569ed007a15a->m_frame.f_lineno = 318;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_replace_with, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 318;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_me == NULL );
        var_me = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_wrap_inside );
        tmp_called_instance_2 = par_wrap_inside;
        CHECK_OBJECT( var_me );
        tmp_args_element_name_2 = var_me;
        frame_05c0c723a3dc2a65077e569ed007a15a->m_frame.f_lineno = 319;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 319;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05c0c723a3dc2a65077e569ed007a15a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_05c0c723a3dc2a65077e569ed007a15a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_05c0c723a3dc2a65077e569ed007a15a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_05c0c723a3dc2a65077e569ed007a15a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_05c0c723a3dc2a65077e569ed007a15a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_05c0c723a3dc2a65077e569ed007a15a,
        type_description_1,
        par_self,
        par_wrap_inside,
        var_me
    );


    // Release cached frame.
    if ( frame_05c0c723a3dc2a65077e569ed007a15a == cache_frame_05c0c723a3dc2a65077e569ed007a15a )
    {
        Py_DECREF( frame_05c0c723a3dc2a65077e569ed007a15a );
    }
    cache_frame_05c0c723a3dc2a65077e569ed007a15a = NULL;

    assertFrameObject( frame_05c0c723a3dc2a65077e569ed007a15a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( par_wrap_inside );
    tmp_return_value = par_wrap_inside;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_21_wrap );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_wrap_inside );
    Py_DECREF( par_wrap_inside );
    par_wrap_inside = NULL;

    CHECK_OBJECT( (PyObject *)var_me );
    Py_DECREF( var_me );
    var_me = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_wrap_inside );
    Py_DECREF( par_wrap_inside );
    par_wrap_inside = NULL;

    Py_XDECREF( var_me );
    var_me = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_21_wrap );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_22_extract( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_last_child = NULL;
    PyObject *var_next_element = NULL;
    struct Nuitka_FrameObject *frame_c703ca9bc738259b4324f501b5ecee93;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_c703ca9bc738259b4324f501b5ecee93 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c703ca9bc738259b4324f501b5ecee93, codeobj_c703ca9bc738259b4324f501b5ecee93, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c703ca9bc738259b4324f501b5ecee93 = cache_frame_c703ca9bc738259b4324f501b5ecee93;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c703ca9bc738259b4324f501b5ecee93 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c703ca9bc738259b4324f501b5ecee93 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 324;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_delsubscr_target_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            PyObject *tmp_delsubscr_subscript_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_source_name_4;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_parent );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 325;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_delsubscr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_contents );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_delsubscr_target_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 325;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_parent );
            if ( tmp_called_instance_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_delsubscr_target_1 );

                exception_lineno = 325;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_args_element_name_1 = par_self;
            frame_c703ca9bc738259b4324f501b5ecee93->m_frame.f_lineno = 325;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_delsubscr_subscript_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_index, call_args );
            }

            Py_DECREF( tmp_called_instance_1 );
            if ( tmp_delsubscr_subscript_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_delsubscr_target_1 );

                exception_lineno = 325;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
            Py_DECREF( tmp_delsubscr_target_1 );
            Py_DECREF( tmp_delsubscr_subscript_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 325;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_2 = par_self;
        frame_c703ca9bc738259b4324f501b5ecee93->m_frame.f_lineno = 330;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__last_descendant );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 330;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_last_child == NULL );
        var_last_child = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_5;
        CHECK_OBJECT( var_last_child );
        tmp_source_name_5 = var_last_child;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_next_element );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 331;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_next_element == NULL );
        var_next_element = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_previous_element );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 333;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_2 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_2 );
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_previous_element );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 334;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_next_element );
        tmp_compexpr_right_3 = var_next_element;
        tmp_and_right_value_1 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_3 );
        tmp_condition_result_2 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_2 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            PyObject *tmp_source_name_8;
            CHECK_OBJECT( var_next_element );
            tmp_assattr_name_1 = var_next_element;
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_assattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_previous_element );
            if ( tmp_assattr_target_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_next_element, tmp_assattr_name_1 );
            Py_DECREF( tmp_assattr_target_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 335;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT( var_next_element );
        tmp_compexpr_left_4 = var_next_element;
        tmp_compexpr_right_4 = Py_None;
        tmp_and_left_value_2 = ( tmp_compexpr_left_4 != tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( var_next_element );
        tmp_compexpr_left_5 = var_next_element;
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_compexpr_right_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_previous_element );
        if ( tmp_compexpr_right_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 336;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_right_5 );
        tmp_condition_result_3 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_3 = tmp_and_left_value_2;
        and_end_2:;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_source_name_10;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_10 = par_self;
            tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_previous_element );
            if ( tmp_assattr_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 337;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_next_element );
            tmp_assattr_target_2 = var_next_element;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_previous_element, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 337;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        tmp_assattr_name_3 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_previous_element, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 338;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        tmp_assattr_name_4 = Py_None;
        CHECK_OBJECT( var_last_child );
        tmp_assattr_target_4 = var_last_child;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_next_element, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 339;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        tmp_assattr_name_5 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_parent, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 341;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        PyObject *tmp_source_name_11;
        PyObject *tmp_compexpr_left_7;
        PyObject *tmp_compexpr_right_7;
        PyObject *tmp_source_name_12;
        PyObject *tmp_source_name_13;
        CHECK_OBJECT( par_self );
        tmp_source_name_11 = par_self;
        tmp_compexpr_left_6 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_previous_sibling );
        if ( tmp_compexpr_left_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 342;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_6 = Py_None;
        tmp_and_left_value_3 = ( tmp_compexpr_left_6 != tmp_compexpr_right_6 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_6 );
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_3 == 1 )
        {
            goto and_right_3;
        }
        else
        {
            goto and_left_3;
        }
        and_right_3:;
        CHECK_OBJECT( par_self );
        tmp_source_name_12 = par_self;
        tmp_compexpr_left_7 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_previous_sibling );
        if ( tmp_compexpr_left_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_13 = par_self;
        tmp_compexpr_right_7 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_next_sibling );
        if ( tmp_compexpr_right_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_7 );

            exception_lineno = 343;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_3 = ( tmp_compexpr_left_7 != tmp_compexpr_right_7 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_7 );
        Py_DECREF( tmp_compexpr_right_7 );
        tmp_condition_result_4 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_condition_result_4 = tmp_and_left_value_3;
        and_end_3:;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assattr_name_6;
            PyObject *tmp_source_name_14;
            PyObject *tmp_assattr_target_6;
            PyObject *tmp_source_name_15;
            CHECK_OBJECT( par_self );
            tmp_source_name_14 = par_self;
            tmp_assattr_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_next_sibling );
            if ( tmp_assattr_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 344;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_15 = par_self;
            tmp_assattr_target_6 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_previous_sibling );
            if ( tmp_assattr_target_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_assattr_name_6 );

                exception_lineno = 344;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_next_sibling, tmp_assattr_name_6 );
            Py_DECREF( tmp_assattr_name_6 );
            Py_DECREF( tmp_assattr_target_6 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 344;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_and_left_truth_4;
        nuitka_bool tmp_and_left_value_4;
        nuitka_bool tmp_and_right_value_4;
        PyObject *tmp_compexpr_left_8;
        PyObject *tmp_compexpr_right_8;
        PyObject *tmp_source_name_16;
        PyObject *tmp_compexpr_left_9;
        PyObject *tmp_compexpr_right_9;
        PyObject *tmp_source_name_17;
        PyObject *tmp_source_name_18;
        CHECK_OBJECT( par_self );
        tmp_source_name_16 = par_self;
        tmp_compexpr_left_8 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_next_sibling );
        if ( tmp_compexpr_left_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 345;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_8 = Py_None;
        tmp_and_left_value_4 = ( tmp_compexpr_left_8 != tmp_compexpr_right_8 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_8 );
        tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_4 == 1 )
        {
            goto and_right_4;
        }
        else
        {
            goto and_left_4;
        }
        and_right_4:;
        CHECK_OBJECT( par_self );
        tmp_source_name_17 = par_self;
        tmp_compexpr_left_9 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_next_sibling );
        if ( tmp_compexpr_left_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_18 = par_self;
        tmp_compexpr_right_9 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_previous_sibling );
        if ( tmp_compexpr_right_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_9 );

            exception_lineno = 346;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_4 = ( tmp_compexpr_left_9 != tmp_compexpr_right_9 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_9 );
        Py_DECREF( tmp_compexpr_right_9 );
        tmp_condition_result_5 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_condition_result_5 = tmp_and_left_value_4;
        and_end_4:;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_source_name_19;
            PyObject *tmp_assattr_target_7;
            PyObject *tmp_source_name_20;
            CHECK_OBJECT( par_self );
            tmp_source_name_19 = par_self;
            tmp_assattr_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_previous_sibling );
            if ( tmp_assattr_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 347;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_source_name_20 = par_self;
            tmp_assattr_target_7 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_next_sibling );
            if ( tmp_assattr_target_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_assattr_name_7 );

                exception_lineno = 347;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_previous_sibling, tmp_assattr_name_7 );
            Py_DECREF( tmp_assattr_name_7 );
            Py_DECREF( tmp_assattr_target_7 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 347;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assattr_name_8;
        PyObject *tmp_assattr_target_8;
        tmp_assattr_name_8 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_previous_sibling, tmp_assattr_name_8 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 348;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        tmp_assattr_name_9 = Py_None;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_next_sibling, tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 348;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c703ca9bc738259b4324f501b5ecee93 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c703ca9bc738259b4324f501b5ecee93 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c703ca9bc738259b4324f501b5ecee93, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c703ca9bc738259b4324f501b5ecee93->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c703ca9bc738259b4324f501b5ecee93, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c703ca9bc738259b4324f501b5ecee93,
        type_description_1,
        par_self,
        var_last_child,
        var_next_element
    );


    // Release cached frame.
    if ( frame_c703ca9bc738259b4324f501b5ecee93 == cache_frame_c703ca9bc738259b4324f501b5ecee93 )
    {
        Py_DECREF( frame_c703ca9bc738259b4324f501b5ecee93 );
    }
    cache_frame_c703ca9bc738259b4324f501b5ecee93 = NULL;

    assertFrameObject( frame_c703ca9bc738259b4324f501b5ecee93 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( par_self );
    tmp_return_value = par_self;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_22_extract );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_last_child );
    Py_DECREF( var_last_child );
    var_last_child = NULL;

    CHECK_OBJECT( (PyObject *)var_next_element );
    Py_DECREF( var_next_element );
    var_next_element = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_last_child );
    var_last_child = NULL;

    Py_XDECREF( var_next_element );
    var_next_element = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_22_extract );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_23__last_descendant( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_is_initialized = python_pars[ 1 ];
    PyObject *par_accept_self = python_pars[ 2 ];
    PyObject *var_last_child = NULL;
    struct Nuitka_FrameObject *frame_0d9096af853ae8895db328ea28d3cd9a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0d9096af853ae8895db328ea28d3cd9a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0d9096af853ae8895db328ea28d3cd9a, codeobj_0d9096af853ae8895db328ea28d3cd9a, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0d9096af853ae8895db328ea28d3cd9a = cache_frame_0d9096af853ae8895db328ea28d3cd9a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0d9096af853ae8895db328ea28d3cd9a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0d9096af853ae8895db328ea28d3cd9a ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        int tmp_truth_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_is_initialized );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_is_initialized );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 353;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_next_sibling );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 353;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = Py_None;
        tmp_and_right_value_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_1 );
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_next_sibling );
            if ( tmp_source_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 354;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_previous_element );
            Py_DECREF( tmp_source_name_2 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 354;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( var_last_child == NULL );
            var_last_child = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            CHECK_OBJECT( par_self );
            tmp_assign_source_2 = par_self;
            assert( var_last_child == NULL );
            Py_INCREF( tmp_assign_source_2 );
            var_last_child = tmp_assign_source_2;
        }
        loop_start_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_operand_name_1;
            int tmp_and_left_truth_2;
            PyObject *tmp_and_left_value_2;
            PyObject *tmp_and_right_value_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_source_name_4;
            CHECK_OBJECT( var_last_child );
            tmp_isinstance_inst_1 = var_last_child;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
                exception_tb = NULL;

                exception_lineno = 357;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 357;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
            if ( tmp_and_left_truth_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 357;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            if ( tmp_and_left_truth_2 == 1 )
            {
                goto and_right_2;
            }
            else
            {
                goto and_left_2;
            }
            and_right_2:;
            CHECK_OBJECT( var_last_child );
            tmp_source_name_4 = var_last_child;
            tmp_and_right_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_contents );
            if ( tmp_and_right_value_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 357;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_operand_name_1 = tmp_and_right_value_2;
            goto and_end_2;
            and_left_2:;
            Py_INCREF( tmp_and_left_value_2 );
            tmp_operand_name_1 = tmp_and_left_value_2;
            and_end_2:;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 357;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            goto loop_end_1;
            branch_no_2:;
        }
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_source_name_5;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( var_last_child );
            tmp_source_name_5 = var_last_child;
            tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_contents );
            if ( tmp_subscribed_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 358;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_subscript_name_1 = const_int_neg_1;
            tmp_assign_source_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, -1 );
            Py_DECREF( tmp_subscribed_name_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 358;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_last_child;
                assert( old != NULL );
                var_last_child = tmp_assign_source_3;
                Py_DECREF( old );
            }

        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 357;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto loop_start_1;
        loop_end_1:;
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_accept_self );
        tmp_operand_name_2 = par_accept_self;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 359;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_3 == 1 )
        {
            goto and_right_3;
        }
        else
        {
            goto and_left_3;
        }
        and_right_3:;
        if ( var_last_child == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "last_child" );
            exception_tb = NULL;

            exception_lineno = 359;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_2 = var_last_child;
        CHECK_OBJECT( par_self );
        tmp_compexpr_right_2 = par_self;
        tmp_and_right_value_3 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_3 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_condition_result_3 = tmp_and_left_value_3;
        and_end_3:;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = Py_None;
            {
                PyObject *old = var_last_child;
                var_last_child = tmp_assign_source_4;
                Py_INCREF( var_last_child );
                Py_XDECREF( old );
            }

        }
        branch_no_3:;
    }
    if ( var_last_child == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "last_child" );
        exception_tb = NULL;

        exception_lineno = 361;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_last_child;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d9096af853ae8895db328ea28d3cd9a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d9096af853ae8895db328ea28d3cd9a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0d9096af853ae8895db328ea28d3cd9a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0d9096af853ae8895db328ea28d3cd9a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0d9096af853ae8895db328ea28d3cd9a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0d9096af853ae8895db328ea28d3cd9a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0d9096af853ae8895db328ea28d3cd9a,
        type_description_1,
        par_self,
        par_is_initialized,
        par_accept_self,
        var_last_child
    );


    // Release cached frame.
    if ( frame_0d9096af853ae8895db328ea28d3cd9a == cache_frame_0d9096af853ae8895db328ea28d3cd9a )
    {
        Py_DECREF( frame_0d9096af853ae8895db328ea28d3cd9a );
    }
    cache_frame_0d9096af853ae8895db328ea28d3cd9a = NULL;

    assertFrameObject( frame_0d9096af853ae8895db328ea28d3cd9a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_23__last_descendant );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_is_initialized );
    Py_DECREF( par_is_initialized );
    par_is_initialized = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_last_child );
    var_last_child = NULL;

    CHECK_OBJECT( (PyObject *)par_accept_self );
    Py_DECREF( par_accept_self );
    par_accept_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_is_initialized );
    Py_DECREF( par_is_initialized );
    par_is_initialized = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_last_child );
    var_last_child = NULL;

    CHECK_OBJECT( (PyObject *)par_accept_self );
    Py_DECREF( par_accept_self );
    par_accept_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_23__last_descendant );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_24_insert( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_position = python_pars[ 1 ];
    PyObject *par_new_child = python_pars[ 2 ];
    PyObject *var_subchild = NULL;
    PyObject *var_parents_next_sibling = NULL;
    PyObject *var_parent = NULL;
    PyObject *var_next_child = NULL;
    PyObject *var_new_childs_last_element = NULL;
    PyObject *var_BeautifulSoup = NULL;
    PyObject *var_current_index = NULL;
    PyObject *var_previous_child = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_946ab5af3c25362849801c2db8c2098f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_946ab5af3c25362849801c2db8c2098f = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_946ab5af3c25362849801c2db8c2098f, codeobj_946ab5af3c25362849801c2db8c2098f, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_946ab5af3c25362849801c2db8c2098f = cache_frame_946ab5af3c25362849801c2db8c2098f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_946ab5af3c25362849801c2db8c2098f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_946ab5af3c25362849801c2db8c2098f ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_new_child );
        tmp_compexpr_left_1 = par_new_child;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_caa1311fbee6a780f68a9bf663ab8344;
            frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 367;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 367;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_new_child );
        tmp_compexpr_left_2 = par_new_child;
        CHECK_OBJECT( par_self );
        tmp_compexpr_right_2 = par_self;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_9e0202f20825ee6726af59eda1c982e0;
            frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 369;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 369;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_new_child );
        tmp_isinstance_inst_1 = par_new_child;
        tmp_isinstance_cls_1 = (PyObject *)&PyBaseString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 370;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_new_child );
        tmp_isinstance_inst_2 = par_new_child;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
            exception_tb = NULL;

            exception_lineno = 371;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 371;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_3 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_3 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_args_element_name_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
                exception_tb = NULL;

                exception_lineno = 372;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_2;
            CHECK_OBJECT( par_new_child );
            tmp_args_element_name_1 = par_new_child;
            frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 372;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 372;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_new_child;
                assert( old != NULL );
                par_new_child = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_plain_bs4;
        tmp_globals_name_1 = (PyObject *)moduledict_bs4$element;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_BeautifulSoup_tuple;
        frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 374;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 374;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_BeautifulSoup );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 374;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_BeautifulSoup == NULL );
        var_BeautifulSoup = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        CHECK_OBJECT( par_new_child );
        tmp_isinstance_inst_3 = par_new_child;
        CHECK_OBJECT( var_BeautifulSoup );
        tmp_isinstance_cls_3 = var_BeautifulSoup;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 375;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_list_arg_1;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( par_new_child );
            tmp_source_name_1 = par_new_child;
            tmp_list_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
            if ( tmp_list_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 378;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_iter_arg_1 = PySequence_List( tmp_list_arg_1 );
            Py_DECREF( tmp_list_arg_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 378;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 378;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_3;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_4 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooooooo";
                    exception_lineno = 378;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_4;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_5 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_subchild;
                var_subchild = tmp_assign_source_5;
                Py_INCREF( var_subchild );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_position );
            tmp_args_element_name_2 = par_position;
            CHECK_OBJECT( var_subchild );
            tmp_args_element_name_3 = var_subchild;
            frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 379;
            {
                PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_insert, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 379;
                type_description_1 = "ooooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            CHECK_OBJECT( par_position );
            tmp_left_name_1 = par_position;
            tmp_right_name_1 = const_int_pos_1;
            tmp_result = BINARY_OPERATION_ADD_OBJECT_INT_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 380;
                type_description_1 = "ooooooooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_6 = tmp_left_name_1;
            par_position = tmp_assign_source_6;

        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 378;
            type_description_1 = "ooooooooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_4:;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_2;
        tmp_called_name_2 = LOOKUP_BUILTIN( const_str_plain_min );
        assert( tmp_called_name_2 != NULL );
        CHECK_OBJECT( par_position );
        tmp_args_element_name_4 = par_position;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_contents );
        if ( tmp_len_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 382;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_5 = BUILTIN_LEN( tmp_len_arg_1 );
        Py_DECREF( tmp_len_arg_1 );
        if ( tmp_args_element_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 382;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 382;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_args_element_name_5 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 382;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_position;
            assert( old != NULL );
            par_position = tmp_assign_source_7;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_attribute_name_1;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( par_new_child );
        tmp_source_name_3 = par_new_child;
        tmp_attribute_name_1 = const_str_plain_parent;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_3, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 383;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_new_child );
        tmp_source_name_4 = par_new_child;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_parent );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 383;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = Py_None;
        tmp_and_right_value_2 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_3 );
        tmp_condition_result_5 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_5 = tmp_and_left_value_2;
        and_end_2:;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( par_new_child );
            tmp_source_name_5 = par_new_child;
            tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_parent );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 386;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_compexpr_right_4 = par_self;
            tmp_condition_result_6 = ( tmp_compexpr_left_4 == tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_compexpr_left_4 );
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_6;
            }
            else
            {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_assign_source_8;
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_6;
                CHECK_OBJECT( par_self );
                tmp_called_instance_2 = par_self;
                CHECK_OBJECT( par_new_child );
                tmp_args_element_name_6 = par_new_child;
                frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 387;
                {
                    PyObject *call_args[] = { tmp_args_element_name_6 };
                    tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_index, call_args );
                }

                if ( tmp_assign_source_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 387;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_current_index == NULL );
                var_current_index = tmp_assign_source_8;
            }
            {
                nuitka_bool tmp_condition_result_7;
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                CHECK_OBJECT( var_current_index );
                tmp_compexpr_left_5 = var_current_index;
                CHECK_OBJECT( par_position );
                tmp_compexpr_right_5 = par_position;
                tmp_res = RICH_COMPARE_BOOL_LT_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 388;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_7;
                }
                else
                {
                    goto branch_no_7;
                }
                branch_yes_7:;
                {
                    PyObject *tmp_assign_source_9;
                    PyObject *tmp_left_name_2;
                    PyObject *tmp_right_name_2;
                    CHECK_OBJECT( par_position );
                    tmp_left_name_2 = par_position;
                    tmp_right_name_2 = const_int_pos_1;
                    tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceSubtract, &tmp_left_name_2, tmp_right_name_2 );
                    if ( tmp_result == false )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 393;
                        type_description_1 = "ooooooooooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_assign_source_9 = tmp_left_name_2;
                    par_position = tmp_assign_source_9;

                }
                branch_no_7:;
            }
            branch_no_6:;
        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( par_new_child );
            tmp_called_instance_3 = par_new_child;
            frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 394;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_extract );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 394;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_self );
        tmp_assattr_name_1 = par_self;
        CHECK_OBJECT( par_new_child );
        tmp_assattr_target_1 = par_new_child;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_parent, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 396;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        if ( par_position == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "position" );
            exception_tb = NULL;

            exception_lineno = 398;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_6 = par_position;
        tmp_compexpr_right_6 = const_int_0;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 398;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_assattr_target_2;
            tmp_assattr_name_2 = Py_None;
            CHECK_OBJECT( par_new_child );
            tmp_assattr_target_2 = par_new_child;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_previous_sibling, tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 399;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_3;
            PyObject *tmp_assattr_target_3;
            CHECK_OBJECT( par_self );
            tmp_assattr_name_3 = par_self;
            CHECK_OBJECT( par_new_child );
            tmp_assattr_target_3 = par_new_child;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_previous_element, tmp_assattr_name_3 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 400;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_8;
        branch_no_8:;
        {
            PyObject *tmp_assign_source_10;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_source_name_6;
            PyObject *tmp_subscript_name_1;
            PyObject *tmp_left_name_3;
            PyObject *tmp_right_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_6 = par_self;
            tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_contents );
            if ( tmp_subscribed_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 402;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            if ( par_position == NULL )
            {
                Py_DECREF( tmp_subscribed_name_1 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "position" );
                exception_tb = NULL;

                exception_lineno = 402;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_left_name_3 = par_position;
            tmp_right_name_3 = const_int_pos_1;
            tmp_subscript_name_1 = BINARY_OPERATION_SUB( tmp_left_name_3, tmp_right_name_3 );
            if ( tmp_subscript_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_subscribed_name_1 );

                exception_lineno = 402;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_10 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
            Py_DECREF( tmp_subscribed_name_1 );
            Py_DECREF( tmp_subscript_name_1 );
            if ( tmp_assign_source_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 402;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_previous_child == NULL );
            var_previous_child = tmp_assign_source_10;
        }
        {
            PyObject *tmp_assattr_name_4;
            PyObject *tmp_assattr_target_4;
            CHECK_OBJECT( var_previous_child );
            tmp_assattr_name_4 = var_previous_child;
            CHECK_OBJECT( par_new_child );
            tmp_assattr_target_4 = par_new_child;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_previous_sibling, tmp_assattr_name_4 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 403;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_5;
            PyObject *tmp_assattr_target_5;
            PyObject *tmp_source_name_7;
            CHECK_OBJECT( par_new_child );
            tmp_assattr_name_5 = par_new_child;
            CHECK_OBJECT( par_new_child );
            tmp_source_name_7 = par_new_child;
            tmp_assattr_target_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_previous_sibling );
            if ( tmp_assattr_target_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 404;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_next_sibling, tmp_assattr_name_5 );
            Py_DECREF( tmp_assattr_target_5 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 404;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assattr_name_6;
            PyObject *tmp_called_instance_4;
            PyObject *tmp_assattr_target_6;
            CHECK_OBJECT( var_previous_child );
            tmp_called_instance_4 = var_previous_child;
            frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 405;
            tmp_assattr_name_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain__last_descendant, &PyTuple_GET_ITEM( const_tuple_false_tuple, 0 ) );

            if ( tmp_assattr_name_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 405;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_new_child );
            tmp_assattr_target_6 = par_new_child;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_previous_element, tmp_assattr_name_6 );
            Py_DECREF( tmp_assattr_name_6 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 405;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_8:;
    }
    {
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_compexpr_left_7;
        PyObject *tmp_compexpr_right_7;
        PyObject *tmp_source_name_8;
        CHECK_OBJECT( par_new_child );
        tmp_source_name_8 = par_new_child;
        tmp_compexpr_left_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_previous_element );
        if ( tmp_compexpr_left_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 406;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_7 = Py_None;
        tmp_condition_result_9 = ( tmp_compexpr_left_7 != tmp_compexpr_right_7 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_7 );
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_assattr_target_7;
            PyObject *tmp_source_name_9;
            CHECK_OBJECT( par_new_child );
            tmp_assattr_name_7 = par_new_child;
            CHECK_OBJECT( par_new_child );
            tmp_source_name_9 = par_new_child;
            tmp_assattr_target_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_previous_element );
            if ( tmp_assattr_target_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 407;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_next_element, tmp_assattr_name_7 );
            Py_DECREF( tmp_assattr_target_7 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 407;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_9:;
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_called_instance_5;
        CHECK_OBJECT( par_new_child );
        tmp_called_instance_5 = par_new_child;
        frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 409;
        tmp_assign_source_11 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain__last_descendant, &PyTuple_GET_ITEM( const_tuple_false_tuple, 0 ) );

        if ( tmp_assign_source_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 409;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_new_childs_last_element == NULL );
        var_new_childs_last_element = tmp_assign_source_11;
    }
    {
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_compexpr_left_8;
        PyObject *tmp_compexpr_right_8;
        PyObject *tmp_len_arg_2;
        PyObject *tmp_source_name_10;
        if ( par_position == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "position" );
            exception_tb = NULL;

            exception_lineno = 411;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_8 = par_position;
        CHECK_OBJECT( par_self );
        tmp_source_name_10 = par_self;
        tmp_len_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_contents );
        if ( tmp_len_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 411;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_8 = BUILTIN_LEN( tmp_len_arg_2 );
        Py_DECREF( tmp_len_arg_2 );
        if ( tmp_compexpr_right_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 411;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
        Py_DECREF( tmp_compexpr_right_8 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 411;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_10;
        }
        else
        {
            goto branch_no_10;
        }
        branch_yes_10:;
        {
            PyObject *tmp_assattr_name_8;
            PyObject *tmp_assattr_target_8;
            tmp_assattr_name_8 = Py_None;
            CHECK_OBJECT( par_new_child );
            tmp_assattr_target_8 = par_new_child;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_next_sibling, tmp_assattr_name_8 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 412;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assign_source_12;
            CHECK_OBJECT( par_self );
            tmp_assign_source_12 = par_self;
            assert( var_parent == NULL );
            Py_INCREF( tmp_assign_source_12 );
            var_parent = tmp_assign_source_12;
        }
        {
            PyObject *tmp_assign_source_13;
            tmp_assign_source_13 = Py_None;
            assert( var_parents_next_sibling == NULL );
            Py_INCREF( tmp_assign_source_13 );
            var_parents_next_sibling = tmp_assign_source_13;
        }
        loop_start_2:;
        {
            nuitka_bool tmp_condition_result_11;
            PyObject *tmp_operand_name_2;
            int tmp_and_left_truth_3;
            PyObject *tmp_and_left_value_3;
            PyObject *tmp_and_right_value_3;
            PyObject *tmp_compexpr_left_9;
            PyObject *tmp_compexpr_right_9;
            PyObject *tmp_compexpr_left_10;
            PyObject *tmp_compexpr_right_10;
            CHECK_OBJECT( var_parents_next_sibling );
            tmp_compexpr_left_9 = var_parents_next_sibling;
            tmp_compexpr_right_9 = Py_None;
            tmp_and_left_value_3 = ( tmp_compexpr_left_9 == tmp_compexpr_right_9 ) ? Py_True : Py_False;
            tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
            if ( tmp_and_left_truth_3 == 1 )
            {
                goto and_right_3;
            }
            else
            {
                goto and_left_3;
            }
            and_right_3:;
            CHECK_OBJECT( var_parent );
            tmp_compexpr_left_10 = var_parent;
            tmp_compexpr_right_10 = Py_None;
            tmp_and_right_value_3 = ( tmp_compexpr_left_10 != tmp_compexpr_right_10 ) ? Py_True : Py_False;
            tmp_operand_name_2 = tmp_and_right_value_3;
            goto and_end_3;
            and_left_3:;
            tmp_operand_name_2 = tmp_and_left_value_3;
            and_end_3:;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            assert( !(tmp_res == -1) );
            tmp_condition_result_11 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_11;
            }
            else
            {
                goto branch_no_11;
            }
            branch_yes_11:;
            goto loop_end_2;
            branch_no_11:;
        }
        {
            PyObject *tmp_assign_source_14;
            PyObject *tmp_source_name_11;
            CHECK_OBJECT( var_parent );
            tmp_source_name_11 = var_parent;
            tmp_assign_source_14 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_next_sibling );
            if ( tmp_assign_source_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 417;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_parents_next_sibling;
                assert( old != NULL );
                var_parents_next_sibling = tmp_assign_source_14;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_15;
            PyObject *tmp_source_name_12;
            CHECK_OBJECT( var_parent );
            tmp_source_name_12 = var_parent;
            tmp_assign_source_15 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_parent );
            if ( tmp_assign_source_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 418;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_parent;
                assert( old != NULL );
                var_parent = tmp_assign_source_15;
                Py_DECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_12;
            PyObject *tmp_compexpr_left_11;
            PyObject *tmp_compexpr_right_11;
            CHECK_OBJECT( var_parents_next_sibling );
            tmp_compexpr_left_11 = var_parents_next_sibling;
            tmp_compexpr_right_11 = Py_None;
            tmp_condition_result_12 = ( tmp_compexpr_left_11 != tmp_compexpr_right_11 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_12;
            }
            else
            {
                goto branch_no_12;
            }
            branch_yes_12:;
            goto loop_end_2;
            branch_no_12:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 416;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        goto loop_start_2;
        loop_end_2:;
        {
            nuitka_bool tmp_condition_result_13;
            PyObject *tmp_compexpr_left_12;
            PyObject *tmp_compexpr_right_12;
            if ( var_parents_next_sibling == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "parents_next_sibling" );
                exception_tb = NULL;

                exception_lineno = 422;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_12 = var_parents_next_sibling;
            tmp_compexpr_right_12 = Py_None;
            tmp_condition_result_13 = ( tmp_compexpr_left_12 != tmp_compexpr_right_12 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_13;
            }
            else
            {
                goto branch_no_13;
            }
            branch_yes_13:;
            {
                PyObject *tmp_assattr_name_9;
                PyObject *tmp_assattr_target_9;
                if ( var_parents_next_sibling == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "parents_next_sibling" );
                    exception_tb = NULL;

                    exception_lineno = 423;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_assattr_name_9 = var_parents_next_sibling;
                CHECK_OBJECT( var_new_childs_last_element );
                tmp_assattr_target_9 = var_new_childs_last_element;
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_next_element, tmp_assattr_name_9 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 423;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
            }
            goto branch_end_13;
            branch_no_13:;
            {
                PyObject *tmp_assattr_name_10;
                PyObject *tmp_assattr_target_10;
                tmp_assattr_name_10 = Py_None;
                CHECK_OBJECT( var_new_childs_last_element );
                tmp_assattr_target_10 = var_new_childs_last_element;
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain_next_element, tmp_assattr_name_10 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 427;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
            }
            branch_end_13:;
        }
        goto branch_end_10;
        branch_no_10:;
        {
            PyObject *tmp_assign_source_16;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_source_name_13;
            PyObject *tmp_subscript_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_13 = par_self;
            tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_contents );
            if ( tmp_subscribed_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 429;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            if ( par_position == NULL )
            {
                Py_DECREF( tmp_subscribed_name_2 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "position" );
                exception_tb = NULL;

                exception_lineno = 429;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_subscript_name_2 = par_position;
            tmp_assign_source_16 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
            Py_DECREF( tmp_subscribed_name_2 );
            if ( tmp_assign_source_16 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 429;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_next_child == NULL );
            var_next_child = tmp_assign_source_16;
        }
        {
            PyObject *tmp_assattr_name_11;
            PyObject *tmp_assattr_target_11;
            CHECK_OBJECT( var_next_child );
            tmp_assattr_name_11 = var_next_child;
            CHECK_OBJECT( par_new_child );
            tmp_assattr_target_11 = par_new_child;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain_next_sibling, tmp_assattr_name_11 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 430;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            nuitka_bool tmp_condition_result_14;
            PyObject *tmp_compexpr_left_13;
            PyObject *tmp_compexpr_right_13;
            PyObject *tmp_source_name_14;
            CHECK_OBJECT( par_new_child );
            tmp_source_name_14 = par_new_child;
            tmp_compexpr_left_13 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_next_sibling );
            if ( tmp_compexpr_left_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 431;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_13 = Py_None;
            tmp_condition_result_14 = ( tmp_compexpr_left_13 != tmp_compexpr_right_13 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_compexpr_left_13 );
            if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_14;
            }
            else
            {
                goto branch_no_14;
            }
            branch_yes_14:;
            {
                PyObject *tmp_assattr_name_12;
                PyObject *tmp_assattr_target_12;
                PyObject *tmp_source_name_15;
                CHECK_OBJECT( par_new_child );
                tmp_assattr_name_12 = par_new_child;
                CHECK_OBJECT( par_new_child );
                tmp_source_name_15 = par_new_child;
                tmp_assattr_target_12 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_next_sibling );
                if ( tmp_assattr_target_12 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 432;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain_previous_sibling, tmp_assattr_name_12 );
                Py_DECREF( tmp_assattr_target_12 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 432;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
            }
            branch_no_14:;
        }
        {
            PyObject *tmp_assattr_name_13;
            PyObject *tmp_assattr_target_13;
            CHECK_OBJECT( var_next_child );
            tmp_assattr_name_13 = var_next_child;
            CHECK_OBJECT( var_new_childs_last_element );
            tmp_assattr_target_13 = var_new_childs_last_element;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_13, const_str_plain_next_element, tmp_assattr_name_13 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 433;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_10:;
    }
    {
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_compexpr_left_14;
        PyObject *tmp_compexpr_right_14;
        PyObject *tmp_source_name_16;
        CHECK_OBJECT( var_new_childs_last_element );
        tmp_source_name_16 = var_new_childs_last_element;
        tmp_compexpr_left_14 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_next_element );
        if ( tmp_compexpr_left_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 435;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_14 = Py_None;
        tmp_condition_result_15 = ( tmp_compexpr_left_14 != tmp_compexpr_right_14 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_compexpr_left_14 );
        if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_15;
        }
        else
        {
            goto branch_no_15;
        }
        branch_yes_15:;
        {
            PyObject *tmp_assattr_name_14;
            PyObject *tmp_assattr_target_14;
            PyObject *tmp_source_name_17;
            CHECK_OBJECT( var_new_childs_last_element );
            tmp_assattr_name_14 = var_new_childs_last_element;
            CHECK_OBJECT( var_new_childs_last_element );
            tmp_source_name_17 = var_new_childs_last_element;
            tmp_assattr_target_14 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_next_element );
            if ( tmp_assattr_target_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 436;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_14, const_str_plain_previous_element, tmp_assattr_name_14 );
            Py_DECREF( tmp_assattr_target_14 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 436;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_15:;
    }
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_18;
        PyObject *tmp_source_name_19;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        CHECK_OBJECT( par_self );
        tmp_source_name_19 = par_self;
        tmp_source_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_contents );
        if ( tmp_source_name_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 437;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_insert );
        Py_DECREF( tmp_source_name_18 );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 437;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        if ( par_position == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "position" );
            exception_tb = NULL;

            exception_lineno = 437;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_7 = par_position;
        CHECK_OBJECT( par_new_child );
        tmp_args_element_name_8 = par_new_child;
        frame_946ab5af3c25362849801c2db8c2098f->m_frame.f_lineno = 437;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 437;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_3 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_946ab5af3c25362849801c2db8c2098f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_946ab5af3c25362849801c2db8c2098f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_946ab5af3c25362849801c2db8c2098f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_946ab5af3c25362849801c2db8c2098f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_946ab5af3c25362849801c2db8c2098f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_946ab5af3c25362849801c2db8c2098f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_946ab5af3c25362849801c2db8c2098f,
        type_description_1,
        par_self,
        par_position,
        par_new_child,
        var_subchild,
        var_parents_next_sibling,
        var_parent,
        var_next_child,
        var_new_childs_last_element,
        var_BeautifulSoup,
        var_current_index,
        var_previous_child
    );


    // Release cached frame.
    if ( frame_946ab5af3c25362849801c2db8c2098f == cache_frame_946ab5af3c25362849801c2db8c2098f )
    {
        Py_DECREF( frame_946ab5af3c25362849801c2db8c2098f );
    }
    cache_frame_946ab5af3c25362849801c2db8c2098f = NULL;

    assertFrameObject( frame_946ab5af3c25362849801c2db8c2098f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_24_insert );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_new_child );
    Py_DECREF( par_new_child );
    par_new_child = NULL;

    Py_XDECREF( var_subchild );
    var_subchild = NULL;

    Py_XDECREF( var_parents_next_sibling );
    var_parents_next_sibling = NULL;

    Py_XDECREF( var_parent );
    var_parent = NULL;

    Py_XDECREF( var_next_child );
    var_next_child = NULL;

    Py_XDECREF( var_new_childs_last_element );
    var_new_childs_last_element = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_BeautifulSoup );
    Py_DECREF( var_BeautifulSoup );
    var_BeautifulSoup = NULL;

    Py_XDECREF( par_position );
    par_position = NULL;

    Py_XDECREF( var_current_index );
    var_current_index = NULL;

    Py_XDECREF( var_previous_child );
    var_previous_child = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_new_child );
    par_new_child = NULL;

    Py_XDECREF( var_subchild );
    var_subchild = NULL;

    Py_XDECREF( var_parents_next_sibling );
    var_parents_next_sibling = NULL;

    Py_XDECREF( var_parent );
    var_parent = NULL;

    Py_XDECREF( var_next_child );
    var_next_child = NULL;

    Py_XDECREF( var_new_childs_last_element );
    var_new_childs_last_element = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_BeautifulSoup );
    var_BeautifulSoup = NULL;

    Py_XDECREF( par_position );
    par_position = NULL;

    Py_XDECREF( var_current_index );
    var_current_index = NULL;

    Py_XDECREF( var_previous_child );
    var_previous_child = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_24_insert );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_25_append( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tag = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_fc15a6c52943040a99d66eb74afa26d4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fc15a6c52943040a99d66eb74afa26d4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fc15a6c52943040a99d66eb74afa26d4, codeobj_fc15a6c52943040a99d66eb74afa26d4, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_fc15a6c52943040a99d66eb74afa26d4 = cache_frame_fc15a6c52943040a99d66eb74afa26d4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fc15a6c52943040a99d66eb74afa26d4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fc15a6c52943040a99d66eb74afa26d4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_insert );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_contents );
        if ( tmp_len_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        Py_DECREF( tmp_len_arg_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_tag );
        tmp_args_element_name_2 = par_tag;
        frame_fc15a6c52943040a99d66eb74afa26d4->m_frame.f_lineno = 441;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 441;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc15a6c52943040a99d66eb74afa26d4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc15a6c52943040a99d66eb74afa26d4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fc15a6c52943040a99d66eb74afa26d4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fc15a6c52943040a99d66eb74afa26d4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fc15a6c52943040a99d66eb74afa26d4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fc15a6c52943040a99d66eb74afa26d4,
        type_description_1,
        par_self,
        par_tag
    );


    // Release cached frame.
    if ( frame_fc15a6c52943040a99d66eb74afa26d4 == cache_frame_fc15a6c52943040a99d66eb74afa26d4 )
    {
        Py_DECREF( frame_fc15a6c52943040a99d66eb74afa26d4 );
    }
    cache_frame_fc15a6c52943040a99d66eb74afa26d4 = NULL;

    assertFrameObject( frame_fc15a6c52943040a99d66eb74afa26d4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_25_append );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_tag );
    Py_DECREF( par_tag );
    par_tag = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_tag );
    Py_DECREF( par_tag );
    par_tag = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_25_append );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_26_extend( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tags = python_pars[ 1 ];
    PyObject *var_tag = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_783bb656bd248096fe5dff1b6735d020;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_783bb656bd248096fe5dff1b6735d020 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_783bb656bd248096fe5dff1b6735d020, codeobj_783bb656bd248096fe5dff1b6735d020, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_783bb656bd248096fe5dff1b6735d020 = cache_frame_783bb656bd248096fe5dff1b6735d020;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_783bb656bd248096fe5dff1b6735d020 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_783bb656bd248096fe5dff1b6735d020 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_tags );
        tmp_iter_arg_1 = par_tags;
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 445;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "ooo";
                exception_lineno = 445;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_tag;
            var_tag = tmp_assign_source_3;
            Py_INCREF( var_tag );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( var_tag );
        tmp_args_element_name_1 = var_tag;
        frame_783bb656bd248096fe5dff1b6735d020->m_frame.f_lineno = 446;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 446;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 445;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_783bb656bd248096fe5dff1b6735d020 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_783bb656bd248096fe5dff1b6735d020 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_783bb656bd248096fe5dff1b6735d020, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_783bb656bd248096fe5dff1b6735d020->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_783bb656bd248096fe5dff1b6735d020, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_783bb656bd248096fe5dff1b6735d020,
        type_description_1,
        par_self,
        par_tags,
        var_tag
    );


    // Release cached frame.
    if ( frame_783bb656bd248096fe5dff1b6735d020 == cache_frame_783bb656bd248096fe5dff1b6735d020 )
    {
        Py_DECREF( frame_783bb656bd248096fe5dff1b6735d020 );
    }
    cache_frame_783bb656bd248096fe5dff1b6735d020 = NULL;

    assertFrameObject( frame_783bb656bd248096fe5dff1b6735d020 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_26_extend );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_tag );
    var_tag = NULL;

    CHECK_OBJECT( (PyObject *)par_tags );
    Py_DECREF( par_tags );
    par_tags = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_tag );
    var_tag = NULL;

    CHECK_OBJECT( (PyObject *)par_tags );
    Py_DECREF( par_tags );
    par_tags = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_26_extend );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_27_insert_before( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *par_args = python_pars[ 1 ];
    PyObject *var_predecessor = NULL;
    PyObject *var_index = NULL;
    PyObject *var_parent = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_3c97804e638eb41eb1fba6e47726f3bb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_3c97804e638eb41eb1fba6e47726f3bb = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3c97804e638eb41eb1fba6e47726f3bb, codeobj_3c97804e638eb41eb1fba6e47726f3bb, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3c97804e638eb41eb1fba6e47726f3bb = cache_frame_3c97804e638eb41eb1fba6e47726f3bb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3c97804e638eb41eb1fba6e47726f3bb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3c97804e638eb41eb1fba6e47726f3bb ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_source_name_1 = PyCell_GET( par_self );
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 454;
            type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        assert( var_parent == NULL );
        var_parent = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_parent );
        tmp_compexpr_left_1 = var_parent;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_750906c63df60c8f9857f2595e15aebc;
            frame_3c97804e638eb41eb1fba6e47726f3bb->m_frame.f_lineno = 456;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 456;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        int tmp_truth_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_any );
        assert( tmp_called_name_1 != NULL );
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_args );
            tmp_iter_arg_1 = par_args;
            tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 458;
                type_description_1 = "coooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_args_element_name_1 = bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element$$$function_27_insert_before );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element$$$function_27_insert_before );
        return NULL;
        outline_result_1:;
        frame_3c97804e638eb41eb1fba6e47726f3bb->m_frame.f_lineno = 458;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 458;
            type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 458;
            type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_6c6b5a57155bef64d81c4e3930a40571;
            frame_3c97804e638eb41eb1fba6e47726f3bb->m_frame.f_lineno = 459;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 459;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( par_args );
        tmp_iter_arg_2 = par_args;
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 460;
            type_description_1 = "coooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "coooo";
                exception_lineno = 460;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_predecessor;
            var_predecessor = tmp_assign_source_5;
            Py_INCREF( var_predecessor );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( var_predecessor );
        tmp_isinstance_inst_1 = var_predecessor;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PageElement );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PageElement );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PageElement" );
            exception_tb = NULL;

            exception_lineno = 463;
            type_description_1 = "coooo";
            goto try_except_handler_3;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 463;
            type_description_1 = "coooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( var_predecessor );
            tmp_called_instance_1 = var_predecessor;
            frame_3c97804e638eb41eb1fba6e47726f3bb->m_frame.f_lineno = 464;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_extract );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 464;
                type_description_1 = "coooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_parent );
        tmp_called_instance_2 = var_parent;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_2 = PyCell_GET( par_self );
        frame_3c97804e638eb41eb1fba6e47726f3bb->m_frame.f_lineno = 465;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_index, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 465;
            type_description_1 = "coooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_index;
            var_index = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( var_parent );
        tmp_called_instance_3 = var_parent;
        CHECK_OBJECT( var_index );
        tmp_args_element_name_3 = var_index;
        CHECK_OBJECT( var_predecessor );
        tmp_args_element_name_4 = var_predecessor;
        frame_3c97804e638eb41eb1fba6e47726f3bb->m_frame.f_lineno = 466;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_3 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_insert, call_args );
        }

        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 466;
            type_description_1 = "coooo";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 460;
        type_description_1 = "coooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c97804e638eb41eb1fba6e47726f3bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c97804e638eb41eb1fba6e47726f3bb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3c97804e638eb41eb1fba6e47726f3bb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3c97804e638eb41eb1fba6e47726f3bb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3c97804e638eb41eb1fba6e47726f3bb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3c97804e638eb41eb1fba6e47726f3bb,
        type_description_1,
        par_self,
        par_args,
        var_predecessor,
        var_index,
        var_parent
    );


    // Release cached frame.
    if ( frame_3c97804e638eb41eb1fba6e47726f3bb == cache_frame_3c97804e638eb41eb1fba6e47726f3bb )
    {
        Py_DECREF( frame_3c97804e638eb41eb1fba6e47726f3bb );
    }
    cache_frame_3c97804e638eb41eb1fba6e47726f3bb = NULL;

    assertFrameObject( frame_3c97804e638eb41eb1fba6e47726f3bb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_27_insert_before );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_predecessor );
    var_predecessor = NULL;

    Py_XDECREF( var_index );
    var_index = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)var_parent );
    Py_DECREF( var_parent );
    var_parent = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_predecessor );
    var_predecessor = NULL;

    Py_XDECREF( var_index );
    var_index = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    Py_XDECREF( var_parent );
    var_parent = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_27_insert_before );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_locals *generator_heap = (struct bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_6ab36e15dbfb5ac3c50a9a40b572a61e, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Noc";
                generator_heap->exception_lineno = 458;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_x );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_x );
        tmp_compexpr_left_1 = generator_heap->var_x;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 458;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_1 = PyCell_GET( generator->m_closure[1] );
        tmp_expression_name_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_expression_name_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 458;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 458;
        generator_heap->type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x,
            generator->m_closure[1]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_context,
        module_bs4$element,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_6ab36e15dbfb5ac3c50a9a40b572a61e,
        2,
        sizeof(struct bs4$element$$$function_27_insert_before$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_bs4$element$$$function_28_insert_after( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *par_args = python_pars[ 1 ];
    PyObject *var_index = NULL;
    PyObject *var_parent = NULL;
    PyObject *var_offset = NULL;
    PyObject *var_successor = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    struct Nuitka_FrameObject *frame_87ceeefa37b5b79d65a252ac8de9f62d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_87ceeefa37b5b79d65a252ac8de9f62d = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_87ceeefa37b5b79d65a252ac8de9f62d, codeobj_87ceeefa37b5b79d65a252ac8de9f62d, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_87ceeefa37b5b79d65a252ac8de9f62d = cache_frame_87ceeefa37b5b79d65a252ac8de9f62d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_87ceeefa37b5b79d65a252ac8de9f62d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_87ceeefa37b5b79d65a252ac8de9f62d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_source_name_1 = PyCell_GET( par_self );
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 475;
            type_description_1 = "cooooo";
            goto frame_exception_exit_1;
        }
        assert( var_parent == NULL );
        var_parent = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_parent );
        tmp_compexpr_left_1 = var_parent;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_de65d084d97cebdd56daaf35cf257c00;
            frame_87ceeefa37b5b79d65a252ac8de9f62d->m_frame.f_lineno = 477;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 477;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "cooooo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        int tmp_truth_name_1;
        tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_any );
        assert( tmp_called_name_1 != NULL );
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_args );
            tmp_iter_arg_1 = par_args;
            tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 479;
                type_description_1 = "cooooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_genexpr_1__$0 == NULL );
            tmp_genexpr_1__$0 = tmp_assign_source_2;
        }
        // Tried code:
        tmp_args_element_name_1 = bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_maker();

        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );
        ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] = par_self;
        Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_args_element_name_1)->m_closure[1] );


        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element$$$function_28_insert_after );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        goto outline_result_1;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
        Py_DECREF( tmp_genexpr_1__$0 );
        tmp_genexpr_1__$0 = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element$$$function_28_insert_after );
        return NULL;
        outline_result_1:;
        frame_87ceeefa37b5b79d65a252ac8de9f62d->m_frame.f_lineno = 479;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 479;
            type_description_1 = "cooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 479;
            type_description_1 = "cooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_2;
            PyObject *tmp_make_exception_arg_2;
            tmp_make_exception_arg_2 = const_str_digest_5b172c0b3f4a4b2fa095be9f536d19f3;
            frame_87ceeefa37b5b79d65a252ac8de9f62d->m_frame.f_lineno = 480;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_2 };
                tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_2 == NULL) );
            exception_type = tmp_raise_type_2;
            exception_lineno = 480;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "cooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = const_int_0;
        assert( var_offset == NULL );
        Py_INCREF( tmp_assign_source_3 );
        var_offset = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( par_args );
        tmp_iter_arg_2 = par_args;
        tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 483;
            type_description_1 = "cooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "cooooo";
                exception_lineno = 483;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_successor;
            var_successor = tmp_assign_source_6;
            Py_INCREF( var_successor );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( var_successor );
        tmp_isinstance_inst_1 = var_successor;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PageElement );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PageElement );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PageElement" );
            exception_tb = NULL;

            exception_lineno = 486;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 486;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_2;
            CHECK_OBJECT( var_successor );
            tmp_called_instance_1 = var_successor;
            frame_87ceeefa37b5b79d65a252ac8de9f62d->m_frame.f_lineno = 487;
            tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_extract );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 487;
                type_description_1 = "cooooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_parent );
        tmp_called_instance_2 = var_parent;
        CHECK_OBJECT( PyCell_GET( par_self ) );
        tmp_args_element_name_2 = PyCell_GET( par_self );
        frame_87ceeefa37b5b79d65a252ac8de9f62d->m_frame.f_lineno = 488;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_assign_source_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_index, call_args );
        }

        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 488;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = var_index;
            var_index = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( var_parent );
        tmp_source_name_2 = var_parent;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_insert );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 489;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_index );
        tmp_left_name_2 = var_index;
        tmp_right_name_1 = const_int_pos_1;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 489;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_offset );
        tmp_right_name_2 = var_offset;
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 489;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_successor );
        tmp_args_element_name_4 = var_successor;
        frame_87ceeefa37b5b79d65a252ac8de9f62d->m_frame.f_lineno = 489;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        if ( tmp_call_result_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 489;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_3 );
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_3;
        CHECK_OBJECT( var_offset );
        tmp_left_name_3 = var_offset;
        tmp_right_name_3 = const_int_pos_1;
        tmp_result = BINARY_OPERATION_ADD_OBJECT_INT_INPLACE( &tmp_left_name_3, tmp_right_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 490;
            type_description_1 = "cooooo";
            goto try_except_handler_3;
        }
        tmp_assign_source_8 = tmp_left_name_3;
        var_offset = tmp_assign_source_8;

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description_1 = "cooooo";
        goto try_except_handler_3;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87ceeefa37b5b79d65a252ac8de9f62d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_87ceeefa37b5b79d65a252ac8de9f62d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_87ceeefa37b5b79d65a252ac8de9f62d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_87ceeefa37b5b79d65a252ac8de9f62d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_87ceeefa37b5b79d65a252ac8de9f62d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_87ceeefa37b5b79d65a252ac8de9f62d,
        type_description_1,
        par_self,
        par_args,
        var_index,
        var_parent,
        var_offset,
        var_successor
    );


    // Release cached frame.
    if ( frame_87ceeefa37b5b79d65a252ac8de9f62d == cache_frame_87ceeefa37b5b79d65a252ac8de9f62d )
    {
        Py_DECREF( frame_87ceeefa37b5b79d65a252ac8de9f62d );
    }
    cache_frame_87ceeefa37b5b79d65a252ac8de9f62d = NULL;

    assertFrameObject( frame_87ceeefa37b5b79d65a252ac8de9f62d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_28_insert_after );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_index );
    var_index = NULL;

    CHECK_OBJECT( (PyObject *)var_parent );
    Py_DECREF( var_parent );
    var_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)var_offset );
    Py_DECREF( var_offset );
    var_offset = NULL;

    Py_XDECREF( var_successor );
    var_successor = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_index );
    var_index = NULL;

    Py_XDECREF( var_parent );
    var_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    Py_XDECREF( var_offset );
    var_offset = NULL;

    Py_XDECREF( var_successor );
    var_successor = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_28_insert_after );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_locals {
    PyObject *var_x;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_locals *generator_heap = (struct bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_x = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_0c917b25026b6e4ab770ad078decf301, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Noc";
                generator_heap->exception_lineno = 479;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_x;
            generator_heap->var_x = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_x );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_x );
        tmp_compexpr_left_1 = generator_heap->var_x;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 479;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_1 = PyCell_GET( generator->m_closure[1] );
        tmp_expression_name_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_expression_name_1 );
        Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), NULL );
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 479;
            generator_heap->type_description_1 = "Noc";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 479;
        generator_heap->type_description_1 = "Noc";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_x,
            generator->m_closure[1]
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_x );
    generator_heap->var_x = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_context,
        module_bs4$element,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_0c917b25026b6e4ab770ad078decf301,
        2,
        sizeof(struct bs4$element$$$function_28_insert_after$$$genexpr_1_genexpr_locals)
    );
}


static PyObject *impl_bs4$element$$$function_29_find_next( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_9bd7632ac089adc376ecbbcb2f6dc690;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9bd7632ac089adc376ecbbcb2f6dc690 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9bd7632ac089adc376ecbbcb2f6dc690, codeobj_9bd7632ac089adc376ecbbcb2f6dc690, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9bd7632ac089adc376ecbbcb2f6dc690 = cache_frame_9bd7632ac089adc376ecbbcb2f6dc690;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9bd7632ac089adc376ecbbcb2f6dc690 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9bd7632ac089adc376ecbbcb2f6dc690 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_one );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 495;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_find_all_next );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );

            exception_lineno = 495;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg2_1 = PyTuple_New( 4 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 495;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bd7632ac089adc376ecbbcb2f6dc690 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bd7632ac089adc376ecbbcb2f6dc690 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9bd7632ac089adc376ecbbcb2f6dc690 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9bd7632ac089adc376ecbbcb2f6dc690, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9bd7632ac089adc376ecbbcb2f6dc690->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9bd7632ac089adc376ecbbcb2f6dc690, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9bd7632ac089adc376ecbbcb2f6dc690,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_9bd7632ac089adc376ecbbcb2f6dc690 == cache_frame_9bd7632ac089adc376ecbbcb2f6dc690 )
    {
        Py_DECREF( frame_9bd7632ac089adc376ecbbcb2f6dc690 );
    }
    cache_frame_9bd7632ac089adc376ecbbcb2f6dc690 = NULL;

    assertFrameObject( frame_9bd7632ac089adc376ecbbcb2f6dc690 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_29_find_next );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_29_find_next );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_30_find_all_next( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_limit = python_pars[ 4 ];
    PyObject *par_kwargs = python_pars[ 5 ];
    struct Nuitka_FrameObject *frame_eda20f939454e2c4a84abc8a549d6b2c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_eda20f939454e2c4a84abc8a549d6b2c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eda20f939454e2c4a84abc8a549d6b2c, codeobj_eda20f939454e2c4a84abc8a549d6b2c, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_eda20f939454e2c4a84abc8a549d6b2c = cache_frame_eda20f939454e2c4a84abc8a549d6b2c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eda20f939454e2c4a84abc8a549d6b2c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eda20f939454e2c4a84abc8a549d6b2c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 502;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 5 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_limit );
        tmp_tuple_element_1 = par_limit;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_next_elements );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 502;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 502;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eda20f939454e2c4a84abc8a549d6b2c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_eda20f939454e2c4a84abc8a549d6b2c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eda20f939454e2c4a84abc8a549d6b2c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eda20f939454e2c4a84abc8a549d6b2c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eda20f939454e2c4a84abc8a549d6b2c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eda20f939454e2c4a84abc8a549d6b2c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_eda20f939454e2c4a84abc8a549d6b2c,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_limit,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_eda20f939454e2c4a84abc8a549d6b2c == cache_frame_eda20f939454e2c4a84abc8a549d6b2c )
    {
        Py_DECREF( frame_eda20f939454e2c4a84abc8a549d6b2c );
    }
    cache_frame_eda20f939454e2c4a84abc8a549d6b2c = NULL;

    assertFrameObject( frame_eda20f939454e2c4a84abc8a549d6b2c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_30_find_all_next );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_30_find_all_next );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_31_find_next_sibling( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_c58eed4264ebc40dcacae7730d18dcc1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c58eed4264ebc40dcacae7730d18dcc1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c58eed4264ebc40dcacae7730d18dcc1, codeobj_c58eed4264ebc40dcacae7730d18dcc1, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c58eed4264ebc40dcacae7730d18dcc1 = cache_frame_c58eed4264ebc40dcacae7730d18dcc1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c58eed4264ebc40dcacae7730d18dcc1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c58eed4264ebc40dcacae7730d18dcc1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_one );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 509;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_find_next_siblings );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );

            exception_lineno = 509;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg2_1 = PyTuple_New( 4 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 509;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c58eed4264ebc40dcacae7730d18dcc1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c58eed4264ebc40dcacae7730d18dcc1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c58eed4264ebc40dcacae7730d18dcc1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c58eed4264ebc40dcacae7730d18dcc1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c58eed4264ebc40dcacae7730d18dcc1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c58eed4264ebc40dcacae7730d18dcc1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c58eed4264ebc40dcacae7730d18dcc1,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_c58eed4264ebc40dcacae7730d18dcc1 == cache_frame_c58eed4264ebc40dcacae7730d18dcc1 )
    {
        Py_DECREF( frame_c58eed4264ebc40dcacae7730d18dcc1 );
    }
    cache_frame_c58eed4264ebc40dcacae7730d18dcc1 = NULL;

    assertFrameObject( frame_c58eed4264ebc40dcacae7730d18dcc1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_31_find_next_sibling );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_31_find_next_sibling );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_32_find_next_siblings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_limit = python_pars[ 4 ];
    PyObject *par_kwargs = python_pars[ 5 ];
    struct Nuitka_FrameObject *frame_8498af97c4b561c649402a169426a52c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8498af97c4b561c649402a169426a52c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8498af97c4b561c649402a169426a52c, codeobj_8498af97c4b561c649402a169426a52c, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8498af97c4b561c649402a169426a52c = cache_frame_8498af97c4b561c649402a169426a52c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8498af97c4b561c649402a169426a52c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8498af97c4b561c649402a169426a52c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 517;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 5 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_limit );
        tmp_tuple_element_1 = par_limit;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_next_siblings );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 518;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 517;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8498af97c4b561c649402a169426a52c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8498af97c4b561c649402a169426a52c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8498af97c4b561c649402a169426a52c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8498af97c4b561c649402a169426a52c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8498af97c4b561c649402a169426a52c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8498af97c4b561c649402a169426a52c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8498af97c4b561c649402a169426a52c,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_limit,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_8498af97c4b561c649402a169426a52c == cache_frame_8498af97c4b561c649402a169426a52c )
    {
        Py_DECREF( frame_8498af97c4b561c649402a169426a52c );
    }
    cache_frame_8498af97c4b561c649402a169426a52c = NULL;

    assertFrameObject( frame_8498af97c4b561c649402a169426a52c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_32_find_next_siblings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_32_find_next_siblings );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_33_find_previous( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_5989077b2bed5d70168fdd512d1c6b58;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5989077b2bed5d70168fdd512d1c6b58 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5989077b2bed5d70168fdd512d1c6b58, codeobj_5989077b2bed5d70168fdd512d1c6b58, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5989077b2bed5d70168fdd512d1c6b58 = cache_frame_5989077b2bed5d70168fdd512d1c6b58;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5989077b2bed5d70168fdd512d1c6b58 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5989077b2bed5d70168fdd512d1c6b58 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_one );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 525;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_find_all_previous );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );

            exception_lineno = 526;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg2_1 = PyTuple_New( 4 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 525;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5989077b2bed5d70168fdd512d1c6b58 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5989077b2bed5d70168fdd512d1c6b58 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5989077b2bed5d70168fdd512d1c6b58 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5989077b2bed5d70168fdd512d1c6b58, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5989077b2bed5d70168fdd512d1c6b58->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5989077b2bed5d70168fdd512d1c6b58, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5989077b2bed5d70168fdd512d1c6b58,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_5989077b2bed5d70168fdd512d1c6b58 == cache_frame_5989077b2bed5d70168fdd512d1c6b58 )
    {
        Py_DECREF( frame_5989077b2bed5d70168fdd512d1c6b58 );
    }
    cache_frame_5989077b2bed5d70168fdd512d1c6b58 = NULL;

    assertFrameObject( frame_5989077b2bed5d70168fdd512d1c6b58 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_33_find_previous );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_33_find_previous );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_34_find_all_previous( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_limit = python_pars[ 4 ];
    PyObject *par_kwargs = python_pars[ 5 ];
    struct Nuitka_FrameObject *frame_ebc3dc41d3b05d7a4f045cf17e6248c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ebc3dc41d3b05d7a4f045cf17e6248c6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ebc3dc41d3b05d7a4f045cf17e6248c6, codeobj_ebc3dc41d3b05d7a4f045cf17e6248c6, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ebc3dc41d3b05d7a4f045cf17e6248c6 = cache_frame_ebc3dc41d3b05d7a4f045cf17e6248c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 533;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 5 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_limit );
        tmp_tuple_element_1 = par_limit;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_previous_elements );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 533;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 533;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ebc3dc41d3b05d7a4f045cf17e6248c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ebc3dc41d3b05d7a4f045cf17e6248c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ebc3dc41d3b05d7a4f045cf17e6248c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ebc3dc41d3b05d7a4f045cf17e6248c6,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_limit,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 == cache_frame_ebc3dc41d3b05d7a4f045cf17e6248c6 )
    {
        Py_DECREF( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 );
    }
    cache_frame_ebc3dc41d3b05d7a4f045cf17e6248c6 = NULL;

    assertFrameObject( frame_ebc3dc41d3b05d7a4f045cf17e6248c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_34_find_all_previous );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_34_find_all_previous );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_35_find_previous_sibling( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_611a6e46dc9df08fc7bf62dc91c5fc9f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_611a6e46dc9df08fc7bf62dc91c5fc9f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_611a6e46dc9df08fc7bf62dc91c5fc9f, codeobj_611a6e46dc9df08fc7bf62dc91c5fc9f, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_611a6e46dc9df08fc7bf62dc91c5fc9f = cache_frame_611a6e46dc9df08fc7bf62dc91c5fc9f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_611a6e46dc9df08fc7bf62dc91c5fc9f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_611a6e46dc9df08fc7bf62dc91c5fc9f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_one );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 541;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_find_previous_siblings );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );

            exception_lineno = 541;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg2_1 = PyTuple_New( 4 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 541;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_611a6e46dc9df08fc7bf62dc91c5fc9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_611a6e46dc9df08fc7bf62dc91c5fc9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_611a6e46dc9df08fc7bf62dc91c5fc9f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_611a6e46dc9df08fc7bf62dc91c5fc9f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_611a6e46dc9df08fc7bf62dc91c5fc9f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_611a6e46dc9df08fc7bf62dc91c5fc9f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_611a6e46dc9df08fc7bf62dc91c5fc9f,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_611a6e46dc9df08fc7bf62dc91c5fc9f == cache_frame_611a6e46dc9df08fc7bf62dc91c5fc9f )
    {
        Py_DECREF( frame_611a6e46dc9df08fc7bf62dc91c5fc9f );
    }
    cache_frame_611a6e46dc9df08fc7bf62dc91c5fc9f = NULL;

    assertFrameObject( frame_611a6e46dc9df08fc7bf62dc91c5fc9f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_35_find_previous_sibling );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_35_find_previous_sibling );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_36_find_previous_siblings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_limit = python_pars[ 4 ];
    PyObject *par_kwargs = python_pars[ 5 ];
    struct Nuitka_FrameObject *frame_65948314dd15ad5fa1518d4867d6d673;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_65948314dd15ad5fa1518d4867d6d673 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_65948314dd15ad5fa1518d4867d6d673, codeobj_65948314dd15ad5fa1518d4867d6d673, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_65948314dd15ad5fa1518d4867d6d673 = cache_frame_65948314dd15ad5fa1518d4867d6d673;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_65948314dd15ad5fa1518d4867d6d673 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_65948314dd15ad5fa1518d4867d6d673 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 549;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 5 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_limit );
        tmp_tuple_element_1 = par_limit;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_previous_siblings );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 550;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 549;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65948314dd15ad5fa1518d4867d6d673 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_65948314dd15ad5fa1518d4867d6d673 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_65948314dd15ad5fa1518d4867d6d673 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_65948314dd15ad5fa1518d4867d6d673, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_65948314dd15ad5fa1518d4867d6d673->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_65948314dd15ad5fa1518d4867d6d673, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_65948314dd15ad5fa1518d4867d6d673,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_limit,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_65948314dd15ad5fa1518d4867d6d673 == cache_frame_65948314dd15ad5fa1518d4867d6d673 )
    {
        Py_DECREF( frame_65948314dd15ad5fa1518d4867d6d673 );
    }
    cache_frame_65948314dd15ad5fa1518d4867d6d673 = NULL;

    assertFrameObject( frame_65948314dd15ad5fa1518d4867d6d673 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_36_find_previous_siblings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_36_find_previous_siblings );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_37_find_parent( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_kwargs = python_pars[ 3 ];
    PyObject *var_l = NULL;
    PyObject *var_r = NULL;
    struct Nuitka_FrameObject *frame_493a1bcafa53978c92f68edb9700afc8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_493a1bcafa53978c92f68edb9700afc8 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert( var_r == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_r = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_493a1bcafa53978c92f68edb9700afc8, codeobj_493a1bcafa53978c92f68edb9700afc8, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_493a1bcafa53978c92f68edb9700afc8 = cache_frame_493a1bcafa53978c92f68edb9700afc8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_493a1bcafa53978c92f68edb9700afc8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_493a1bcafa53978c92f68edb9700afc8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_find_parents );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 560;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_int_pos_1;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_assign_source_2 = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 560;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_l == NULL );
        var_l = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_l );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_l );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 561;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( var_l );
            tmp_subscribed_name_1 = var_l;
            tmp_subscript_name_1 = const_int_0;
            tmp_assign_source_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 562;
                type_description_1 = "oooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_r;
                assert( old != NULL );
                var_r = tmp_assign_source_3;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_493a1bcafa53978c92f68edb9700afc8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_493a1bcafa53978c92f68edb9700afc8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_493a1bcafa53978c92f68edb9700afc8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_493a1bcafa53978c92f68edb9700afc8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_493a1bcafa53978c92f68edb9700afc8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_493a1bcafa53978c92f68edb9700afc8,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_kwargs,
        var_l,
        var_r
    );


    // Release cached frame.
    if ( frame_493a1bcafa53978c92f68edb9700afc8 == cache_frame_493a1bcafa53978c92f68edb9700afc8 )
    {
        Py_DECREF( frame_493a1bcafa53978c92f68edb9700afc8 );
    }
    cache_frame_493a1bcafa53978c92f68edb9700afc8 = NULL;

    assertFrameObject( frame_493a1bcafa53978c92f68edb9700afc8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_r );
    tmp_return_value = var_r;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_37_find_parent );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    CHECK_OBJECT( (PyObject *)var_r );
    Py_DECREF( var_r );
    var_r = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    CHECK_OBJECT( (PyObject *)var_r );
    Py_DECREF( var_r );
    var_r = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_37_find_parent );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_38_find_parents( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_limit = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_c53dfbe39dd3a6e1884caed588a6e018;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c53dfbe39dd3a6e1884caed588a6e018 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c53dfbe39dd3a6e1884caed588a6e018, codeobj_c53dfbe39dd3a6e1884caed588a6e018, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c53dfbe39dd3a6e1884caed588a6e018 = cache_frame_c53dfbe39dd3a6e1884caed588a6e018;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c53dfbe39dd3a6e1884caed588a6e018 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c53dfbe39dd3a6e1884caed588a6e018 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 570;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 5 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        tmp_tuple_element_1 = Py_None;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_limit );
        tmp_tuple_element_1 = par_limit;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parents );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_dircall_arg1_1 );
            Py_DECREF( tmp_dircall_arg2_1 );

            exception_lineno = 570;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 570;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c53dfbe39dd3a6e1884caed588a6e018 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c53dfbe39dd3a6e1884caed588a6e018 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c53dfbe39dd3a6e1884caed588a6e018 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c53dfbe39dd3a6e1884caed588a6e018, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c53dfbe39dd3a6e1884caed588a6e018->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c53dfbe39dd3a6e1884caed588a6e018, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c53dfbe39dd3a6e1884caed588a6e018,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_limit,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_c53dfbe39dd3a6e1884caed588a6e018 == cache_frame_c53dfbe39dd3a6e1884caed588a6e018 )
    {
        Py_DECREF( frame_c53dfbe39dd3a6e1884caed588a6e018 );
    }
    cache_frame_c53dfbe39dd3a6e1884caed588a6e018 = NULL;

    assertFrameObject( frame_c53dfbe39dd3a6e1884caed588a6e018 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_38_find_parents );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_38_find_parents );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_39_next( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_98b78ce301e50c61555c5e7b2c6faa12;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_98b78ce301e50c61555c5e7b2c6faa12 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_98b78ce301e50c61555c5e7b2c6faa12, codeobj_98b78ce301e50c61555c5e7b2c6faa12, module_bs4$element, sizeof(void *) );
    frame_98b78ce301e50c61555c5e7b2c6faa12 = cache_frame_98b78ce301e50c61555c5e7b2c6faa12;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_98b78ce301e50c61555c5e7b2c6faa12 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_98b78ce301e50c61555c5e7b2c6faa12 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_next_element );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 577;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98b78ce301e50c61555c5e7b2c6faa12 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_98b78ce301e50c61555c5e7b2c6faa12 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98b78ce301e50c61555c5e7b2c6faa12 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_98b78ce301e50c61555c5e7b2c6faa12, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_98b78ce301e50c61555c5e7b2c6faa12->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_98b78ce301e50c61555c5e7b2c6faa12, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_98b78ce301e50c61555c5e7b2c6faa12,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_98b78ce301e50c61555c5e7b2c6faa12 == cache_frame_98b78ce301e50c61555c5e7b2c6faa12 )
    {
        Py_DECREF( frame_98b78ce301e50c61555c5e7b2c6faa12 );
    }
    cache_frame_98b78ce301e50c61555c5e7b2c6faa12 = NULL;

    assertFrameObject( frame_98b78ce301e50c61555c5e7b2c6faa12 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_39_next );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_39_next );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_40_previous( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_43344189d34fada79b0c4b1db6aa313e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_43344189d34fada79b0c4b1db6aa313e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_43344189d34fada79b0c4b1db6aa313e, codeobj_43344189d34fada79b0c4b1db6aa313e, module_bs4$element, sizeof(void *) );
    frame_43344189d34fada79b0c4b1db6aa313e = cache_frame_43344189d34fada79b0c4b1db6aa313e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_43344189d34fada79b0c4b1db6aa313e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_43344189d34fada79b0c4b1db6aa313e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_previous_element );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 581;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_43344189d34fada79b0c4b1db6aa313e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_43344189d34fada79b0c4b1db6aa313e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_43344189d34fada79b0c4b1db6aa313e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_43344189d34fada79b0c4b1db6aa313e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_43344189d34fada79b0c4b1db6aa313e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_43344189d34fada79b0c4b1db6aa313e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_43344189d34fada79b0c4b1db6aa313e,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_43344189d34fada79b0c4b1db6aa313e == cache_frame_43344189d34fada79b0c4b1db6aa313e )
    {
        Py_DECREF( frame_43344189d34fada79b0c4b1db6aa313e );
    }
    cache_frame_43344189d34fada79b0c4b1db6aa313e = NULL;

    assertFrameObject( frame_43344189d34fada79b0c4b1db6aa313e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_40_previous );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_40_previous );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_41__find_one( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_method = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *par_attrs = python_pars[ 3 ];
    PyObject *par_text = python_pars[ 4 ];
    PyObject *par_kwargs = python_pars[ 5 ];
    PyObject *var_l = NULL;
    PyObject *var_r = NULL;
    struct Nuitka_FrameObject *frame_d650e4d8a3ab64c145624f43bf0229a6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d650e4d8a3ab64c145624f43bf0229a6 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert( var_r == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_r = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d650e4d8a3ab64c145624f43bf0229a6, codeobj_d650e4d8a3ab64c145624f43bf0229a6, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_d650e4d8a3ab64c145624f43bf0229a6 = cache_frame_d650e4d8a3ab64c145624f43bf0229a6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d650e4d8a3ab64c145624f43bf0229a6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d650e4d8a3ab64c145624f43bf0229a6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_method );
        tmp_dircall_arg1_1 = par_method;
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 4 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_int_pos_1;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg1_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_assign_source_2 = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 587;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_l == NULL );
        var_l = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_l );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_l );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 588;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( var_l );
            tmp_subscribed_name_1 = var_l;
            tmp_subscript_name_1 = const_int_0;
            tmp_assign_source_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 589;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_r;
                assert( old != NULL );
                var_r = tmp_assign_source_3;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d650e4d8a3ab64c145624f43bf0229a6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d650e4d8a3ab64c145624f43bf0229a6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d650e4d8a3ab64c145624f43bf0229a6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d650e4d8a3ab64c145624f43bf0229a6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d650e4d8a3ab64c145624f43bf0229a6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d650e4d8a3ab64c145624f43bf0229a6,
        type_description_1,
        par_self,
        par_method,
        par_name,
        par_attrs,
        par_text,
        par_kwargs,
        var_l,
        var_r
    );


    // Release cached frame.
    if ( frame_d650e4d8a3ab64c145624f43bf0229a6 == cache_frame_d650e4d8a3ab64c145624f43bf0229a6 )
    {
        Py_DECREF( frame_d650e4d8a3ab64c145624f43bf0229a6 );
    }
    cache_frame_d650e4d8a3ab64c145624f43bf0229a6 = NULL;

    assertFrameObject( frame_d650e4d8a3ab64c145624f43bf0229a6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_r );
    tmp_return_value = var_r;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_41__find_one );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    CHECK_OBJECT( (PyObject *)var_r );
    Py_DECREF( var_r );
    var_r = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_method );
    Py_DECREF( par_method );
    par_method = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    CHECK_OBJECT( (PyObject *)var_r );
    Py_DECREF( var_r );
    var_r = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_method );
    Py_DECREF( par_method );
    par_method = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_41__find_one );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_42__find_all( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_CellObject *par_name = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_limit = python_pars[ 4 ];
    PyObject *par_generator = python_pars[ 5 ];
    PyObject *par_kwargs = python_pars[ 6 ];
    PyObject *var_i = NULL;
    struct Nuitka_CellObject *var_local_name = PyCell_EMPTY();
    PyObject *var_results = NULL;
    struct Nuitka_CellObject *var_prefix = PyCell_EMPTY();
    PyObject *var_found = NULL;
    PyObject *var_strainer = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_genexpr_1__$0 = NULL;
    PyObject *tmp_genexpr_2__$0 = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_74e0b40b40a8bd05233067bcf4acb342;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_74e0b40b40a8bd05233067bcf4acb342 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_74e0b40b40a8bd05233067bcf4acb342, codeobj_74e0b40b40a8bd05233067bcf4acb342, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_74e0b40b40a8bd05233067bcf4acb342 = cache_frame_74e0b40b40a8bd05233067bcf4acb342;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_74e0b40b40a8bd05233067bcf4acb342 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_74e0b40b40a8bd05233067bcf4acb342 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_text );
        tmp_compexpr_left_1 = par_text;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        tmp_compexpr_left_2 = const_str_plain_string;
        CHECK_OBJECT( par_kwargs );
        tmp_compexpr_right_2 = par_kwargs;
        tmp_res = PySequence_Contains( tmp_compexpr_right_2, tmp_compexpr_left_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 595;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( par_kwargs );
            tmp_subscribed_name_1 = par_kwargs;
            tmp_subscript_name_1 = const_str_plain_string;
            tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 596;
                type_description_1 = "ocoooooococooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_text;
                assert( old != NULL );
                par_text = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_delsubscr_target_1;
            PyObject *tmp_delsubscr_subscript_1;
            CHECK_OBJECT( par_kwargs );
            tmp_delsubscr_target_1 = par_kwargs;
            tmp_delsubscr_subscript_1 = const_str_plain_string;
            tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 597;
                type_description_1 = "ocoooooococooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( PyCell_GET( par_name ) );
        tmp_isinstance_inst_1 = PyCell_GET( par_name );
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_SoupStrainer );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SoupStrainer );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "SoupStrainer" );
            exception_tb = NULL;

            exception_lineno = 599;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 599;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_2;
            CHECK_OBJECT( PyCell_GET( par_name ) );
            tmp_assign_source_2 = PyCell_GET( par_name );
            assert( var_strainer == NULL );
            Py_INCREF( tmp_assign_source_2 );
            var_strainer = tmp_assign_source_2;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_dircall_arg1_1;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_dircall_arg2_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_dircall_arg3_1;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_SoupStrainer );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_SoupStrainer );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "SoupStrainer" );
                exception_tb = NULL;

                exception_lineno = 602;
                type_description_1 = "ocoooooococooo";
                goto frame_exception_exit_1;
            }

            tmp_dircall_arg1_1 = tmp_mvar_value_2;
            CHECK_OBJECT( PyCell_GET( par_name ) );
            tmp_tuple_element_1 = PyCell_GET( par_name );
            tmp_dircall_arg2_1 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_attrs );
            tmp_tuple_element_1 = par_attrs;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
            CHECK_OBJECT( par_text );
            tmp_tuple_element_1 = par_text;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
            CHECK_OBJECT( par_kwargs );
            tmp_dircall_arg3_1 = par_kwargs;
            Py_INCREF( tmp_dircall_arg1_1 );
            Py_INCREF( tmp_dircall_arg3_1 );

            {
                PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
                tmp_assign_source_3 = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
            }
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 602;
                type_description_1 = "ocoooooococooo";
                goto frame_exception_exit_1;
            }
            assert( var_strainer == NULL );
            var_strainer = tmp_assign_source_3;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        PyObject *tmp_operand_name_1;
        int tmp_and_left_truth_4;
        nuitka_bool tmp_and_left_value_4;
        nuitka_bool tmp_and_right_value_4;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_operand_name_3;
        CHECK_OBJECT( par_text );
        tmp_compexpr_left_3 = par_text;
        tmp_compexpr_right_3 = Py_None;
        tmp_and_left_value_2 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_limit );
        tmp_operand_name_1 = par_limit;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 604;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_3 == 1 )
        {
            goto and_right_3;
        }
        else
        {
            goto and_left_3;
        }
        and_right_3:;
        CHECK_OBJECT( par_attrs );
        tmp_operand_name_2 = par_attrs;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 604;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_4 == 1 )
        {
            goto and_right_4;
        }
        else
        {
            goto and_left_4;
        }
        and_right_4:;
        CHECK_OBJECT( par_kwargs );
        tmp_operand_name_3 = par_kwargs;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 604;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_3 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_and_right_value_3 = tmp_and_left_value_4;
        and_end_4:;
        tmp_and_right_value_2 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_and_right_value_2 = tmp_and_left_value_3;
        and_end_3:;
        tmp_condition_result_3 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_3 = tmp_and_left_value_2;
        and_end_2:;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_or_left_truth_1;
            nuitka_bool tmp_or_left_value_1;
            nuitka_bool tmp_or_right_value_1;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            CHECK_OBJECT( PyCell_GET( par_name ) );
            tmp_compexpr_left_4 = PyCell_GET( par_name );
            tmp_compexpr_right_4 = Py_True;
            tmp_or_left_value_1 = ( tmp_compexpr_left_4 == tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_or_left_truth_1 == 1 )
            {
                goto or_left_1;
            }
            else
            {
                goto or_right_1;
            }
            or_right_1:;
            CHECK_OBJECT( PyCell_GET( par_name ) );
            tmp_compexpr_left_5 = PyCell_GET( par_name );
            tmp_compexpr_right_5 = Py_None;
            tmp_or_right_value_1 = ( tmp_compexpr_left_5 == tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_4 = tmp_or_right_value_1;
            goto or_end_1;
            or_left_1:;
            tmp_condition_result_4 = tmp_or_left_value_1;
            or_end_1:;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_4;
                {
                    PyObject *tmp_assign_source_5;
                    PyObject *tmp_iter_arg_1;
                    CHECK_OBJECT( par_generator );
                    tmp_iter_arg_1 = par_generator;
                    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
                    if ( tmp_assign_source_5 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 607;
                        type_description_1 = "ocoooooococooo";
                        goto frame_exception_exit_1;
                    }
                    assert( tmp_genexpr_1__$0 == NULL );
                    tmp_genexpr_1__$0 = tmp_assign_source_5;
                }
                // Tried code:
                tmp_assign_source_4 = bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_maker();

                ((struct Nuitka_GeneratorObject *)tmp_assign_source_4)->m_closure[0] = PyCell_NEW0( tmp_genexpr_1__$0 );


                goto try_return_handler_2;
                // tried codes exits in all cases
                NUITKA_CANNOT_GET_HERE( bs4$element$$$function_42__find_all );
                return NULL;
                // Return handler code:
                try_return_handler_2:;
                CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
                Py_DECREF( tmp_genexpr_1__$0 );
                tmp_genexpr_1__$0 = NULL;

                goto outline_result_1;
                // End of try:
                CHECK_OBJECT( (PyObject *)tmp_genexpr_1__$0 );
                Py_DECREF( tmp_genexpr_1__$0 );
                tmp_genexpr_1__$0 = NULL;

                // Return statement must have exited already.
                NUITKA_CANNOT_GET_HERE( bs4$element$$$function_42__find_all );
                return NULL;
                outline_result_1:;
                assert( var_result == NULL );
                var_result = tmp_assign_source_4;
            }
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_mvar_value_3;
                PyObject *tmp_args_element_name_1;
                PyObject *tmp_args_element_name_2;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ResultSet );

                if (unlikely( tmp_mvar_value_3 == NULL ))
                {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ResultSet );
                }

                if ( tmp_mvar_value_3 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "ResultSet" );
                    exception_tb = NULL;

                    exception_lineno = 609;
                    type_description_1 = "ocoooooococooo";
                    goto frame_exception_exit_1;
                }

                tmp_called_name_1 = tmp_mvar_value_3;
                CHECK_OBJECT( var_strainer );
                tmp_args_element_name_1 = var_strainer;
                CHECK_OBJECT( var_result );
                tmp_args_element_name_2 = var_result;
                frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = 609;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                    tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
                }

                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 609;
                    type_description_1 = "ocoooooococooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            goto branch_end_4;
            branch_no_4:;
            {
                nuitka_bool tmp_condition_result_5;
                PyObject *tmp_isinstance_inst_2;
                PyObject *tmp_isinstance_cls_2;
                CHECK_OBJECT( PyCell_GET( par_name ) );
                tmp_isinstance_inst_2 = PyCell_GET( par_name );
                tmp_isinstance_cls_2 = (PyObject *)&PyBaseString_Type;
                tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 610;
                    type_description_1 = "ocoooooococooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    nuitka_bool tmp_condition_result_6;
                    PyObject *tmp_compexpr_left_6;
                    PyObject *tmp_compexpr_right_6;
                    PyObject *tmp_called_instance_1;
                    CHECK_OBJECT( PyCell_GET( par_name ) );
                    tmp_called_instance_1 = PyCell_GET( par_name );
                    frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = 612;
                    tmp_compexpr_left_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_count, &PyTuple_GET_ITEM( const_tuple_str_chr_58_tuple, 0 ) );

                    if ( tmp_compexpr_left_6 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 612;
                        type_description_1 = "ocoooooococooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_compexpr_right_6 = const_int_pos_1;
                    tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
                    Py_DECREF( tmp_compexpr_left_6 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 612;
                        type_description_1 = "ocoooooococooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_6;
                    }
                    else
                    {
                        goto branch_no_6;
                    }
                    branch_yes_6:;
                    // Tried code:
                    {
                        PyObject *tmp_assign_source_6;
                        PyObject *tmp_iter_arg_2;
                        PyObject *tmp_called_instance_2;
                        CHECK_OBJECT( PyCell_GET( par_name ) );
                        tmp_called_instance_2 = PyCell_GET( par_name );
                        frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = 616;
                        tmp_iter_arg_2 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_split, &PyTuple_GET_ITEM( const_tuple_str_chr_58_int_pos_1_tuple, 0 ) );

                        if ( tmp_iter_arg_2 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 616;
                            type_description_1 = "ocoooooococooo";
                            goto try_except_handler_3;
                        }
                        tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_2 );
                        Py_DECREF( tmp_iter_arg_2 );
                        if ( tmp_assign_source_6 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 616;
                            type_description_1 = "ocoooooococooo";
                            goto try_except_handler_3;
                        }
                        assert( tmp_tuple_unpack_1__source_iter == NULL );
                        tmp_tuple_unpack_1__source_iter = tmp_assign_source_6;
                    }
                    // Tried code:
                    {
                        PyObject *tmp_assign_source_7;
                        PyObject *tmp_unpack_1;
                        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
                        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
                        tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_1, 0 );
                        if ( tmp_assign_source_7 == NULL )
                        {
                            if ( !ERROR_OCCURRED() )
                            {
                                exception_type = PyExc_StopIteration;
                                Py_INCREF( exception_type );
                                exception_value = NULL;
                                exception_tb = NULL;
                            }
                            else
                            {
                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                            }


                            type_description_1 = "ocoooooococooo";
                            exception_lineno = 616;
                            goto try_except_handler_4;
                        }
                        assert( tmp_tuple_unpack_1__element_1 == NULL );
                        tmp_tuple_unpack_1__element_1 = tmp_assign_source_7;
                    }
                    {
                        PyObject *tmp_assign_source_8;
                        PyObject *tmp_unpack_2;
                        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
                        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
                        tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_2, 1 );
                        if ( tmp_assign_source_8 == NULL )
                        {
                            if ( !ERROR_OCCURRED() )
                            {
                                exception_type = PyExc_StopIteration;
                                Py_INCREF( exception_type );
                                exception_value = NULL;
                                exception_tb = NULL;
                            }
                            else
                            {
                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                            }


                            type_description_1 = "ocoooooococooo";
                            exception_lineno = 616;
                            goto try_except_handler_4;
                        }
                        assert( tmp_tuple_unpack_1__element_2 == NULL );
                        tmp_tuple_unpack_1__element_2 = tmp_assign_source_8;
                    }
                    {
                        PyObject *tmp_iterator_name_1;
                        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
                        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
                        // Check if iterator has left-over elements.
                        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

                        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

                        if (likely( tmp_iterator_attempt == NULL ))
                        {
                            PyObject *error = GET_ERROR_OCCURRED();

                            if ( error != NULL )
                            {
                                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                                {
                                    CLEAR_ERROR_OCCURRED();
                                }
                                else
                                {
                                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                                    type_description_1 = "ocoooooococooo";
                                    exception_lineno = 616;
                                    goto try_except_handler_4;
                                }
                            }
                        }
                        else
                        {
                            Py_DECREF( tmp_iterator_attempt );

                            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                            type_description_1 = "ocoooooococooo";
                            exception_lineno = 616;
                            goto try_except_handler_4;
                        }
                    }
                    goto try_end_1;
                    // Exception handler code:
                    try_except_handler_4:;
                    exception_keeper_type_1 = exception_type;
                    exception_keeper_value_1 = exception_value;
                    exception_keeper_tb_1 = exception_tb;
                    exception_keeper_lineno_1 = exception_lineno;
                    exception_type = NULL;
                    exception_value = NULL;
                    exception_tb = NULL;
                    exception_lineno = 0;

                    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
                    Py_DECREF( tmp_tuple_unpack_1__source_iter );
                    tmp_tuple_unpack_1__source_iter = NULL;

                    // Re-raise.
                    exception_type = exception_keeper_type_1;
                    exception_value = exception_keeper_value_1;
                    exception_tb = exception_keeper_tb_1;
                    exception_lineno = exception_keeper_lineno_1;

                    goto try_except_handler_3;
                    // End of try:
                    try_end_1:;
                    goto try_end_2;
                    // Exception handler code:
                    try_except_handler_3:;
                    exception_keeper_type_2 = exception_type;
                    exception_keeper_value_2 = exception_value;
                    exception_keeper_tb_2 = exception_tb;
                    exception_keeper_lineno_2 = exception_lineno;
                    exception_type = NULL;
                    exception_value = NULL;
                    exception_tb = NULL;
                    exception_lineno = 0;

                    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
                    tmp_tuple_unpack_1__element_1 = NULL;

                    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
                    tmp_tuple_unpack_1__element_2 = NULL;

                    // Re-raise.
                    exception_type = exception_keeper_type_2;
                    exception_value = exception_keeper_value_2;
                    exception_tb = exception_keeper_tb_2;
                    exception_lineno = exception_keeper_lineno_2;

                    goto frame_exception_exit_1;
                    // End of try:
                    try_end_2:;
                    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
                    Py_DECREF( tmp_tuple_unpack_1__source_iter );
                    tmp_tuple_unpack_1__source_iter = NULL;

                    {
                        PyObject *tmp_assign_source_9;
                        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
                        tmp_assign_source_9 = tmp_tuple_unpack_1__element_1;
                        assert( PyCell_GET( var_prefix ) == NULL );
                        Py_INCREF( tmp_assign_source_9 );
                        PyCell_SET( var_prefix, tmp_assign_source_9 );

                    }
                    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
                    tmp_tuple_unpack_1__element_1 = NULL;

                    {
                        PyObject *tmp_assign_source_10;
                        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
                        tmp_assign_source_10 = tmp_tuple_unpack_1__element_2;
                        assert( PyCell_GET( var_local_name ) == NULL );
                        Py_INCREF( tmp_assign_source_10 );
                        PyCell_SET( var_local_name, tmp_assign_source_10 );

                    }
                    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
                    tmp_tuple_unpack_1__element_2 = NULL;

                    goto branch_end_6;
                    branch_no_6:;
                    {
                        PyObject *tmp_assign_source_11;
                        tmp_assign_source_11 = Py_None;
                        assert( PyCell_GET( var_prefix ) == NULL );
                        Py_INCREF( tmp_assign_source_11 );
                        PyCell_SET( var_prefix, tmp_assign_source_11 );

                    }
                    {
                        PyObject *tmp_assign_source_12;
                        CHECK_OBJECT( PyCell_GET( par_name ) );
                        tmp_assign_source_12 = PyCell_GET( par_name );
                        assert( PyCell_GET( var_local_name ) == NULL );
                        Py_INCREF( tmp_assign_source_12 );
                        PyCell_SET( var_local_name, tmp_assign_source_12 );

                    }
                    branch_end_6:;
                }
                {
                    PyObject *tmp_assign_source_13;
                    {
                        PyObject *tmp_assign_source_14;
                        PyObject *tmp_iter_arg_3;
                        CHECK_OBJECT( par_generator );
                        tmp_iter_arg_3 = par_generator;
                        tmp_assign_source_14 = MAKE_ITERATOR( tmp_iter_arg_3 );
                        if ( tmp_assign_source_14 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 620;
                            type_description_1 = "ocoooooococooo";
                            goto frame_exception_exit_1;
                        }
                        assert( tmp_genexpr_2__$0 == NULL );
                        tmp_genexpr_2__$0 = tmp_assign_source_14;
                    }
                    // Tried code:
                    tmp_assign_source_13 = bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_maker();

                    ((struct Nuitka_GeneratorObject *)tmp_assign_source_13)->m_closure[0] = PyCell_NEW0( tmp_genexpr_2__$0 );
                    ((struct Nuitka_GeneratorObject *)tmp_assign_source_13)->m_closure[1] = var_local_name;
                    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_assign_source_13)->m_closure[1] );
                    ((struct Nuitka_GeneratorObject *)tmp_assign_source_13)->m_closure[2] = par_name;
                    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_assign_source_13)->m_closure[2] );
                    ((struct Nuitka_GeneratorObject *)tmp_assign_source_13)->m_closure[3] = var_prefix;
                    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_assign_source_13)->m_closure[3] );


                    goto try_return_handler_5;
                    // tried codes exits in all cases
                    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_42__find_all );
                    return NULL;
                    // Return handler code:
                    try_return_handler_5:;
                    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
                    Py_DECREF( tmp_genexpr_2__$0 );
                    tmp_genexpr_2__$0 = NULL;

                    goto outline_result_2;
                    // End of try:
                    CHECK_OBJECT( (PyObject *)tmp_genexpr_2__$0 );
                    Py_DECREF( tmp_genexpr_2__$0 );
                    tmp_genexpr_2__$0 = NULL;

                    // Return statement must have exited already.
                    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_42__find_all );
                    return NULL;
                    outline_result_2:;
                    assert( var_result == NULL );
                    var_result = tmp_assign_source_13;
                }
                {
                    PyObject *tmp_called_name_2;
                    PyObject *tmp_mvar_value_4;
                    PyObject *tmp_args_element_name_3;
                    PyObject *tmp_args_element_name_4;
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ResultSet );

                    if (unlikely( tmp_mvar_value_4 == NULL ))
                    {
                        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ResultSet );
                    }

                    if ( tmp_mvar_value_4 == NULL )
                    {

                        exception_type = PyExc_NameError;
                        Py_INCREF( exception_type );
                        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ResultSet" );
                        exception_tb = NULL;

                        exception_lineno = 629;
                        type_description_1 = "ocoooooococooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_called_name_2 = tmp_mvar_value_4;
                    CHECK_OBJECT( var_strainer );
                    tmp_args_element_name_3 = var_strainer;
                    CHECK_OBJECT( var_result );
                    tmp_args_element_name_4 = var_result;
                    frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = 629;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                        tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
                    }

                    if ( tmp_return_value == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 629;
                        type_description_1 = "ocoooooococooo";
                        goto frame_exception_exit_1;
                    }
                    goto frame_return_exit_1;
                }
                branch_no_5:;
            }
            branch_end_4:;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ResultSet );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ResultSet );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "ResultSet" );
            exception_tb = NULL;

            exception_lineno = 630;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        CHECK_OBJECT( var_strainer );
        tmp_args_element_name_5 = var_strainer;
        frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = 630;
        {
            PyObject *call_args[] = { tmp_args_element_name_5 };
            tmp_assign_source_15 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 630;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        assert( var_results == NULL );
        var_results = tmp_assign_source_15;
    }
    loop_start_1:;
    // Tried code:
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_value_name_1;
        CHECK_OBJECT( par_generator );
        tmp_value_name_1 = par_generator;
        tmp_assign_source_16 = ITERATOR_NEXT( tmp_value_name_1 );
        if ( tmp_assign_source_16 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "ocoooooococooo";
            exception_lineno = 633;
            goto try_except_handler_6;
        }
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_16;
            Py_XDECREF( old );
        }

    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_74e0b40b40a8bd05233067bcf4acb342 );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_74e0b40b40a8bd05233067bcf4acb342, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != 0 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_74e0b40b40a8bd05233067bcf4acb342, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_compexpr_left_7;
        PyObject *tmp_compexpr_right_7;
        tmp_compexpr_left_7 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_7 = PyExc_StopIteration;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_7, tmp_compexpr_right_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 634;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        goto loop_end_1;
        goto branch_end_7;
        branch_no_7:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 632;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_74e0b40b40a8bd05233067bcf4acb342->m_frame) frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "ocoooooococooo";
        goto frame_exception_exit_1;
        branch_end_7:;
    }
    // End of try:
    try_end_3:;
    {
        nuitka_bool tmp_condition_result_8;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_i );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_i );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 636;
            type_description_1 = "ocoooooococooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_8 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assign_source_17;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_args_element_name_6;
            CHECK_OBJECT( var_strainer );
            tmp_called_instance_3 = var_strainer;
            CHECK_OBJECT( var_i );
            tmp_args_element_name_6 = var_i;
            frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = 637;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_assign_source_17 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_search, call_args );
            }

            if ( tmp_assign_source_17 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 637;
                type_description_1 = "ocoooooococooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_found;
                var_found = tmp_assign_source_17;
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_9;
            int tmp_truth_name_2;
            CHECK_OBJECT( var_found );
            tmp_truth_name_2 = CHECK_IF_TRUE( var_found );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 638;
                type_description_1 = "ocoooooococooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_9 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_9;
            }
            else
            {
                goto branch_no_9;
            }
            branch_yes_9:;
            {
                PyObject *tmp_called_instance_4;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_7;
                CHECK_OBJECT( var_results );
                tmp_called_instance_4 = var_results;
                CHECK_OBJECT( var_found );
                tmp_args_element_name_7 = var_found;
                frame_74e0b40b40a8bd05233067bcf4acb342->m_frame.f_lineno = 639;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 639;
                    type_description_1 = "ocoooooococooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            {
                nuitka_bool tmp_condition_result_10;
                int tmp_and_left_truth_5;
                nuitka_bool tmp_and_left_value_5;
                nuitka_bool tmp_and_right_value_5;
                int tmp_truth_name_3;
                PyObject *tmp_compexpr_left_8;
                PyObject *tmp_compexpr_right_8;
                PyObject *tmp_len_arg_1;
                CHECK_OBJECT( par_limit );
                tmp_truth_name_3 = CHECK_IF_TRUE( par_limit );
                if ( tmp_truth_name_3 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 640;
                    type_description_1 = "ocoooooococooo";
                    goto frame_exception_exit_1;
                }
                tmp_and_left_value_5 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_and_left_truth_5 = tmp_and_left_value_5 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_and_left_truth_5 == 1 )
                {
                    goto and_right_5;
                }
                else
                {
                    goto and_left_5;
                }
                and_right_5:;
                CHECK_OBJECT( var_results );
                tmp_len_arg_1 = var_results;
                tmp_compexpr_left_8 = BUILTIN_LEN( tmp_len_arg_1 );
                if ( tmp_compexpr_left_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 640;
                    type_description_1 = "ocoooooococooo";
                    goto frame_exception_exit_1;
                }
                CHECK_OBJECT( par_limit );
                tmp_compexpr_right_8 = par_limit;
                tmp_res = RICH_COMPARE_BOOL_GTE_OBJECT_OBJECT( tmp_compexpr_left_8, tmp_compexpr_right_8 );
                Py_DECREF( tmp_compexpr_left_8 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 640;
                    type_description_1 = "ocoooooococooo";
                    goto frame_exception_exit_1;
                }
                tmp_and_right_value_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_condition_result_10 = tmp_and_right_value_5;
                goto and_end_5;
                and_left_5:;
                tmp_condition_result_10 = tmp_and_left_value_5;
                and_end_5:;
                if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_10;
                }
                else
                {
                    goto branch_no_10;
                }
                branch_yes_10:;
                goto loop_end_1;
                branch_no_10:;
            }
            branch_no_9:;
        }
        branch_no_8:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description_1 = "ocoooooococooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_74e0b40b40a8bd05233067bcf4acb342 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_74e0b40b40a8bd05233067bcf4acb342 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_74e0b40b40a8bd05233067bcf4acb342 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_74e0b40b40a8bd05233067bcf4acb342, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_74e0b40b40a8bd05233067bcf4acb342->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_74e0b40b40a8bd05233067bcf4acb342, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_74e0b40b40a8bd05233067bcf4acb342,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_limit,
        par_generator,
        par_kwargs,
        var_i,
        var_local_name,
        var_results,
        var_prefix,
        var_found,
        var_strainer,
        var_result
    );


    // Release cached frame.
    if ( frame_74e0b40b40a8bd05233067bcf4acb342 == cache_frame_74e0b40b40a8bd05233067bcf4acb342 )
    {
        Py_DECREF( frame_74e0b40b40a8bd05233067bcf4acb342 );
    }
    cache_frame_74e0b40b40a8bd05233067bcf4acb342 = NULL;

    assertFrameObject( frame_74e0b40b40a8bd05233067bcf4acb342 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_results );
    tmp_return_value = var_results;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_42__find_all );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_generator );
    Py_DECREF( par_generator );
    par_generator = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_local_name );
    Py_DECREF( var_local_name );
    var_local_name = NULL;

    Py_XDECREF( var_results );
    var_results = NULL;

    CHECK_OBJECT( (PyObject *)var_prefix );
    Py_DECREF( var_prefix );
    var_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    Py_XDECREF( var_found );
    var_found = NULL;

    CHECK_OBJECT( (PyObject *)var_strainer );
    Py_DECREF( var_strainer );
    var_strainer = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_generator );
    Py_DECREF( par_generator );
    par_generator = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_local_name );
    Py_DECREF( var_local_name );
    var_local_name = NULL;

    Py_XDECREF( var_results );
    var_results = NULL;

    CHECK_OBJECT( (PyObject *)var_prefix );
    Py_DECREF( var_prefix );
    var_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    Py_XDECREF( var_found );
    var_found = NULL;

    Py_XDECREF( var_strainer );
    var_strainer = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_42__find_all );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_locals {
    PyObject *var_element;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_locals *generator_heap = (struct bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_element = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_f82a295a662e8886705acead8db7eae2, module_bs4$element, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "No";
                generator_heap->exception_lineno = 607;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_element;
            generator_heap->var_element = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_element );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( generator_heap->var_element );
        tmp_isinstance_inst_1 = generator_heap->var_element;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 608;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 608;
            generator_heap->type_description_1 = "No";
            goto try_except_handler_2;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_expression_name_1;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            CHECK_OBJECT( generator_heap->var_element );
            tmp_expression_name_1 = generator_heap->var_element;
            Py_INCREF( tmp_expression_name_1 );
            Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL );
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), NULL );
            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 607;
                generator_heap->type_description_1 = "No";
                goto try_except_handler_2;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 607;
        generator_heap->type_description_1 = "No";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator_heap->var_element
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_element );
    generator_heap->var_element = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_element );
    generator_heap->var_element = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_context,
        module_bs4$element,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_f82a295a662e8886705acead8db7eae2,
        1,
        sizeof(struct bs4$element$$$function_42__find_all$$$genexpr_1_genexpr_locals)
    );
}



struct bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_locals {
    PyObject *var_element;
    PyObject *tmp_iter_value_0;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    char yield_tmps[1024];
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_locals *generator_heap = (struct bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_element = NULL;
    generator_heap->tmp_iter_value_0 = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_feea27494a1468bad8c92211b86b996d, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( PyCell_GET( generator->m_closure[0] ) );
        tmp_next_source_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "Nccco";
                generator_heap->exception_lineno = 620;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_iter_value_0;
            generator_heap->tmp_iter_value_0 = tmp_assign_source_1;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_iter_value_0 );
        tmp_assign_source_2 = generator_heap->tmp_iter_value_0;
        {
            PyObject *old = generator_heap->var_element;
            generator_heap->var_element = tmp_assign_source_2;
            Py_INCREF( generator_heap->var_element );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( generator_heap->var_element );
        tmp_isinstance_inst_1 = generator_heap->var_element;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 621;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 621;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }
        tmp_and_left_value_1 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( generator_heap->var_element );
        tmp_source_name_1 = generator_heap->var_element;
        tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 623;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {
            Py_DECREF( tmp_compexpr_left_1 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "name" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 623;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_1 = PyCell_GET( generator->m_closure[2] );
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 623;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }
        tmp_and_right_value_1 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_value_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_or_left_value_1 = tmp_and_left_value_1;
        and_end_1:;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( generator_heap->var_element );
        tmp_source_name_2 = generator_heap->var_element;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 625;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {
            Py_DECREF( tmp_compexpr_left_2 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "local_name" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 625;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_2 = PyCell_GET( generator->m_closure[1] );
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 625;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }
        tmp_and_left_value_2 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        if ( PyCell_GET( generator->m_closure[3] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "prefix" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 626;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }

        tmp_compexpr_left_3 = PyCell_GET( generator->m_closure[3] );
        tmp_compexpr_right_3 = Py_None;
        tmp_or_left_value_2 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_2 == 1 )
        {
            goto or_left_2;
        }
        else
        {
            goto or_right_2;
        }
        or_right_2:;
        CHECK_OBJECT( generator_heap->var_element );
        tmp_source_name_3 = generator_heap->var_element;
        tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_prefix );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 626;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }
        if ( PyCell_GET( generator->m_closure[3] ) == NULL )
        {
            Py_DECREF( tmp_compexpr_left_4 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "prefix" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 626;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_4 = PyCell_GET( generator->m_closure[3] );
        generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 626;
            generator_heap->type_description_1 = "Nccco";
            goto try_except_handler_2;
        }
        tmp_or_right_value_2 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_2 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_and_right_value_2 = tmp_or_left_value_2;
        or_end_2:;
        tmp_or_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_or_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_expression_name_1;
            NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
            CHECK_OBJECT( generator_heap->var_element );
            tmp_expression_name_1 = generator_heap->var_element;
            Py_INCREF( tmp_expression_name_1 );
            Nuitka_PreserveHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_or_left_truth_1, sizeof(int), &tmp_or_left_value_1, sizeof(nuitka_bool), &tmp_or_right_value_1, sizeof(nuitka_bool), &tmp_and_left_truth_1, sizeof(int), &tmp_and_left_value_1, sizeof(nuitka_bool), &tmp_and_right_value_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_and_left_truth_2, sizeof(int), &tmp_and_left_value_2, sizeof(nuitka_bool), &tmp_and_right_value_2, sizeof(nuitka_bool), &tmp_compexpr_left_2, sizeof(PyObject *), &tmp_compexpr_right_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_or_left_truth_2, sizeof(int), &tmp_or_left_value_2, sizeof(nuitka_bool), &tmp_or_right_value_2, sizeof(nuitka_bool), &tmp_compexpr_left_3, sizeof(PyObject *), &tmp_compexpr_right_3, sizeof(PyObject *), &tmp_compexpr_left_4, sizeof(PyObject *), &tmp_compexpr_right_4, sizeof(PyObject *), &tmp_source_name_3, sizeof(PyObject *), NULL );
            generator->m_yield_return_index = 1;
            return tmp_expression_name_1;
            yield_return_1:
            Nuitka_RestoreHeap( generator_heap->yield_tmps, &tmp_condition_result_1, sizeof(nuitka_bool), &tmp_or_left_truth_1, sizeof(int), &tmp_or_left_value_1, sizeof(nuitka_bool), &tmp_or_right_value_1, sizeof(nuitka_bool), &tmp_and_left_truth_1, sizeof(int), &tmp_and_left_value_1, sizeof(nuitka_bool), &tmp_and_right_value_1, sizeof(nuitka_bool), &tmp_isinstance_inst_1, sizeof(PyObject *), &tmp_isinstance_cls_1, sizeof(PyObject *), &tmp_mvar_value_1, sizeof(PyObject *), &tmp_compexpr_left_1, sizeof(PyObject *), &tmp_compexpr_right_1, sizeof(PyObject *), &tmp_source_name_1, sizeof(PyObject *), &tmp_and_left_truth_2, sizeof(int), &tmp_and_left_value_2, sizeof(nuitka_bool), &tmp_and_right_value_2, sizeof(nuitka_bool), &tmp_compexpr_left_2, sizeof(PyObject *), &tmp_compexpr_right_2, sizeof(PyObject *), &tmp_source_name_2, sizeof(PyObject *), &tmp_or_left_truth_2, sizeof(int), &tmp_or_left_value_2, sizeof(nuitka_bool), &tmp_or_right_value_2, sizeof(nuitka_bool), &tmp_compexpr_left_3, sizeof(PyObject *), &tmp_compexpr_right_3, sizeof(PyObject *), &tmp_compexpr_left_4, sizeof(PyObject *), &tmp_compexpr_right_4, sizeof(PyObject *), &tmp_source_name_3, sizeof(PyObject *), NULL );
            if ( yield_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 620;
                generator_heap->type_description_1 = "Nccco";
                goto try_except_handler_2;
            }
            tmp_yield_result_1 = yield_return_value;
        }
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 620;
        generator_heap->type_description_1 = "Nccco";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            NULL,
            generator->m_closure[3],
            generator->m_closure[1],
            generator->m_closure[2],
            generator_heap->var_element
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_element );
    generator_heap->var_element = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_iter_value_0 );
    generator_heap->tmp_iter_value_0 = NULL;

    Py_XDECREF( generator_heap->var_element );
    generator_heap->var_element = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_context,
        module_bs4$element,
        const_str_angle_genexpr,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_feea27494a1468bad8c92211b86b996d,
        4,
        sizeof(struct bs4$element$$$function_42__find_all$$$genexpr_2_genexpr_locals)
    );
}


static PyObject *impl_bs4$element$$$function_43_next_elements( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_43_next_elements );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_43_next_elements );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_locals {
    PyObject *var_i;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_locals *generator_heap = (struct bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_2ce30ad51f869b601f01107834b055c1, module_bs4$element, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 648;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_next_element );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 648;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_i == NULL );
        generator_heap->var_i = tmp_assign_source_1;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_compexpr_left_1 = generator_heap->var_i;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_expression_name_1 = generator_heap->var_i;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 650;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_source_name_2 = generator_heap->var_i;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_next_element );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 651;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_i;
            assert( old != NULL );
            generator_heap->var_i = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 649;
        generator_heap->type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_i
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)generator_heap->var_i );
    Py_DECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_context,
        module_bs4$element,
        const_str_plain_next_elements,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_2ce30ad51f869b601f01107834b055c1,
        1,
        sizeof(struct bs4$element$$$function_43_next_elements$$$genobj_1_next_elements_locals)
    );
}


static PyObject *impl_bs4$element$$$function_44_next_siblings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_44_next_siblings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_44_next_siblings );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_locals {
    PyObject *var_i;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_locals *generator_heap = (struct bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_96d5c0615e56d061f1a75be0898d3893, module_bs4$element, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 655;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_next_sibling );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 655;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_i == NULL );
        generator_heap->var_i = tmp_assign_source_1;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_compexpr_left_1 = generator_heap->var_i;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_expression_name_1 = generator_heap->var_i;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 657;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_source_name_2 = generator_heap->var_i;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_next_sibling );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 658;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_i;
            assert( old != NULL );
            generator_heap->var_i = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 656;
        generator_heap->type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_i
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)generator_heap->var_i );
    Py_DECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_context,
        module_bs4$element,
        const_str_plain_next_siblings,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_96d5c0615e56d061f1a75be0898d3893,
        1,
        sizeof(struct bs4$element$$$function_44_next_siblings$$$genobj_1_next_siblings_locals)
    );
}


static PyObject *impl_bs4$element$$$function_45_previous_elements( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_45_previous_elements );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_45_previous_elements );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_locals {
    PyObject *var_i;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_locals *generator_heap = (struct bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_30fec37bac69a968b531d72f50d1eab0, module_bs4$element, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 662;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_previous_element );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 662;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_i == NULL );
        generator_heap->var_i = tmp_assign_source_1;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_compexpr_left_1 = generator_heap->var_i;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_expression_name_1 = generator_heap->var_i;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 664;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_source_name_2 = generator_heap->var_i;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_previous_element );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 665;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_i;
            assert( old != NULL );
            generator_heap->var_i = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 663;
        generator_heap->type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_i
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)generator_heap->var_i );
    Py_DECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_context,
        module_bs4$element,
        const_str_plain_previous_elements,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_30fec37bac69a968b531d72f50d1eab0,
        1,
        sizeof(struct bs4$element$$$function_45_previous_elements$$$genobj_1_previous_elements_locals)
    );
}


static PyObject *impl_bs4$element$$$function_46_previous_siblings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_46_previous_siblings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_46_previous_siblings );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_locals {
    PyObject *var_i;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_locals *generator_heap = (struct bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_101279b401d05ad5c4ab4058c37f2e3a, module_bs4$element, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 669;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_previous_sibling );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 669;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_i == NULL );
        generator_heap->var_i = tmp_assign_source_1;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_compexpr_left_1 = generator_heap->var_i;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_expression_name_1 = generator_heap->var_i;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 671;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_source_name_2 = generator_heap->var_i;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_previous_sibling );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 672;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_i;
            assert( old != NULL );
            generator_heap->var_i = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 670;
        generator_heap->type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_i
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)generator_heap->var_i );
    Py_DECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_context,
        module_bs4$element,
        const_str_plain_previous_siblings,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_101279b401d05ad5c4ab4058c37f2e3a,
        1,
        sizeof(struct bs4$element$$$function_46_previous_siblings$$$genobj_1_previous_siblings_locals)
    );
}


static PyObject *impl_bs4$element$$$function_47_parents( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_47_parents$$$genobj_1_parents_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_47_parents );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_47_parents );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_47_parents$$$genobj_1_parents_locals {
    PyObject *var_i;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *bs4$element$$$function_47_parents$$$genobj_1_parents_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_47_parents$$$genobj_1_parents_locals *generator_heap = (struct bs4$element$$$function_47_parents$$$genobj_1_parents_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_i = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_2389c2d402cbef9638c4531890382b4c, module_bs4$element, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 676;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parent );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 676;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_i == NULL );
        generator_heap->var_i = tmp_assign_source_1;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_compexpr_left_1 = generator_heap->var_i;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_expression_name_1 = generator_heap->var_i;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 678;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( generator_heap->var_i );
        tmp_source_name_2 = generator_heap->var_i;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_parent );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 679;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_i;
            assert( old != NULL );
            generator_heap->var_i = tmp_assign_source_2;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 677;
        generator_heap->type_description_1 = "co";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_i
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)generator_heap->var_i );
    Py_DECREF( generator_heap->var_i );
    generator_heap->var_i = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_47_parents$$$genobj_1_parents_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_47_parents$$$genobj_1_parents_context,
        module_bs4$element,
        const_str_plain_parents,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_2389c2d402cbef9638c4531890382b4c,
        1,
        sizeof(struct bs4$element$$$function_47_parents$$$genobj_1_parents_locals)
    );
}


static PyObject *impl_bs4$element$$$function_48_nextGenerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_5d84c23d22e2c284d1e911e1df415815;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5d84c23d22e2c284d1e911e1df415815 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d84c23d22e2c284d1e911e1df415815, codeobj_5d84c23d22e2c284d1e911e1df415815, module_bs4$element, sizeof(void *) );
    frame_5d84c23d22e2c284d1e911e1df415815 = cache_frame_5d84c23d22e2c284d1e911e1df415815;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d84c23d22e2c284d1e911e1df415815 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d84c23d22e2c284d1e911e1df415815 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_next_elements );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 684;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d84c23d22e2c284d1e911e1df415815 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d84c23d22e2c284d1e911e1df415815 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d84c23d22e2c284d1e911e1df415815 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d84c23d22e2c284d1e911e1df415815, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d84c23d22e2c284d1e911e1df415815->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d84c23d22e2c284d1e911e1df415815, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5d84c23d22e2c284d1e911e1df415815,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_5d84c23d22e2c284d1e911e1df415815 == cache_frame_5d84c23d22e2c284d1e911e1df415815 )
    {
        Py_DECREF( frame_5d84c23d22e2c284d1e911e1df415815 );
    }
    cache_frame_5d84c23d22e2c284d1e911e1df415815 = NULL;

    assertFrameObject( frame_5d84c23d22e2c284d1e911e1df415815 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_48_nextGenerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_48_nextGenerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_49_nextSiblingGenerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_0104bb1a834c0db99dc949612ee9e530;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0104bb1a834c0db99dc949612ee9e530 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0104bb1a834c0db99dc949612ee9e530, codeobj_0104bb1a834c0db99dc949612ee9e530, module_bs4$element, sizeof(void *) );
    frame_0104bb1a834c0db99dc949612ee9e530 = cache_frame_0104bb1a834c0db99dc949612ee9e530;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0104bb1a834c0db99dc949612ee9e530 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0104bb1a834c0db99dc949612ee9e530 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_next_siblings );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 687;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0104bb1a834c0db99dc949612ee9e530 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0104bb1a834c0db99dc949612ee9e530 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0104bb1a834c0db99dc949612ee9e530 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0104bb1a834c0db99dc949612ee9e530, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0104bb1a834c0db99dc949612ee9e530->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0104bb1a834c0db99dc949612ee9e530, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0104bb1a834c0db99dc949612ee9e530,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_0104bb1a834c0db99dc949612ee9e530 == cache_frame_0104bb1a834c0db99dc949612ee9e530 )
    {
        Py_DECREF( frame_0104bb1a834c0db99dc949612ee9e530 );
    }
    cache_frame_0104bb1a834c0db99dc949612ee9e530 = NULL;

    assertFrameObject( frame_0104bb1a834c0db99dc949612ee9e530 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_49_nextSiblingGenerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_49_nextSiblingGenerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_50_previousGenerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6b8832c71060328b0d13cb2fbbebfc80;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6b8832c71060328b0d13cb2fbbebfc80 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6b8832c71060328b0d13cb2fbbebfc80, codeobj_6b8832c71060328b0d13cb2fbbebfc80, module_bs4$element, sizeof(void *) );
    frame_6b8832c71060328b0d13cb2fbbebfc80 = cache_frame_6b8832c71060328b0d13cb2fbbebfc80;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6b8832c71060328b0d13cb2fbbebfc80 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6b8832c71060328b0d13cb2fbbebfc80 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_previous_elements );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 690;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6b8832c71060328b0d13cb2fbbebfc80 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6b8832c71060328b0d13cb2fbbebfc80 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6b8832c71060328b0d13cb2fbbebfc80 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6b8832c71060328b0d13cb2fbbebfc80, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6b8832c71060328b0d13cb2fbbebfc80->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6b8832c71060328b0d13cb2fbbebfc80, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6b8832c71060328b0d13cb2fbbebfc80,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6b8832c71060328b0d13cb2fbbebfc80 == cache_frame_6b8832c71060328b0d13cb2fbbebfc80 )
    {
        Py_DECREF( frame_6b8832c71060328b0d13cb2fbbebfc80 );
    }
    cache_frame_6b8832c71060328b0d13cb2fbbebfc80 = NULL;

    assertFrameObject( frame_6b8832c71060328b0d13cb2fbbebfc80 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_50_previousGenerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_50_previousGenerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_51_previousSiblingGenerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_793293dba737101c30c17c8b35d070dc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_793293dba737101c30c17c8b35d070dc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_793293dba737101c30c17c8b35d070dc, codeobj_793293dba737101c30c17c8b35d070dc, module_bs4$element, sizeof(void *) );
    frame_793293dba737101c30c17c8b35d070dc = cache_frame_793293dba737101c30c17c8b35d070dc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_793293dba737101c30c17c8b35d070dc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_793293dba737101c30c17c8b35d070dc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_previous_siblings );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 693;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_793293dba737101c30c17c8b35d070dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_793293dba737101c30c17c8b35d070dc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_793293dba737101c30c17c8b35d070dc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_793293dba737101c30c17c8b35d070dc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_793293dba737101c30c17c8b35d070dc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_793293dba737101c30c17c8b35d070dc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_793293dba737101c30c17c8b35d070dc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_793293dba737101c30c17c8b35d070dc == cache_frame_793293dba737101c30c17c8b35d070dc )
    {
        Py_DECREF( frame_793293dba737101c30c17c8b35d070dc );
    }
    cache_frame_793293dba737101c30c17c8b35d070dc = NULL;

    assertFrameObject( frame_793293dba737101c30c17c8b35d070dc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_51_previousSiblingGenerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_51_previousSiblingGenerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_52_parentGenerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6bbdfb85b0c1bb816d1a814b3fcd7b62;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6bbdfb85b0c1bb816d1a814b3fcd7b62, codeobj_6bbdfb85b0c1bb816d1a814b3fcd7b62, module_bs4$element, sizeof(void *) );
    frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 = cache_frame_6bbdfb85b0c1bb816d1a814b3fcd7b62;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_parents );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 696;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6bbdfb85b0c1bb816d1a814b3fcd7b62->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6bbdfb85b0c1bb816d1a814b3fcd7b62, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6bbdfb85b0c1bb816d1a814b3fcd7b62,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 == cache_frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 )
    {
        Py_DECREF( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 );
    }
    cache_frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 = NULL;

    assertFrameObject( frame_6bbdfb85b0c1bb816d1a814b3fcd7b62 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_52_parentGenerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_52_parentGenerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_53___new__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    PyObject *var_u = NULL;
    struct Nuitka_FrameObject *frame_b85adaa470e25a69858dfde85e7c078a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b85adaa470e25a69858dfde85e7c078a = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b85adaa470e25a69858dfde85e7c078a, codeobj_b85adaa470e25a69858dfde85e7c078a, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b85adaa470e25a69858dfde85e7c078a = cache_frame_b85adaa470e25a69858dfde85e7c078a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b85adaa470e25a69858dfde85e7c078a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b85adaa470e25a69858dfde85e7c078a ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_value );
        tmp_isinstance_inst_1 = par_value;
        tmp_isinstance_cls_1 = (PyObject *)&PyUnicode_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 717;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            tmp_called_instance_1 = (PyObject *)&PyUnicode_Type;
            CHECK_OBJECT( par_cls );
            tmp_args_element_name_1 = par_cls;
            CHECK_OBJECT( par_value );
            tmp_args_element_name_2 = par_value;
            frame_b85adaa470e25a69858dfde85e7c078a->m_frame.f_lineno = 718;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain___new__, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 718;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( var_u == NULL );
            var_u = tmp_assign_source_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_mvar_value_1;
            tmp_source_name_1 = (PyObject *)&PyUnicode_Type;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___new__ );
            assert( !(tmp_called_name_1 == NULL) );
            CHECK_OBJECT( par_cls );
            tmp_args_element_name_3 = par_cls;
            CHECK_OBJECT( par_value );
            tmp_args_element_name_4 = par_value;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );
            }

            if ( tmp_mvar_value_1 == NULL )
            {
                Py_DECREF( tmp_called_name_1 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "DEFAULT_OUTPUT_ENCODING" );
                exception_tb = NULL;

                exception_lineno = 720;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_5 = tmp_mvar_value_1;
            frame_b85adaa470e25a69858dfde85e7c078a->m_frame.f_lineno = 720;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
                tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 720;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( var_u == NULL );
            var_u = tmp_assign_source_2;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( var_u );
        tmp_called_instance_2 = var_u;
        frame_b85adaa470e25a69858dfde85e7c078a->m_frame.f_lineno = 721;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_setup );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 721;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b85adaa470e25a69858dfde85e7c078a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b85adaa470e25a69858dfde85e7c078a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b85adaa470e25a69858dfde85e7c078a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b85adaa470e25a69858dfde85e7c078a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b85adaa470e25a69858dfde85e7c078a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b85adaa470e25a69858dfde85e7c078a,
        type_description_1,
        par_cls,
        par_value,
        var_u
    );


    // Release cached frame.
    if ( frame_b85adaa470e25a69858dfde85e7c078a == cache_frame_b85adaa470e25a69858dfde85e7c078a )
    {
        Py_DECREF( frame_b85adaa470e25a69858dfde85e7c078a );
    }
    cache_frame_b85adaa470e25a69858dfde85e7c078a = NULL;

    assertFrameObject( frame_b85adaa470e25a69858dfde85e7c078a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_u );
    tmp_return_value = var_u;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_53___new__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_u );
    Py_DECREF( var_u );
    var_u = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_u );
    var_u = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_53___new__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_54___copy__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_36b2c8d556861624aae77de0a07304d0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_36b2c8d556861624aae77de0a07304d0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_36b2c8d556861624aae77de0a07304d0, codeobj_36b2c8d556861624aae77de0a07304d0, module_bs4$element, sizeof(void *) );
    frame_36b2c8d556861624aae77de0a07304d0 = cache_frame_36b2c8d556861624aae77de0a07304d0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_36b2c8d556861624aae77de0a07304d0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_36b2c8d556861624aae77de0a07304d0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_type_arg_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_self );
        tmp_type_arg_1 = par_self;
        tmp_called_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_called_name_1 == NULL) );
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        frame_36b2c8d556861624aae77de0a07304d0->m_frame.f_lineno = 728;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 728;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36b2c8d556861624aae77de0a07304d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_36b2c8d556861624aae77de0a07304d0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36b2c8d556861624aae77de0a07304d0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_36b2c8d556861624aae77de0a07304d0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_36b2c8d556861624aae77de0a07304d0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_36b2c8d556861624aae77de0a07304d0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_36b2c8d556861624aae77de0a07304d0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_36b2c8d556861624aae77de0a07304d0 == cache_frame_36b2c8d556861624aae77de0a07304d0 )
    {
        Py_DECREF( frame_36b2c8d556861624aae77de0a07304d0 );
    }
    cache_frame_36b2c8d556861624aae77de0a07304d0 = NULL;

    assertFrameObject( frame_36b2c8d556861624aae77de0a07304d0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_54___copy__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_54___copy__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_55___getnewargs__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c07331a2a0ef212bddc2df31da1b3830;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c07331a2a0ef212bddc2df31da1b3830 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c07331a2a0ef212bddc2df31da1b3830, codeobj_c07331a2a0ef212bddc2df31da1b3830, module_bs4$element, sizeof(void *) );
    frame_c07331a2a0ef212bddc2df31da1b3830 = cache_frame_c07331a2a0ef212bddc2df31da1b3830;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c07331a2a0ef212bddc2df31da1b3830 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c07331a2a0ef212bddc2df31da1b3830 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_str_arg_1;
        CHECK_OBJECT( par_self );
        tmp_str_arg_1 = par_self;
        tmp_tuple_element_1 = PyObject_Unicode( tmp_str_arg_1 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 731;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = PyTuple_New( 1 );
        PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c07331a2a0ef212bddc2df31da1b3830 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c07331a2a0ef212bddc2df31da1b3830 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c07331a2a0ef212bddc2df31da1b3830 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c07331a2a0ef212bddc2df31da1b3830, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c07331a2a0ef212bddc2df31da1b3830->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c07331a2a0ef212bddc2df31da1b3830, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c07331a2a0ef212bddc2df31da1b3830,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_c07331a2a0ef212bddc2df31da1b3830 == cache_frame_c07331a2a0ef212bddc2df31da1b3830 )
    {
        Py_DECREF( frame_c07331a2a0ef212bddc2df31da1b3830 );
    }
    cache_frame_c07331a2a0ef212bddc2df31da1b3830 = NULL;

    assertFrameObject( frame_c07331a2a0ef212bddc2df31da1b3830 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_55___getnewargs__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_55___getnewargs__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_56___getattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_attr = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_fc41c2ad8dbe85f71981b8bba617eec6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_fc41c2ad8dbe85f71981b8bba617eec6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fc41c2ad8dbe85f71981b8bba617eec6, codeobj_fc41c2ad8dbe85f71981b8bba617eec6, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_fc41c2ad8dbe85f71981b8bba617eec6 = cache_frame_fc41c2ad8dbe85f71981b8bba617eec6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fc41c2ad8dbe85f71981b8bba617eec6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fc41c2ad8dbe85f71981b8bba617eec6 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_attr );
        tmp_compexpr_left_1 = par_attr;
        tmp_compexpr_right_1 = const_str_plain_string;
        tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 737;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( par_self );
        tmp_return_value = par_self;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_source_name_2;
            tmp_left_name_1 = const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_source_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
            if ( tmp_source_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 742;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
            Py_DECREF( tmp_source_name_1 );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 742;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyTuple_New( 2 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_attr );
            tmp_tuple_element_1 = par_attr;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_make_exception_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 741;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            frame_fc41c2ad8dbe85f71981b8bba617eec6->m_frame.f_lineno = 740;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
            }

            Py_DECREF( tmp_make_exception_arg_1 );
            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 740;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc41c2ad8dbe85f71981b8bba617eec6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc41c2ad8dbe85f71981b8bba617eec6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc41c2ad8dbe85f71981b8bba617eec6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fc41c2ad8dbe85f71981b8bba617eec6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fc41c2ad8dbe85f71981b8bba617eec6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fc41c2ad8dbe85f71981b8bba617eec6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fc41c2ad8dbe85f71981b8bba617eec6,
        type_description_1,
        par_self,
        par_attr
    );


    // Release cached frame.
    if ( frame_fc41c2ad8dbe85f71981b8bba617eec6 == cache_frame_fc41c2ad8dbe85f71981b8bba617eec6 )
    {
        Py_DECREF( frame_fc41c2ad8dbe85f71981b8bba617eec6 );
    }
    cache_frame_fc41c2ad8dbe85f71981b8bba617eec6 = NULL;

    assertFrameObject( frame_fc41c2ad8dbe85f71981b8bba617eec6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_56___getattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_attr );
    Py_DECREF( par_attr );
    par_attr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_attr );
    Py_DECREF( par_attr );
    par_attr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_56___getattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_57_output_ready( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_formatter = python_pars[ 1 ];
    PyObject *var_output = NULL;
    struct Nuitka_FrameObject *frame_be712631c87fcbe3bc2bb6dcb0fd15ab;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_be712631c87fcbe3bc2bb6dcb0fd15ab = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_be712631c87fcbe3bc2bb6dcb0fd15ab, codeobj_be712631c87fcbe3bc2bb6dcb0fd15ab, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_be712631c87fcbe3bc2bb6dcb0fd15ab = cache_frame_be712631c87fcbe3bc2bb6dcb0fd15ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_be712631c87fcbe3bc2bb6dcb0fd15ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_be712631c87fcbe3bc2bb6dcb0fd15ab ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_formatter );
        tmp_args_element_name_2 = par_formatter;
        frame_be712631c87fcbe3bc2bb6dcb0fd15ab->m_frame.f_lineno = 745;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_format_string, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 745;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_output == NULL );
        var_output = tmp_assign_source_1;
    }
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PREFIX );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 746;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_output );
        tmp_right_name_1 = var_output;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 746;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SUFFIX );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 746;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 746;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be712631c87fcbe3bc2bb6dcb0fd15ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_be712631c87fcbe3bc2bb6dcb0fd15ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_be712631c87fcbe3bc2bb6dcb0fd15ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_be712631c87fcbe3bc2bb6dcb0fd15ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_be712631c87fcbe3bc2bb6dcb0fd15ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_be712631c87fcbe3bc2bb6dcb0fd15ab, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_be712631c87fcbe3bc2bb6dcb0fd15ab,
        type_description_1,
        par_self,
        par_formatter,
        var_output
    );


    // Release cached frame.
    if ( frame_be712631c87fcbe3bc2bb6dcb0fd15ab == cache_frame_be712631c87fcbe3bc2bb6dcb0fd15ab )
    {
        Py_DECREF( frame_be712631c87fcbe3bc2bb6dcb0fd15ab );
    }
    cache_frame_be712631c87fcbe3bc2bb6dcb0fd15ab = NULL;

    assertFrameObject( frame_be712631c87fcbe3bc2bb6dcb0fd15ab );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_57_output_ready );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_output );
    Py_DECREF( var_output );
    var_output = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_output );
    var_output = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_57_output_ready );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_58_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_58_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_58_name );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_59_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_363b9dadd23cca41333766adec78f9ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_363b9dadd23cca41333766adec78f9ef = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_363b9dadd23cca41333766adec78f9ef, codeobj_363b9dadd23cca41333766adec78f9ef, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_363b9dadd23cca41333766adec78f9ef = cache_frame_363b9dadd23cca41333766adec78f9ef;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_363b9dadd23cca41333766adec78f9ef );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_363b9dadd23cca41333766adec78f9ef ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        tmp_make_exception_arg_1 = const_str_digest_427ece6c74a8f7bed9c0a0f9f58768bf;
        frame_363b9dadd23cca41333766adec78f9ef->m_frame.f_lineno = 754;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
        }

        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 754;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_363b9dadd23cca41333766adec78f9ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_363b9dadd23cca41333766adec78f9ef );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_363b9dadd23cca41333766adec78f9ef, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_363b9dadd23cca41333766adec78f9ef->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_363b9dadd23cca41333766adec78f9ef, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_363b9dadd23cca41333766adec78f9ef,
        type_description_1,
        par_self,
        par_name
    );


    // Release cached frame.
    if ( frame_363b9dadd23cca41333766adec78f9ef == cache_frame_363b9dadd23cca41333766adec78f9ef )
    {
        Py_DECREF( frame_363b9dadd23cca41333766adec78f9ef );
    }
    cache_frame_363b9dadd23cca41333766adec78f9ef = NULL;

    assertFrameObject( frame_363b9dadd23cca41333766adec78f9ef );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_59_name );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_59_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_bs4$element$$$function_60_output_ready( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_formatter = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_f4cab256fd83a2e1d0fcdc2f34349723;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f4cab256fd83a2e1d0fcdc2f34349723 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f4cab256fd83a2e1d0fcdc2f34349723, codeobj_f4cab256fd83a2e1d0fcdc2f34349723, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_f4cab256fd83a2e1d0fcdc2f34349723 = cache_frame_f4cab256fd83a2e1d0fcdc2f34349723;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f4cab256fd83a2e1d0fcdc2f34349723 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f4cab256fd83a2e1d0fcdc2f34349723 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_self );
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT( par_formatter );
        tmp_args_element_name_2 = par_formatter;
        frame_f4cab256fd83a2e1d0fcdc2f34349723->m_frame.f_lineno = 766;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_format_string, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 766;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PREFIX );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 767;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_right_name_1 = par_self;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 767;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SUFFIX );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 767;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 767;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4cab256fd83a2e1d0fcdc2f34349723 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4cab256fd83a2e1d0fcdc2f34349723 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f4cab256fd83a2e1d0fcdc2f34349723 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f4cab256fd83a2e1d0fcdc2f34349723, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f4cab256fd83a2e1d0fcdc2f34349723->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f4cab256fd83a2e1d0fcdc2f34349723, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f4cab256fd83a2e1d0fcdc2f34349723,
        type_description_1,
        par_self,
        par_formatter
    );


    // Release cached frame.
    if ( frame_f4cab256fd83a2e1d0fcdc2f34349723 == cache_frame_f4cab256fd83a2e1d0fcdc2f34349723 )
    {
        Py_DECREF( frame_f4cab256fd83a2e1d0fcdc2f34349723 );
    }
    cache_frame_f4cab256fd83a2e1d0fcdc2f34349723 = NULL;

    assertFrameObject( frame_f4cab256fd83a2e1d0fcdc2f34349723 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_60_output_ready );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_60_output_ready );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_61_for_name_and_ids( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_pub_id = python_pars[ 2 ];
    PyObject *par_system_id = python_pars[ 3 ];
    PyObject *var_value = NULL;
    struct Nuitka_FrameObject *frame_c01b4cc490155bdf7d76523f4d2063da;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c01b4cc490155bdf7d76523f4d2063da = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c01b4cc490155bdf7d76523f4d2063da, codeobj_c01b4cc490155bdf7d76523f4d2063da, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_c01b4cc490155bdf7d76523f4d2063da = cache_frame_c01b4cc490155bdf7d76523f4d2063da;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c01b4cc490155bdf7d76523f4d2063da );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c01b4cc490155bdf7d76523f4d2063da ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        CHECK_OBJECT( par_name );
        tmp_or_left_value_1 = par_name;
        tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
        if ( tmp_or_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 800;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        tmp_or_right_value_1 = const_str_empty;
        tmp_assign_source_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_assign_source_1 = tmp_or_left_value_1;
        or_end_1:;
        assert( var_value == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_value = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_pub_id );
        tmp_compexpr_left_1 = par_pub_id;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_right_name_2;
            CHECK_OBJECT( var_value );
            tmp_left_name_1 = var_value;
            tmp_left_name_2 = const_str_digest_6e71b18f4f00a0af73d97ee880b369b1;
            CHECK_OBJECT( par_pub_id );
            tmp_right_name_2 = par_pub_id;
            tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
            if ( tmp_right_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 802;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 802;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_2 = tmp_left_name_1;
            var_value = tmp_assign_source_2;

        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_system_id );
            tmp_compexpr_left_2 = par_system_id;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_left_name_3;
                PyObject *tmp_right_name_3;
                PyObject *tmp_left_name_4;
                PyObject *tmp_right_name_4;
                CHECK_OBJECT( var_value );
                tmp_left_name_3 = var_value;
                tmp_left_name_4 = const_str_digest_b08f55921cd8c7f8cc8a2534d60adbcd;
                CHECK_OBJECT( par_system_id );
                tmp_right_name_4 = par_system_id;
                tmp_right_name_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
                if ( tmp_right_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 804;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE( &tmp_left_name_3, tmp_right_name_3 );
                Py_DECREF( tmp_right_name_3 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 804;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_3 = tmp_left_name_3;
                var_value = tmp_assign_source_3;

            }
            branch_no_2:;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            CHECK_OBJECT( par_system_id );
            tmp_compexpr_left_3 = par_system_id;
            tmp_compexpr_right_3 = Py_None;
            tmp_condition_result_3 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_4;
                PyObject *tmp_left_name_5;
                PyObject *tmp_right_name_5;
                PyObject *tmp_left_name_6;
                PyObject *tmp_right_name_6;
                CHECK_OBJECT( var_value );
                tmp_left_name_5 = var_value;
                tmp_left_name_6 = const_str_digest_a9c30e8b7efc851a52b36f9f117da2a2;
                CHECK_OBJECT( par_system_id );
                tmp_right_name_6 = par_system_id;
                tmp_right_name_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
                if ( tmp_right_name_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 806;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE( &tmp_left_name_5, tmp_right_name_5 );
                Py_DECREF( tmp_right_name_5 );
                if ( tmp_result == false )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 806;
                    type_description_1 = "ooooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_4 = tmp_left_name_5;
                var_value = tmp_assign_source_4;

            }
            branch_no_3:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Doctype );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Doctype );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Doctype" );
            exception_tb = NULL;

            exception_lineno = 808;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        if ( var_value == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "value" );
            exception_tb = NULL;

            exception_lineno = 808;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = var_value;
        frame_c01b4cc490155bdf7d76523f4d2063da->m_frame.f_lineno = 808;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 808;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c01b4cc490155bdf7d76523f4d2063da );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c01b4cc490155bdf7d76523f4d2063da );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c01b4cc490155bdf7d76523f4d2063da );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c01b4cc490155bdf7d76523f4d2063da, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c01b4cc490155bdf7d76523f4d2063da->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c01b4cc490155bdf7d76523f4d2063da, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c01b4cc490155bdf7d76523f4d2063da,
        type_description_1,
        par_cls,
        par_name,
        par_pub_id,
        par_system_id,
        var_value
    );


    // Release cached frame.
    if ( frame_c01b4cc490155bdf7d76523f4d2063da == cache_frame_c01b4cc490155bdf7d76523f4d2063da )
    {
        Py_DECREF( frame_c01b4cc490155bdf7d76523f4d2063da );
    }
    cache_frame_c01b4cc490155bdf7d76523f4d2063da = NULL;

    assertFrameObject( frame_c01b4cc490155bdf7d76523f4d2063da );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_61_for_name_and_ids );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_pub_id );
    Py_DECREF( par_pub_id );
    par_pub_id = NULL;

    CHECK_OBJECT( (PyObject *)par_system_id );
    Py_DECREF( par_system_id );
    par_system_id = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_pub_id );
    Py_DECREF( par_pub_id );
    par_pub_id = NULL;

    CHECK_OBJECT( (PyObject *)par_system_id );
    Py_DECREF( par_system_id );
    par_system_id = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_61_for_name_and_ids );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_62___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_parser = python_pars[ 1 ];
    PyObject *par_builder = python_pars[ 2 ];
    PyObject *par_name = python_pars[ 3 ];
    PyObject *par_namespace = python_pars[ 4 ];
    PyObject *par_prefix = python_pars[ 5 ];
    PyObject *par_attrs = python_pars[ 6 ];
    PyObject *par_parent = python_pars[ 7 ];
    PyObject *par_previous = python_pars[ 8 ];
    PyObject *par_is_xml = python_pars[ 9 ];
    PyObject *var_preserve_whitespace_tags = NULL;
    struct Nuitka_FrameObject *frame_5258e8cca0a1d712e5493a4091af0ee6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5258e8cca0a1d712e5493a4091af0ee6 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5258e8cca0a1d712e5493a4091af0ee6, codeobj_5258e8cca0a1d712e5493a4091af0ee6, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_5258e8cca0a1d712e5493a4091af0ee6 = cache_frame_5258e8cca0a1d712e5493a4091af0ee6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5258e8cca0a1d712e5493a4091af0ee6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5258e8cca0a1d712e5493a4091af0ee6 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_parser );
        tmp_compexpr_left_1 = par_parser;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assattr_name_1;
            PyObject *tmp_assattr_target_1;
            tmp_assattr_name_1 = Py_None;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_1 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_parser_class, tmp_assattr_name_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 824;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assattr_name_2;
            PyObject *tmp_source_name_1;
            PyObject *tmp_assattr_target_2;
            CHECK_OBJECT( par_parser );
            tmp_source_name_1 = par_parser;
            tmp_assattr_name_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_1 );
            if ( tmp_assattr_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 828;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_2 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_parser_class, tmp_assattr_name_2 );
            Py_DECREF( tmp_assattr_name_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 828;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_name );
        tmp_compexpr_left_2 = par_name;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_91a4593114737d6b7d9b775dc212ec2f;
            frame_5258e8cca0a1d712e5493a4091af0ee6->m_frame.f_lineno = 830;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 830;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_name );
        tmp_assattr_name_3 = par_name;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_name, tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 831;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT( par_namespace );
        tmp_assattr_name_4 = par_namespace;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_namespace, tmp_assattr_name_4 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 832;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        CHECK_OBJECT( par_prefix );
        tmp_assattr_name_5 = par_prefix;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_prefix, tmp_assattr_name_5 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 833;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( par_builder );
        tmp_compexpr_left_3 = par_builder;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_builder );
            tmp_source_name_2 = par_builder;
            tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_preserve_whitespace_tags );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 835;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_preserve_whitespace_tags == NULL );
            var_preserve_whitespace_tags = tmp_assign_source_1;
        }
        goto branch_end_3;
        branch_no_3:;
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_truth_name_1;
            CHECK_OBJECT( par_is_xml );
            tmp_truth_name_1 = CHECK_IF_TRUE( par_is_xml );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 837;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_2;
                tmp_assign_source_2 = PyList_New( 0 );
                assert( var_preserve_whitespace_tags == NULL );
                var_preserve_whitespace_tags = tmp_assign_source_2;
            }
            goto branch_end_4;
            branch_no_4:;
            {
                PyObject *tmp_assign_source_3;
                PyObject *tmp_source_name_3;
                PyObject *tmp_mvar_value_1;
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );

                if (unlikely( tmp_mvar_value_1 == NULL ))
                {
                    tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution );
                }

                if ( tmp_mvar_value_1 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "HTMLAwareEntitySubstitution" );
                    exception_tb = NULL;

                    exception_lineno = 840;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_source_name_3 = tmp_mvar_value_1;
                tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_preserve_whitespace_tags );
                if ( tmp_assign_source_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 840;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_preserve_whitespace_tags == NULL );
                var_preserve_whitespace_tags = tmp_assign_source_3;
            }
            branch_end_4:;
        }
        branch_end_3:;
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        if ( var_preserve_whitespace_tags == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "preserve_whitespace_tags" );
            exception_tb = NULL;

            exception_lineno = 841;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_assattr_name_6 = var_preserve_whitespace_tags;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_preserve_whitespace_tags, tmp_assattr_name_6 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 841;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT( par_attrs );
        tmp_compexpr_left_4 = par_attrs;
        tmp_compexpr_right_4 = Py_None;
        tmp_condition_result_5 = ( tmp_compexpr_left_4 == tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyDict_New();
            {
                PyObject *old = par_attrs;
                assert( old != NULL );
                par_attrs = tmp_assign_source_4;
                Py_DECREF( old );
            }

        }
        goto branch_end_5;
        branch_no_5:;
        {
            nuitka_bool tmp_condition_result_6;
            int tmp_truth_name_2;
            CHECK_OBJECT( par_attrs );
            tmp_truth_name_2 = CHECK_IF_TRUE( par_attrs );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 844;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_6 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_6;
            }
            else
            {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                nuitka_bool tmp_condition_result_7;
                int tmp_and_left_truth_1;
                nuitka_bool tmp_and_left_value_1;
                nuitka_bool tmp_and_right_value_1;
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                PyObject *tmp_source_name_4;
                PyObject *tmp_attribute_value_1;
                int tmp_truth_name_3;
                CHECK_OBJECT( par_builder );
                tmp_compexpr_left_5 = par_builder;
                tmp_compexpr_right_5 = Py_None;
                tmp_and_left_value_1 = ( tmp_compexpr_left_5 != tmp_compexpr_right_5 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_and_left_truth_1 == 1 )
                {
                    goto and_right_1;
                }
                else
                {
                    goto and_left_1;
                }
                and_right_1:;
                CHECK_OBJECT( par_builder );
                tmp_source_name_4 = par_builder;
                tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_cdata_list_attributes );
                if ( tmp_attribute_value_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 845;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_3 = CHECK_IF_TRUE( tmp_attribute_value_1 );
                if ( tmp_truth_name_3 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_attribute_value_1 );

                    exception_lineno = 845;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_and_right_value_1 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_attribute_value_1 );
                tmp_condition_result_7 = tmp_and_right_value_1;
                goto and_end_1;
                and_left_1:;
                tmp_condition_result_7 = tmp_and_left_value_1;
                and_end_1:;
                if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_7;
                }
                else
                {
                    goto branch_no_7;
                }
                branch_yes_7:;
                {
                    PyObject *tmp_assign_source_5;
                    PyObject *tmp_called_name_1;
                    PyObject *tmp_source_name_5;
                    PyObject *tmp_args_element_name_1;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_args_element_name_2;
                    CHECK_OBJECT( par_builder );
                    tmp_source_name_5 = par_builder;
                    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__replace_cdata_list_attribute_values );
                    if ( tmp_called_name_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 846;
                        type_description_1 = "ooooooooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( par_self );
                    tmp_source_name_6 = par_self;
                    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_name );
                    if ( tmp_args_element_name_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_1 );

                        exception_lineno = 847;
                        type_description_1 = "ooooooooooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( par_attrs );
                    tmp_args_element_name_2 = par_attrs;
                    frame_5258e8cca0a1d712e5493a4091af0ee6->m_frame.f_lineno = 846;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
                    }

                    Py_DECREF( tmp_called_name_1 );
                    Py_DECREF( tmp_args_element_name_1 );
                    if ( tmp_assign_source_5 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 846;
                        type_description_1 = "ooooooooooo";
                        goto frame_exception_exit_1;
                    }
                    {
                        PyObject *old = par_attrs;
                        assert( old != NULL );
                        par_attrs = tmp_assign_source_5;
                        Py_DECREF( old );
                    }

                }
                goto branch_end_7;
                branch_no_7:;
                {
                    PyObject *tmp_assign_source_6;
                    PyObject *tmp_dict_seq_1;
                    CHECK_OBJECT( par_attrs );
                    tmp_dict_seq_1 = par_attrs;
                    tmp_assign_source_6 = TO_DICT( tmp_dict_seq_1, NULL );
                    if ( tmp_assign_source_6 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 849;
                        type_description_1 = "ooooooooooo";
                        goto frame_exception_exit_1;
                    }
                    {
                        PyObject *old = par_attrs;
                        assert( old != NULL );
                        par_attrs = tmp_assign_source_6;
                        Py_DECREF( old );
                    }

                }
                branch_end_7:;
            }
            goto branch_end_6;
            branch_no_6:;
            {
                PyObject *tmp_assign_source_7;
                PyObject *tmp_dict_seq_2;
                CHECK_OBJECT( par_attrs );
                tmp_dict_seq_2 = par_attrs;
                tmp_assign_source_7 = TO_DICT( tmp_dict_seq_2, NULL );
                if ( tmp_assign_source_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 851;
                    type_description_1 = "ooooooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_attrs;
                    assert( old != NULL );
                    par_attrs = tmp_assign_source_7;
                    Py_DECREF( old );
                }

            }
            branch_end_6:;
        }
        branch_end_5:;
    }
    {
        nuitka_bool tmp_condition_result_8;
        int tmp_truth_name_4;
        CHECK_OBJECT( par_builder );
        tmp_truth_name_4 = CHECK_IF_TRUE( par_builder );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 855;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_8 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assattr_name_7;
            PyObject *tmp_source_name_7;
            PyObject *tmp_assattr_target_7;
            CHECK_OBJECT( par_builder );
            tmp_source_name_7 = par_builder;
            tmp_assattr_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_is_xml );
            if ( tmp_assattr_name_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 856;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_7 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_known_xml, tmp_assattr_name_7 );
            Py_DECREF( tmp_assattr_name_7 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 856;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_8;
        branch_no_8:;
        {
            PyObject *tmp_assattr_name_8;
            PyObject *tmp_assattr_target_8;
            CHECK_OBJECT( par_is_xml );
            tmp_assattr_name_8 = par_is_xml;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_8 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_known_xml, tmp_assattr_name_8 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 858;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_8:;
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        if ( par_attrs == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "attrs" );
            exception_tb = NULL;

            exception_lineno = 859;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_assattr_name_9 = par_attrs;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain_attrs, tmp_assattr_name_9 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 859;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_assattr_target_10;
        tmp_assattr_name_10 = PyList_New( 0 );
        CHECK_OBJECT( par_self );
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain_contents, tmp_assattr_name_10 );
        Py_DECREF( tmp_assattr_name_10 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 860;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_parent );
        tmp_args_element_name_3 = par_parent;
        CHECK_OBJECT( par_previous );
        tmp_args_element_name_4 = par_previous;
        frame_5258e8cca0a1d712e5493a4091af0ee6->m_frame.f_lineno = 861;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_setup, call_args );
        }

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 861;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_assattr_target_11;
        tmp_assattr_name_11 = Py_False;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain_hidden, tmp_assattr_name_11 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 862;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        CHECK_OBJECT( par_builder );
        tmp_compexpr_left_6 = par_builder;
        tmp_compexpr_right_6 = Py_None;
        tmp_condition_result_9 = ( tmp_compexpr_left_6 != tmp_compexpr_right_6 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT( par_builder );
            tmp_called_instance_2 = par_builder;
            CHECK_OBJECT( par_self );
            tmp_args_element_name_5 = par_self;
            frame_5258e8cca0a1d712e5493a4091af0ee6->m_frame.f_lineno = 866;
            {
                PyObject *call_args[] = { tmp_args_element_name_5 };
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_set_up_substitutions, call_args );
            }

            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 866;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            PyObject *tmp_assattr_name_12;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_assattr_target_12;
            CHECK_OBJECT( par_builder );
            tmp_called_instance_3 = par_builder;
            CHECK_OBJECT( par_name );
            tmp_args_element_name_6 = par_name;
            frame_5258e8cca0a1d712e5493a4091af0ee6->m_frame.f_lineno = 867;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_assattr_name_12 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_can_be_empty_element, call_args );
            }

            if ( tmp_assattr_name_12 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 867;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_self );
            tmp_assattr_target_12 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain_can_be_empty_element, tmp_assattr_name_12 );
            Py_DECREF( tmp_assattr_name_12 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 867;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        goto branch_end_9;
        branch_no_9:;
        {
            PyObject *tmp_assattr_name_13;
            PyObject *tmp_assattr_target_13;
            tmp_assattr_name_13 = Py_False;
            CHECK_OBJECT( par_self );
            tmp_assattr_target_13 = par_self;
            tmp_result = SET_ATTRIBUTE( tmp_assattr_target_13, const_str_plain_can_be_empty_element, tmp_assattr_name_13 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 869;
                type_description_1 = "ooooooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_end_9:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5258e8cca0a1d712e5493a4091af0ee6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5258e8cca0a1d712e5493a4091af0ee6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5258e8cca0a1d712e5493a4091af0ee6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5258e8cca0a1d712e5493a4091af0ee6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5258e8cca0a1d712e5493a4091af0ee6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5258e8cca0a1d712e5493a4091af0ee6,
        type_description_1,
        par_self,
        par_parser,
        par_builder,
        par_name,
        par_namespace,
        par_prefix,
        par_attrs,
        par_parent,
        par_previous,
        par_is_xml,
        var_preserve_whitespace_tags
    );


    // Release cached frame.
    if ( frame_5258e8cca0a1d712e5493a4091af0ee6 == cache_frame_5258e8cca0a1d712e5493a4091af0ee6 )
    {
        Py_DECREF( frame_5258e8cca0a1d712e5493a4091af0ee6 );
    }
    cache_frame_5258e8cca0a1d712e5493a4091af0ee6 = NULL;

    assertFrameObject( frame_5258e8cca0a1d712e5493a4091af0ee6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_62___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_parent );
    Py_DECREF( par_parent );
    par_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_parser );
    Py_DECREF( par_parser );
    par_parser = NULL;

    CHECK_OBJECT( (PyObject *)par_namespace );
    Py_DECREF( par_namespace );
    par_namespace = NULL;

    Py_XDECREF( var_preserve_whitespace_tags );
    var_preserve_whitespace_tags = NULL;

    CHECK_OBJECT( (PyObject *)par_prefix );
    Py_DECREF( par_prefix );
    par_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_is_xml );
    Py_DECREF( par_is_xml );
    par_is_xml = NULL;

    Py_XDECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_builder );
    Py_DECREF( par_builder );
    par_builder = NULL;

    CHECK_OBJECT( (PyObject *)par_previous );
    Py_DECREF( par_previous );
    par_previous = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_parent );
    Py_DECREF( par_parent );
    par_parent = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_parser );
    Py_DECREF( par_parser );
    par_parser = NULL;

    CHECK_OBJECT( (PyObject *)par_namespace );
    Py_DECREF( par_namespace );
    par_namespace = NULL;

    Py_XDECREF( var_preserve_whitespace_tags );
    var_preserve_whitespace_tags = NULL;

    CHECK_OBJECT( (PyObject *)par_prefix );
    Py_DECREF( par_prefix );
    par_prefix = NULL;

    CHECK_OBJECT( (PyObject *)par_is_xml );
    Py_DECREF( par_is_xml );
    par_is_xml = NULL;

    Py_XDECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_builder );
    Py_DECREF( par_builder );
    par_builder = NULL;

    CHECK_OBJECT( (PyObject *)par_previous );
    Py_DECREF( par_previous );
    par_previous = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_62___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_63___copy__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_child = NULL;
    PyObject *var_clone = NULL;
    PyObject *var_attr = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    struct Nuitka_FrameObject *frame_28dae34448982e5cb647814084cb47ed;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_28dae34448982e5cb647814084cb47ed = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_28dae34448982e5cb647814084cb47ed, codeobj_28dae34448982e5cb647814084cb47ed, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_28dae34448982e5cb647814084cb47ed = cache_frame_28dae34448982e5cb647814084cb47ed;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_28dae34448982e5cb647814084cb47ed );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_28dae34448982e5cb647814084cb47ed ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_type_arg_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_6;
        CHECK_OBJECT( par_self );
        tmp_type_arg_1 = par_self;
        tmp_called_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_called_name_1 == NULL) );
        tmp_tuple_element_1 = Py_None;
        tmp_args_name_1 = PyTuple_New( 6 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_builder );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 877;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 877;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_namespace );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 877;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_args_name_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_prefix );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 878;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_args_name_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_attrs );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 878;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        PyTuple_SET_ITEM( tmp_args_name_1, 5, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__is_xml );
        if ( tmp_dict_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_name_1 );

            exception_lineno = 878;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_is_xml;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        Py_DECREF( tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        frame_28dae34448982e5cb647814084cb47ed->m_frame.f_lineno = 877;
        tmp_assign_source_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 877;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_clone == NULL );
        var_clone = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        tmp_iter_arg_1 = const_tuple_str_plain_can_be_empty_element_str_plain_hidden_tuple;
        tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
        assert( !(tmp_assign_source_2 == NULL) );
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_3 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 879;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_attr;
            var_attr = tmp_assign_source_4;
            Py_INCREF( var_attr );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_setattr_target_1;
        PyObject *tmp_setattr_attr_1;
        PyObject *tmp_setattr_value_1;
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_getattr_attr_1;
        PyObject *tmp_capi_result_1;
        CHECK_OBJECT( var_clone );
        tmp_setattr_target_1 = var_clone;
        CHECK_OBJECT( var_attr );
        tmp_setattr_attr_1 = var_attr;
        CHECK_OBJECT( par_self );
        tmp_getattr_target_1 = par_self;
        CHECK_OBJECT( var_attr );
        tmp_getattr_attr_1 = var_attr;
        tmp_setattr_value_1 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, NULL );
        if ( tmp_setattr_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 880;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_capi_result_1 = BUILTIN_SETATTR( tmp_setattr_target_1, tmp_setattr_attr_1, tmp_setattr_value_1 );
        Py_DECREF( tmp_setattr_value_1 );
        if ( tmp_capi_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 880;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_iter_arg_2;
        PyObject *tmp_source_name_7;
        CHECK_OBJECT( par_self );
        tmp_source_name_7 = par_self;
        tmp_iter_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_contents );
        if ( tmp_iter_arg_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 881;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_2 );
        Py_DECREF( tmp_iter_arg_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 881;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_2__for_iterator == NULL );
        tmp_for_loop_2__for_iterator = tmp_assign_source_5;
    }
    // Tried code:
    loop_start_2:;
    {
        PyObject *tmp_next_source_2;
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_2__for_iterator );
        tmp_next_source_2 = tmp_for_loop_2__for_iterator;
        tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_2 );
        if ( tmp_assign_source_6 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_2;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 881;
                goto try_except_handler_3;
            }
        }

        {
            PyObject *old = tmp_for_loop_2__iter_value;
            tmp_for_loop_2__iter_value = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        CHECK_OBJECT( tmp_for_loop_2__iter_value );
        tmp_assign_source_7 = tmp_for_loop_2__iter_value;
        {
            PyObject *old = var_child;
            var_child = tmp_assign_source_7;
            Py_INCREF( var_child );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( var_clone );
        tmp_source_name_8 = var_clone;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_append );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 882;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        CHECK_OBJECT( var_child );
        tmp_called_instance_1 = var_child;
        frame_28dae34448982e5cb647814084cb47ed->m_frame.f_lineno = 882;
        tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain___copy__ );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 882;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        frame_28dae34448982e5cb647814084cb47ed->m_frame.f_lineno = 882;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 882;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 881;
        type_description_1 = "oooo";
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_28dae34448982e5cb647814084cb47ed );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_28dae34448982e5cb647814084cb47ed );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_28dae34448982e5cb647814084cb47ed, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_28dae34448982e5cb647814084cb47ed->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_28dae34448982e5cb647814084cb47ed, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_28dae34448982e5cb647814084cb47ed,
        type_description_1,
        par_self,
        var_child,
        var_clone,
        var_attr
    );


    // Release cached frame.
    if ( frame_28dae34448982e5cb647814084cb47ed == cache_frame_28dae34448982e5cb647814084cb47ed )
    {
        Py_DECREF( frame_28dae34448982e5cb647814084cb47ed );
    }
    cache_frame_28dae34448982e5cb647814084cb47ed = NULL;

    assertFrameObject( frame_28dae34448982e5cb647814084cb47ed );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    CHECK_OBJECT( var_clone );
    tmp_return_value = var_clone;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_63___copy__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    CHECK_OBJECT( (PyObject *)var_clone );
    Py_DECREF( var_clone );
    var_clone = NULL;

    Py_XDECREF( var_attr );
    var_attr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    Py_XDECREF( var_clone );
    var_clone = NULL;

    Py_XDECREF( var_attr );
    var_attr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_63___copy__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_64_is_empty_element( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_aa9ed37f4d2da439684924b28158708d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_aa9ed37f4d2da439684924b28158708d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aa9ed37f4d2da439684924b28158708d, codeobj_aa9ed37f4d2da439684924b28158708d, module_bs4$element, sizeof(void *) );
    frame_aa9ed37f4d2da439684924b28158708d = cache_frame_aa9ed37f4d2da439684924b28158708d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aa9ed37f4d2da439684924b28158708d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aa9ed37f4d2da439684924b28158708d ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_len_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 900;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        Py_DECREF( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 900;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_0;
        tmp_and_left_value_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_and_left_value_1 == NULL) );
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_and_left_value_1 );

            exception_lineno = 900;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        Py_DECREF( tmp_and_left_value_1 );
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_can_be_empty_element );
        if ( tmp_and_right_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 900;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa9ed37f4d2da439684924b28158708d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa9ed37f4d2da439684924b28158708d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa9ed37f4d2da439684924b28158708d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aa9ed37f4d2da439684924b28158708d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aa9ed37f4d2da439684924b28158708d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aa9ed37f4d2da439684924b28158708d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aa9ed37f4d2da439684924b28158708d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_aa9ed37f4d2da439684924b28158708d == cache_frame_aa9ed37f4d2da439684924b28158708d )
    {
        Py_DECREF( frame_aa9ed37f4d2da439684924b28158708d );
    }
    cache_frame_aa9ed37f4d2da439684924b28158708d = NULL;

    assertFrameObject( frame_aa9ed37f4d2da439684924b28158708d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_64_is_empty_element );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_64_is_empty_element );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_65_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_child = NULL;
    struct Nuitka_FrameObject *frame_b70a4906c97184e98518c95aaa529398;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b70a4906c97184e98518c95aaa529398 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b70a4906c97184e98518c95aaa529398, codeobj_b70a4906c97184e98518c95aaa529398, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_b70a4906c97184e98518c95aaa529398 = cache_frame_b70a4906c97184e98518c95aaa529398;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b70a4906c97184e98518c95aaa529398 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b70a4906c97184e98518c95aaa529398 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_len_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 913;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        Py_DECREF( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 913;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_1;
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_contents );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_1 = const_int_0;
        tmp_assign_source_1 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 915;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert( var_child == NULL );
        var_child = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( var_child );
        tmp_isinstance_inst_1 = var_child;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
            exception_tb = NULL;

            exception_lineno = 916;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 916;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        CHECK_OBJECT( var_child );
        tmp_return_value = var_child;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_source_name_3;
        CHECK_OBJECT( var_child );
        tmp_source_name_3 = var_child;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_string );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 918;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b70a4906c97184e98518c95aaa529398 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b70a4906c97184e98518c95aaa529398 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b70a4906c97184e98518c95aaa529398 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b70a4906c97184e98518c95aaa529398, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b70a4906c97184e98518c95aaa529398->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b70a4906c97184e98518c95aaa529398, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b70a4906c97184e98518c95aaa529398,
        type_description_1,
        par_self,
        var_child
    );


    // Release cached frame.
    if ( frame_b70a4906c97184e98518c95aaa529398 == cache_frame_b70a4906c97184e98518c95aaa529398 )
    {
        Py_DECREF( frame_b70a4906c97184e98518c95aaa529398 );
    }
    cache_frame_b70a4906c97184e98518c95aaa529398 = NULL;

    assertFrameObject( frame_b70a4906c97184e98518c95aaa529398 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_65_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_65_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_66_string( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_string = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_5548f114506669f9d9e933fd7df4510b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5548f114506669f9d9e933fd7df4510b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5548f114506669f9d9e933fd7df4510b, codeobj_5548f114506669f9d9e933fd7df4510b, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_5548f114506669f9d9e933fd7df4510b = cache_frame_5548f114506669f9d9e933fd7df4510b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5548f114506669f9d9e933fd7df4510b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5548f114506669f9d9e933fd7df4510b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_5548f114506669f9d9e933fd7df4510b->m_frame.f_lineno = 922;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_clear );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 922;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 923;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_string );
        tmp_source_name_2 = par_string;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 923;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_string );
        tmp_args_element_name_2 = par_string;
        frame_5548f114506669f9d9e933fd7df4510b->m_frame.f_lineno = 923;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 923;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_5548f114506669f9d9e933fd7df4510b->m_frame.f_lineno = 923;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 923;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5548f114506669f9d9e933fd7df4510b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5548f114506669f9d9e933fd7df4510b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5548f114506669f9d9e933fd7df4510b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5548f114506669f9d9e933fd7df4510b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5548f114506669f9d9e933fd7df4510b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5548f114506669f9d9e933fd7df4510b,
        type_description_1,
        par_self,
        par_string
    );


    // Release cached frame.
    if ( frame_5548f114506669f9d9e933fd7df4510b == cache_frame_5548f114506669f9d9e933fd7df4510b )
    {
        Py_DECREF( frame_5548f114506669f9d9e933fd7df4510b );
    }
    cache_frame_5548f114506669f9d9e933fd7df4510b = NULL;

    assertFrameObject( frame_5548f114506669f9d9e933fd7df4510b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_66_string );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_string );
    Py_DECREF( par_string );
    par_string = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_string );
    Py_DECREF( par_string );
    par_string = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_66_string );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_67__all_strings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    struct Nuitka_CellObject *par_strip = PyCell_NEW1( python_pars[ 1 ] );
    struct Nuitka_CellObject *par_types = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] = par_strip;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[1] );
    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[2] = par_types;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[2] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_67__all_strings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_types );
    Py_DECREF( par_types );
    par_types = NULL;

    CHECK_OBJECT( (PyObject *)par_strip );
    Py_DECREF( par_strip );
    par_strip = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_types );
    Py_DECREF( par_types );
    par_types = NULL;

    CHECK_OBJECT( (PyObject *)par_strip );
    Py_DECREF( par_strip );
    par_strip = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_67__all_strings );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_locals {
    PyObject *var_descendant;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_locals *generator_heap = (struct bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_descendant = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_30b570e03eb3cc558516ab120ff84408, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 931;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_descendants );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 931;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 931;
            generator_heap->type_description_1 = "ccco";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "ccco";
                generator_heap->exception_lineno = 931;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_descendant;
            generator_heap->var_descendant = tmp_assign_source_3;
            Py_INCREF( generator_heap->var_descendant );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_type_arg_1;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "types" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 933;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }

        tmp_compexpr_left_1 = PyCell_GET( generator->m_closure[2] );
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( generator_heap->var_descendant );
        tmp_isinstance_inst_1 = generator_heap->var_descendant;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 933;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        generator_heap->tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 933;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }
        tmp_operand_name_1 = ( generator_heap->tmp_res != 0 ) ? Py_True : Py_False;
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 933;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }
        tmp_and_right_value_1 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_value_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_or_left_value_1 = tmp_and_left_value_1;
        and_end_1:;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "types" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 935;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }

        tmp_compexpr_left_2 = PyCell_GET( generator->m_closure[2] );
        tmp_compexpr_right_2 = Py_None;
        tmp_and_left_value_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( generator_heap->var_descendant );
        tmp_type_arg_1 = generator_heap->var_descendant;
        tmp_compexpr_left_3 = BUILTIN_TYPE1( tmp_type_arg_1 );
        assert( !(tmp_compexpr_left_3 == NULL) );
        if ( PyCell_GET( generator->m_closure[2] ) == NULL )
        {
            Py_DECREF( tmp_compexpr_left_3 );
            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "types" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 935;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_3 = PyCell_GET( generator->m_closure[2] );
        generator_heap->tmp_res = PySequence_Contains( tmp_compexpr_right_3, tmp_compexpr_left_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 935;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }
        tmp_and_right_value_2 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_right_value_1 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_or_right_value_1 = tmp_and_left_value_2;
        and_end_2:;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_start_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        if ( PyCell_GET( generator->m_closure[1] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "strip" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 937;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }

        tmp_truth_name_1 = CHECK_IF_TRUE( PyCell_GET( generator->m_closure[1] ) );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 937;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( generator_heap->var_descendant );
            tmp_called_instance_1 = generator_heap->var_descendant;
            generator->m_frame->m_frame.f_lineno = 938;
            tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_strip );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 938;
                generator_heap->type_description_1 = "ccco";
                goto try_except_handler_2;
            }
            {
                PyObject *old = generator_heap->var_descendant;
                assert( old != NULL );
                generator_heap->var_descendant = tmp_assign_source_4;
                Py_DECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_len_arg_1;
            CHECK_OBJECT( generator_heap->var_descendant );
            tmp_len_arg_1 = generator_heap->var_descendant;
            tmp_compexpr_left_4 = BUILTIN_LEN( tmp_len_arg_1 );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


                generator_heap->exception_lineno = 939;
                generator_heap->type_description_1 = "ccco";
                goto try_except_handler_2;
            }
            tmp_compexpr_right_4 = const_int_0;
            generator_heap->tmp_res = RICH_COMPARE_BOOL_EQ_OBJECT_INT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            assert( !(generator_heap->tmp_res == -1) );
            tmp_condition_result_3 = ( generator_heap->tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            goto loop_start_1;
            branch_no_3:;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_descendant );
        tmp_expression_name_1 = generator_heap->var_descendant;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 941;
            generator_heap->type_description_1 = "ccco";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 931;
        generator_heap->type_description_1 = "ccco";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator->m_closure[1],
            generator->m_closure[2],
            generator_heap->var_descendant
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_descendant );
    generator_heap->var_descendant = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    Py_XDECREF( generator_heap->var_descendant );
    generator_heap->var_descendant = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_context,
        module_bs4$element,
        const_str_plain__all_strings,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_30b570e03eb3cc558516ab120ff84408,
        3,
        sizeof(struct bs4$element$$$function_67__all_strings$$$genobj_1__all_strings_locals)
    );
}


static PyObject *impl_bs4$element$$$function_68_stripped_strings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_68_stripped_strings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_68_stripped_strings );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_locals {
    PyObject *var_string;
    PyObject *tmp_for_loop_1__for_iterator;
    PyObject *tmp_for_loop_1__iter_value;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    int exception_keeper_lineno_2;
};

static PyObject *bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_locals *generator_heap = (struct bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_string = NULL;
    generator_heap->tmp_for_loop_1__for_iterator = NULL;
    generator_heap->tmp_for_loop_1__iter_value = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_3d5f44d2cf135a3c60072595cf5a7ac9, module_bs4$element, sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 947;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = PyCell_GET( generator->m_closure[0] );
        generator->m_frame->m_frame.f_lineno = 947;
        tmp_iter_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__all_strings, &PyTuple_GET_ITEM( const_tuple_true_tuple, 0 ) );

        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 947;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 947;
            generator_heap->type_description_1 = "co";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->tmp_for_loop_1__for_iterator == NULL );
        generator_heap->tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = generator_heap->tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );
                generator_heap->type_description_1 = "co";
                generator_heap->exception_lineno = 947;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = generator_heap->tmp_for_loop_1__iter_value;
            generator_heap->tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( generator_heap->tmp_for_loop_1__iter_value );
        tmp_assign_source_3 = generator_heap->tmp_for_loop_1__iter_value;
        {
            PyObject *old = generator_heap->var_string;
            generator_heap->var_string = tmp_assign_source_3;
            Py_INCREF( generator_heap->var_string );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_string );
        tmp_expression_name_1 = generator_heap->var_string;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 948;
            generator_heap->type_description_1 = "co";
            goto try_except_handler_2;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 947;
        generator_heap->type_description_1 = "co";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_string
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_2 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_2 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_2 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_2 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_string );
    generator_heap->var_string = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_2;
    generator_heap->exception_value = generator_heap->exception_keeper_value_2;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_2;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:
    try_end_2:;
    Py_XDECREF( generator_heap->tmp_for_loop_1__iter_value );
    generator_heap->tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->tmp_for_loop_1__for_iterator );
    Py_DECREF( generator_heap->tmp_for_loop_1__for_iterator );
    generator_heap->tmp_for_loop_1__for_iterator = NULL;

    Py_XDECREF( generator_heap->var_string );
    generator_heap->var_string = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;

}

static PyObject *bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_context,
        module_bs4$element,
        const_str_plain_stripped_strings,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_3d5f44d2cf135a3c60072595cf5a7ac9,
        1,
        sizeof(struct bs4$element$$$function_68_stripped_strings$$$genobj_1_stripped_strings_locals)
    );
}


static PyObject *impl_bs4$element$$$function_69_get_text( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_separator = python_pars[ 1 ];
    PyObject *par_strip = python_pars[ 2 ];
    PyObject *par_types = python_pars[ 3 ];
    PyObject *var_s = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_10e6028ad198a440f60e91ee9df066ba;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_10e6028ad198a440f60e91ee9df066ba = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_10e6028ad198a440f60e91ee9df066ba, codeobj_10e6028ad198a440f60e91ee9df066ba, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_10e6028ad198a440f60e91ee9df066ba = cache_frame_10e6028ad198a440f60e91ee9df066ba;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_10e6028ad198a440f60e91ee9df066ba );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_10e6028ad198a440f60e91ee9df066ba ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT( par_separator );
        tmp_source_name_1 = par_separator;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_join );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 955;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        // Tried code:
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__all_strings );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 955;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( par_strip );
            tmp_tuple_element_1 = par_strip;
            tmp_args_name_1 = PyTuple_New( 1 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_types );
            tmp_dict_value_1 = par_types;
            tmp_dict_key_1 = const_str_plain_types;
            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            frame_10e6028ad198a440f60e91ee9df066ba->m_frame.f_lineno = 955;
            tmp_iter_arg_1 = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_1, tmp_kw_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_name_1 );
            Py_DECREF( tmp_kw_name_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 955;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 955;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            assert( tmp_list_contraction_1__$0 == NULL );
            tmp_list_contraction_1__$0 = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = PyList_New( 0 );
            assert( tmp_list_contraction_1__contraction_result == NULL );
            tmp_list_contraction_1__contraction_result = tmp_assign_source_2;
        }
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( tmp_list_contraction_1__$0 );
            tmp_next_source_1 = tmp_list_contraction_1__$0;
            tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooo";
                    exception_lineno = 955;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_list_contraction_1__iter_value_0;
                tmp_list_contraction_1__iter_value_0 = tmp_assign_source_3;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT( tmp_list_contraction_1__iter_value_0 );
            tmp_assign_source_4 = tmp_list_contraction_1__iter_value_0;
            {
                PyObject *old = var_s;
                var_s = tmp_assign_source_4;
                Py_INCREF( var_s );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
            tmp_append_list_1 = tmp_list_contraction_1__contraction_result;
            CHECK_OBJECT( var_s );
            tmp_append_value_1 = var_s;
            assert( PyList_Check( tmp_append_list_1 ) );
            tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 955;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 955;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_list_contraction_1__contraction_result );
        tmp_args_element_name_1 = tmp_list_contraction_1__contraction_result;
        Py_INCREF( tmp_args_element_name_1 );
        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element$$$function_69_get_text );
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
        Py_DECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
        Py_DECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_list_contraction_1__$0 );
        tmp_list_contraction_1__$0 = NULL;

        Py_XDECREF( tmp_list_contraction_1__contraction_result );
        tmp_list_contraction_1__contraction_result = NULL;

        Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
        tmp_list_contraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element$$$function_69_get_text );
        return NULL;
        outline_result_1:;
        frame_10e6028ad198a440f60e91ee9df066ba->m_frame.f_lineno = 955;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 955;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10e6028ad198a440f60e91ee9df066ba );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_10e6028ad198a440f60e91ee9df066ba );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10e6028ad198a440f60e91ee9df066ba );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_10e6028ad198a440f60e91ee9df066ba, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_10e6028ad198a440f60e91ee9df066ba->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_10e6028ad198a440f60e91ee9df066ba, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_10e6028ad198a440f60e91ee9df066ba,
        type_description_1,
        par_self,
        par_separator,
        par_strip,
        par_types,
        var_s
    );


    // Release cached frame.
    if ( frame_10e6028ad198a440f60e91ee9df066ba == cache_frame_10e6028ad198a440f60e91ee9df066ba )
    {
        Py_DECREF( frame_10e6028ad198a440f60e91ee9df066ba );
    }
    cache_frame_10e6028ad198a440f60e91ee9df066ba = NULL;

    assertFrameObject( frame_10e6028ad198a440f60e91ee9df066ba );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_69_get_text );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_separator );
    Py_DECREF( par_separator );
    par_separator = NULL;

    Py_XDECREF( var_s );
    var_s = NULL;

    CHECK_OBJECT( (PyObject *)par_types );
    Py_DECREF( par_types );
    par_types = NULL;

    CHECK_OBJECT( (PyObject *)par_strip );
    Py_DECREF( par_strip );
    par_strip = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_separator );
    Py_DECREF( par_separator );
    par_separator = NULL;

    Py_XDECREF( var_s );
    var_s = NULL;

    CHECK_OBJECT( (PyObject *)par_types );
    Py_DECREF( par_types );
    par_types = NULL;

    CHECK_OBJECT( (PyObject *)par_strip );
    Py_DECREF( par_strip );
    par_strip = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_69_get_text );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_70_decompose( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_i = NULL;
    PyObject *var_next = NULL;
    struct Nuitka_FrameObject *frame_43f0e352fcabe0b721afedeac0d47b0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_43f0e352fcabe0b721afedeac0d47b0b = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_43f0e352fcabe0b721afedeac0d47b0b, codeobj_43f0e352fcabe0b721afedeac0d47b0b, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_43f0e352fcabe0b721afedeac0d47b0b = cache_frame_43f0e352fcabe0b721afedeac0d47b0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_43f0e352fcabe0b721afedeac0d47b0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_43f0e352fcabe0b721afedeac0d47b0b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_43f0e352fcabe0b721afedeac0d47b0b->m_frame.f_lineno = 962;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_extract );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 962;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assign_source_1;
        CHECK_OBJECT( par_self );
        tmp_assign_source_1 = par_self;
        assert( var_i == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_i = tmp_assign_source_1;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_i );
        tmp_compexpr_left_1 = var_i;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto loop_end_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( var_i );
        tmp_source_name_1 = var_i;
        tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_next_element );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 965;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_next;
            var_next = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT( var_i );
        tmp_source_name_2 = var_i;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE_DICT_SLOT( tmp_source_name_2 );
        if ( tmp_called_instance_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 966;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_43f0e352fcabe0b721afedeac0d47b0b->m_frame.f_lineno = 966;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_clear );
        Py_DECREF( tmp_called_instance_2 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 966;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_2 );
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = PyList_New( 0 );
        CHECK_OBJECT( var_i );
        tmp_assattr_target_1 = var_i;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_contents, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 967;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT( var_next );
        tmp_assign_source_3 = var_next;
        {
            PyObject *old = var_i;
            assert( old != NULL );
            var_i = tmp_assign_source_3;
            Py_INCREF( var_i );
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 964;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_43f0e352fcabe0b721afedeac0d47b0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_43f0e352fcabe0b721afedeac0d47b0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_43f0e352fcabe0b721afedeac0d47b0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_43f0e352fcabe0b721afedeac0d47b0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_43f0e352fcabe0b721afedeac0d47b0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_43f0e352fcabe0b721afedeac0d47b0b,
        type_description_1,
        par_self,
        var_i,
        var_next
    );


    // Release cached frame.
    if ( frame_43f0e352fcabe0b721afedeac0d47b0b == cache_frame_43f0e352fcabe0b721afedeac0d47b0b )
    {
        Py_DECREF( frame_43f0e352fcabe0b721afedeac0d47b0b );
    }
    cache_frame_43f0e352fcabe0b721afedeac0d47b0b = NULL;

    assertFrameObject( frame_43f0e352fcabe0b721afedeac0d47b0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_70_decompose );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_i );
    Py_DECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_next );
    var_next = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_next );
    var_next = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_70_decompose );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_71_clear( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_decompose = python_pars[ 1 ];
    PyObject *var_element = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    struct Nuitka_FrameObject *frame_7707ae06690f1d6d8642fa5203e1fb8c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_7707ae06690f1d6d8642fa5203e1fb8c = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7707ae06690f1d6d8642fa5203e1fb8c, codeobj_7707ae06690f1d6d8642fa5203e1fb8c, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7707ae06690f1d6d8642fa5203e1fb8c = cache_frame_7707ae06690f1d6d8642fa5203e1fb8c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7707ae06690f1d6d8642fa5203e1fb8c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7707ae06690f1d6d8642fa5203e1fb8c ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_decompose );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_decompose );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 974;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            PyObject *tmp_source_name_1;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_slice_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
            if ( tmp_slice_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 975;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_iter_arg_1 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
            Py_DECREF( tmp_slice_source_1 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 975;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 975;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_1;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_2;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooo";
                    exception_lineno = 975;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_2;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_3 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_element;
                var_element = tmp_assign_source_3;
                Py_INCREF( var_element );
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_isinstance_inst_1;
            PyObject *tmp_isinstance_cls_1;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT( var_element );
            tmp_isinstance_inst_1 = var_element;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
                exception_tb = NULL;

                exception_lineno = 976;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }

            tmp_isinstance_cls_1 = tmp_mvar_value_1;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 976;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_1;
                PyObject *tmp_call_result_1;
                CHECK_OBJECT( var_element );
                tmp_called_instance_1 = var_element;
                frame_7707ae06690f1d6d8642fa5203e1fb8c->m_frame.f_lineno = 977;
                tmp_call_result_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_decompose );
                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 977;
                    type_description_1 = "ooo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            goto branch_end_2;
            branch_no_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_call_result_2;
                CHECK_OBJECT( var_element );
                tmp_called_instance_2 = var_element;
                frame_7707ae06690f1d6d8642fa5203e1fb8c->m_frame.f_lineno = 979;
                tmp_call_result_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_extract );
                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 979;
                    type_description_1 = "ooo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_end_2:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 975;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_iter_arg_2;
            Py_ssize_t tmp_sliceslicedel_index_lower_2;
            Py_ssize_t tmp_slice_index_upper_2;
            PyObject *tmp_slice_source_2;
            PyObject *tmp_source_name_2;
            tmp_sliceslicedel_index_lower_2 = 0;
            tmp_slice_index_upper_2 = PY_SSIZE_T_MAX;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_slice_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_contents );
            if ( tmp_slice_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 981;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_iter_arg_2 = LOOKUP_INDEX_SLICE( tmp_slice_source_2, tmp_sliceslicedel_index_lower_2, tmp_slice_index_upper_2 );
            Py_DECREF( tmp_slice_source_2 );
            if ( tmp_iter_arg_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 981;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
            Py_DECREF( tmp_iter_arg_2 );
            if ( tmp_assign_source_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 981;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_2__for_iterator == NULL );
            tmp_for_loop_2__for_iterator = tmp_assign_source_4;
        }
        // Tried code:
        loop_start_2:;
        {
            PyObject *tmp_next_source_2;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT( tmp_for_loop_2__for_iterator );
            tmp_next_source_2 = tmp_for_loop_2__for_iterator;
            tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_2 );
            if ( tmp_assign_source_5 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_2;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooo";
                    exception_lineno = 981;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_for_loop_2__iter_value;
                tmp_for_loop_2__iter_value = tmp_assign_source_5;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT( tmp_for_loop_2__iter_value );
            tmp_assign_source_6 = tmp_for_loop_2__iter_value;
            {
                PyObject *old = var_element;
                var_element = tmp_assign_source_6;
                Py_INCREF( var_element );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_called_instance_3;
            PyObject *tmp_call_result_3;
            CHECK_OBJECT( var_element );
            tmp_called_instance_3 = var_element;
            frame_7707ae06690f1d6d8642fa5203e1fb8c->m_frame.f_lineno = 982;
            tmp_call_result_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_extract );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 982;
                type_description_1 = "ooo";
                goto try_except_handler_3;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 981;
            type_description_1 = "ooo";
            goto try_except_handler_3;
        }
        goto loop_start_2;
        loop_end_2:;
        goto try_end_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        try_end_2:;
        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7707ae06690f1d6d8642fa5203e1fb8c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7707ae06690f1d6d8642fa5203e1fb8c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7707ae06690f1d6d8642fa5203e1fb8c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7707ae06690f1d6d8642fa5203e1fb8c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7707ae06690f1d6d8642fa5203e1fb8c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7707ae06690f1d6d8642fa5203e1fb8c,
        type_description_1,
        par_self,
        par_decompose,
        var_element
    );


    // Release cached frame.
    if ( frame_7707ae06690f1d6d8642fa5203e1fb8c == cache_frame_7707ae06690f1d6d8642fa5203e1fb8c )
    {
        Py_DECREF( frame_7707ae06690f1d6d8642fa5203e1fb8c );
    }
    cache_frame_7707ae06690f1d6d8642fa5203e1fb8c = NULL;

    assertFrameObject( frame_7707ae06690f1d6d8642fa5203e1fb8c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_71_clear );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_decompose );
    Py_DECREF( par_decompose );
    par_decompose = NULL;

    Py_XDECREF( var_element );
    var_element = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_decompose );
    Py_DECREF( par_decompose );
    par_decompose = NULL;

    Py_XDECREF( var_element );
    var_element = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_71_clear );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_72_index( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_element = python_pars[ 1 ];
    PyObject *var_i = NULL;
    PyObject *var_child = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_f0e649407f94da0d732748f63e73614d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_f0e649407f94da0d732748f63e73614d = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f0e649407f94da0d732748f63e73614d, codeobj_f0e649407f94da0d732748f63e73614d, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f0e649407f94da0d732748f63e73614d = cache_frame_f0e649407f94da0d732748f63e73614d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f0e649407f94da0d732748f63e73614d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f0e649407f94da0d732748f63e73614d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_1;
        tmp_called_name_1 = (PyObject *)&PyEnum_Type;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 989;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_f0e649407f94da0d732748f63e73614d->m_frame.f_lineno = 989;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 989;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 989;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 989;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 989;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooo";
            exception_lineno = 989;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooo";
            exception_lineno = 989;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooo";
                    exception_lineno = 989;
                    goto try_except_handler_4;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooo";
            exception_lineno = 989;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_6 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_6;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_7;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_7 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_child;
            var_child = tmp_assign_source_7;
            Py_INCREF( var_child );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( var_child );
        tmp_compexpr_left_1 = var_child;
        CHECK_OBJECT( par_element );
        tmp_compexpr_right_1 = par_element;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( var_i );
        tmp_return_value = var_i;
        Py_INCREF( tmp_return_value );
        goto try_return_handler_2;
        branch_no_1:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 989;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        tmp_make_exception_arg_1 = const_str_digest_2eb78fd35de0c552fcd9f4234a3e2fee;
        frame_f0e649407f94da0d732748f63e73614d->m_frame.f_lineno = 992;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
        }

        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 992;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0e649407f94da0d732748f63e73614d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0e649407f94da0d732748f63e73614d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f0e649407f94da0d732748f63e73614d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f0e649407f94da0d732748f63e73614d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f0e649407f94da0d732748f63e73614d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f0e649407f94da0d732748f63e73614d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f0e649407f94da0d732748f63e73614d,
        type_description_1,
        par_self,
        par_element,
        var_i,
        var_child
    );


    // Release cached frame.
    if ( frame_f0e649407f94da0d732748f63e73614d == cache_frame_f0e649407f94da0d732748f63e73614d )
    {
        Py_DECREF( frame_f0e649407f94da0d732748f63e73614d );
    }
    cache_frame_f0e649407f94da0d732748f63e73614d = NULL;

    assertFrameObject( frame_f0e649407f94da0d732748f63e73614d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_72_index );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_i );
    Py_DECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_child );
    Py_DECREF( var_child );
    var_child = NULL;

    CHECK_OBJECT( (PyObject *)par_element );
    Py_DECREF( par_element );
    par_element = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    CHECK_OBJECT( (PyObject *)par_element );
    Py_DECREF( par_element );
    par_element = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_72_index );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_73_get( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_default = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_fcd1cb2a719ec8e30788d0fa79a3b2c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fcd1cb2a719ec8e30788d0fa79a3b2c6, codeobj_fcd1cb2a719ec8e30788d0fa79a3b2c6, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 = cache_frame_fcd1cb2a719ec8e30788d0fa79a3b2c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_attrs );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 998;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_key );
        tmp_args_element_name_1 = par_key;
        CHECK_OBJECT( par_default );
        tmp_args_element_name_2 = par_default;
        frame_fcd1cb2a719ec8e30788d0fa79a3b2c6->m_frame.f_lineno = 998;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_get, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 998;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fcd1cb2a719ec8e30788d0fa79a3b2c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fcd1cb2a719ec8e30788d0fa79a3b2c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fcd1cb2a719ec8e30788d0fa79a3b2c6,
        type_description_1,
        par_self,
        par_key,
        par_default
    );


    // Release cached frame.
    if ( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 == cache_frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 )
    {
        Py_DECREF( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 );
    }
    cache_frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 = NULL;

    assertFrameObject( frame_fcd1cb2a719ec8e30788d0fa79a3b2c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_73_get );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_default );
    Py_DECREF( par_default );
    par_default = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_default );
    Py_DECREF( par_default );
    par_default = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_73_get );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_74_get_attribute_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_default = python_pars[ 2 ];
    PyObject *var_value = NULL;
    struct Nuitka_FrameObject *frame_46e9c6ffef111ec7276e47293446caf3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_46e9c6ffef111ec7276e47293446caf3 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_46e9c6ffef111ec7276e47293446caf3, codeobj_46e9c6ffef111ec7276e47293446caf3, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_46e9c6ffef111ec7276e47293446caf3 = cache_frame_46e9c6ffef111ec7276e47293446caf3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_46e9c6ffef111ec7276e47293446caf3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_46e9c6ffef111ec7276e47293446caf3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_key );
        tmp_args_element_name_1 = par_key;
        CHECK_OBJECT( par_default );
        tmp_args_element_name_2 = par_default;
        frame_46e9c6ffef111ec7276e47293446caf3->m_frame.f_lineno = 1002;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_get, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1002;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( var_value == NULL );
        var_value = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( var_value );
        tmp_isinstance_inst_1 = var_value;
        tmp_isinstance_cls_1 = (PyObject *)&PyList_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1003;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1003;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_list_element_1;
            CHECK_OBJECT( var_value );
            tmp_list_element_1 = var_value;
            tmp_assign_source_2 = PyList_New( 1 );
            Py_INCREF( tmp_list_element_1 );
            PyList_SET_ITEM( tmp_assign_source_2, 0, tmp_list_element_1 );
            {
                PyObject *old = var_value;
                assert( old != NULL );
                var_value = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_46e9c6ffef111ec7276e47293446caf3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_46e9c6ffef111ec7276e47293446caf3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_46e9c6ffef111ec7276e47293446caf3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_46e9c6ffef111ec7276e47293446caf3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_46e9c6ffef111ec7276e47293446caf3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_46e9c6ffef111ec7276e47293446caf3,
        type_description_1,
        par_self,
        par_key,
        par_default,
        var_value
    );


    // Release cached frame.
    if ( frame_46e9c6ffef111ec7276e47293446caf3 == cache_frame_46e9c6ffef111ec7276e47293446caf3 )
    {
        Py_DECREF( frame_46e9c6ffef111ec7276e47293446caf3 );
    }
    cache_frame_46e9c6ffef111ec7276e47293446caf3 = NULL;

    assertFrameObject( frame_46e9c6ffef111ec7276e47293446caf3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_value );
    tmp_return_value = var_value;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_74_get_attribute_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_default );
    Py_DECREF( par_default );
    par_default = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_value );
    Py_DECREF( var_value );
    var_value = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_default );
    Py_DECREF( par_default );
    par_default = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_74_get_attribute_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_75_has_attr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_c11ea474ffae6c6476256a2a70014948;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c11ea474ffae6c6476256a2a70014948 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c11ea474ffae6c6476256a2a70014948, codeobj_c11ea474ffae6c6476256a2a70014948, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_c11ea474ffae6c6476256a2a70014948 = cache_frame_c11ea474ffae6c6476256a2a70014948;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c11ea474ffae6c6476256a2a70014948 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c11ea474ffae6c6476256a2a70014948 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_key );
        tmp_compexpr_left_1 = par_key;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_attrs );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1008;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1008;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c11ea474ffae6c6476256a2a70014948 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c11ea474ffae6c6476256a2a70014948 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c11ea474ffae6c6476256a2a70014948 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c11ea474ffae6c6476256a2a70014948, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c11ea474ffae6c6476256a2a70014948->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c11ea474ffae6c6476256a2a70014948, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c11ea474ffae6c6476256a2a70014948,
        type_description_1,
        par_self,
        par_key
    );


    // Release cached frame.
    if ( frame_c11ea474ffae6c6476256a2a70014948 == cache_frame_c11ea474ffae6c6476256a2a70014948 )
    {
        Py_DECREF( frame_c11ea474ffae6c6476256a2a70014948 );
    }
    cache_frame_c11ea474ffae6c6476256a2a70014948 = NULL;

    assertFrameObject( frame_c11ea474ffae6c6476256a2a70014948 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_75_has_attr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_75_has_attr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_76___hash__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1d647466fb145e14671911abb2f457d6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1d647466fb145e14671911abb2f457d6 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1d647466fb145e14671911abb2f457d6, codeobj_1d647466fb145e14671911abb2f457d6, module_bs4$element, sizeof(void *) );
    frame_1d647466fb145e14671911abb2f457d6 = cache_frame_1d647466fb145e14671911abb2f457d6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1d647466fb145e14671911abb2f457d6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1d647466fb145e14671911abb2f457d6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_str_arg_1;
        CHECK_OBJECT( par_self );
        tmp_str_arg_1 = par_self;
        tmp_called_instance_1 = PyObject_Str( tmp_str_arg_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1011;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1d647466fb145e14671911abb2f457d6->m_frame.f_lineno = 1011;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain___hash__ );
        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1011;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d647466fb145e14671911abb2f457d6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d647466fb145e14671911abb2f457d6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d647466fb145e14671911abb2f457d6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1d647466fb145e14671911abb2f457d6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1d647466fb145e14671911abb2f457d6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1d647466fb145e14671911abb2f457d6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1d647466fb145e14671911abb2f457d6,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_1d647466fb145e14671911abb2f457d6 == cache_frame_1d647466fb145e14671911abb2f457d6 )
    {
        Py_DECREF( frame_1d647466fb145e14671911abb2f457d6 );
    }
    cache_frame_1d647466fb145e14671911abb2f457d6 = NULL;

    assertFrameObject( frame_1d647466fb145e14671911abb2f457d6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_76___hash__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_76___hash__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_77___getitem__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_d67dc5583d9735364a2e7eb7aa2f4f9f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d67dc5583d9735364a2e7eb7aa2f4f9f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d67dc5583d9735364a2e7eb7aa2f4f9f, codeobj_d67dc5583d9735364a2e7eb7aa2f4f9f, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_d67dc5583d9735364a2e7eb7aa2f4f9f = cache_frame_d67dc5583d9735364a2e7eb7aa2f4f9f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d67dc5583d9735364a2e7eb7aa2f4f9f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d67dc5583d9735364a2e7eb7aa2f4f9f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_attrs );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1016;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_key );
        tmp_subscript_name_1 = par_key;
        tmp_return_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1016;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d67dc5583d9735364a2e7eb7aa2f4f9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d67dc5583d9735364a2e7eb7aa2f4f9f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d67dc5583d9735364a2e7eb7aa2f4f9f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d67dc5583d9735364a2e7eb7aa2f4f9f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d67dc5583d9735364a2e7eb7aa2f4f9f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d67dc5583d9735364a2e7eb7aa2f4f9f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d67dc5583d9735364a2e7eb7aa2f4f9f,
        type_description_1,
        par_self,
        par_key
    );


    // Release cached frame.
    if ( frame_d67dc5583d9735364a2e7eb7aa2f4f9f == cache_frame_d67dc5583d9735364a2e7eb7aa2f4f9f )
    {
        Py_DECREF( frame_d67dc5583d9735364a2e7eb7aa2f4f9f );
    }
    cache_frame_d67dc5583d9735364a2e7eb7aa2f4f9f = NULL;

    assertFrameObject( frame_d67dc5583d9735364a2e7eb7aa2f4f9f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_77___getitem__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_77___getitem__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_78___iter__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_f8ede56649c9acbcf3e4d1611cbd7bf1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f8ede56649c9acbcf3e4d1611cbd7bf1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f8ede56649c9acbcf3e4d1611cbd7bf1, codeobj_f8ede56649c9acbcf3e4d1611cbd7bf1, module_bs4$element, sizeof(void *) );
    frame_f8ede56649c9acbcf3e4d1611cbd7bf1 = cache_frame_f8ede56649c9acbcf3e4d1611cbd7bf1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1020;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1020;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f8ede56649c9acbcf3e4d1611cbd7bf1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f8ede56649c9acbcf3e4d1611cbd7bf1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f8ede56649c9acbcf3e4d1611cbd7bf1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f8ede56649c9acbcf3e4d1611cbd7bf1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 == cache_frame_f8ede56649c9acbcf3e4d1611cbd7bf1 )
    {
        Py_DECREF( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 );
    }
    cache_frame_f8ede56649c9acbcf3e4d1611cbd7bf1 = NULL;

    assertFrameObject( frame_f8ede56649c9acbcf3e4d1611cbd7bf1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_78___iter__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_78___iter__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_79___len__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_df689961d1889b2bc63517aeff723192;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_df689961d1889b2bc63517aeff723192 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df689961d1889b2bc63517aeff723192, codeobj_df689961d1889b2bc63517aeff723192, module_bs4$element, sizeof(void *) );
    frame_df689961d1889b2bc63517aeff723192 = cache_frame_df689961d1889b2bc63517aeff723192;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df689961d1889b2bc63517aeff723192 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df689961d1889b2bc63517aeff723192 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_len_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1024;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BUILTIN_LEN( tmp_len_arg_1 );
        Py_DECREF( tmp_len_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1024;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df689961d1889b2bc63517aeff723192 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_df689961d1889b2bc63517aeff723192 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df689961d1889b2bc63517aeff723192 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df689961d1889b2bc63517aeff723192, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df689961d1889b2bc63517aeff723192->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df689961d1889b2bc63517aeff723192, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_df689961d1889b2bc63517aeff723192,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_df689961d1889b2bc63517aeff723192 == cache_frame_df689961d1889b2bc63517aeff723192 )
    {
        Py_DECREF( frame_df689961d1889b2bc63517aeff723192 );
    }
    cache_frame_df689961d1889b2bc63517aeff723192 = NULL;

    assertFrameObject( frame_df689961d1889b2bc63517aeff723192 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_79___len__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_79___len__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_80___contains__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_x = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_d06555feeb0f99a8946ae79358eebe14;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_d06555feeb0f99a8946ae79358eebe14 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d06555feeb0f99a8946ae79358eebe14, codeobj_d06555feeb0f99a8946ae79358eebe14, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_d06555feeb0f99a8946ae79358eebe14 = cache_frame_d06555feeb0f99a8946ae79358eebe14;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d06555feeb0f99a8946ae79358eebe14 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d06555feeb0f99a8946ae79358eebe14 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_x );
        tmp_compexpr_left_1 = par_x;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_compexpr_right_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1027;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        Py_DECREF( tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1027;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 1 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d06555feeb0f99a8946ae79358eebe14 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d06555feeb0f99a8946ae79358eebe14 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d06555feeb0f99a8946ae79358eebe14 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d06555feeb0f99a8946ae79358eebe14, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d06555feeb0f99a8946ae79358eebe14->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d06555feeb0f99a8946ae79358eebe14, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d06555feeb0f99a8946ae79358eebe14,
        type_description_1,
        par_self,
        par_x
    );


    // Release cached frame.
    if ( frame_d06555feeb0f99a8946ae79358eebe14 == cache_frame_d06555feeb0f99a8946ae79358eebe14 )
    {
        Py_DECREF( frame_d06555feeb0f99a8946ae79358eebe14 );
    }
    cache_frame_d06555feeb0f99a8946ae79358eebe14 = NULL;

    assertFrameObject( frame_d06555feeb0f99a8946ae79358eebe14 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_80___contains__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_80___contains__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_81___nonzero__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_81___nonzero__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_81___nonzero__ );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_82___setitem__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    PyObject *par_value = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_e799db36c7ac958aeacbc8d3fbdfd7c6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_e799db36c7ac958aeacbc8d3fbdfd7c6 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e799db36c7ac958aeacbc8d3fbdfd7c6, codeobj_e799db36c7ac958aeacbc8d3fbdfd7c6, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_e799db36c7ac958aeacbc8d3fbdfd7c6 = cache_frame_e799db36c7ac958aeacbc8d3fbdfd7c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e799db36c7ac958aeacbc8d3fbdfd7c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e799db36c7ac958aeacbc8d3fbdfd7c6 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_ass_subscript_1;
        CHECK_OBJECT( par_value );
        tmp_ass_subvalue_1 = par_value;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_attrs );
        if ( tmp_ass_subscribed_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1036;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_key );
        tmp_ass_subscript_1 = par_key;
        tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subscribed_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1036;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e799db36c7ac958aeacbc8d3fbdfd7c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e799db36c7ac958aeacbc8d3fbdfd7c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e799db36c7ac958aeacbc8d3fbdfd7c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e799db36c7ac958aeacbc8d3fbdfd7c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e799db36c7ac958aeacbc8d3fbdfd7c6, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e799db36c7ac958aeacbc8d3fbdfd7c6,
        type_description_1,
        par_self,
        par_key,
        par_value
    );


    // Release cached frame.
    if ( frame_e799db36c7ac958aeacbc8d3fbdfd7c6 == cache_frame_e799db36c7ac958aeacbc8d3fbdfd7c6 )
    {
        Py_DECREF( frame_e799db36c7ac958aeacbc8d3fbdfd7c6 );
    }
    cache_frame_e799db36c7ac958aeacbc8d3fbdfd7c6 = NULL;

    assertFrameObject( frame_e799db36c7ac958aeacbc8d3fbdfd7c6 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_82___setitem__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_82___setitem__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_83___delitem__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_18dce61cea9fc7c55052b8072b93f4ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_18dce61cea9fc7c55052b8072b93f4ef = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_18dce61cea9fc7c55052b8072b93f4ef, codeobj_18dce61cea9fc7c55052b8072b93f4ef, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_18dce61cea9fc7c55052b8072b93f4ef = cache_frame_18dce61cea9fc7c55052b8072b93f4ef;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_18dce61cea9fc7c55052b8072b93f4ef );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_18dce61cea9fc7c55052b8072b93f4ef ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_attrs );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1040;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_key );
        tmp_args_element_name_1 = par_key;
        tmp_args_element_name_2 = Py_None;
        frame_18dce61cea9fc7c55052b8072b93f4ef->m_frame.f_lineno = 1040;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_pop, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1040;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18dce61cea9fc7c55052b8072b93f4ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18dce61cea9fc7c55052b8072b93f4ef );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_18dce61cea9fc7c55052b8072b93f4ef, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_18dce61cea9fc7c55052b8072b93f4ef->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_18dce61cea9fc7c55052b8072b93f4ef, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_18dce61cea9fc7c55052b8072b93f4ef,
        type_description_1,
        par_self,
        par_key
    );


    // Release cached frame.
    if ( frame_18dce61cea9fc7c55052b8072b93f4ef == cache_frame_18dce61cea9fc7c55052b8072b93f4ef )
    {
        Py_DECREF( frame_18dce61cea9fc7c55052b8072b93f4ef );
    }
    cache_frame_18dce61cea9fc7c55052b8072b93f4ef = NULL;

    assertFrameObject( frame_18dce61cea9fc7c55052b8072b93f4ef );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_83___delitem__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_83___delitem__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_84___call__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kwargs = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_14c9ca35b08857b494d3b34d6a24c792;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_14c9ca35b08857b494d3b34d6a24c792 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_14c9ca35b08857b494d3b34d6a24c792, codeobj_14c9ca35b08857b494d3b34d6a24c792, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_14c9ca35b08857b494d3b34d6a24c792 = cache_frame_14c9ca35b08857b494d3b34d6a24c792;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_14c9ca35b08857b494d3b34d6a24c792 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_14c9ca35b08857b494d3b34d6a24c792 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1046;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_args );
        tmp_dircall_arg2_1 = par_args;
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg2_1 );
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_3_complex_call_helper_star_list_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1046;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_14c9ca35b08857b494d3b34d6a24c792 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_14c9ca35b08857b494d3b34d6a24c792 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_14c9ca35b08857b494d3b34d6a24c792 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_14c9ca35b08857b494d3b34d6a24c792, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_14c9ca35b08857b494d3b34d6a24c792->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_14c9ca35b08857b494d3b34d6a24c792, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_14c9ca35b08857b494d3b34d6a24c792,
        type_description_1,
        par_self,
        par_args,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_14c9ca35b08857b494d3b34d6a24c792 == cache_frame_14c9ca35b08857b494d3b34d6a24c792 )
    {
        Py_DECREF( frame_14c9ca35b08857b494d3b34d6a24c792 );
    }
    cache_frame_14c9ca35b08857b494d3b34d6a24c792 = NULL;

    assertFrameObject( frame_14c9ca35b08857b494d3b34d6a24c792 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_84___call__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_84___call__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_85___getattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_tag = python_pars[ 1 ];
    PyObject *var_tag_name = NULL;
    struct Nuitka_FrameObject *frame_b69ca57a2878fd3ed8c2fa69b9943835;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b69ca57a2878fd3ed8c2fa69b9943835 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b69ca57a2878fd3ed8c2fa69b9943835, codeobj_b69ca57a2878fd3ed8c2fa69b9943835, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_b69ca57a2878fd3ed8c2fa69b9943835 = cache_frame_b69ca57a2878fd3ed8c2fa69b9943835;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b69ca57a2878fd3ed8c2fa69b9943835 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b69ca57a2878fd3ed8c2fa69b9943835 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_tag );
        tmp_len_arg_1 = par_tag;
        tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1050;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_3;
        tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_INT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        Py_DECREF( tmp_compexpr_left_1 );
        assert( !(tmp_res == -1) );
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_tag );
        tmp_called_instance_1 = par_tag;
        frame_b69ca57a2878fd3ed8c2fa69b9943835->m_frame.f_lineno = 1050;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_endswith, &PyTuple_GET_ITEM( const_tuple_str_plain_Tag_tuple, 0 ) );

        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1050;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 1050;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            Py_ssize_t tmp_sliceslicedel_index_lower_1;
            Py_ssize_t tmp_slice_index_upper_1;
            PyObject *tmp_slice_source_1;
            tmp_sliceslicedel_index_lower_1 = 0;
            tmp_slice_index_upper_1 = -3;
            CHECK_OBJECT( par_tag );
            tmp_slice_source_1 = par_tag;
            tmp_assign_source_1 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1052;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            assert( var_tag_name == NULL );
            var_tag_name = tmp_assign_source_1;
        }
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_warnings );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
                exception_tb = NULL;

                exception_lineno = 1053;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }

            tmp_source_name_1 = tmp_mvar_value_1;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_warn );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1053;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_1 = const_str_digest_f71329a7fdb204c7f3cb9c7636f075d9;
            CHECK_OBJECT( var_tag_name );
            tmp_dict_value_1 = var_tag_name;
            tmp_dict_key_1 = const_str_plain_name;
            tmp_right_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem( tmp_right_name_1, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_args_element_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 1054;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            frame_b69ca57a2878fd3ed8c2fa69b9943835->m_frame.f_lineno = 1053;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_1 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1053;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_2 );
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( var_tag_name );
            tmp_args_element_name_2 = var_tag_name;
            frame_b69ca57a2878fd3ed8c2fa69b9943835->m_frame.f_lineno = 1058;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_find, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1058;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            int tmp_and_left_truth_2;
            nuitka_bool tmp_and_left_value_2;
            nuitka_bool tmp_and_right_value_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_tag );
            tmp_called_instance_3 = par_tag;
            frame_b69ca57a2878fd3ed8c2fa69b9943835->m_frame.f_lineno = 1060;
            tmp_operand_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_startswith, &PyTuple_GET_ITEM( const_tuple_str_plain____tuple, 0 ) );

            if ( tmp_operand_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1060;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            Py_DECREF( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1060;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_2 == 1 )
            {
                goto and_right_2;
            }
            else
            {
                goto and_left_2;
            }
            and_right_2:;
            CHECK_OBJECT( par_tag );
            tmp_compexpr_left_2 = par_tag;
            tmp_compexpr_right_2 = const_str_plain_contents;
            tmp_operand_name_2 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
            if ( tmp_operand_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1060;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            Py_DECREF( tmp_operand_name_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1060;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_2 = tmp_and_right_value_2;
            goto and_end_2;
            and_left_2:;
            tmp_condition_result_2 = tmp_and_left_value_2;
            and_end_2:;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_4;
                PyObject *tmp_args_element_name_3;
                CHECK_OBJECT( par_self );
                tmp_called_instance_4 = par_self;
                CHECK_OBJECT( par_tag );
                tmp_args_element_name_3 = par_tag;
                frame_b69ca57a2878fd3ed8c2fa69b9943835->m_frame.f_lineno = 1061;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_find, call_args );
                }

                if ( tmp_return_value == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1061;
                    type_description_1 = "ooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        branch_end_1:;
    }
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_source_name_2;
        tmp_left_name_2 = const_str_digest_ca7f1c3e5d90e78a07e9f85863c06c8e;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_tuple_element_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
        if ( tmp_tuple_element_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = PyTuple_New( 2 );
        PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_tag );
        tmp_tuple_element_1 = par_tag;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_1 );
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1063;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_b69ca57a2878fd3ed8c2fa69b9943835->m_frame.f_lineno = 1062;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 1062;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b69ca57a2878fd3ed8c2fa69b9943835 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b69ca57a2878fd3ed8c2fa69b9943835 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b69ca57a2878fd3ed8c2fa69b9943835 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b69ca57a2878fd3ed8c2fa69b9943835, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b69ca57a2878fd3ed8c2fa69b9943835->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b69ca57a2878fd3ed8c2fa69b9943835, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b69ca57a2878fd3ed8c2fa69b9943835,
        type_description_1,
        par_self,
        par_tag,
        var_tag_name
    );


    // Release cached frame.
    if ( frame_b69ca57a2878fd3ed8c2fa69b9943835 == cache_frame_b69ca57a2878fd3ed8c2fa69b9943835 )
    {
        Py_DECREF( frame_b69ca57a2878fd3ed8c2fa69b9943835 );
    }
    cache_frame_b69ca57a2878fd3ed8c2fa69b9943835 = NULL;

    assertFrameObject( frame_b69ca57a2878fd3ed8c2fa69b9943835 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_85___getattr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_tag );
    Py_DECREF( par_tag );
    par_tag = NULL;

    Py_XDECREF( var_tag_name );
    var_tag_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_tag );
    Py_DECREF( par_tag );
    par_tag = NULL;

    Py_XDECREF( var_tag_name );
    var_tag_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_85___getattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_86___eq__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_i = NULL;
    PyObject *var_my_child = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_return_value = NULL;
    struct Nuitka_FrameObject *frame_0f121366c6314e05c4e94b4ba4f281db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_0f121366c6314e05c4e94b4ba4f281db = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_compexpr_right_1 = par_other;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_True;
        Py_INCREF( tmp_return_value );
        goto try_return_handler_1;
        branch_no_1:;
    }
    MAKE_OR_REUSE_FRAME( cache_frame_0f121366c6314e05c4e94b4ba4f281db, codeobj_0f121366c6314e05c4e94b4ba4f281db, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0f121366c6314e05c4e94b4ba4f281db = cache_frame_0f121366c6314e05c4e94b4ba4f281db;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0f121366c6314e05c4e94b4ba4f281db );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0f121366c6314e05c4e94b4ba4f281db ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_name_1;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_attribute_name_2;
        int tmp_or_left_truth_3;
        nuitka_bool tmp_or_left_value_3;
        nuitka_bool tmp_or_right_value_3;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_source_name_3;
        PyObject *tmp_attribute_name_3;
        int tmp_or_left_truth_4;
        nuitka_bool tmp_or_left_value_4;
        nuitka_bool tmp_or_right_value_4;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_4;
        PyObject *tmp_source_name_5;
        int tmp_or_left_truth_5;
        nuitka_bool tmp_or_left_value_5;
        nuitka_bool tmp_or_right_value_5;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_source_name_7;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_len_arg_2;
        CHECK_OBJECT( par_other );
        tmp_source_name_1 = par_other;
        tmp_attribute_name_1 = const_str_plain_name;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_1, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1070;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1070;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( par_other );
        tmp_source_name_2 = par_other;
        tmp_attribute_name_2 = const_str_plain_attrs;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_2, tmp_attribute_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1071;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1071;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_2 == 1 )
        {
            goto or_left_2;
        }
        else
        {
            goto or_right_2;
        }
        or_right_2:;
        CHECK_OBJECT( par_other );
        tmp_source_name_3 = par_other;
        tmp_attribute_name_3 = const_str_plain_contents;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_3, tmp_attribute_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1072;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_3 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1072;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_3 = tmp_or_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_3 == 1 )
        {
            goto or_left_3;
        }
        else
        {
            goto or_right_3;
        }
        or_right_3:;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_name );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1073;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_5 = par_other;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_name );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 1073;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1073;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_4 = tmp_or_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_4 == 1 )
        {
            goto or_left_4;
        }
        else
        {
            goto or_right_4;
        }
        or_right_4:;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_attrs );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1074;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_source_name_7 = par_other;
        tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_attrs );
        if ( tmp_compexpr_right_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_3 );

            exception_lineno = 1074;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        Py_DECREF( tmp_compexpr_right_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1074;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_5 = tmp_or_left_value_5 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_5 == 1 )
        {
            goto or_left_5;
        }
        else
        {
            goto or_right_5;
        }
        or_right_5:;
        CHECK_OBJECT( par_self );
        tmp_len_arg_1 = par_self;
        tmp_compexpr_left_4 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_compexpr_left_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1075;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_other );
        tmp_len_arg_2 = par_other;
        tmp_compexpr_right_4 = BUILTIN_LEN( tmp_len_arg_2 );
        if ( tmp_compexpr_right_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_4 );

            exception_lineno = 1075;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        Py_DECREF( tmp_compexpr_left_4 );
        Py_DECREF( tmp_compexpr_right_4 );
        assert( !(tmp_res == -1) );
        tmp_or_right_value_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_right_value_4 = tmp_or_right_value_5;
        goto or_end_5;
        or_left_5:;
        tmp_or_right_value_4 = tmp_or_left_value_5;
        or_end_5:;
        tmp_or_right_value_3 = tmp_or_right_value_4;
        goto or_end_4;
        or_left_4:;
        tmp_or_right_value_3 = tmp_or_left_value_4;
        or_end_4:;
        tmp_or_right_value_2 = tmp_or_right_value_3;
        goto or_end_3;
        or_left_3:;
        tmp_or_right_value_2 = tmp_or_left_value_3;
        or_end_3:;
        tmp_or_right_value_1 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_or_right_value_1 = tmp_or_left_value_2;
        or_end_2:;
        tmp_condition_result_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_2 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_source_name_8;
        tmp_called_name_1 = (PyObject *)&PyEnum_Type;
        CHECK_OBJECT( par_self );
        tmp_source_name_8 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_contents );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1077;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        frame_0f121366c6314e05c4e94b4ba4f281db->m_frame.f_lineno = 1077;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1077;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1077;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooo";
                exception_lineno = 1077;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
        tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1077;
            type_description_1 = "oooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_3;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_4 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooo";
            exception_lineno = 1077;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_4;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooo";
            exception_lineno = 1077;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooo";
                    exception_lineno = 1077;
                    goto try_except_handler_4;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooo";
            exception_lineno = 1077;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_6 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_i;
            var_i = tmp_assign_source_6;
            Py_INCREF( var_i );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_7;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_7 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_my_child;
            var_my_child = tmp_assign_source_7;
            Py_INCREF( var_my_child );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_9;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT( var_my_child );
        tmp_compexpr_left_5 = var_my_child;
        CHECK_OBJECT( par_other );
        tmp_source_name_9 = par_other;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_contents );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1078;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_i );
        tmp_subscript_name_1 = var_i;
        tmp_compexpr_right_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_compexpr_right_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1078;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
        Py_DECREF( tmp_compexpr_right_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1078;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto try_return_handler_2;
        branch_no_3:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1077;
        type_description_1 = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
    Py_DECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f121366c6314e05c4e94b4ba4f281db );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f121366c6314e05c4e94b4ba4f281db );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0f121366c6314e05c4e94b4ba4f281db );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0f121366c6314e05c4e94b4ba4f281db, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0f121366c6314e05c4e94b4ba4f281db->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0f121366c6314e05c4e94b4ba4f281db, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0f121366c6314e05c4e94b4ba4f281db,
        type_description_1,
        par_self,
        par_other,
        var_i,
        var_my_child
    );


    // Release cached frame.
    if ( frame_0f121366c6314e05c4e94b4ba4f281db == cache_frame_0f121366c6314e05c4e94b4ba4f281db )
    {
        Py_DECREF( frame_0f121366c6314e05c4e94b4ba4f281db );
    }
    cache_frame_0f121366c6314e05c4e94b4ba4f281db = NULL;

    assertFrameObject( frame_0f121366c6314e05c4e94b4ba4f281db );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_86___eq__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_my_child );
    var_my_child = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_my_child );
    var_my_child = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_86___eq__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_87___ne__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_47e271e4323d4ffe193e3efd217220e8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_47e271e4323d4ffe193e3efd217220e8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_47e271e4323d4ffe193e3efd217220e8, codeobj_47e271e4323d4ffe193e3efd217220e8, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_47e271e4323d4ffe193e3efd217220e8 = cache_frame_47e271e4323d4ffe193e3efd217220e8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_47e271e4323d4ffe193e3efd217220e8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_47e271e4323d4ffe193e3efd217220e8 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_operand_name_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_self );
        tmp_compexpr_left_1 = par_self;
        CHECK_OBJECT( par_other );
        tmp_compexpr_right_1 = par_other;
        tmp_operand_name_1 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1085;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1085;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = ( tmp_res == 0 ) ? Py_True : Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47e271e4323d4ffe193e3efd217220e8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_47e271e4323d4ffe193e3efd217220e8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47e271e4323d4ffe193e3efd217220e8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_47e271e4323d4ffe193e3efd217220e8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_47e271e4323d4ffe193e3efd217220e8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_47e271e4323d4ffe193e3efd217220e8, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_47e271e4323d4ffe193e3efd217220e8,
        type_description_1,
        par_self,
        par_other
    );


    // Release cached frame.
    if ( frame_47e271e4323d4ffe193e3efd217220e8 == cache_frame_47e271e4323d4ffe193e3efd217220e8 )
    {
        Py_DECREF( frame_47e271e4323d4ffe193e3efd217220e8 );
    }
    cache_frame_47e271e4323d4ffe193e3efd217220e8 = NULL;

    assertFrameObject( frame_47e271e4323d4ffe193e3efd217220e8 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_87___ne__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_87___ne__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_88___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_encoding = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_7ae4d0ab18c86a7b052b0c944ba8bd65;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7ae4d0ab18c86a7b052b0c944ba8bd65 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7ae4d0ab18c86a7b052b0c944ba8bd65, codeobj_7ae4d0ab18c86a7b052b0c944ba8bd65, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_7ae4d0ab18c86a7b052b0c944ba8bd65 = cache_frame_7ae4d0ab18c86a7b052b0c944ba8bd65;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_mvar_value_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PY3K );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PY3K );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PY3K" );
            exception_tb = NULL;

            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_mvar_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            frame_7ae4d0ab18c86a7b052b0c944ba8bd65->m_frame.f_lineno = 1091;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_decode );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1091;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            CHECK_OBJECT( par_encoding );
            tmp_args_element_name_1 = par_encoding;
            frame_7ae4d0ab18c86a7b052b0c944ba8bd65->m_frame.f_lineno = 1096;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_encode, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1096;
                type_description_1 = "oo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7ae4d0ab18c86a7b052b0c944ba8bd65, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7ae4d0ab18c86a7b052b0c944ba8bd65->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7ae4d0ab18c86a7b052b0c944ba8bd65, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7ae4d0ab18c86a7b052b0c944ba8bd65,
        type_description_1,
        par_self,
        par_encoding
    );


    // Release cached frame.
    if ( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 == cache_frame_7ae4d0ab18c86a7b052b0c944ba8bd65 )
    {
        Py_DECREF( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 );
    }
    cache_frame_7ae4d0ab18c86a7b052b0c944ba8bd65 = NULL;

    assertFrameObject( frame_7ae4d0ab18c86a7b052b0c944ba8bd65 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_88___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_88___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_89___unicode__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9c1c3b549a0cf791cb178533927bbf79;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9c1c3b549a0cf791cb178533927bbf79 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9c1c3b549a0cf791cb178533927bbf79, codeobj_9c1c3b549a0cf791cb178533927bbf79, module_bs4$element, sizeof(void *) );
    frame_9c1c3b549a0cf791cb178533927bbf79 = cache_frame_9c1c3b549a0cf791cb178533927bbf79;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9c1c3b549a0cf791cb178533927bbf79 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9c1c3b549a0cf791cb178533927bbf79 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        frame_9c1c3b549a0cf791cb178533927bbf79->m_frame.f_lineno = 1099;
        tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_decode );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1099;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c1c3b549a0cf791cb178533927bbf79 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c1c3b549a0cf791cb178533927bbf79 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9c1c3b549a0cf791cb178533927bbf79 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9c1c3b549a0cf791cb178533927bbf79, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9c1c3b549a0cf791cb178533927bbf79->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9c1c3b549a0cf791cb178533927bbf79, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9c1c3b549a0cf791cb178533927bbf79,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_9c1c3b549a0cf791cb178533927bbf79 == cache_frame_9c1c3b549a0cf791cb178533927bbf79 )
    {
        Py_DECREF( frame_9c1c3b549a0cf791cb178533927bbf79 );
    }
    cache_frame_9c1c3b549a0cf791cb178533927bbf79 = NULL;

    assertFrameObject( frame_9c1c3b549a0cf791cb178533927bbf79 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_89___unicode__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_89___unicode__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_90___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_099aaa80f69d337732d9b444d82bacd1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_099aaa80f69d337732d9b444d82bacd1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_099aaa80f69d337732d9b444d82bacd1, codeobj_099aaa80f69d337732d9b444d82bacd1, module_bs4$element, sizeof(void *) );
    frame_099aaa80f69d337732d9b444d82bacd1 = cache_frame_099aaa80f69d337732d9b444d82bacd1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_099aaa80f69d337732d9b444d82bacd1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_099aaa80f69d337732d9b444d82bacd1 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_mvar_value_1;
        int tmp_truth_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PY3K );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PY3K );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "PY3K" );
            exception_tb = NULL;

            exception_lineno = 1102;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_mvar_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1102;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            frame_099aaa80f69d337732d9b444d82bacd1->m_frame.f_lineno = 1103;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_decode );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1103;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_instance_2;
            CHECK_OBJECT( par_self );
            tmp_called_instance_2 = par_self;
            frame_099aaa80f69d337732d9b444d82bacd1->m_frame.f_lineno = 1105;
            tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_encode );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1105;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_099aaa80f69d337732d9b444d82bacd1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_099aaa80f69d337732d9b444d82bacd1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_099aaa80f69d337732d9b444d82bacd1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_099aaa80f69d337732d9b444d82bacd1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_099aaa80f69d337732d9b444d82bacd1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_099aaa80f69d337732d9b444d82bacd1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_099aaa80f69d337732d9b444d82bacd1,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_099aaa80f69d337732d9b444d82bacd1 == cache_frame_099aaa80f69d337732d9b444d82bacd1 )
    {
        Py_DECREF( frame_099aaa80f69d337732d9b444d82bacd1 );
    }
    cache_frame_099aaa80f69d337732d9b444d82bacd1 = NULL;

    assertFrameObject( frame_099aaa80f69d337732d9b444d82bacd1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_90___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_90___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_91_encode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_encoding = python_pars[ 1 ];
    PyObject *par_indent_level = python_pars[ 2 ];
    PyObject *par_formatter = python_pars[ 3 ];
    PyObject *par_errors = python_pars[ 4 ];
    PyObject *var_u = NULL;
    struct Nuitka_FrameObject *frame_8135d7ca17005947bac227662c113913;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8135d7ca17005947bac227662c113913 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8135d7ca17005947bac227662c113913, codeobj_8135d7ca17005947bac227662c113913, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_8135d7ca17005947bac227662c113913 = cache_frame_8135d7ca17005947bac227662c113913;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8135d7ca17005947bac227662c113913 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8135d7ca17005947bac227662c113913 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_indent_level );
        tmp_args_element_name_1 = par_indent_level;
        CHECK_OBJECT( par_encoding );
        tmp_args_element_name_2 = par_encoding;
        CHECK_OBJECT( par_formatter );
        tmp_args_element_name_3 = par_formatter;
        frame_8135d7ca17005947bac227662c113913->m_frame.f_lineno = 1115;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_decode, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1115;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert( var_u == NULL );
        var_u = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT( var_u );
        tmp_called_instance_2 = var_u;
        CHECK_OBJECT( par_encoding );
        tmp_args_element_name_4 = par_encoding;
        CHECK_OBJECT( par_errors );
        tmp_args_element_name_5 = par_errors;
        frame_8135d7ca17005947bac227662c113913->m_frame.f_lineno = 1116;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
            tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_encode, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1116;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8135d7ca17005947bac227662c113913 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8135d7ca17005947bac227662c113913 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8135d7ca17005947bac227662c113913 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8135d7ca17005947bac227662c113913, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8135d7ca17005947bac227662c113913->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8135d7ca17005947bac227662c113913, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8135d7ca17005947bac227662c113913,
        type_description_1,
        par_self,
        par_encoding,
        par_indent_level,
        par_formatter,
        par_errors,
        var_u
    );


    // Release cached frame.
    if ( frame_8135d7ca17005947bac227662c113913 == cache_frame_8135d7ca17005947bac227662c113913 )
    {
        Py_DECREF( frame_8135d7ca17005947bac227662c113913 );
    }
    cache_frame_8135d7ca17005947bac227662c113913 = NULL;

    assertFrameObject( frame_8135d7ca17005947bac227662c113913 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_91_encode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_errors );
    Py_DECREF( par_errors );
    par_errors = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_u );
    Py_DECREF( var_u );
    var_u = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_errors );
    Py_DECREF( par_errors );
    par_errors = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_u );
    var_u = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_91_encode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_92__should_pretty_print( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_indent_level = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_2cb78b1700e9c5a78e9a9931b71ffd39;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2cb78b1700e9c5a78e9a9931b71ffd39 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2cb78b1700e9c5a78e9a9931b71ffd39, codeobj_2cb78b1700e9c5a78e9a9931b71ffd39, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_2cb78b1700e9c5a78e9a9931b71ffd39 = cache_frame_2cb78b1700e9c5a78e9a9931b71ffd39;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2cb78b1700e9c5a78e9a9931b71ffd39 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2cb78b1700e9c5a78e9a9931b71ffd39 ) == 2 ); // Frame stack

    // Framed code:
    {
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( par_indent_level );
        tmp_compexpr_left_1 = par_indent_level;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1123;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_preserve_whitespace_tags );
        if ( tmp_compexpr_right_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_compexpr_left_2 );

            exception_lineno = 1123;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains( tmp_compexpr_right_2, tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        Py_DECREF( tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1123;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? Py_True : Py_False;
        tmp_return_value = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_return_value = tmp_and_left_value_1;
        and_end_1:;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cb78b1700e9c5a78e9a9931b71ffd39 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cb78b1700e9c5a78e9a9931b71ffd39 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2cb78b1700e9c5a78e9a9931b71ffd39 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2cb78b1700e9c5a78e9a9931b71ffd39, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2cb78b1700e9c5a78e9a9931b71ffd39->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2cb78b1700e9c5a78e9a9931b71ffd39, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2cb78b1700e9c5a78e9a9931b71ffd39,
        type_description_1,
        par_self,
        par_indent_level
    );


    // Release cached frame.
    if ( frame_2cb78b1700e9c5a78e9a9931b71ffd39 == cache_frame_2cb78b1700e9c5a78e9a9931b71ffd39 )
    {
        Py_DECREF( frame_2cb78b1700e9c5a78e9a9931b71ffd39 );
    }
    cache_frame_2cb78b1700e9c5a78e9a9931b71ffd39 = NULL;

    assertFrameObject( frame_2cb78b1700e9c5a78e9a9931b71ffd39 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_92__should_pretty_print );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_92__should_pretty_print );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_93_decode( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_indent_level = python_pars[ 1 ];
    PyObject *par_eventual_encoding = python_pars[ 2 ];
    PyObject *par_formatter = python_pars[ 3 ];
    PyObject *var_indent_contents = NULL;
    PyObject *var_decoded = NULL;
    PyObject *var_contents = NULL;
    PyObject *var_val = NULL;
    PyObject *var_space = NULL;
    PyObject *var_pretty_print = NULL;
    PyObject *var_text = NULL;
    PyObject *var_closeTag = NULL;
    PyObject *var_s = NULL;
    PyObject *var_prefix = NULL;
    PyObject *var_attrs = NULL;
    PyObject *var_key = NULL;
    PyObject *var_close = NULL;
    PyObject *var_indent_space = NULL;
    PyObject *var_attribute_string = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_7e5ea0a96abd38fc63210a5d0436fdc4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_7e5ea0a96abd38fc63210a5d0436fdc4 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7e5ea0a96abd38fc63210a5d0436fdc4, codeobj_7e5ea0a96abd38fc63210a5d0436fdc4, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7e5ea0a96abd38fc63210a5d0436fdc4 = cache_frame_7e5ea0a96abd38fc63210a5d0436fdc4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7e5ea0a96abd38fc63210a5d0436fdc4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7e5ea0a96abd38fc63210a5d0436fdc4 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_formatter );
        tmp_isinstance_inst_1 = par_formatter;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Formatter );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Formatter" );
            exception_tb = NULL;

            exception_lineno = 1141;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1141;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1141;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_formatter );
        tmp_isinstance_inst_2 = par_formatter;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Callable );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Callable" );
            exception_tb = NULL;

            exception_lineno = 1141;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1141;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1141;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_formatter );
            tmp_args_element_name_1 = par_formatter;
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1142;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__formatter_for_name, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1142;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_formatter;
                assert( old != NULL );
                par_formatter = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New( 0 );
        assert( var_attrs == NULL );
        var_attrs = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_attrs );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1144;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1144;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_source_name_2;
            tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_sorted );
            assert( tmp_called_name_1 != NULL );
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_attrs );
            if ( tmp_called_instance_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1145;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1145;
            tmp_args_element_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_items );
            Py_DECREF( tmp_called_instance_2 );
            if ( tmp_args_element_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1145;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1145;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_args_element_name_2 );
            if ( tmp_iter_arg_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1145;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
            Py_DECREF( tmp_iter_arg_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1145;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_3;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_4 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooooooooooooooo";
                    exception_lineno = 1145;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_4;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_iter_arg_2;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
            tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_2 );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1145;
                type_description_1 = "ooooooooooooooooooo";
                goto try_except_handler_3;
            }
            {
                PyObject *old = tmp_tuple_unpack_1__source_iter;
                tmp_tuple_unpack_1__source_iter = tmp_assign_source_5;
                Py_XDECREF( old );
            }

        }
        // Tried code:
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_unpack_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_1, 0 );
            if ( tmp_assign_source_6 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "ooooooooooooooooooo";
                exception_lineno = 1145;
                goto try_except_handler_4;
            }
            {
                PyObject *old = tmp_tuple_unpack_1__element_1;
                tmp_tuple_unpack_1__element_1 = tmp_assign_source_6;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_7;
            PyObject *tmp_unpack_2;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
            tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_2, 1 );
            if ( tmp_assign_source_7 == NULL )
            {
                if ( !ERROR_OCCURRED() )
                {
                    exception_type = PyExc_StopIteration;
                    Py_INCREF( exception_type );
                    exception_value = NULL;
                    exception_tb = NULL;
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                }


                type_description_1 = "ooooooooooooooooooo";
                exception_lineno = 1145;
                goto try_except_handler_4;
            }
            {
                PyObject *old = tmp_tuple_unpack_1__element_2;
                tmp_tuple_unpack_1__element_2 = tmp_assign_source_7;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_iterator_name_1;
            CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
            tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
            // Check if iterator has left-over elements.
            CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

            tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

            if (likely( tmp_iterator_attempt == NULL ))
            {
                PyObject *error = GET_ERROR_OCCURRED();

                if ( error != NULL )
                {
                    if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                    {
                        CLEAR_ERROR_OCCURRED();
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                        type_description_1 = "ooooooooooooooooooo";
                        exception_lineno = 1145;
                        goto try_except_handler_4;
                    }
                }
            }
            else
            {
                Py_DECREF( tmp_iterator_attempt );

                // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description_1 = "ooooooooooooooooooo";
                exception_lineno = 1145;
                goto try_except_handler_4;
            }
        }
        goto try_end_1;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_3;
        // End of try:
        try_end_1:;
        goto try_end_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto try_except_handler_2;
        // End of try:
        try_end_2:;
        CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
        Py_DECREF( tmp_tuple_unpack_1__source_iter );
        tmp_tuple_unpack_1__source_iter = NULL;

        {
            PyObject *tmp_assign_source_8;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
            tmp_assign_source_8 = tmp_tuple_unpack_1__element_1;
            {
                PyObject *old = var_key;
                var_key = tmp_assign_source_8;
                Py_INCREF( var_key );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_tuple_unpack_1__element_1 );
        tmp_tuple_unpack_1__element_1 = NULL;

        {
            PyObject *tmp_assign_source_9;
            CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
            tmp_assign_source_9 = tmp_tuple_unpack_1__element_2;
            {
                PyObject *old = var_val;
                var_val = tmp_assign_source_9;
                Py_INCREF( var_val );
                Py_XDECREF( old );
            }

        }
        Py_XDECREF( tmp_tuple_unpack_1__element_2 );
        tmp_tuple_unpack_1__element_2 = NULL;

        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            CHECK_OBJECT( var_val );
            tmp_compexpr_left_1 = var_val;
            tmp_compexpr_right_1 = Py_None;
            tmp_condition_result_3 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_10;
                CHECK_OBJECT( var_key );
                tmp_assign_source_10 = var_key;
                {
                    PyObject *old = var_decoded;
                    var_decoded = tmp_assign_source_10;
                    Py_INCREF( var_decoded );
                    Py_XDECREF( old );
                }

            }
            goto branch_end_3;
            branch_no_3:;
            {
                nuitka_bool tmp_condition_result_4;
                int tmp_or_left_truth_1;
                nuitka_bool tmp_or_left_value_1;
                nuitka_bool tmp_or_right_value_1;
                PyObject *tmp_isinstance_inst_3;
                PyObject *tmp_isinstance_cls_3;
                PyObject *tmp_isinstance_inst_4;
                PyObject *tmp_isinstance_cls_4;
                CHECK_OBJECT( var_val );
                tmp_isinstance_inst_3 = var_val;
                tmp_isinstance_cls_3 = (PyObject *)&PyList_Type;
                tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1149;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_or_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_or_left_truth_1 == 1 )
                {
                    goto or_left_1;
                }
                else
                {
                    goto or_right_1;
                }
                or_right_1:;
                CHECK_OBJECT( var_val );
                tmp_isinstance_inst_4 = var_val;
                tmp_isinstance_cls_4 = (PyObject *)&PyTuple_Type;
                tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_4, tmp_isinstance_cls_4 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1149;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_or_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_condition_result_4 = tmp_or_right_value_1;
                goto or_end_1;
                or_left_1:;
                tmp_condition_result_4 = tmp_or_left_value_1;
                or_end_1:;
                if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_4;
                }
                else
                {
                    goto branch_no_4;
                }
                branch_yes_4:;
                {
                    PyObject *tmp_assign_source_11;
                    PyObject *tmp_called_instance_3;
                    PyObject *tmp_args_element_name_3;
                    tmp_called_instance_3 = const_str_space;
                    CHECK_OBJECT( var_val );
                    tmp_args_element_name_3 = var_val;
                    frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1150;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_3 };
                        tmp_assign_source_11 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_join, call_args );
                    }

                    if ( tmp_assign_source_11 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1150;
                        type_description_1 = "ooooooooooooooooooo";
                        goto try_except_handler_2;
                    }
                    {
                        PyObject *old = var_val;
                        assert( old != NULL );
                        var_val = tmp_assign_source_11;
                        Py_DECREF( old );
                    }

                }
                goto branch_end_4;
                branch_no_4:;
                {
                    nuitka_bool tmp_condition_result_5;
                    PyObject *tmp_operand_name_3;
                    PyObject *tmp_isinstance_inst_5;
                    PyObject *tmp_isinstance_cls_5;
                    CHECK_OBJECT( var_val );
                    tmp_isinstance_inst_5 = var_val;
                    tmp_isinstance_cls_5 = (PyObject *)&PyBaseString_Type;
                    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_5, tmp_isinstance_cls_5 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1151;
                        type_description_1 = "ooooooooooooooooooo";
                        goto try_except_handler_2;
                    }
                    tmp_operand_name_3 = ( tmp_res != 0 ) ? Py_True : Py_False;
                    tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1151;
                        type_description_1 = "ooooooooooooooooooo";
                        goto try_except_handler_2;
                    }
                    tmp_condition_result_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_5;
                    }
                    else
                    {
                        goto branch_no_5;
                    }
                    branch_yes_5:;
                    {
                        PyObject *tmp_assign_source_12;
                        PyObject *tmp_str_arg_1;
                        CHECK_OBJECT( var_val );
                        tmp_str_arg_1 = var_val;
                        tmp_assign_source_12 = PyObject_Unicode( tmp_str_arg_1 );
                        if ( tmp_assign_source_12 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 1152;
                            type_description_1 = "ooooooooooooooooooo";
                            goto try_except_handler_2;
                        }
                        {
                            PyObject *old = var_val;
                            assert( old != NULL );
                            var_val = tmp_assign_source_12;
                            Py_DECREF( old );
                        }

                    }
                    goto branch_end_5;
                    branch_no_5:;
                    {
                        nuitka_bool tmp_condition_result_6;
                        int tmp_and_left_truth_2;
                        nuitka_bool tmp_and_left_value_2;
                        nuitka_bool tmp_and_right_value_2;
                        PyObject *tmp_isinstance_inst_6;
                        PyObject *tmp_isinstance_cls_6;
                        PyObject *tmp_mvar_value_3;
                        PyObject *tmp_compexpr_left_2;
                        PyObject *tmp_compexpr_right_2;
                        CHECK_OBJECT( var_val );
                        tmp_isinstance_inst_6 = var_val;
                        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_AttributeValueWithCharsetSubstitution );

                        if (unlikely( tmp_mvar_value_3 == NULL ))
                        {
                            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AttributeValueWithCharsetSubstitution );
                        }

                        if ( tmp_mvar_value_3 == NULL )
                        {

                            exception_type = PyExc_NameError;
                            Py_INCREF( exception_type );
                            exception_value = PyString_FromFormat( "global name '%s' is not defined", "AttributeValueWithCharsetSubstitution" );
                            exception_tb = NULL;

                            exception_lineno = 1154;
                            type_description_1 = "ooooooooooooooooooo";
                            goto try_except_handler_2;
                        }

                        tmp_isinstance_cls_6 = tmp_mvar_value_3;
                        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_6, tmp_isinstance_cls_6 );
                        if ( tmp_res == -1 )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 1154;
                            type_description_1 = "ooooooooooooooooooo";
                            goto try_except_handler_2;
                        }
                        tmp_and_left_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
                        if ( tmp_and_left_truth_2 == 1 )
                        {
                            goto and_right_2;
                        }
                        else
                        {
                            goto and_left_2;
                        }
                        and_right_2:;
                        CHECK_OBJECT( par_eventual_encoding );
                        tmp_compexpr_left_2 = par_eventual_encoding;
                        tmp_compexpr_right_2 = Py_None;
                        tmp_and_right_value_2 = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                        tmp_condition_result_6 = tmp_and_right_value_2;
                        goto and_end_2;
                        and_left_2:;
                        tmp_condition_result_6 = tmp_and_left_value_2;
                        and_end_2:;
                        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                        {
                            goto branch_yes_6;
                        }
                        else
                        {
                            goto branch_no_6;
                        }
                        branch_yes_6:;
                        {
                            PyObject *tmp_assign_source_13;
                            PyObject *tmp_called_instance_4;
                            PyObject *tmp_args_element_name_4;
                            CHECK_OBJECT( var_val );
                            tmp_called_instance_4 = var_val;
                            CHECK_OBJECT( par_eventual_encoding );
                            tmp_args_element_name_4 = par_eventual_encoding;
                            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1156;
                            {
                                PyObject *call_args[] = { tmp_args_element_name_4 };
                                tmp_assign_source_13 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_encode, call_args );
                            }

                            if ( tmp_assign_source_13 == NULL )
                            {
                                assert( ERROR_OCCURRED() );

                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                                exception_lineno = 1156;
                                type_description_1 = "ooooooooooooooooooo";
                                goto try_except_handler_2;
                            }
                            {
                                PyObject *old = var_val;
                                assert( old != NULL );
                                var_val = tmp_assign_source_13;
                                Py_DECREF( old );
                            }

                        }
                        branch_no_6:;
                    }
                    branch_end_5:;
                }
                branch_end_4:;
            }
            {
                PyObject *tmp_assign_source_14;
                PyObject *tmp_called_name_2;
                PyObject *tmp_source_name_3;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_args_element_name_6;
                CHECK_OBJECT( par_self );
                tmp_source_name_3 = par_self;
                tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_format_string );
                if ( tmp_called_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1158;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                if ( var_val == NULL )
                {
                    Py_DECREF( tmp_called_name_2 );
                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "val" );
                    exception_tb = NULL;

                    exception_lineno = 1158;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }

                tmp_args_element_name_5 = var_val;
                CHECK_OBJECT( par_formatter );
                tmp_args_element_name_6 = par_formatter;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1158;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                    tmp_assign_source_14 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
                }

                Py_DECREF( tmp_called_name_2 );
                if ( tmp_assign_source_14 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1158;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                {
                    PyObject *old = var_text;
                    var_text = tmp_assign_source_14;
                    Py_XDECREF( old );
                }

            }
            {
                PyObject *tmp_assign_source_15;
                PyObject *tmp_left_name_1;
                PyObject *tmp_left_name_2;
                PyObject *tmp_str_arg_2;
                PyObject *tmp_right_name_1;
                PyObject *tmp_right_name_2;
                PyObject *tmp_called_instance_5;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_args_element_name_7;
                CHECK_OBJECT( var_key );
                tmp_str_arg_2 = var_key;
                tmp_left_name_2 = PyObject_Unicode( tmp_str_arg_2 );
                if ( tmp_left_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1160;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_right_name_1 = const_str_chr_61;
                tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_STR( tmp_left_name_2, tmp_right_name_1 );
                Py_DECREF( tmp_left_name_2 );
                if ( tmp_left_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1160;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );
                }

                if ( tmp_mvar_value_4 == NULL )
                {
                    Py_DECREF( tmp_left_name_1 );
                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "EntitySubstitution" );
                    exception_tb = NULL;

                    exception_lineno = 1161;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }

                tmp_called_instance_5 = tmp_mvar_value_4;
                CHECK_OBJECT( var_text );
                tmp_args_element_name_7 = var_text;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1161;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_right_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_quoted_attribute_value, call_args );
                }

                if ( tmp_right_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_left_name_1 );

                    exception_lineno = 1161;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_assign_source_15 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
                Py_DECREF( tmp_left_name_1 );
                Py_DECREF( tmp_right_name_2 );
                if ( tmp_assign_source_15 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1161;
                    type_description_1 = "ooooooooooooooooooo";
                    goto try_except_handler_2;
                }
                {
                    PyObject *old = var_decoded;
                    var_decoded = tmp_assign_source_15;
                    Py_XDECREF( old );
                }

            }
            branch_end_3:;
        }
        {
            PyObject *tmp_called_instance_6;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_8;
            CHECK_OBJECT( var_attrs );
            tmp_called_instance_6 = var_attrs;
            CHECK_OBJECT( var_decoded );
            tmp_args_element_name_8 = var_decoded;
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1162;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_append, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1162;
                type_description_1 = "ooooooooooooooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1145;
            type_description_1 = "ooooooooooooooooooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_3;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto frame_exception_exit_1;
        // End of try:
        try_end_3:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        branch_no_2:;
    }
    {
        PyObject *tmp_assign_source_16;
        tmp_assign_source_16 = const_str_empty;
        assert( var_close == NULL );
        Py_INCREF( tmp_assign_source_16 );
        var_close = tmp_assign_source_16;
    }
    {
        PyObject *tmp_assign_source_17;
        tmp_assign_source_17 = const_str_empty;
        assert( var_closeTag == NULL );
        Py_INCREF( tmp_assign_source_17 );
        var_closeTag = tmp_assign_source_17;
    }
    {
        PyObject *tmp_assign_source_18;
        tmp_assign_source_18 = const_str_empty;
        assert( var_prefix == NULL );
        Py_INCREF( tmp_assign_source_18 );
        var_prefix = tmp_assign_source_18;
    }
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_source_name_4;
        PyObject *tmp_attribute_value_2;
        int tmp_truth_name_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_attribute_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_prefix );
        if ( tmp_attribute_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1167;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_2 = CHECK_IF_TRUE( tmp_attribute_value_2 );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_2 );

            exception_lineno = 1167;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_7 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_2 );
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_assign_source_19;
            PyObject *tmp_left_name_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_right_name_3;
            CHECK_OBJECT( par_self );
            tmp_source_name_5 = par_self;
            tmp_left_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_prefix );
            if ( tmp_left_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1168;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_3 = const_str_chr_58;
            tmp_assign_source_19 = BINARY_OPERATION_ADD_OBJECT_STR( tmp_left_name_3, tmp_right_name_3 );
            Py_DECREF( tmp_left_name_3 );
            if ( tmp_assign_source_19 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1168;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_prefix;
                assert( old != NULL );
                var_prefix = tmp_assign_source_19;
                Py_DECREF( old );
            }

        }
        branch_no_7:;
    }
    {
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_source_name_6;
        PyObject *tmp_attribute_value_3;
        int tmp_truth_name_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_attribute_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_is_empty_element );
        if ( tmp_attribute_value_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1170;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_3 = CHECK_IF_TRUE( tmp_attribute_value_3 );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_3 );

            exception_lineno = 1170;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_8 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_3 );
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assign_source_20;
            tmp_assign_source_20 = const_str_empty;
            {
                PyObject *old = var_close;
                assert( old != NULL );
                var_close = tmp_assign_source_20;
                Py_INCREF( var_close );
                Py_DECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_9;
            PyObject *tmp_isinstance_inst_7;
            PyObject *tmp_isinstance_cls_7;
            PyObject *tmp_mvar_value_5;
            CHECK_OBJECT( par_formatter );
            tmp_isinstance_inst_7 = par_formatter;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter );

            if (unlikely( tmp_mvar_value_5 == NULL ))
            {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Formatter );
            }

            if ( tmp_mvar_value_5 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Formatter" );
                exception_tb = NULL;

                exception_lineno = 1172;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_7 = tmp_mvar_value_5;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_7, tmp_isinstance_cls_7 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1172;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_9;
            }
            else
            {
                goto branch_no_9;
            }
            branch_yes_9:;
            {
                PyObject *tmp_assign_source_21;
                int tmp_or_left_truth_2;
                PyObject *tmp_or_left_value_2;
                PyObject *tmp_or_right_value_2;
                PyObject *tmp_source_name_7;
                CHECK_OBJECT( par_formatter );
                tmp_source_name_7 = par_formatter;
                tmp_or_left_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_void_element_close_prefix );
                if ( tmp_or_left_value_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1173;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
                if ( tmp_or_left_truth_2 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_or_left_value_2 );

                    exception_lineno = 1173;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                if ( tmp_or_left_truth_2 == 1 )
                {
                    goto or_left_2;
                }
                else
                {
                    goto or_right_2;
                }
                or_right_2:;
                Py_DECREF( tmp_or_left_value_2 );
                tmp_or_right_value_2 = const_str_empty;
                Py_INCREF( tmp_or_right_value_2 );
                tmp_assign_source_21 = tmp_or_right_value_2;
                goto or_end_2;
                or_left_2:;
                tmp_assign_source_21 = tmp_or_left_value_2;
                or_end_2:;
                {
                    PyObject *old = var_close;
                    assert( old != NULL );
                    var_close = tmp_assign_source_21;
                    Py_DECREF( old );
                }

            }
            branch_no_9:;
        }
        goto branch_end_8;
        branch_no_8:;
        {
            PyObject *tmp_assign_source_22;
            PyObject *tmp_left_name_4;
            PyObject *tmp_right_name_4;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_8;
            tmp_left_name_4 = const_str_digest_b63f4abf4c20ed95c5280f099ca7f649;
            CHECK_OBJECT( var_prefix );
            tmp_tuple_element_1 = var_prefix;
            tmp_right_name_4 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_right_name_4, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_self );
            tmp_source_name_8 = par_self;
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_name );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_4 );

                exception_lineno = 1175;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_4, 1, tmp_tuple_element_1 );
            tmp_assign_source_22 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
            Py_DECREF( tmp_right_name_4 );
            if ( tmp_assign_source_22 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1175;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_closeTag;
                assert( old != NULL );
                var_closeTag = tmp_assign_source_22;
                Py_DECREF( old );
            }

        }
        branch_end_8:;
    }
    {
        PyObject *tmp_assign_source_23;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT( par_self );
        tmp_called_instance_7 = par_self;
        CHECK_OBJECT( par_indent_level );
        tmp_args_element_name_9 = par_indent_level;
        frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1177;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_assign_source_23 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain__should_pretty_print, call_args );
        }

        if ( tmp_assign_source_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1177;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_pretty_print == NULL );
        var_pretty_print = tmp_assign_source_23;
    }
    {
        PyObject *tmp_assign_source_24;
        tmp_assign_source_24 = const_str_empty;
        assert( var_space == NULL );
        Py_INCREF( tmp_assign_source_24 );
        var_space = tmp_assign_source_24;
    }
    {
        PyObject *tmp_assign_source_25;
        tmp_assign_source_25 = const_str_empty;
        assert( var_indent_space == NULL );
        Py_INCREF( tmp_assign_source_25 );
        var_indent_space = tmp_assign_source_25;
    }
    {
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( par_indent_level );
        tmp_compexpr_left_3 = par_indent_level;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_10 = ( tmp_compexpr_left_3 != tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_10;
        }
        else
        {
            goto branch_no_10;
        }
        branch_yes_10:;
        {
            PyObject *tmp_assign_source_26;
            PyObject *tmp_left_name_5;
            PyObject *tmp_right_name_5;
            PyObject *tmp_left_name_6;
            PyObject *tmp_right_name_6;
            tmp_left_name_5 = const_str_space;
            CHECK_OBJECT( par_indent_level );
            tmp_left_name_6 = par_indent_level;
            tmp_right_name_6 = const_int_pos_1;
            tmp_right_name_5 = BINARY_OPERATION_SUB( tmp_left_name_6, tmp_right_name_6 );
            if ( tmp_right_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1181;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_assign_source_26 = BINARY_OPERATION_MUL( tmp_left_name_5, tmp_right_name_5 );
            Py_DECREF( tmp_right_name_5 );
            if ( tmp_assign_source_26 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1181;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_indent_space;
                assert( old != NULL );
                var_indent_space = tmp_assign_source_26;
                Py_DECREF( old );
            }

        }
        branch_no_10:;
    }
    {
        nuitka_bool tmp_condition_result_11;
        int tmp_truth_name_4;
        CHECK_OBJECT( var_pretty_print );
        tmp_truth_name_4 = CHECK_IF_TRUE( var_pretty_print );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1182;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_11 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_11;
        }
        else
        {
            goto branch_no_11;
        }
        branch_yes_11:;
        {
            PyObject *tmp_assign_source_27;
            CHECK_OBJECT( var_indent_space );
            tmp_assign_source_27 = var_indent_space;
            {
                PyObject *old = var_space;
                assert( old != NULL );
                var_space = tmp_assign_source_27;
                Py_INCREF( var_space );
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_28;
            PyObject *tmp_left_name_7;
            PyObject *tmp_right_name_7;
            CHECK_OBJECT( par_indent_level );
            tmp_left_name_7 = par_indent_level;
            tmp_right_name_7 = const_int_pos_1;
            tmp_assign_source_28 = BINARY_OPERATION_ADD_OBJECT_INT( tmp_left_name_7, tmp_right_name_7 );
            if ( tmp_assign_source_28 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1184;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            assert( var_indent_contents == NULL );
            var_indent_contents = tmp_assign_source_28;
        }
        goto branch_end_11;
        branch_no_11:;
        {
            PyObject *tmp_assign_source_29;
            tmp_assign_source_29 = Py_None;
            assert( var_indent_contents == NULL );
            Py_INCREF( tmp_assign_source_29 );
            var_indent_contents = tmp_assign_source_29;
        }
        branch_end_11:;
    }
    {
        PyObject *tmp_assign_source_30;
        PyObject *tmp_called_instance_8;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        CHECK_OBJECT( par_self );
        tmp_called_instance_8 = par_self;
        CHECK_OBJECT( var_indent_contents );
        tmp_args_element_name_10 = var_indent_contents;
        CHECK_OBJECT( par_eventual_encoding );
        tmp_args_element_name_11 = par_eventual_encoding;
        CHECK_OBJECT( par_formatter );
        tmp_args_element_name_12 = par_formatter;
        frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1187;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
            tmp_assign_source_30 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_8, const_str_plain_decode_contents, call_args );
        }

        if ( tmp_assign_source_30 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1187;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_contents == NULL );
        var_contents = tmp_assign_source_30;
    }
    {
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_source_name_9;
        PyObject *tmp_attribute_value_4;
        int tmp_truth_name_5;
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_attribute_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_hidden );
        if ( tmp_attribute_value_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1190;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_5 = CHECK_IF_TRUE( tmp_attribute_value_4 );
        if ( tmp_truth_name_5 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_4 );

            exception_lineno = 1190;
            type_description_1 = "ooooooooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_12 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_4 );
        if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_12;
        }
        else
        {
            goto branch_no_12;
        }
        branch_yes_12:;
        {
            PyObject *tmp_assign_source_31;
            CHECK_OBJECT( var_contents );
            tmp_assign_source_31 = var_contents;
            assert( var_s == NULL );
            Py_INCREF( tmp_assign_source_31 );
            var_s = tmp_assign_source_31;
        }
        goto branch_end_12;
        branch_no_12:;
        {
            PyObject *tmp_assign_source_32;
            tmp_assign_source_32 = PyList_New( 0 );
            assert( var_s == NULL );
            var_s = tmp_assign_source_32;
        }
        {
            PyObject *tmp_assign_source_33;
            tmp_assign_source_33 = const_str_empty;
            assert( var_attribute_string == NULL );
            Py_INCREF( tmp_assign_source_33 );
            var_attribute_string = tmp_assign_source_33;
        }
        {
            nuitka_bool tmp_condition_result_13;
            int tmp_truth_name_6;
            CHECK_OBJECT( var_attrs );
            tmp_truth_name_6 = CHECK_IF_TRUE( var_attrs );
            if ( tmp_truth_name_6 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1196;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_13 = tmp_truth_name_6 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_13;
            }
            else
            {
                goto branch_no_13;
            }
            branch_yes_13:;
            {
                PyObject *tmp_assign_source_34;
                PyObject *tmp_left_name_8;
                PyObject *tmp_right_name_8;
                PyObject *tmp_called_instance_9;
                PyObject *tmp_args_element_name_13;
                tmp_left_name_8 = const_str_space;
                tmp_called_instance_9 = const_str_space;
                CHECK_OBJECT( var_attrs );
                tmp_args_element_name_13 = var_attrs;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1197;
                {
                    PyObject *call_args[] = { tmp_args_element_name_13 };
                    tmp_right_name_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_join, call_args );
                }

                if ( tmp_right_name_8 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1197;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_34 = BINARY_OPERATION_ADD_STR_OBJECT( tmp_left_name_8, tmp_right_name_8 );
                Py_DECREF( tmp_right_name_8 );
                if ( tmp_assign_source_34 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1197;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = var_attribute_string;
                    assert( old != NULL );
                    var_attribute_string = tmp_assign_source_34;
                    Py_DECREF( old );
                }

            }
            branch_no_13:;
        }
        {
            nuitka_bool tmp_condition_result_14;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( par_indent_level );
            tmp_compexpr_left_4 = par_indent_level;
            tmp_compexpr_right_4 = Py_None;
            tmp_condition_result_14 = ( tmp_compexpr_left_4 != tmp_compexpr_right_4 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_14;
            }
            else
            {
                goto branch_no_14;
            }
            branch_yes_14:;
            {
                PyObject *tmp_called_instance_10;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_14;
                CHECK_OBJECT( var_s );
                tmp_called_instance_10 = var_s;
                CHECK_OBJECT( var_indent_space );
                tmp_args_element_name_14 = var_indent_space;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1201;
                {
                    PyObject *call_args[] = { tmp_args_element_name_14 };
                    tmp_call_result_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1201;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_no_14:;
        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_10;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_left_name_9;
            PyObject *tmp_right_name_9;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_source_name_11;
            CHECK_OBJECT( var_s );
            tmp_source_name_10 = var_s;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_append );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1202;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_left_name_9 = const_str_digest_b0c38f7df4c7a5de79b4700d224aa3b6;
            CHECK_OBJECT( var_prefix );
            tmp_tuple_element_2 = var_prefix;
            tmp_right_name_9 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_9, 0, tmp_tuple_element_2 );
            CHECK_OBJECT( par_self );
            tmp_source_name_11 = par_self;
            tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_name );
            if ( tmp_tuple_element_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_right_name_9 );

                exception_lineno = 1203;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_9, 1, tmp_tuple_element_2 );
            CHECK_OBJECT( var_attribute_string );
            tmp_tuple_element_2 = var_attribute_string;
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_9, 2, tmp_tuple_element_2 );
            if ( var_close == NULL )
            {
                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_right_name_9 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "close" );
                exception_tb = NULL;

                exception_lineno = 1203;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_2 = var_close;
            Py_INCREF( tmp_tuple_element_2 );
            PyTuple_SET_ITEM( tmp_right_name_9, 3, tmp_tuple_element_2 );
            tmp_args_element_name_15 = BINARY_OPERATION_REMAINDER( tmp_left_name_9, tmp_right_name_9 );
            Py_DECREF( tmp_right_name_9 );
            if ( tmp_args_element_name_15 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1202;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1202;
            {
                PyObject *call_args[] = { tmp_args_element_name_15 };
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_15 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1202;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        {
            nuitka_bool tmp_condition_result_15;
            int tmp_truth_name_7;
            CHECK_OBJECT( var_pretty_print );
            tmp_truth_name_7 = CHECK_IF_TRUE( var_pretty_print );
            if ( tmp_truth_name_7 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1204;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_15 = tmp_truth_name_7 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_15;
            }
            else
            {
                goto branch_no_15;
            }
            branch_yes_15:;
            {
                PyObject *tmp_called_instance_11;
                PyObject *tmp_call_result_4;
                CHECK_OBJECT( var_s );
                tmp_called_instance_11 = var_s;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1205;
                tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_11, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_newline_tuple, 0 ) );

                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1205;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_4 );
            }
            branch_no_15:;
        }
        {
            PyObject *tmp_called_instance_12;
            PyObject *tmp_call_result_5;
            PyObject *tmp_args_element_name_16;
            CHECK_OBJECT( var_s );
            tmp_called_instance_12 = var_s;
            CHECK_OBJECT( var_contents );
            tmp_args_element_name_16 = var_contents;
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1206;
            {
                PyObject *call_args[] = { tmp_args_element_name_16 };
                tmp_call_result_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_12, const_str_plain_append, call_args );
            }

            if ( tmp_call_result_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1206;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_5 );
        }
        {
            nuitka_bool tmp_condition_result_16;
            int tmp_and_left_truth_3;
            nuitka_bool tmp_and_left_value_3;
            nuitka_bool tmp_and_right_value_3;
            int tmp_truth_name_8;
            int tmp_and_left_truth_4;
            nuitka_bool tmp_and_left_value_4;
            nuitka_bool tmp_and_right_value_4;
            int tmp_truth_name_9;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( var_pretty_print );
            tmp_truth_name_8 = CHECK_IF_TRUE( var_pretty_print );
            if ( tmp_truth_name_8 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1207;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_3 = tmp_truth_name_8 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_3 == 1 )
            {
                goto and_right_3;
            }
            else
            {
                goto and_left_3;
            }
            and_right_3:;
            CHECK_OBJECT( var_contents );
            tmp_truth_name_9 = CHECK_IF_TRUE( var_contents );
            if ( tmp_truth_name_9 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1207;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_4 = tmp_truth_name_9 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_4 == 1 )
            {
                goto and_right_4;
            }
            else
            {
                goto and_left_4;
            }
            and_right_4:;
            CHECK_OBJECT( var_contents );
            tmp_subscribed_name_1 = var_contents;
            tmp_subscript_name_1 = const_int_neg_1;
            tmp_compexpr_left_5 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, -1 );
            if ( tmp_compexpr_left_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1207;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_5 = const_str_newline;
            tmp_res = RICH_COMPARE_BOOL_NOTEQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            Py_DECREF( tmp_compexpr_left_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1207;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_right_value_3 = tmp_and_right_value_4;
            goto and_end_4;
            and_left_4:;
            tmp_and_right_value_3 = tmp_and_left_value_4;
            and_end_4:;
            tmp_condition_result_16 = tmp_and_right_value_3;
            goto and_end_3;
            and_left_3:;
            tmp_condition_result_16 = tmp_and_left_value_3;
            and_end_3:;
            if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_16;
            }
            else
            {
                goto branch_no_16;
            }
            branch_yes_16:;
            {
                PyObject *tmp_called_instance_13;
                PyObject *tmp_call_result_6;
                CHECK_OBJECT( var_s );
                tmp_called_instance_13 = var_s;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1208;
                tmp_call_result_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_13, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_newline_tuple, 0 ) );

                if ( tmp_call_result_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1208;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_6 );
            }
            branch_no_16:;
        }
        {
            nuitka_bool tmp_condition_result_17;
            int tmp_and_left_truth_5;
            nuitka_bool tmp_and_left_value_5;
            nuitka_bool tmp_and_right_value_5;
            int tmp_truth_name_10;
            int tmp_truth_name_11;
            CHECK_OBJECT( var_pretty_print );
            tmp_truth_name_10 = CHECK_IF_TRUE( var_pretty_print );
            if ( tmp_truth_name_10 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1209;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_5 = tmp_truth_name_10 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_5 = tmp_and_left_value_5 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_5 == 1 )
            {
                goto and_right_5;
            }
            else
            {
                goto and_left_5;
            }
            and_right_5:;
            CHECK_OBJECT( var_closeTag );
            tmp_truth_name_11 = CHECK_IF_TRUE( var_closeTag );
            if ( tmp_truth_name_11 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1209;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_5 = tmp_truth_name_11 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_17 = tmp_and_right_value_5;
            goto and_end_5;
            and_left_5:;
            tmp_condition_result_17 = tmp_and_left_value_5;
            and_end_5:;
            if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_17;
            }
            else
            {
                goto branch_no_17;
            }
            branch_yes_17:;
            {
                PyObject *tmp_called_instance_14;
                PyObject *tmp_call_result_7;
                PyObject *tmp_args_element_name_17;
                CHECK_OBJECT( var_s );
                tmp_called_instance_14 = var_s;
                CHECK_OBJECT( var_space );
                tmp_args_element_name_17 = var_space;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1210;
                {
                    PyObject *call_args[] = { tmp_args_element_name_17 };
                    tmp_call_result_7 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_14, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1210;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_7 );
            }
            branch_no_17:;
        }
        {
            PyObject *tmp_called_instance_15;
            PyObject *tmp_call_result_8;
            PyObject *tmp_args_element_name_18;
            CHECK_OBJECT( var_s );
            tmp_called_instance_15 = var_s;
            CHECK_OBJECT( var_closeTag );
            tmp_args_element_name_18 = var_closeTag;
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1211;
            {
                PyObject *call_args[] = { tmp_args_element_name_18 };
                tmp_call_result_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_15, const_str_plain_append, call_args );
            }

            if ( tmp_call_result_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1211;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_8 );
        }
        {
            nuitka_bool tmp_condition_result_18;
            int tmp_and_left_truth_6;
            nuitka_bool tmp_and_left_value_6;
            nuitka_bool tmp_and_right_value_6;
            PyObject *tmp_compexpr_left_6;
            PyObject *tmp_compexpr_right_6;
            int tmp_and_left_truth_7;
            nuitka_bool tmp_and_left_value_7;
            nuitka_bool tmp_and_right_value_7;
            int tmp_truth_name_12;
            PyObject *tmp_source_name_12;
            PyObject *tmp_attribute_value_5;
            int tmp_truth_name_13;
            CHECK_OBJECT( par_indent_level );
            tmp_compexpr_left_6 = par_indent_level;
            tmp_compexpr_right_6 = Py_None;
            tmp_and_left_value_6 = ( tmp_compexpr_left_6 != tmp_compexpr_right_6 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_6 = tmp_and_left_value_6 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_6 == 1 )
            {
                goto and_right_6;
            }
            else
            {
                goto and_left_6;
            }
            and_right_6:;
            CHECK_OBJECT( var_closeTag );
            tmp_truth_name_12 = CHECK_IF_TRUE( var_closeTag );
            if ( tmp_truth_name_12 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1212;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_left_value_7 = tmp_truth_name_12 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_7 = tmp_and_left_value_7 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_7 == 1 )
            {
                goto and_right_7;
            }
            else
            {
                goto and_left_7;
            }
            and_right_7:;
            CHECK_OBJECT( par_self );
            tmp_source_name_12 = par_self;
            tmp_attribute_value_5 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_next_sibling );
            if ( tmp_attribute_value_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1212;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_truth_name_13 = CHECK_IF_TRUE( tmp_attribute_value_5 );
            if ( tmp_truth_name_13 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_attribute_value_5 );

                exception_lineno = 1212;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_and_right_value_7 = tmp_truth_name_13 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_attribute_value_5 );
            tmp_and_right_value_6 = tmp_and_right_value_7;
            goto and_end_7;
            and_left_7:;
            tmp_and_right_value_6 = tmp_and_left_value_7;
            and_end_7:;
            tmp_condition_result_18 = tmp_and_right_value_6;
            goto and_end_6;
            and_left_6:;
            tmp_condition_result_18 = tmp_and_left_value_6;
            and_end_6:;
            if ( tmp_condition_result_18 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_18;
            }
            else
            {
                goto branch_no_18;
            }
            branch_yes_18:;
            {
                PyObject *tmp_called_instance_16;
                PyObject *tmp_call_result_9;
                CHECK_OBJECT( var_s );
                tmp_called_instance_16 = var_s;
                frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1216;
                tmp_call_result_9 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_16, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_newline_tuple, 0 ) );

                if ( tmp_call_result_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1216;
                    type_description_1 = "ooooooooooooooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_9 );
            }
            branch_no_18:;
        }
        {
            PyObject *tmp_assign_source_35;
            PyObject *tmp_called_instance_17;
            PyObject *tmp_args_element_name_19;
            tmp_called_instance_17 = const_str_empty;
            CHECK_OBJECT( var_s );
            tmp_args_element_name_19 = var_s;
            frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame.f_lineno = 1217;
            {
                PyObject *call_args[] = { tmp_args_element_name_19 };
                tmp_assign_source_35 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_17, const_str_plain_join, call_args );
            }

            if ( tmp_assign_source_35 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1217;
                type_description_1 = "ooooooooooooooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_s;
                assert( old != NULL );
                var_s = tmp_assign_source_35;
                Py_DECREF( old );
            }

        }
        branch_end_12:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e5ea0a96abd38fc63210a5d0436fdc4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e5ea0a96abd38fc63210a5d0436fdc4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7e5ea0a96abd38fc63210a5d0436fdc4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7e5ea0a96abd38fc63210a5d0436fdc4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7e5ea0a96abd38fc63210a5d0436fdc4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7e5ea0a96abd38fc63210a5d0436fdc4,
        type_description_1,
        par_self,
        par_indent_level,
        par_eventual_encoding,
        par_formatter,
        var_indent_contents,
        var_decoded,
        var_contents,
        var_val,
        var_space,
        var_pretty_print,
        var_text,
        var_closeTag,
        var_s,
        var_prefix,
        var_attrs,
        var_key,
        var_close,
        var_indent_space,
        var_attribute_string
    );


    // Release cached frame.
    if ( frame_7e5ea0a96abd38fc63210a5d0436fdc4 == cache_frame_7e5ea0a96abd38fc63210a5d0436fdc4 )
    {
        Py_DECREF( frame_7e5ea0a96abd38fc63210a5d0436fdc4 );
    }
    cache_frame_7e5ea0a96abd38fc63210a5d0436fdc4 = NULL;

    assertFrameObject( frame_7e5ea0a96abd38fc63210a5d0436fdc4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_s );
    tmp_return_value = var_s;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_93_decode );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_indent_contents );
    Py_DECREF( var_indent_contents );
    var_indent_contents = NULL;

    Py_XDECREF( var_decoded );
    var_decoded = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)var_contents );
    Py_DECREF( var_contents );
    var_contents = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    Py_XDECREF( var_val );
    var_val = NULL;

    CHECK_OBJECT( (PyObject *)var_space );
    Py_DECREF( var_space );
    var_space = NULL;

    CHECK_OBJECT( (PyObject *)var_pretty_print );
    Py_DECREF( var_pretty_print );
    var_pretty_print = NULL;

    Py_XDECREF( var_text );
    var_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_closeTag );
    Py_DECREF( var_closeTag );
    var_closeTag = NULL;

    CHECK_OBJECT( (PyObject *)var_s );
    Py_DECREF( var_s );
    var_s = NULL;

    CHECK_OBJECT( (PyObject *)var_prefix );
    Py_DECREF( var_prefix );
    var_prefix = NULL;

    CHECK_OBJECT( (PyObject *)var_attrs );
    Py_DECREF( var_attrs );
    var_attrs = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( var_close );
    var_close = NULL;

    CHECK_OBJECT( (PyObject *)par_eventual_encoding );
    Py_DECREF( par_eventual_encoding );
    par_eventual_encoding = NULL;

    CHECK_OBJECT( (PyObject *)var_indent_space );
    Py_DECREF( var_indent_space );
    var_indent_space = NULL;

    Py_XDECREF( var_attribute_string );
    var_attribute_string = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_indent_contents );
    var_indent_contents = NULL;

    Py_XDECREF( var_decoded );
    var_decoded = NULL;

    Py_XDECREF( par_formatter );
    par_formatter = NULL;

    Py_XDECREF( var_contents );
    var_contents = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    Py_XDECREF( var_val );
    var_val = NULL;

    Py_XDECREF( var_space );
    var_space = NULL;

    Py_XDECREF( var_pretty_print );
    var_pretty_print = NULL;

    Py_XDECREF( var_text );
    var_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_closeTag );
    var_closeTag = NULL;

    Py_XDECREF( var_s );
    var_s = NULL;

    Py_XDECREF( var_prefix );
    var_prefix = NULL;

    Py_XDECREF( var_attrs );
    var_attrs = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( var_close );
    var_close = NULL;

    CHECK_OBJECT( (PyObject *)par_eventual_encoding );
    Py_DECREF( par_eventual_encoding );
    par_eventual_encoding = NULL;

    Py_XDECREF( var_indent_space );
    var_indent_space = NULL;

    Py_XDECREF( var_attribute_string );
    var_attribute_string = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_93_decode );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_94_prettify( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_encoding = python_pars[ 1 ];
    PyObject *par_formatter = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_7e3e5722d1e42f7d6ddb1bbecd61c01f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_7e3e5722d1e42f7d6ddb1bbecd61c01f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7e3e5722d1e42f7d6ddb1bbecd61c01f, codeobj_7e3e5722d1e42f7d6ddb1bbecd61c01f, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7e3e5722d1e42f7d6ddb1bbecd61c01f = cache_frame_7e3e5722d1e42f7d6ddb1bbecd61c01f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_encoding );
        tmp_compexpr_left_1 = par_encoding;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_args_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_decode );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1222;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            tmp_args_name_1 = const_tuple_true_tuple;
            CHECK_OBJECT( par_formatter );
            tmp_dict_value_1 = par_formatter;
            tmp_dict_key_1 = const_str_plain_formatter;
            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            frame_7e3e5722d1e42f7d6ddb1bbecd61c01f->m_frame.f_lineno = 1222;
            tmp_return_value = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_kw_name_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1222;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_name_2;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_kw_name_2;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_encode );
            if ( tmp_called_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1224;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_encoding );
            tmp_tuple_element_1 = par_encoding;
            tmp_args_name_2 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_1 );
            tmp_tuple_element_1 = Py_True;
            Py_INCREF( tmp_tuple_element_1 );
            PyTuple_SET_ITEM( tmp_args_name_2, 1, tmp_tuple_element_1 );
            CHECK_OBJECT( par_formatter );
            tmp_dict_value_2 = par_formatter;
            tmp_dict_key_2 = const_str_plain_formatter;
            tmp_kw_name_2 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
            assert( !(tmp_res != 0) );
            frame_7e3e5722d1e42f7d6ddb1bbecd61c01f->m_frame.f_lineno = 1224;
            tmp_return_value = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_2, tmp_kw_name_2 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_args_name_2 );
            Py_DECREF( tmp_kw_name_2 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1224;
                type_description_1 = "ooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7e3e5722d1e42f7d6ddb1bbecd61c01f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7e3e5722d1e42f7d6ddb1bbecd61c01f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7e3e5722d1e42f7d6ddb1bbecd61c01f,
        type_description_1,
        par_self,
        par_encoding,
        par_formatter
    );


    // Release cached frame.
    if ( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f == cache_frame_7e3e5722d1e42f7d6ddb1bbecd61c01f )
    {
        Py_DECREF( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f );
    }
    cache_frame_7e3e5722d1e42f7d6ddb1bbecd61c01f = NULL;

    assertFrameObject( frame_7e3e5722d1e42f7d6ddb1bbecd61c01f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_94_prettify );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_94_prettify );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_95_decode_contents( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_indent_level = python_pars[ 1 ];
    PyObject *par_eventual_encoding = python_pars[ 2 ];
    PyObject *par_formatter = python_pars[ 3 ];
    PyObject *var_c = NULL;
    PyObject *var_text = NULL;
    nuitka_bool var_pretty_print = NUITKA_BOOL_UNASSIGNED;
    PyObject *var_s = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_f80e94e61a5498e34db5e8bf04849743;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f80e94e61a5498e34db5e8bf04849743 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f80e94e61a5498e34db5e8bf04849743, codeobj_f80e94e61a5498e34db5e8bf04849743, module_bs4$element, sizeof(nuitka_bool)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_f80e94e61a5498e34db5e8bf04849743 = cache_frame_f80e94e61a5498e34db5e8bf04849743;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f80e94e61a5498e34db5e8bf04849743 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f80e94e61a5498e34db5e8bf04849743 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_formatter );
        tmp_isinstance_inst_1 = par_formatter;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Formatter );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Formatter" );
            exception_tb = NULL;

            exception_lineno = 1246;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1246;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1246;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_formatter );
        tmp_isinstance_inst_2 = par_formatter;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Callable );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Callable" );
            exception_tb = NULL;

            exception_lineno = 1246;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1246;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1246;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( par_formatter );
            tmp_args_element_name_1 = par_formatter;
            frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1247;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__formatter_for_name, call_args );
            }

            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1247;
                type_description_1 = "oooooobo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_formatter;
                assert( old != NULL );
                par_formatter = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_assign_source_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_indent_level );
        tmp_compexpr_left_1 = par_indent_level;
        tmp_compexpr_right_1 = Py_None;
        tmp_assign_source_2 = ( tmp_compexpr_left_1 != tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        var_pretty_print = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = PyList_New( 0 );
        assert( var_s == NULL );
        var_s = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT( par_self );
        tmp_iter_arg_1 = par_self;
        tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1251;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooobo";
                exception_lineno = 1251;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_c;
            var_c = tmp_assign_source_6;
            Py_INCREF( var_c );
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_7;
        tmp_assign_source_7 = Py_None;
        {
            PyObject *old = var_text;
            var_text = tmp_assign_source_7;
            Py_INCREF( var_text );
            Py_XDECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( var_c );
        tmp_isinstance_inst_3 = var_c;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
            exception_tb = NULL;

            exception_lineno = 1253;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }

        tmp_isinstance_cls_3 = tmp_mvar_value_3;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1253;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT( var_c );
            tmp_called_instance_2 = var_c;
            CHECK_OBJECT( par_formatter );
            tmp_args_element_name_2 = par_formatter;
            frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1254;
            {
                PyObject *call_args[] = { tmp_args_element_name_2 };
                tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_output_ready, call_args );
            }

            if ( tmp_assign_source_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1254;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            {
                PyObject *old = var_text;
                assert( old != NULL );
                var_text = tmp_assign_source_8;
                Py_DECREF( old );
            }

        }
        goto branch_end_2;
        branch_no_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_isinstance_inst_4;
            PyObject *tmp_isinstance_cls_4;
            PyObject *tmp_mvar_value_4;
            CHECK_OBJECT( var_c );
            tmp_isinstance_inst_4 = var_c;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

            if (unlikely( tmp_mvar_value_4 == NULL ))
            {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
            }

            if ( tmp_mvar_value_4 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
                exception_tb = NULL;

                exception_lineno = 1255;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }

            tmp_isinstance_cls_4 = tmp_mvar_value_4;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_4, tmp_isinstance_cls_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1255;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_source_name_1;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_3;
                PyObject *tmp_called_instance_3;
                PyObject *tmp_args_element_name_4;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_args_element_name_6;
                CHECK_OBJECT( var_s );
                tmp_source_name_1 = var_s;
                tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
                if ( tmp_called_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1256;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                CHECK_OBJECT( var_c );
                tmp_called_instance_3 = var_c;
                CHECK_OBJECT( par_indent_level );
                tmp_args_element_name_4 = par_indent_level;
                CHECK_OBJECT( par_eventual_encoding );
                tmp_args_element_name_5 = par_eventual_encoding;
                CHECK_OBJECT( par_formatter );
                tmp_args_element_name_6 = par_formatter;
                frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1256;
                {
                    PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
                    tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_3, const_str_plain_decode, call_args );
                }

                if ( tmp_args_element_name_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );

                    exception_lineno = 1256;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1256;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_args_element_name_3 );
                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1256;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            branch_no_3:;
        }
        branch_end_2:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        int tmp_truth_name_1;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        int tmp_truth_name_2;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT( var_text );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_text );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1258;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }
        tmp_and_left_value_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_indent_level );
        tmp_truth_name_2 = CHECK_IF_TRUE( par_indent_level );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1258;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }
        tmp_and_left_value_3 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_3 == 1 )
        {
            goto and_right_3;
        }
        else
        {
            goto and_left_3;
        }
        and_right_3:;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
        if ( tmp_compexpr_left_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1258;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }
        tmp_compexpr_right_2 = const_str_plain_pre;
        tmp_operand_name_3 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        Py_DECREF( tmp_compexpr_left_2 );
        if ( tmp_operand_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1258;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        Py_DECREF( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1258;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }
        tmp_and_right_value_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_2 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_and_right_value_2 = tmp_and_left_value_3;
        and_end_3:;
        tmp_condition_result_4 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_4 = tmp_and_left_value_2;
        and_end_2:;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_called_instance_4;
            CHECK_OBJECT( var_text );
            tmp_called_instance_4 = var_text;
            frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1259;
            tmp_assign_source_9 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_strip );
            if ( tmp_assign_source_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1259;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            {
                PyObject *old = var_text;
                assert( old != NULL );
                var_text = tmp_assign_source_9;
                Py_DECREF( old );
            }

        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        int tmp_truth_name_3;
        if ( var_text == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "text" );
            exception_tb = NULL;

            exception_lineno = 1260;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }

        tmp_truth_name_3 = CHECK_IF_TRUE( var_text );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1260;
            type_description_1 = "oooooobo";
            goto try_except_handler_2;
        }
        tmp_condition_result_5 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            nuitka_bool tmp_condition_result_6;
            int tmp_and_left_truth_4;
            nuitka_bool tmp_and_left_value_4;
            nuitka_bool tmp_and_right_value_4;
            PyObject *tmp_operand_name_4;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_source_name_3;
            assert( var_pretty_print != NUITKA_BOOL_UNASSIGNED);
            tmp_and_left_value_4 = var_pretty_print;
            tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_4 == 1 )
            {
                goto and_right_4;
            }
            else
            {
                goto and_left_4;
            }
            and_right_4:;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_name );
            if ( tmp_compexpr_left_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1261;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            tmp_compexpr_right_3 = const_str_plain_pre;
            tmp_operand_name_4 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
            Py_DECREF( tmp_compexpr_left_3 );
            if ( tmp_operand_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1261;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
            Py_DECREF( tmp_operand_name_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1261;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            tmp_and_right_value_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_6 = tmp_and_right_value_4;
            goto and_end_4;
            and_left_4:;
            tmp_condition_result_6 = tmp_and_left_value_4;
            and_end_4:;
            if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_6;
            }
            else
            {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_called_name_2;
                PyObject *tmp_source_name_4;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_7;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_2;
                CHECK_OBJECT( var_s );
                tmp_source_name_4 = var_s;
                tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
                if ( tmp_called_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1262;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                tmp_left_name_1 = const_str_space;
                CHECK_OBJECT( par_indent_level );
                tmp_left_name_2 = par_indent_level;
                tmp_right_name_2 = const_int_pos_1;
                tmp_right_name_1 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
                if ( tmp_right_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_2 );

                    exception_lineno = 1262;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                tmp_args_element_name_7 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_1 );
                Py_DECREF( tmp_right_name_1 );
                if ( tmp_args_element_name_7 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_2 );

                    exception_lineno = 1262;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1262;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
                }

                Py_DECREF( tmp_called_name_2 );
                Py_DECREF( tmp_args_element_name_7 );
                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1262;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_no_6:;
        }
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_5;
            PyObject *tmp_call_result_3;
            PyObject *tmp_args_element_name_8;
            CHECK_OBJECT( var_s );
            tmp_source_name_5 = var_s;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_append );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1263;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            if ( var_text == NULL )
            {
                Py_DECREF( tmp_called_name_3 );
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "text" );
                exception_tb = NULL;

                exception_lineno = 1263;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }

            tmp_args_element_name_8 = var_text;
            frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1263;
            {
                PyObject *call_args[] = { tmp_args_element_name_8 };
                tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            if ( tmp_call_result_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1263;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            Py_DECREF( tmp_call_result_3 );
        }
        {
            nuitka_bool tmp_condition_result_7;
            int tmp_and_left_truth_5;
            nuitka_bool tmp_and_left_value_5;
            nuitka_bool tmp_and_right_value_5;
            PyObject *tmp_operand_name_5;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            PyObject *tmp_source_name_6;
            assert( var_pretty_print != NUITKA_BOOL_UNASSIGNED);
            tmp_and_left_value_5 = var_pretty_print;
            tmp_and_left_truth_5 = tmp_and_left_value_5 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_5 == 1 )
            {
                goto and_right_5;
            }
            else
            {
                goto and_left_5;
            }
            and_right_5:;
            CHECK_OBJECT( par_self );
            tmp_source_name_6 = par_self;
            tmp_compexpr_left_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_name );
            if ( tmp_compexpr_left_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1264;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            tmp_compexpr_right_4 = const_str_plain_pre;
            tmp_operand_name_5 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
            Py_DECREF( tmp_compexpr_left_4 );
            if ( tmp_operand_name_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1264;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_5 );
            Py_DECREF( tmp_operand_name_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1264;
                type_description_1 = "oooooobo";
                goto try_except_handler_2;
            }
            tmp_and_right_value_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_condition_result_7 = tmp_and_right_value_5;
            goto and_end_5;
            and_left_5:;
            tmp_condition_result_7 = tmp_and_left_value_5;
            and_end_5:;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                PyObject *tmp_called_instance_5;
                PyObject *tmp_call_result_4;
                CHECK_OBJECT( var_s );
                tmp_called_instance_5 = var_s;
                frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1265;
                tmp_call_result_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_str_newline_tuple, 0 ) );

                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1265;
                    type_description_1 = "oooooobo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_4 );
            }
            branch_no_7:;
        }
        branch_no_5:;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description_1 = "oooooobo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_instance_6;
        PyObject *tmp_args_element_name_9;
        tmp_called_instance_6 = const_str_empty;
        CHECK_OBJECT( var_s );
        tmp_args_element_name_9 = var_s;
        frame_f80e94e61a5498e34db5e8bf04849743->m_frame.f_lineno = 1266;
        {
            PyObject *call_args[] = { tmp_args_element_name_9 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_join, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1266;
            type_description_1 = "oooooobo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f80e94e61a5498e34db5e8bf04849743 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f80e94e61a5498e34db5e8bf04849743 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f80e94e61a5498e34db5e8bf04849743 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f80e94e61a5498e34db5e8bf04849743, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f80e94e61a5498e34db5e8bf04849743->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f80e94e61a5498e34db5e8bf04849743, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f80e94e61a5498e34db5e8bf04849743,
        type_description_1,
        par_self,
        par_indent_level,
        par_eventual_encoding,
        par_formatter,
        var_c,
        var_text,
        (int)var_pretty_print,
        var_s
    );


    // Release cached frame.
    if ( frame_f80e94e61a5498e34db5e8bf04849743 == cache_frame_f80e94e61a5498e34db5e8bf04849743 )
    {
        Py_DECREF( frame_f80e94e61a5498e34db5e8bf04849743 );
    }
    cache_frame_f80e94e61a5498e34db5e8bf04849743 = NULL;

    assertFrameObject( frame_f80e94e61a5498e34db5e8bf04849743 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_95_decode_contents );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_c );
    var_c = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    Py_XDECREF( var_text );
    var_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_s );
    Py_DECREF( var_s );
    var_s = NULL;

    CHECK_OBJECT( (PyObject *)par_eventual_encoding );
    Py_DECREF( par_eventual_encoding );
    par_eventual_encoding = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_c );
    var_c = NULL;

    Py_XDECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    Py_XDECREF( var_text );
    var_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_s );
    var_s = NULL;

    CHECK_OBJECT( (PyObject *)par_eventual_encoding );
    Py_DECREF( par_eventual_encoding );
    par_eventual_encoding = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_95_decode_contents );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_96_encode_contents( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_indent_level = python_pars[ 1 ];
    PyObject *par_encoding = python_pars[ 2 ];
    PyObject *par_formatter = python_pars[ 3 ];
    PyObject *var_contents = NULL;
    struct Nuitka_FrameObject *frame_ef22ab60bd4c83e9125fddfcee10b1a1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ef22ab60bd4c83e9125fddfcee10b1a1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ef22ab60bd4c83e9125fddfcee10b1a1, codeobj_ef22ab60bd4c83e9125fddfcee10b1a1, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_ef22ab60bd4c83e9125fddfcee10b1a1 = cache_frame_ef22ab60bd4c83e9125fddfcee10b1a1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ef22ab60bd4c83e9125fddfcee10b1a1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ef22ab60bd4c83e9125fddfcee10b1a1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_indent_level );
        tmp_args_element_name_1 = par_indent_level;
        CHECK_OBJECT( par_encoding );
        tmp_args_element_name_2 = par_encoding;
        CHECK_OBJECT( par_formatter );
        tmp_args_element_name_3 = par_formatter;
        frame_ef22ab60bd4c83e9125fddfcee10b1a1->m_frame.f_lineno = 1282;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_decode_contents, call_args );
        }

        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1282;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_contents == NULL );
        var_contents = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT( var_contents );
        tmp_called_instance_2 = var_contents;
        CHECK_OBJECT( par_encoding );
        tmp_args_element_name_4 = par_encoding;
        frame_ef22ab60bd4c83e9125fddfcee10b1a1->m_frame.f_lineno = 1283;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_encode, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1283;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef22ab60bd4c83e9125fddfcee10b1a1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef22ab60bd4c83e9125fddfcee10b1a1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ef22ab60bd4c83e9125fddfcee10b1a1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ef22ab60bd4c83e9125fddfcee10b1a1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ef22ab60bd4c83e9125fddfcee10b1a1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ef22ab60bd4c83e9125fddfcee10b1a1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ef22ab60bd4c83e9125fddfcee10b1a1,
        type_description_1,
        par_self,
        par_indent_level,
        par_encoding,
        par_formatter,
        var_contents
    );


    // Release cached frame.
    if ( frame_ef22ab60bd4c83e9125fddfcee10b1a1 == cache_frame_ef22ab60bd4c83e9125fddfcee10b1a1 )
    {
        Py_DECREF( frame_ef22ab60bd4c83e9125fddfcee10b1a1 );
    }
    cache_frame_ef22ab60bd4c83e9125fddfcee10b1a1 = NULL;

    assertFrameObject( frame_ef22ab60bd4c83e9125fddfcee10b1a1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_96_encode_contents );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    CHECK_OBJECT( (PyObject *)var_contents );
    Py_DECREF( var_contents );
    var_contents = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_formatter );
    Py_DECREF( par_formatter );
    par_formatter = NULL;

    CHECK_OBJECT( (PyObject *)par_indent_level );
    Py_DECREF( par_indent_level );
    par_indent_level = NULL;

    Py_XDECREF( var_contents );
    var_contents = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_96_encode_contents );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_97_renderContents( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_encoding = python_pars[ 1 ];
    PyObject *par_prettyPrint = python_pars[ 2 ];
    PyObject *par_indentLevel = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_6aa072799d86fee962e5df98aa577a0b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_6aa072799d86fee962e5df98aa577a0b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6aa072799d86fee962e5df98aa577a0b, codeobj_6aa072799d86fee962e5df98aa577a0b, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6aa072799d86fee962e5df98aa577a0b = cache_frame_6aa072799d86fee962e5df98aa577a0b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6aa072799d86fee962e5df98aa577a0b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6aa072799d86fee962e5df98aa577a0b ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_prettyPrint );
        tmp_operand_name_1 = par_prettyPrint;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1288;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            tmp_assign_source_1 = Py_None;
            {
                PyObject *old = par_indentLevel;
                assert( old != NULL );
                par_indentLevel = tmp_assign_source_1;
                Py_INCREF( par_indentLevel );
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_encode_contents );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1290;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_indentLevel );
        tmp_dict_value_1 = par_indentLevel;
        tmp_dict_key_1 = const_str_plain_indent_level;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        CHECK_OBJECT( par_encoding );
        tmp_dict_value_2 = par_encoding;
        tmp_dict_key_2 = const_str_plain_encoding;
        tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        frame_6aa072799d86fee962e5df98aa577a0b->m_frame.f_lineno = 1290;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1290;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6aa072799d86fee962e5df98aa577a0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6aa072799d86fee962e5df98aa577a0b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6aa072799d86fee962e5df98aa577a0b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6aa072799d86fee962e5df98aa577a0b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6aa072799d86fee962e5df98aa577a0b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6aa072799d86fee962e5df98aa577a0b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6aa072799d86fee962e5df98aa577a0b,
        type_description_1,
        par_self,
        par_encoding,
        par_prettyPrint,
        par_indentLevel
    );


    // Release cached frame.
    if ( frame_6aa072799d86fee962e5df98aa577a0b == cache_frame_6aa072799d86fee962e5df98aa577a0b )
    {
        Py_DECREF( frame_6aa072799d86fee962e5df98aa577a0b );
    }
    cache_frame_6aa072799d86fee962e5df98aa577a0b = NULL;

    assertFrameObject( frame_6aa072799d86fee962e5df98aa577a0b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_97_renderContents );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_indentLevel );
    Py_DECREF( par_indentLevel );
    par_indentLevel = NULL;

    CHECK_OBJECT( (PyObject *)par_prettyPrint );
    Py_DECREF( par_prettyPrint );
    par_prettyPrint = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_indentLevel );
    par_indentLevel = NULL;

    CHECK_OBJECT( (PyObject *)par_prettyPrint );
    Py_DECREF( par_prettyPrint );
    par_prettyPrint = NULL;

    CHECK_OBJECT( (PyObject *)par_encoding );
    Py_DECREF( par_encoding );
    par_encoding = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_97_renderContents );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_98_find( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_recursive = python_pars[ 3 ];
    PyObject *par_text = python_pars[ 4 ];
    PyObject *par_kwargs = python_pars[ 5 ];
    PyObject *var_l = NULL;
    PyObject *var_r = NULL;
    struct Nuitka_FrameObject *frame_6df50eb59cc2c378df6c21e1c696f6a0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6df50eb59cc2c378df6c21e1c696f6a0 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert( var_r == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_r = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6df50eb59cc2c378df6c21e1c696f6a0, codeobj_6df50eb59cc2c378df6c21e1c696f6a0, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6df50eb59cc2c378df6c21e1c696f6a0 = cache_frame_6df50eb59cc2c378df6c21e1c696f6a0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6df50eb59cc2c378df6c21e1c696f6a0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6df50eb59cc2c378df6c21e1c696f6a0 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1300;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 5 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_recursive );
        tmp_tuple_element_1 = par_recursive;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_int_pos_1;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_assign_source_2 = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1300;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_l == NULL );
        var_l = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_l );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_l );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1301;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( var_l );
            tmp_subscribed_name_1 = var_l;
            tmp_subscript_name_1 = const_int_0;
            tmp_assign_source_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_assign_source_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1302;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_r;
                assert( old != NULL );
                var_r = tmp_assign_source_3;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6df50eb59cc2c378df6c21e1c696f6a0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6df50eb59cc2c378df6c21e1c696f6a0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6df50eb59cc2c378df6c21e1c696f6a0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6df50eb59cc2c378df6c21e1c696f6a0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6df50eb59cc2c378df6c21e1c696f6a0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6df50eb59cc2c378df6c21e1c696f6a0,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_recursive,
        par_text,
        par_kwargs,
        var_l,
        var_r
    );


    // Release cached frame.
    if ( frame_6df50eb59cc2c378df6c21e1c696f6a0 == cache_frame_6df50eb59cc2c378df6c21e1c696f6a0 )
    {
        Py_DECREF( frame_6df50eb59cc2c378df6c21e1c696f6a0 );
    }
    cache_frame_6df50eb59cc2c378df6c21e1c696f6a0 = NULL;

    assertFrameObject( frame_6df50eb59cc2c378df6c21e1c696f6a0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_r );
    tmp_return_value = var_r;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_98_find );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_recursive );
    Py_DECREF( par_recursive );
    par_recursive = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    CHECK_OBJECT( (PyObject *)var_r );
    Py_DECREF( var_r );
    var_r = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_recursive );
    Py_DECREF( par_recursive );
    par_recursive = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    CHECK_OBJECT( (PyObject *)var_r );
    Py_DECREF( var_r );
    var_r = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_98_find );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_99_find_all( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_recursive = python_pars[ 3 ];
    PyObject *par_text = python_pars[ 4 ];
    PyObject *par_limit = python_pars[ 5 ];
    PyObject *par_kwargs = python_pars[ 6 ];
    PyObject *var_generator = NULL;
    struct Nuitka_FrameObject *frame_984ee2fe2ba0922e4dd2853b23c0064e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_984ee2fe2ba0922e4dd2853b23c0064e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_984ee2fe2ba0922e4dd2853b23c0064e, codeobj_984ee2fe2ba0922e4dd2853b23c0064e, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_984ee2fe2ba0922e4dd2853b23c0064e = cache_frame_984ee2fe2ba0922e4dd2853b23c0064e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_984ee2fe2ba0922e4dd2853b23c0064e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_984ee2fe2ba0922e4dd2853b23c0064e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_descendants );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1318;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_generator == NULL );
        var_generator = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        CHECK_OBJECT( par_recursive );
        tmp_operand_name_1 = par_recursive;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1319;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_children );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1320;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_generator;
                assert( old != NULL );
                var_generator = tmp_assign_source_2;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__find_all );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1321;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_name );
        tmp_tuple_element_1 = par_name;
        tmp_dircall_arg2_1 = PyTuple_New( 5 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_attrs );
        tmp_tuple_element_1 = par_attrs;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_text );
        tmp_tuple_element_1 = par_text;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_limit );
        tmp_tuple_element_1 = par_limit;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( var_generator );
        tmp_tuple_element_1 = var_generator;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 4, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1321;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_984ee2fe2ba0922e4dd2853b23c0064e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_984ee2fe2ba0922e4dd2853b23c0064e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_984ee2fe2ba0922e4dd2853b23c0064e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_984ee2fe2ba0922e4dd2853b23c0064e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_984ee2fe2ba0922e4dd2853b23c0064e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_984ee2fe2ba0922e4dd2853b23c0064e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_984ee2fe2ba0922e4dd2853b23c0064e,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_recursive,
        par_text,
        par_limit,
        par_kwargs,
        var_generator
    );


    // Release cached frame.
    if ( frame_984ee2fe2ba0922e4dd2853b23c0064e == cache_frame_984ee2fe2ba0922e4dd2853b23c0064e )
    {
        Py_DECREF( frame_984ee2fe2ba0922e4dd2853b23c0064e );
    }
    cache_frame_984ee2fe2ba0922e4dd2853b23c0064e = NULL;

    assertFrameObject( frame_984ee2fe2ba0922e4dd2853b23c0064e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_99_find_all );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_recursive );
    Py_DECREF( par_recursive );
    par_recursive = NULL;

    CHECK_OBJECT( (PyObject *)var_generator );
    Py_DECREF( var_generator );
    var_generator = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_recursive );
    Py_DECREF( par_recursive );
    par_recursive = NULL;

    Py_XDECREF( var_generator );
    var_generator = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_attrs );
    Py_DECREF( par_attrs );
    par_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_99_find_all );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_100_children( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6ffb6f921d156ce8415ba690c7511991;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6ffb6f921d156ce8415ba690c7511991 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6ffb6f921d156ce8415ba690c7511991, codeobj_6ffb6f921d156ce8415ba690c7511991, module_bs4$element, sizeof(void *) );
    frame_6ffb6f921d156ce8415ba690c7511991 = cache_frame_6ffb6f921d156ce8415ba690c7511991;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6ffb6f921d156ce8415ba690c7511991 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6ffb6f921d156ce8415ba690c7511991 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1329;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1329;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ffb6f921d156ce8415ba690c7511991 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ffb6f921d156ce8415ba690c7511991 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ffb6f921d156ce8415ba690c7511991 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6ffb6f921d156ce8415ba690c7511991, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6ffb6f921d156ce8415ba690c7511991->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6ffb6f921d156ce8415ba690c7511991, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6ffb6f921d156ce8415ba690c7511991,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_6ffb6f921d156ce8415ba690c7511991 == cache_frame_6ffb6f921d156ce8415ba690c7511991 )
    {
        Py_DECREF( frame_6ffb6f921d156ce8415ba690c7511991 );
    }
    cache_frame_6ffb6f921d156ce8415ba690c7511991 = NULL;

    assertFrameObject( frame_6ffb6f921d156ce8415ba690c7511991 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_100_children );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_100_children );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_101_descendants( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = bs4$element$$$function_101_descendants$$$genobj_1_descendants_maker();

    ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] = par_self;
    Py_INCREF( ((struct Nuitka_GeneratorObject *)tmp_return_value)->m_closure[0] );


    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_101_descendants );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_101_descendants );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



struct bs4$element$$$function_101_descendants$$$genobj_1_descendants_locals {
    PyObject *var_current;
    PyObject *var_stopNode;
    char const *type_description_1;
    PyObject *exception_type;
    PyObject *exception_value;
    PyTracebackObject *exception_tb;
    int exception_lineno;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    int exception_keeper_lineno_1;
};

static PyObject *bs4$element$$$function_101_descendants$$$genobj_1_descendants_context( struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Heap access if used.
    struct bs4$element$$$function_101_descendants$$$genobj_1_descendants_locals *generator_heap = (struct bs4$element$$$function_101_descendants$$$genobj_1_descendants_locals *)generator->m_heap_storage;

    // Dispatch to yield based on return label index:
    switch(generator->m_yield_return_index) {
    case 1: goto yield_return_1;
    }

    // Local variable initialization
    static struct Nuitka_FrameObject *cache_m_frame = NULL;
    generator_heap->var_current = NULL;
    generator_heap->var_stopNode = NULL;
    generator_heap->type_description_1 = NULL;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    // Actual generator function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_m_frame, codeobj_e2f97cb35361b509cf888ea2dba587ae, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    generator->m_frame = cache_m_frame;

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( generator->m_frame );
    assert( Py_REFCNT( generator->m_frame ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    generator->m_frame->m_frame.f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->m_frame.f_back );

    generator->m_frame->m_frame.f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->m_frame.f_back );

    PyThreadState_GET()->frame = &generator->m_frame->m_frame;
    Py_INCREF( generator->m_frame );

    Nuitka_Frame_MarkAsExecuting( generator->m_frame );

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.
    {
        PyThreadState *thread_state = PyThreadState_GET();

#if PYTHON_VERSION < 370
        generator->m_frame->m_frame.f_exc_type = EXC_TYPE( thread_state );
    if ( generator->m_frame->m_frame.f_exc_type == Py_None ) generator->m_frame->m_frame.f_exc_type = NULL;
        Py_XINCREF( generator->m_frame->m_frame.f_exc_type );
    generator->m_frame->m_frame.f_exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_value );
    generator->m_frame->m_frame.f_exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_frame->m_frame.f_exc_traceback );
#else
        generator->m_exc_state.exc_type = EXC_TYPE( thread_state );
        if ( generator->m_exc_state.exc_type == Py_None ) generator->m_exc_state.exc_type = NULL;
        Py_XINCREF( generator->m_exc_state.exc_type );
        generator->m_exc_state.exc_value = EXC_VALUE( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_value );
        generator->m_exc_state.exc_traceback = EXC_TRACEBACK( thread_state );
        Py_XINCREF( generator->m_exc_state.exc_traceback );
#endif
    }

#endif

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_source_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1333;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = PyCell_GET( generator->m_closure[0] );
        tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_contents );
        if ( tmp_len_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1333;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        Py_DECREF( tmp_len_arg_1 );
        if ( tmp_operand_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1333;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        generator_heap->tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        Py_DECREF( tmp_operand_name_1 );
        if ( generator_heap->tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1333;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( generator_heap->tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_called_instance_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1335;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = PyCell_GET( generator->m_closure[0] );
        generator->m_frame->m_frame.f_lineno = 1335;
        tmp_source_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__last_descendant );
        if ( tmp_source_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1335;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_next_element );
        Py_DECREF( tmp_source_name_2 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1335;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_stopNode == NULL );
        generator_heap->var_stopNode = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_subscript_name_1;
        if ( PyCell_GET( generator->m_closure[0] ) == NULL )
        {

            generator_heap->exception_type = PyExc_NameError;
            Py_INCREF( generator_heap->exception_type );
            generator_heap->exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
            generator_heap->exception_tb = NULL;

            generator_heap->exception_lineno = 1336;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = PyCell_GET( generator->m_closure[0] );
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_contents );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1336;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_1 = const_int_0;
        tmp_assign_source_2 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1336;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        assert( generator_heap->var_current == NULL );
        generator_heap->var_current = tmp_assign_source_2;
    }
    loop_start_1:;
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( generator_heap->var_current );
        tmp_compexpr_left_1 = generator_heap->var_current;
        CHECK_OBJECT( generator_heap->var_stopNode );
        tmp_compexpr_right_1 = generator_heap->var_stopNode;
        tmp_condition_result_2 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        goto loop_end_1;
        branch_no_2:;
    }
    {
        PyObject *tmp_expression_name_1;
        NUITKA_MAY_BE_UNUSED PyObject *tmp_yield_result_1;
        CHECK_OBJECT( generator_heap->var_current );
        tmp_expression_name_1 = generator_heap->var_current;
        Py_INCREF( tmp_expression_name_1 );
        generator->m_yield_return_index = 1;
        return tmp_expression_name_1;
        yield_return_1:
        if ( yield_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1338;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        tmp_yield_result_1 = yield_return_value;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_source_name_4;
        CHECK_OBJECT( generator_heap->var_current );
        tmp_source_name_4 = generator_heap->var_current;
        tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_next_element );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


            generator_heap->exception_lineno = 1339;
            generator_heap->type_description_1 = "coo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = generator_heap->var_current;
            assert( old != NULL );
            generator_heap->var_current = tmp_assign_source_3;
            Py_DECREF( old );
        }

    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &generator_heap->exception_type, &generator_heap->exception_value, &generator_heap->exception_tb );


        generator_heap->exception_lineno = 1337;
        generator_heap->type_description_1 = "coo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

    Nuitka_Frame_MarkAsNotExecuting( generator->m_frame );

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    // Allow re-use of the frame again.
    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_return_exit_1:;

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    goto function_return_exit;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( generator_heap->exception_type ) )
    {
        if ( generator_heap->exception_tb == NULL )
        {
            generator_heap->exception_tb = MAKE_TRACEBACK( generator->m_frame, generator_heap->exception_lineno );
        }
        else if ( generator_heap->exception_tb->tb_frame != &generator->m_frame->m_frame )
        {
            generator_heap->exception_tb = ADD_TRACEBACK( generator_heap->exception_tb, generator->m_frame, generator_heap->exception_lineno );
        }

        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)generator->m_frame,
            generator_heap->type_description_1,
            generator->m_closure[0],
            generator_heap->var_current,
            generator_heap->var_stopNode
        );


        // Release cached frame.
        if ( generator->m_frame == cache_m_frame )
        {
            Py_DECREF( generator->m_frame );
        }
        cache_m_frame = NULL;

        assertFrameObject( generator->m_frame );
    }

#if PYTHON_VERSION >= 370
    Py_CLEAR( generator->m_exc_state.exc_type );
    Py_CLEAR( generator->m_exc_state.exc_value );
    Py_CLEAR( generator->m_exc_state.exc_traceback );
#elif PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->m_frame.f_exc_type );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_value );
    Py_CLEAR( generator->m_frame->m_frame.f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    generator_heap->exception_keeper_type_1 = generator_heap->exception_type;
    generator_heap->exception_keeper_value_1 = generator_heap->exception_value;
    generator_heap->exception_keeper_tb_1 = generator_heap->exception_tb;
    generator_heap->exception_keeper_lineno_1 = generator_heap->exception_lineno;
    generator_heap->exception_type = NULL;
    generator_heap->exception_value = NULL;
    generator_heap->exception_tb = NULL;
    generator_heap->exception_lineno = 0;

    Py_XDECREF( generator_heap->var_current );
    generator_heap->var_current = NULL;

    Py_XDECREF( generator_heap->var_stopNode );
    generator_heap->var_stopNode = NULL;

    // Re-raise.
    generator_heap->exception_type = generator_heap->exception_keeper_type_1;
    generator_heap->exception_value = generator_heap->exception_keeper_value_1;
    generator_heap->exception_tb = generator_heap->exception_keeper_tb_1;
    generator_heap->exception_lineno = generator_heap->exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)generator_heap->var_current );
    Py_DECREF( generator_heap->var_current );
    generator_heap->var_current = NULL;

    CHECK_OBJECT( (PyObject *)generator_heap->var_stopNode );
    Py_DECREF( generator_heap->var_stopNode );
    generator_heap->var_stopNode = NULL;



    return NULL;

    function_exception_exit:
    assert( generator_heap->exception_type );
    RESTORE_ERROR_OCCURRED( generator_heap->exception_type, generator_heap->exception_value, generator_heap->exception_tb );

    return NULL;
    // The above won't return, but we need to make it clear to the compiler
    // as well, or else it will complain and/or generate inferior code.
    assert(false);
    return NULL;

    function_return_exit:
#if PYTHON_VERSION >= 300
    generator->m_returned = None;
#endif

    return NULL;

}

static PyObject *bs4$element$$$function_101_descendants$$$genobj_1_descendants_maker( void )
{
    return Nuitka_Generator_New(
        bs4$element$$$function_101_descendants$$$genobj_1_descendants_context,
        module_bs4$element,
        const_str_plain_descendants,
#if PYTHON_VERSION >= 350
        NULL,
#endif
        codeobj_e2f97cb35361b509cf888ea2dba587ae,
        1,
        sizeof(struct bs4$element$$$function_101_descendants$$$genobj_1_descendants_locals)
    );
}


static PyObject *impl_bs4$element$$$function_102_select_one( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_selector = python_pars[ 1 ];
    PyObject *par_namespaces = python_pars[ 2 ];
    PyObject *par_kwargs = python_pars[ 3 ];
    PyObject *var_value = NULL;
    struct Nuitka_FrameObject *frame_3d28736148c648faaf499826a4bcee28;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3d28736148c648faaf499826a4bcee28 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3d28736148c648faaf499826a4bcee28, codeobj_3d28736148c648faaf499826a4bcee28, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3d28736148c648faaf499826a4bcee28 = cache_frame_3d28736148c648faaf499826a4bcee28;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3d28736148c648faaf499826a4bcee28 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3d28736148c648faaf499826a4bcee28 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_select );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1344;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_selector );
        tmp_tuple_element_1 = par_selector;
        tmp_dircall_arg2_1 = PyTuple_New( 3 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_namespaces );
        tmp_tuple_element_1 = par_namespaces;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        tmp_tuple_element_1 = const_int_pos_1;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_assign_source_1 = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1344;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert( var_value == NULL );
        var_value = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( var_value );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_value );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1345;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            CHECK_OBJECT( var_value );
            tmp_subscribed_name_1 = var_value;
            tmp_subscript_name_1 = const_int_0;
            tmp_return_value = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1346;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d28736148c648faaf499826a4bcee28 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d28736148c648faaf499826a4bcee28 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3d28736148c648faaf499826a4bcee28 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3d28736148c648faaf499826a4bcee28, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3d28736148c648faaf499826a4bcee28->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3d28736148c648faaf499826a4bcee28, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3d28736148c648faaf499826a4bcee28,
        type_description_1,
        par_self,
        par_selector,
        par_namespaces,
        par_kwargs,
        var_value
    );


    // Release cached frame.
    if ( frame_3d28736148c648faaf499826a4bcee28 == cache_frame_3d28736148c648faaf499826a4bcee28 )
    {
        Py_DECREF( frame_3d28736148c648faaf499826a4bcee28 );
    }
    cache_frame_3d28736148c648faaf499826a4bcee28 = NULL;

    assertFrameObject( frame_3d28736148c648faaf499826a4bcee28 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_102_select_one );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)var_value );
    Py_DECREF( var_value );
    var_value = NULL;

    CHECK_OBJECT( (PyObject *)par_namespaces );
    Py_DECREF( par_namespaces );
    par_namespaces = NULL;

    CHECK_OBJECT( (PyObject *)par_selector );
    Py_DECREF( par_selector );
    par_selector = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    CHECK_OBJECT( (PyObject *)par_namespaces );
    Py_DECREF( par_namespaces );
    par_namespaces = NULL;

    CHECK_OBJECT( (PyObject *)par_selector );
    Py_DECREF( par_selector );
    par_selector = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_102_select_one );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_103_select( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_selector = python_pars[ 1 ];
    PyObject *par_namespaces = python_pars[ 2 ];
    PyObject *par_limit = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    struct Nuitka_FrameObject *frame_72b4cacabb8769a6ac882f9fe6ea574e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_72b4cacabb8769a6ac882f9fe6ea574e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_72b4cacabb8769a6ac882f9fe6ea574e, codeobj_72b4cacabb8769a6ac882f9fe6ea574e, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_72b4cacabb8769a6ac882f9fe6ea574e = cache_frame_72b4cacabb8769a6ac882f9fe6ea574e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_72b4cacabb8769a6ac882f9fe6ea574e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_72b4cacabb8769a6ac882f9fe6ea574e ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_namespaces );
        tmp_compexpr_left_1 = par_namespaces;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_source_name_1;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__namespaces );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1367;
                type_description_1 = "ooooo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_namespaces;
                assert( old != NULL );
                par_namespaces = tmp_assign_source_1;
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT( par_limit );
        tmp_compexpr_left_2 = par_limit;
        tmp_compexpr_right_2 = Py_None;
        tmp_condition_result_2 = ( tmp_compexpr_left_2 == tmp_compexpr_right_2 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_2;
            tmp_assign_source_2 = const_int_0;
            {
                PyObject *old = par_limit;
                assert( old != NULL );
                par_limit = tmp_assign_source_2;
                Py_INCREF( par_limit );
                Py_DECREF( old );
            }

        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_soupsieve );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_soupsieve );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "soupsieve" );
            exception_tb = NULL;

            exception_lineno = 1371;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_3 = tmp_mvar_value_1;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_3 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_make_exception_arg_1;
            tmp_make_exception_arg_1 = const_str_digest_16a272a1ac84aa8c964578a8dee1c6dd;
            frame_72b4cacabb8769a6ac882f9fe6ea574e->m_frame.f_lineno = 1372;
            {
                PyObject *call_args[] = { tmp_make_exception_arg_1 };
                tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
            }

            assert( !(tmp_raise_type_1 == NULL) );
            exception_type = tmp_raise_type_1;
            exception_lineno = 1372;
            RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_soupsieve );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_soupsieve );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "soupsieve" );
            exception_tb = NULL;

            exception_lineno = 1376;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_select );
        if ( tmp_dircall_arg1_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1376;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_selector );
        tmp_tuple_element_1 = par_selector;
        tmp_dircall_arg2_1 = PyTuple_New( 4 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
        CHECK_OBJECT( par_self );
        tmp_tuple_element_1 = par_self;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_1 );
        CHECK_OBJECT( par_namespaces );
        tmp_tuple_element_1 = par_namespaces;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_1 );
        CHECK_OBJECT( par_limit );
        tmp_tuple_element_1 = par_limit;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_dircall_arg2_1, 3, tmp_tuple_element_1 );
        CHECK_OBJECT( par_kwargs );
        tmp_dircall_arg3_1 = par_kwargs;
        Py_INCREF( tmp_dircall_arg3_1 );

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_4_complex_call_helper_pos_star_dict( dir_call_args );
        }
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1376;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_72b4cacabb8769a6ac882f9fe6ea574e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_72b4cacabb8769a6ac882f9fe6ea574e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_72b4cacabb8769a6ac882f9fe6ea574e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_72b4cacabb8769a6ac882f9fe6ea574e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_72b4cacabb8769a6ac882f9fe6ea574e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_72b4cacabb8769a6ac882f9fe6ea574e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_72b4cacabb8769a6ac882f9fe6ea574e,
        type_description_1,
        par_self,
        par_selector,
        par_namespaces,
        par_limit,
        par_kwargs
    );


    // Release cached frame.
    if ( frame_72b4cacabb8769a6ac882f9fe6ea574e == cache_frame_72b4cacabb8769a6ac882f9fe6ea574e )
    {
        Py_DECREF( frame_72b4cacabb8769a6ac882f9fe6ea574e );
    }
    cache_frame_72b4cacabb8769a6ac882f9fe6ea574e = NULL;

    assertFrameObject( frame_72b4cacabb8769a6ac882f9fe6ea574e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_103_select );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)par_limit );
    Py_DECREF( par_limit );
    par_limit = NULL;

    CHECK_OBJECT( (PyObject *)par_namespaces );
    Py_DECREF( par_namespaces );
    par_namespaces = NULL;

    CHECK_OBJECT( (PyObject *)par_selector );
    Py_DECREF( par_selector );
    par_selector = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    Py_XDECREF( par_limit );
    par_limit = NULL;

    Py_XDECREF( par_namespaces );
    par_namespaces = NULL;

    CHECK_OBJECT( (PyObject *)par_selector );
    Py_DECREF( par_selector );
    par_selector = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_103_select );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_104_childGenerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_a0696e67cb1c97143c8c36692ffcc165;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a0696e67cb1c97143c8c36692ffcc165 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a0696e67cb1c97143c8c36692ffcc165, codeobj_a0696e67cb1c97143c8c36692ffcc165, module_bs4$element, sizeof(void *) );
    frame_a0696e67cb1c97143c8c36692ffcc165 = cache_frame_a0696e67cb1c97143c8c36692ffcc165;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a0696e67cb1c97143c8c36692ffcc165 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a0696e67cb1c97143c8c36692ffcc165 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_children );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1380;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0696e67cb1c97143c8c36692ffcc165 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0696e67cb1c97143c8c36692ffcc165 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0696e67cb1c97143c8c36692ffcc165 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a0696e67cb1c97143c8c36692ffcc165, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a0696e67cb1c97143c8c36692ffcc165->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a0696e67cb1c97143c8c36692ffcc165, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a0696e67cb1c97143c8c36692ffcc165,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_a0696e67cb1c97143c8c36692ffcc165 == cache_frame_a0696e67cb1c97143c8c36692ffcc165 )
    {
        Py_DECREF( frame_a0696e67cb1c97143c8c36692ffcc165 );
    }
    cache_frame_a0696e67cb1c97143c8c36692ffcc165 = NULL;

    assertFrameObject( frame_a0696e67cb1c97143c8c36692ffcc165 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_104_childGenerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_104_childGenerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_105_recursiveChildGenerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d46550f1626ed88f6f7e24f94e3481b3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d46550f1626ed88f6f7e24f94e3481b3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d46550f1626ed88f6f7e24f94e3481b3, codeobj_d46550f1626ed88f6f7e24f94e3481b3, module_bs4$element, sizeof(void *) );
    frame_d46550f1626ed88f6f7e24f94e3481b3 = cache_frame_d46550f1626ed88f6f7e24f94e3481b3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d46550f1626ed88f6f7e24f94e3481b3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d46550f1626ed88f6f7e24f94e3481b3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_descendants );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1383;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d46550f1626ed88f6f7e24f94e3481b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d46550f1626ed88f6f7e24f94e3481b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d46550f1626ed88f6f7e24f94e3481b3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d46550f1626ed88f6f7e24f94e3481b3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d46550f1626ed88f6f7e24f94e3481b3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d46550f1626ed88f6f7e24f94e3481b3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d46550f1626ed88f6f7e24f94e3481b3,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_d46550f1626ed88f6f7e24f94e3481b3 == cache_frame_d46550f1626ed88f6f7e24f94e3481b3 )
    {
        Py_DECREF( frame_d46550f1626ed88f6f7e24f94e3481b3 );
    }
    cache_frame_d46550f1626ed88f6f7e24f94e3481b3 = NULL;

    assertFrameObject( frame_d46550f1626ed88f6f7e24f94e3481b3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_105_recursiveChildGenerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_105_recursiveChildGenerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_106_has_key( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_5d5df9b0a86031ac8bf61af23f959ddb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5d5df9b0a86031ac8bf61af23f959ddb = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d5df9b0a86031ac8bf61af23f959ddb, codeobj_5d5df9b0a86031ac8bf61af23f959ddb, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_5d5df9b0a86031ac8bf61af23f959ddb = cache_frame_5d5df9b0a86031ac8bf61af23f959ddb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d5df9b0a86031ac8bf61af23f959ddb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d5df9b0a86031ac8bf61af23f959ddb ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_warnings );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
            exception_tb = NULL;

            exception_lineno = 1389;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_warn );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1389;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_2723f6e7179adb3f95d6ef44f1805134;
        CHECK_OBJECT( par_key );
        tmp_right_name_1 = par_key;
        tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1389;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_5d5df9b0a86031ac8bf61af23f959ddb->m_frame.f_lineno = 1389;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1389;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_key );
        tmp_args_element_name_2 = par_key;
        frame_5d5df9b0a86031ac8bf61af23f959ddb->m_frame.f_lineno = 1391;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_has_attr, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1391;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d5df9b0a86031ac8bf61af23f959ddb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d5df9b0a86031ac8bf61af23f959ddb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d5df9b0a86031ac8bf61af23f959ddb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d5df9b0a86031ac8bf61af23f959ddb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d5df9b0a86031ac8bf61af23f959ddb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d5df9b0a86031ac8bf61af23f959ddb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5d5df9b0a86031ac8bf61af23f959ddb,
        type_description_1,
        par_self,
        par_key
    );


    // Release cached frame.
    if ( frame_5d5df9b0a86031ac8bf61af23f959ddb == cache_frame_5d5df9b0a86031ac8bf61af23f959ddb )
    {
        Py_DECREF( frame_5d5df9b0a86031ac8bf61af23f959ddb );
    }
    cache_frame_5d5df9b0a86031ac8bf61af23f959ddb = NULL;

    assertFrameObject( frame_5d5df9b0a86031ac8bf61af23f959ddb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_106_has_key );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_106_has_key );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_107___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_attrs = python_pars[ 2 ];
    PyObject *par_text = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    PyObject *var_normalized_attrs = NULL;
    PyObject *var_value = NULL;
    PyObject *var_key = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_0659d3a8834673b2723e32a986aab130;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    int tmp_res;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_0659d3a8834673b2723e32a986aab130 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0659d3a8834673b2723e32a986aab130, codeobj_0659d3a8834673b2723e32a986aab130, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_0659d3a8834673b2723e32a986aab130 = cache_frame_0659d3a8834673b2723e32a986aab130;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0659d3a8834673b2723e32a986aab130 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0659d3a8834673b2723e32a986aab130 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_self );
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT( par_name );
        tmp_args_element_name_1 = par_name;
        frame_0659d3a8834673b2723e32a986aab130->m_frame.f_lineno = 1399;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assattr_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__normalize_search_value, call_args );
        }

        if ( tmp_assattr_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1399;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_name, tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1399;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT( par_attrs );
        tmp_isinstance_inst_1 = par_attrs;
        tmp_isinstance_cls_1 = (PyObject *)&PyDict_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1400;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1400;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_ass_subvalue_1;
            PyObject *tmp_ass_subscribed_1;
            PyObject *tmp_ass_subscript_1;
            CHECK_OBJECT( par_attrs );
            tmp_ass_subvalue_1 = par_attrs;
            CHECK_OBJECT( par_kwargs );
            tmp_ass_subscribed_1 = par_kwargs;
            tmp_ass_subscript_1 = const_str_plain_class;
            tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1403;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_assign_source_1;
            tmp_assign_source_1 = Py_None;
            {
                PyObject *old = par_attrs;
                assert( old != NULL );
                par_attrs = tmp_assign_source_1;
                Py_INCREF( par_attrs );
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = const_str_plain_class_;
        CHECK_OBJECT( par_kwargs );
        tmp_compexpr_right_1 = par_kwargs;
        tmp_res = PySequence_Contains( tmp_compexpr_right_1, tmp_compexpr_left_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1406;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_ass_subvalue_2;
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            PyObject *tmp_ass_subscribed_2;
            PyObject *tmp_ass_subscript_2;
            CHECK_OBJECT( par_kwargs );
            tmp_subscribed_name_1 = par_kwargs;
            tmp_subscript_name_1 = const_str_plain_class_;
            tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
            if ( tmp_ass_subvalue_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1409;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_kwargs );
            tmp_ass_subscribed_2 = par_kwargs;
            tmp_ass_subscript_2 = const_str_plain_class;
            tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_2, tmp_ass_subscript_2, tmp_ass_subvalue_2 );
            Py_DECREF( tmp_ass_subvalue_2 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1409;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
        }
        {
            PyObject *tmp_delsubscr_target_1;
            PyObject *tmp_delsubscr_subscript_1;
            CHECK_OBJECT( par_kwargs );
            tmp_delsubscr_target_1 = par_kwargs;
            tmp_delsubscr_subscript_1 = const_str_plain_class_;
            tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
            if ( tmp_result == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1410;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_kwargs );
        tmp_truth_name_1 = CHECK_IF_TRUE( par_kwargs );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1412;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_truth_name_2;
            CHECK_OBJECT( par_attrs );
            tmp_truth_name_2 = CHECK_IF_TRUE( par_attrs );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1413;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_4 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_assign_source_2;
                PyObject *tmp_called_instance_2;
                CHECK_OBJECT( par_attrs );
                tmp_called_instance_2 = par_attrs;
                frame_0659d3a8834673b2723e32a986aab130->m_frame.f_lineno = 1414;
                tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_copy );
                if ( tmp_assign_source_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1414;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                {
                    PyObject *old = par_attrs;
                    assert( old != NULL );
                    par_attrs = tmp_assign_source_2;
                    Py_DECREF( old );
                }

            }
            {
                PyObject *tmp_called_instance_3;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT( par_attrs );
                tmp_called_instance_3 = par_attrs;
                CHECK_OBJECT( par_kwargs );
                tmp_args_element_name_2 = par_kwargs;
                frame_0659d3a8834673b2723e32a986aab130->m_frame.f_lineno = 1415;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_update, call_args );
                }

                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1415;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            goto branch_end_4;
            branch_no_4:;
            {
                PyObject *tmp_assign_source_3;
                CHECK_OBJECT( par_kwargs );
                tmp_assign_source_3 = par_kwargs;
                {
                    PyObject *old = par_attrs;
                    assert( old != NULL );
                    par_attrs = tmp_assign_source_3;
                    Py_INCREF( par_attrs );
                    Py_DECREF( old );
                }

            }
            branch_end_4:;
        }
        branch_no_3:;
    }
    {
        PyObject *tmp_assign_source_4;
        tmp_assign_source_4 = PyDict_New();
        assert( var_normalized_attrs == NULL );
        var_normalized_attrs = tmp_assign_source_4;
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_called_instance_4;
        if ( par_attrs == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "attrs" );
            exception_tb = NULL;

            exception_lineno = 1419;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_4 = par_attrs;
        frame_0659d3a8834673b2723e32a986aab130->m_frame.f_lineno = 1419;
        tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_items );
        if ( tmp_iter_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1419;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
        Py_DECREF( tmp_iter_arg_1 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1419;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert( tmp_for_loop_1__for_iterator == NULL );
        tmp_for_loop_1__for_iterator = tmp_assign_source_5;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT( tmp_for_loop_1__for_iterator );
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
        if ( tmp_assign_source_6 == NULL )
        {
            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
            {

                goto loop_end_1;
            }
            else
            {

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                type_description_1 = "oooooooo";
                exception_lineno = 1419;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_6;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_iter_arg_2;
        CHECK_OBJECT( tmp_for_loop_1__iter_value );
        tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
        tmp_assign_source_7 = MAKE_ITERATOR( tmp_iter_arg_2 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1419;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_7;
            Py_XDECREF( old );
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_1, 0 );
        if ( tmp_assign_source_8 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 1419;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_8;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_9 = UNPACK_NEXT( tmp_unpack_2, 1 );
        if ( tmp_assign_source_9 == NULL )
        {
            if ( !ERROR_OCCURRED() )
            {
                exception_type = PyExc_StopIteration;
                Py_INCREF( exception_type );
                exception_value = NULL;
                exception_tb = NULL;
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            }


            type_description_1 = "oooooooo";
            exception_lineno = 1419;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_9;
            Py_XDECREF( old );
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

        if (likely( tmp_iterator_attempt == NULL ))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if ( error != NULL )
            {
                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                {
                    CLEAR_ERROR_OCCURRED();
                }
                else
                {
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "oooooooo";
                    exception_lineno = 1419;
                    goto try_except_handler_4;
                }
            }
        }
        else
        {
            Py_DECREF( tmp_iterator_attempt );

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

            type_description_1 = "oooooooo";
            exception_lineno = 1419;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
        tmp_assign_source_10 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_key;
            var_key = tmp_assign_source_10;
            Py_INCREF( var_key );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_11;
        CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
        tmp_assign_source_11 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_value;
            var_value = tmp_assign_source_11;
            Py_INCREF( var_value );
            Py_XDECREF( old );
        }

    }
    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        PyObject *tmp_called_instance_5;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_5 = par_self;
        CHECK_OBJECT( var_value );
        tmp_args_element_name_3 = var_value;
        frame_0659d3a8834673b2723e32a986aab130->m_frame.f_lineno = 1420;
        {
            PyObject *call_args[] = { tmp_args_element_name_3 };
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain__normalize_search_value, call_args );
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1420;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT( var_normalized_attrs );
        tmp_dictset_dict = var_normalized_attrs;
        CHECK_OBJECT( var_key );
        tmp_dictset_key = var_key;
        tmp_res = PyDict_SetItem( tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        if ( tmp_res != 0 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1420;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1419;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT( var_normalized_attrs );
        tmp_assattr_name_2 = var_normalized_attrs;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_attrs, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1422;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_called_instance_6;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT( par_self );
        tmp_called_instance_6 = par_self;
        CHECK_OBJECT( par_text );
        tmp_args_element_name_4 = par_text;
        frame_0659d3a8834673b2723e32a986aab130->m_frame.f_lineno = 1423;
        {
            PyObject *call_args[] = { tmp_args_element_name_4 };
            tmp_assattr_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain__normalize_search_value, call_args );
        }

        if ( tmp_assattr_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1423;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_text, tmp_assattr_name_3 );
        Py_DECREF( tmp_assattr_name_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1423;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0659d3a8834673b2723e32a986aab130 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0659d3a8834673b2723e32a986aab130 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0659d3a8834673b2723e32a986aab130, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0659d3a8834673b2723e32a986aab130->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0659d3a8834673b2723e32a986aab130, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0659d3a8834673b2723e32a986aab130,
        type_description_1,
        par_self,
        par_name,
        par_attrs,
        par_text,
        par_kwargs,
        var_normalized_attrs,
        var_value,
        var_key
    );


    // Release cached frame.
    if ( frame_0659d3a8834673b2723e32a986aab130 == cache_frame_0659d3a8834673b2723e32a986aab130 )
    {
        Py_DECREF( frame_0659d3a8834673b2723e32a986aab130 );
    }
    cache_frame_0659d3a8834673b2723e32a986aab130 = NULL;

    assertFrameObject( frame_0659d3a8834673b2723e32a986aab130 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_107___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)var_normalized_attrs );
    Py_DECREF( var_normalized_attrs );
    var_normalized_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( par_attrs );
    par_attrs = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_normalized_attrs );
    var_normalized_attrs = NULL;

    CHECK_OBJECT( (PyObject *)par_text );
    Py_DECREF( par_text );
    par_text = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( par_attrs );
    par_attrs = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_107___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_108__normalize_search_value( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_value = python_pars[ 1 ];
    PyObject *var_new_value = NULL;
    PyObject *var_v = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_20cb79926d5c997e0fc30883874ed8c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_20cb79926d5c997e0fc30883874ed8c5 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_20cb79926d5c997e0fc30883874ed8c5, codeobj_20cb79926d5c997e0fc30883874ed8c5, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_20cb79926d5c997e0fc30883874ed8c5 = cache_frame_20cb79926d5c997e0fc30883874ed8c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_20cb79926d5c997e0fc30883874ed8c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_20cb79926d5c997e0fc30883874ed8c5 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_mvar_value_1;
        int tmp_or_left_truth_3;
        nuitka_bool tmp_or_left_value_3;
        nuitka_bool tmp_or_right_value_3;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_name_1;
        int tmp_or_left_truth_4;
        nuitka_bool tmp_or_left_value_4;
        nuitka_bool tmp_or_right_value_4;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_value );
        tmp_isinstance_inst_1 = par_value;
        tmp_isinstance_cls_1 = (PyObject *)&PyUnicode_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1428;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( par_value );
        tmp_isinstance_inst_2 = par_value;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Callable );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Callable" );
            exception_tb = NULL;

            exception_lineno = 1428;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1428;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_2 == 1 )
        {
            goto or_left_2;
        }
        else
        {
            goto or_right_2;
        }
        or_right_2:;
        CHECK_OBJECT( par_value );
        tmp_source_name_1 = par_value;
        tmp_attribute_name_1 = const_str_plain_match;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_1, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1428;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_3 = tmp_or_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_3 == 1 )
        {
            goto or_left_3;
        }
        else
        {
            goto or_right_3;
        }
        or_right_3:;
        CHECK_OBJECT( par_value );
        tmp_isinstance_inst_3 = par_value;
        tmp_isinstance_cls_3 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1429;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_4 = tmp_or_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_4 == 1 )
        {
            goto or_left_4;
        }
        else
        {
            goto or_right_4;
        }
        or_right_4:;
        CHECK_OBJECT( par_value );
        tmp_compexpr_left_1 = par_value;
        tmp_compexpr_right_1 = Py_None;
        tmp_or_right_value_4 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_right_value_3 = tmp_or_right_value_4;
        goto or_end_4;
        or_left_4:;
        tmp_or_right_value_3 = tmp_or_left_value_4;
        or_end_4:;
        tmp_or_right_value_2 = tmp_or_right_value_3;
        goto or_end_3;
        or_left_3:;
        tmp_or_right_value_2 = tmp_or_left_value_3;
        or_end_3:;
        tmp_or_right_value_1 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_or_right_value_1 = tmp_or_left_value_2;
        or_end_2:;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT( par_value );
        tmp_return_value = par_value;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_4;
        PyObject *tmp_isinstance_cls_4;
        CHECK_OBJECT( par_value );
        tmp_isinstance_inst_4 = par_value;
        tmp_isinstance_cls_4 = (PyObject *)&PyString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_4, tmp_isinstance_cls_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1433;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_called_instance_1;
            CHECK_OBJECT( par_value );
            tmp_called_instance_1 = par_value;
            frame_20cb79926d5c997e0fc30883874ed8c5->m_frame.f_lineno = 1434;
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_decode, &PyTuple_GET_ITEM( const_tuple_str_plain_utf8_tuple, 0 ) );

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1434;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_attribute_name_2;
        CHECK_OBJECT( par_value );
        tmp_source_name_2 = par_value;
        tmp_attribute_name_2 = const_str_plain___iter__;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_2, tmp_attribute_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1437;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_3;
        }
        else
        {
            goto branch_no_3;
        }
        branch_yes_3:;
        {
            PyObject *tmp_assign_source_1;
            tmp_assign_source_1 = PyList_New( 0 );
            assert( var_new_value == NULL );
            var_new_value = tmp_assign_source_1;
        }
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_value );
            tmp_iter_arg_1 = par_value;
            tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1439;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_2;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooo";
                    exception_lineno = 1439;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_3;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_4 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_v;
                var_v = tmp_assign_source_4;
                Py_INCREF( var_v );
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_4;
            int tmp_and_left_truth_1;
            nuitka_bool tmp_and_left_value_1;
            nuitka_bool tmp_and_right_value_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_attribute_name_3;
            int tmp_and_left_truth_2;
            nuitka_bool tmp_and_left_value_2;
            nuitka_bool tmp_and_right_value_2;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_isinstance_inst_5;
            PyObject *tmp_isinstance_cls_5;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_isinstance_inst_6;
            PyObject *tmp_isinstance_cls_6;
            CHECK_OBJECT( var_v );
            tmp_source_name_3 = var_v;
            tmp_attribute_name_3 = const_str_plain___iter__;
            tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_3, tmp_attribute_name_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1440;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_1 == 1 )
            {
                goto and_right_1;
            }
            else
            {
                goto and_left_1;
            }
            and_right_1:;
            CHECK_OBJECT( var_v );
            tmp_isinstance_inst_5 = var_v;
            tmp_isinstance_cls_5 = (PyObject *)&PyString_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_5, tmp_isinstance_cls_5 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1440;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1440;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_and_left_value_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_2 == 1 )
            {
                goto and_right_2;
            }
            else
            {
                goto and_left_2;
            }
            and_right_2:;
            CHECK_OBJECT( var_v );
            tmp_isinstance_inst_6 = var_v;
            tmp_isinstance_cls_6 = (PyObject *)&PyUnicode_Type;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_6, tmp_isinstance_cls_6 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1441;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1441;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_and_right_value_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_right_value_1 = tmp_and_right_value_2;
            goto and_end_2;
            and_left_2:;
            tmp_and_right_value_1 = tmp_and_left_value_2;
            and_end_2:;
            tmp_condition_result_4 = tmp_and_right_value_1;
            goto and_end_1;
            and_left_1:;
            tmp_condition_result_4 = tmp_and_left_value_1;
            and_end_1:;
            if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_4;
            }
            else
            {
                goto branch_no_4;
            }
            branch_yes_4:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_call_result_1;
                PyObject *tmp_args_element_name_1;
                CHECK_OBJECT( var_new_value );
                tmp_called_instance_2 = var_new_value;
                CHECK_OBJECT( var_v );
                tmp_args_element_name_1 = var_v;
                frame_20cb79926d5c997e0fc30883874ed8c5->m_frame.f_lineno = 1445;
                {
                    PyObject *call_args[] = { tmp_args_element_name_1 };
                    tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
                }

                if ( tmp_call_result_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1445;
                    type_description_1 = "oooo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_1 );
            }
            goto branch_end_4;
            branch_no_4:;
            {
                PyObject *tmp_called_name_1;
                PyObject *tmp_source_name_4;
                PyObject *tmp_call_result_2;
                PyObject *tmp_args_element_name_2;
                PyObject *tmp_called_instance_3;
                PyObject *tmp_args_element_name_3;
                CHECK_OBJECT( var_new_value );
                tmp_source_name_4 = var_new_value;
                tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
                if ( tmp_called_name_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1447;
                    type_description_1 = "oooo";
                    goto try_except_handler_2;
                }
                CHECK_OBJECT( par_self );
                tmp_called_instance_3 = par_self;
                CHECK_OBJECT( var_v );
                tmp_args_element_name_3 = var_v;
                frame_20cb79926d5c997e0fc30883874ed8c5->m_frame.f_lineno = 1447;
                {
                    PyObject *call_args[] = { tmp_args_element_name_3 };
                    tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__normalize_search_value, call_args );
                }

                if ( tmp_args_element_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_called_name_1 );

                    exception_lineno = 1447;
                    type_description_1 = "oooo";
                    goto try_except_handler_2;
                }
                frame_20cb79926d5c997e0fc30883874ed8c5->m_frame.f_lineno = 1447;
                {
                    PyObject *call_args[] = { tmp_args_element_name_2 };
                    tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
                }

                Py_DECREF( tmp_called_name_1 );
                Py_DECREF( tmp_args_element_name_2 );
                if ( tmp_call_result_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1447;
                    type_description_1 = "oooo";
                    goto try_except_handler_2;
                }
                Py_DECREF( tmp_call_result_2 );
            }
            branch_end_4:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1439;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        CHECK_OBJECT( var_new_value );
        tmp_return_value = var_new_value;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_3:;
    }
    {
        PyObject *tmp_str_arg_1;
        PyObject *tmp_str_arg_2;
        CHECK_OBJECT( par_value );
        tmp_str_arg_2 = par_value;
        tmp_str_arg_1 = PyObject_Str( tmp_str_arg_2 );
        if ( tmp_str_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1453;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = PyObject_Unicode( tmp_str_arg_1 );
        Py_DECREF( tmp_str_arg_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1453;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_20cb79926d5c997e0fc30883874ed8c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_20cb79926d5c997e0fc30883874ed8c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_20cb79926d5c997e0fc30883874ed8c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_20cb79926d5c997e0fc30883874ed8c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_20cb79926d5c997e0fc30883874ed8c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_20cb79926d5c997e0fc30883874ed8c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_20cb79926d5c997e0fc30883874ed8c5,
        type_description_1,
        par_self,
        par_value,
        var_new_value,
        var_v
    );


    // Release cached frame.
    if ( frame_20cb79926d5c997e0fc30883874ed8c5 == cache_frame_20cb79926d5c997e0fc30883874ed8c5 )
    {
        Py_DECREF( frame_20cb79926d5c997e0fc30883874ed8c5 );
    }
    cache_frame_20cb79926d5c997e0fc30883874ed8c5 = NULL;

    assertFrameObject( frame_20cb79926d5c997e0fc30883874ed8c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_108__normalize_search_value );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_new_value );
    var_new_value = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_v );
    var_v = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_new_value );
    var_new_value = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_value );
    Py_DECREF( par_value );
    par_value = NULL;

    Py_XDECREF( var_v );
    var_v = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_108__normalize_search_value );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_109___str__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_285a3a357c7e6df9e65ab69b915876e0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_285a3a357c7e6df9e65ab69b915876e0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_285a3a357c7e6df9e65ab69b915876e0, codeobj_285a3a357c7e6df9e65ab69b915876e0, module_bs4$element, sizeof(void *) );
    frame_285a3a357c7e6df9e65ab69b915876e0 = cache_frame_285a3a357c7e6df9e65ab69b915876e0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_285a3a357c7e6df9e65ab69b915876e0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_285a3a357c7e6df9e65ab69b915876e0 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_text );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1456;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1456;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_2 = par_self;
            tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_text );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1457;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_left_name_1;
            PyObject *tmp_right_name_1;
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_source_name_3;
            PyObject *tmp_source_name_4;
            tmp_left_name_1 = const_str_digest_2fb35f5b371e4357763cfefa063b5165;
            CHECK_OBJECT( par_self );
            tmp_source_name_3 = par_self;
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_name );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1459;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = PyTuple_New( 2 );
            PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
            CHECK_OBJECT( par_self );
            tmp_source_name_4 = par_self;
            tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_attrs );
            if ( tmp_tuple_element_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_right_name_1 );

                exception_lineno = 1459;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
            tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
            Py_DECREF( tmp_right_name_1 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1459;
                type_description_1 = "o";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_285a3a357c7e6df9e65ab69b915876e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_285a3a357c7e6df9e65ab69b915876e0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_285a3a357c7e6df9e65ab69b915876e0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_285a3a357c7e6df9e65ab69b915876e0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_285a3a357c7e6df9e65ab69b915876e0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_285a3a357c7e6df9e65ab69b915876e0, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_285a3a357c7e6df9e65ab69b915876e0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if ( frame_285a3a357c7e6df9e65ab69b915876e0 == cache_frame_285a3a357c7e6df9e65ab69b915876e0 )
    {
        Py_DECREF( frame_285a3a357c7e6df9e65ab69b915876e0 );
    }
    cache_frame_285a3a357c7e6df9e65ab69b915876e0 = NULL;

    assertFrameObject( frame_285a3a357c7e6df9e65ab69b915876e0 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_109___str__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_109___str__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_110_search_tag( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_markup_name = python_pars[ 1 ];
    PyObject *par_markup_attrs = python_pars[ 2 ];
    PyObject *var_markup = NULL;
    PyObject *var_match_against = NULL;
    PyObject *var_k = NULL;
    PyObject *var_markup_attr_map = NULL;
    PyObject *var_attr_value = NULL;
    PyObject *var_v = NULL;
    PyObject *var_found = NULL;
    PyObject *var_call_function_with_tag_data = NULL;
    PyObject *var_match = NULL;
    PyObject *var_attr = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    struct Nuitka_FrameObject *frame_9eb6ed3effa667fc4260fde143db8cce;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9eb6ed3effa667fc4260fde143db8cce = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert( var_found == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_found = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = Py_None;
        assert( var_markup == NULL );
        Py_INCREF( tmp_assign_source_2 );
        var_markup = tmp_assign_source_2;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9eb6ed3effa667fc4260fde143db8cce, codeobj_9eb6ed3effa667fc4260fde143db8cce, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_9eb6ed3effa667fc4260fde143db8cce = cache_frame_9eb6ed3effa667fc4260fde143db8cce;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9eb6ed3effa667fc4260fde143db8cce );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9eb6ed3effa667fc4260fde143db8cce ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_markup_name );
        tmp_isinstance_inst_1 = par_markup_name;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
            exception_tb = NULL;

            exception_lineno = 1464;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_1 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1464;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( par_markup_name );
            tmp_assign_source_3 = par_markup_name;
            {
                PyObject *old = var_markup;
                assert( old != NULL );
                var_markup = tmp_assign_source_3;
                Py_INCREF( var_markup );
                Py_DECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT( var_markup );
            tmp_assign_source_4 = var_markup;
            {
                PyObject *old = par_markup_attrs;
                assert( old != NULL );
                par_markup_attrs = tmp_assign_source_4;
                Py_INCREF( par_markup_attrs );
                Py_DECREF( old );
            }

        }
        branch_no_1:;
    }
    {
        PyObject *tmp_assign_source_5;
        int tmp_and_left_truth_1;
        PyObject *tmp_and_left_value_1;
        PyObject *tmp_and_right_value_1;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        PyObject *tmp_mvar_value_3;
        CHECK_OBJECT( par_self );
        tmp_source_name_1 = par_self;
        tmp_isinstance_inst_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
        if ( tmp_isinstance_inst_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1468;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Callable );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_isinstance_inst_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Callable" );
            exception_tb = NULL;

            exception_lineno = 1468;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_2 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        Py_DECREF( tmp_isinstance_inst_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1468;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
        if ( tmp_and_left_truth_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1469;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_markup_name );
        tmp_isinstance_inst_3 = par_markup_name;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
            exception_tb = NULL;

            exception_lineno = 1469;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_3 = tmp_mvar_value_3;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1469;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1469;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? Py_True : Py_False;
        tmp_assign_source_5 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_assign_source_5 = tmp_and_left_value_1;
        and_end_1:;
        assert( var_call_function_with_tag_data == NULL );
        Py_INCREF( tmp_assign_source_5 );
        var_call_function_with_tag_data = tmp_assign_source_5;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_source_name_2;
        int tmp_or_left_truth_2;
        nuitka_bool tmp_or_left_value_2;
        nuitka_bool tmp_or_right_value_2;
        int tmp_truth_name_1;
        int tmp_or_left_truth_3;
        nuitka_bool tmp_or_left_value_3;
        nuitka_bool tmp_or_right_value_3;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        int tmp_truth_name_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_source_name_4;
        int tmp_truth_name_3;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        PyObject *tmp_operand_name_3;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_5;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_source_name_6;
        int tmp_truth_name_4;
        CHECK_OBJECT( par_self );
        tmp_source_name_2 = par_self;
        tmp_operand_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
        if ( tmp_operand_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1471;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        Py_DECREF( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1471;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( var_call_function_with_tag_data );
        tmp_truth_name_1 = CHECK_IF_TRUE( var_call_function_with_tag_data );
        if ( tmp_truth_name_1 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1472;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_2 == 1 )
        {
            goto or_left_2;
        }
        else
        {
            goto or_right_2;
        }
        or_right_2:;
        CHECK_OBJECT( var_markup );
        tmp_truth_name_2 = CHECK_IF_TRUE( var_markup );
        if ( tmp_truth_name_2 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1473;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_self );
        tmp_source_name_3 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__matches );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1473;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_markup );
        tmp_args_element_name_1 = var_markup;
        CHECK_OBJECT( par_self );
        tmp_source_name_4 = par_self;
        tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_name );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 1473;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_9eb6ed3effa667fc4260fde143db8cce->m_frame.f_lineno = 1473;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1473;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_3 = CHECK_IF_TRUE( tmp_call_result_1 );
        if ( tmp_truth_name_3 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_1 );

            exception_lineno = 1473;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_1 );
        tmp_or_left_value_3 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_or_left_value_3 = tmp_and_left_value_2;
        and_end_2:;
        tmp_or_left_truth_3 = tmp_or_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_3 == 1 )
        {
            goto or_left_3;
        }
        else
        {
            goto or_right_3;
        }
        or_right_3:;
        CHECK_OBJECT( var_markup );
        tmp_operand_name_3 = var_markup;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1474;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_3 == 1 )
        {
            goto and_right_3;
        }
        else
        {
            goto and_left_3;
        }
        and_right_3:;
        CHECK_OBJECT( par_self );
        tmp_source_name_5 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__matches );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1474;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_markup_name );
        tmp_args_element_name_3 = par_markup_name;
        CHECK_OBJECT( par_self );
        tmp_source_name_6 = par_self;
        tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_name );
        if ( tmp_args_element_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 1474;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_9eb6ed3effa667fc4260fde143db8cce->m_frame.f_lineno = 1474;
        {
            PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
            tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        if ( tmp_call_result_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1474;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_4 = CHECK_IF_TRUE( tmp_call_result_2 );
        if ( tmp_truth_name_4 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_call_result_2 );

            exception_lineno = 1474;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_3 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_call_result_2 );
        tmp_or_right_value_3 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_or_right_value_3 = tmp_and_left_value_3;
        and_end_3:;
        tmp_or_right_value_2 = tmp_or_right_value_3;
        goto or_end_3;
        or_left_3:;
        tmp_or_right_value_2 = tmp_or_left_value_3;
        or_end_3:;
        tmp_or_right_value_1 = tmp_or_right_value_2;
        goto or_end_2;
        or_left_2:;
        tmp_or_right_value_1 = tmp_or_left_value_2;
        or_end_2:;
        tmp_condition_result_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_2 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            int tmp_truth_name_5;
            CHECK_OBJECT( var_call_function_with_tag_data );
            tmp_truth_name_5 = CHECK_IF_TRUE( var_call_function_with_tag_data );
            if ( tmp_truth_name_5 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1475;
                type_description_1 = "ooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_6;
                PyObject *tmp_called_instance_1;
                PyObject *tmp_args_element_name_5;
                PyObject *tmp_args_element_name_6;
                CHECK_OBJECT( par_self );
                tmp_called_instance_1 = par_self;
                CHECK_OBJECT( par_markup_name );
                tmp_args_element_name_5 = par_markup_name;
                CHECK_OBJECT( par_markup_attrs );
                tmp_args_element_name_6 = par_markup_attrs;
                frame_9eb6ed3effa667fc4260fde143db8cce->m_frame.f_lineno = 1476;
                {
                    PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
                    tmp_assign_source_6 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_name, call_args );
                }

                if ( tmp_assign_source_6 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1476;
                    type_description_1 = "ooooooooooooo";
                    goto frame_exception_exit_1;
                }
                assert( var_match == NULL );
                var_match = tmp_assign_source_6;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                PyObject *tmp_assign_source_7;
                tmp_assign_source_7 = Py_True;
                assert( var_match == NULL );
                Py_INCREF( tmp_assign_source_7 );
                var_match = tmp_assign_source_7;
            }
            {
                PyObject *tmp_assign_source_8;
                tmp_assign_source_8 = Py_None;
                assert( var_markup_attr_map == NULL );
                Py_INCREF( tmp_assign_source_8 );
                var_markup_attr_map = tmp_assign_source_8;
            }
            {
                PyObject *tmp_assign_source_9;
                PyObject *tmp_iter_arg_1;
                PyObject *tmp_list_arg_1;
                PyObject *tmp_called_instance_2;
                PyObject *tmp_source_name_7;
                CHECK_OBJECT( par_self );
                tmp_source_name_7 = par_self;
                tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_attrs );
                if ( tmp_called_instance_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1480;
                    type_description_1 = "ooooooooooooo";
                    goto frame_exception_exit_1;
                }
                frame_9eb6ed3effa667fc4260fde143db8cce->m_frame.f_lineno = 1480;
                tmp_list_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_items );
                Py_DECREF( tmp_called_instance_2 );
                if ( tmp_list_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1480;
                    type_description_1 = "ooooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_iter_arg_1 = PySequence_List( tmp_list_arg_1 );
                Py_DECREF( tmp_list_arg_1 );
                if ( tmp_iter_arg_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1480;
                    type_description_1 = "ooooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_assign_source_9 = MAKE_ITERATOR( tmp_iter_arg_1 );
                Py_DECREF( tmp_iter_arg_1 );
                if ( tmp_assign_source_9 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1480;
                    type_description_1 = "ooooooooooooo";
                    goto frame_exception_exit_1;
                }
                assert( tmp_for_loop_1__for_iterator == NULL );
                tmp_for_loop_1__for_iterator = tmp_assign_source_9;
            }
            // Tried code:
            loop_start_1:;
            {
                PyObject *tmp_next_source_1;
                PyObject *tmp_assign_source_10;
                CHECK_OBJECT( tmp_for_loop_1__for_iterator );
                tmp_next_source_1 = tmp_for_loop_1__for_iterator;
                tmp_assign_source_10 = ITERATOR_NEXT( tmp_next_source_1 );
                if ( tmp_assign_source_10 == NULL )
                {
                    if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                    {

                        goto loop_end_1;
                    }
                    else
                    {

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        type_description_1 = "ooooooooooooo";
                        exception_lineno = 1480;
                        goto try_except_handler_2;
                    }
                }

                {
                    PyObject *old = tmp_for_loop_1__iter_value;
                    tmp_for_loop_1__iter_value = tmp_assign_source_10;
                    Py_XDECREF( old );
                }

            }
            // Tried code:
            {
                PyObject *tmp_assign_source_11;
                PyObject *tmp_iter_arg_2;
                CHECK_OBJECT( tmp_for_loop_1__iter_value );
                tmp_iter_arg_2 = tmp_for_loop_1__iter_value;
                tmp_assign_source_11 = MAKE_ITERATOR( tmp_iter_arg_2 );
                if ( tmp_assign_source_11 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1480;
                    type_description_1 = "ooooooooooooo";
                    goto try_except_handler_3;
                }
                {
                    PyObject *old = tmp_tuple_unpack_1__source_iter;
                    tmp_tuple_unpack_1__source_iter = tmp_assign_source_11;
                    Py_XDECREF( old );
                }

            }
            // Tried code:
            {
                PyObject *tmp_assign_source_12;
                PyObject *tmp_unpack_1;
                CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
                tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
                tmp_assign_source_12 = UNPACK_NEXT( tmp_unpack_1, 0 );
                if ( tmp_assign_source_12 == NULL )
                {
                    if ( !ERROR_OCCURRED() )
                    {
                        exception_type = PyExc_StopIteration;
                        Py_INCREF( exception_type );
                        exception_value = NULL;
                        exception_tb = NULL;
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    }


                    type_description_1 = "ooooooooooooo";
                    exception_lineno = 1480;
                    goto try_except_handler_4;
                }
                {
                    PyObject *old = tmp_tuple_unpack_1__element_1;
                    tmp_tuple_unpack_1__element_1 = tmp_assign_source_12;
                    Py_XDECREF( old );
                }

            }
            {
                PyObject *tmp_assign_source_13;
                PyObject *tmp_unpack_2;
                CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
                tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
                tmp_assign_source_13 = UNPACK_NEXT( tmp_unpack_2, 1 );
                if ( tmp_assign_source_13 == NULL )
                {
                    if ( !ERROR_OCCURRED() )
                    {
                        exception_type = PyExc_StopIteration;
                        Py_INCREF( exception_type );
                        exception_value = NULL;
                        exception_tb = NULL;
                    }
                    else
                    {
                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    }


                    type_description_1 = "ooooooooooooo";
                    exception_lineno = 1480;
                    goto try_except_handler_4;
                }
                {
                    PyObject *old = tmp_tuple_unpack_1__element_2;
                    tmp_tuple_unpack_1__element_2 = tmp_assign_source_13;
                    Py_XDECREF( old );
                }

            }
            {
                PyObject *tmp_iterator_name_1;
                CHECK_OBJECT( tmp_tuple_unpack_1__source_iter );
                tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
                // Check if iterator has left-over elements.
                CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

                tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

                if (likely( tmp_iterator_attempt == NULL ))
                {
                    PyObject *error = GET_ERROR_OCCURRED();

                    if ( error != NULL )
                    {
                        if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                        {
                            CLEAR_ERROR_OCCURRED();
                        }
                        else
                        {
                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                            type_description_1 = "ooooooooooooo";
                            exception_lineno = 1480;
                            goto try_except_handler_4;
                        }
                    }
                }
                else
                {
                    Py_DECREF( tmp_iterator_attempt );

                    // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                    PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                    PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                    type_description_1 = "ooooooooooooo";
                    exception_lineno = 1480;
                    goto try_except_handler_4;
                }
            }
            goto try_end_1;
            // Exception handler code:
            try_except_handler_4:;
            exception_keeper_type_1 = exception_type;
            exception_keeper_value_1 = exception_value;
            exception_keeper_tb_1 = exception_tb;
            exception_keeper_lineno_1 = exception_lineno;
            exception_type = NULL;
            exception_value = NULL;
            exception_tb = NULL;
            exception_lineno = 0;

            CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
            Py_DECREF( tmp_tuple_unpack_1__source_iter );
            tmp_tuple_unpack_1__source_iter = NULL;

            // Re-raise.
            exception_type = exception_keeper_type_1;
            exception_value = exception_keeper_value_1;
            exception_tb = exception_keeper_tb_1;
            exception_lineno = exception_keeper_lineno_1;

            goto try_except_handler_3;
            // End of try:
            try_end_1:;
            goto try_end_2;
            // Exception handler code:
            try_except_handler_3:;
            exception_keeper_type_2 = exception_type;
            exception_keeper_value_2 = exception_value;
            exception_keeper_tb_2 = exception_tb;
            exception_keeper_lineno_2 = exception_lineno;
            exception_type = NULL;
            exception_value = NULL;
            exception_tb = NULL;
            exception_lineno = 0;

            Py_XDECREF( tmp_tuple_unpack_1__element_1 );
            tmp_tuple_unpack_1__element_1 = NULL;

            Py_XDECREF( tmp_tuple_unpack_1__element_2 );
            tmp_tuple_unpack_1__element_2 = NULL;

            // Re-raise.
            exception_type = exception_keeper_type_2;
            exception_value = exception_keeper_value_2;
            exception_tb = exception_keeper_tb_2;
            exception_lineno = exception_keeper_lineno_2;

            goto try_except_handler_2;
            // End of try:
            try_end_2:;
            CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
            Py_DECREF( tmp_tuple_unpack_1__source_iter );
            tmp_tuple_unpack_1__source_iter = NULL;

            {
                PyObject *tmp_assign_source_14;
                CHECK_OBJECT( tmp_tuple_unpack_1__element_1 );
                tmp_assign_source_14 = tmp_tuple_unpack_1__element_1;
                {
                    PyObject *old = var_attr;
                    var_attr = tmp_assign_source_14;
                    Py_INCREF( var_attr );
                    Py_XDECREF( old );
                }

            }
            Py_XDECREF( tmp_tuple_unpack_1__element_1 );
            tmp_tuple_unpack_1__element_1 = NULL;

            {
                PyObject *tmp_assign_source_15;
                CHECK_OBJECT( tmp_tuple_unpack_1__element_2 );
                tmp_assign_source_15 = tmp_tuple_unpack_1__element_2;
                {
                    PyObject *old = var_match_against;
                    var_match_against = tmp_assign_source_15;
                    Py_INCREF( var_match_against );
                    Py_XDECREF( old );
                }

            }
            Py_XDECREF( tmp_tuple_unpack_1__element_2 );
            tmp_tuple_unpack_1__element_2 = NULL;

            {
                nuitka_bool tmp_condition_result_4;
                PyObject *tmp_operand_name_4;
                if ( var_markup_attr_map == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "markup_attr_map" );
                    exception_tb = NULL;

                    exception_lineno = 1481;
                    type_description_1 = "ooooooooooooo";
                    goto try_except_handler_2;
                }

                tmp_operand_name_4 = var_markup_attr_map;
                tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1481;
                    type_description_1 = "ooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_condition_result_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_4;
                }
                else
                {
                    goto branch_no_4;
                }
                branch_yes_4:;
                {
                    nuitka_bool tmp_condition_result_5;
                    PyObject *tmp_source_name_8;
                    PyObject *tmp_attribute_name_1;
                    CHECK_OBJECT( par_markup_attrs );
                    tmp_source_name_8 = par_markup_attrs;
                    tmp_attribute_name_1 = const_str_plain_get;
                    tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_8, tmp_attribute_name_1 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1482;
                        type_description_1 = "ooooooooooooo";
                        goto try_except_handler_2;
                    }
                    tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_5;
                    }
                    else
                    {
                        goto branch_no_5;
                    }
                    branch_yes_5:;
                    {
                        PyObject *tmp_assign_source_16;
                        CHECK_OBJECT( par_markup_attrs );
                        tmp_assign_source_16 = par_markup_attrs;
                        {
                            PyObject *old = var_markup_attr_map;
                            var_markup_attr_map = tmp_assign_source_16;
                            Py_INCREF( var_markup_attr_map );
                            Py_XDECREF( old );
                        }

                    }
                    goto branch_end_5;
                    branch_no_5:;
                    {
                        PyObject *tmp_assign_source_17;
                        tmp_assign_source_17 = PyDict_New();
                        {
                            PyObject *old = var_markup_attr_map;
                            var_markup_attr_map = tmp_assign_source_17;
                            Py_XDECREF( old );
                        }

                    }
                    {
                        PyObject *tmp_assign_source_18;
                        PyObject *tmp_iter_arg_3;
                        CHECK_OBJECT( par_markup_attrs );
                        tmp_iter_arg_3 = par_markup_attrs;
                        tmp_assign_source_18 = MAKE_ITERATOR( tmp_iter_arg_3 );
                        if ( tmp_assign_source_18 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 1486;
                            type_description_1 = "ooooooooooooo";
                            goto try_except_handler_2;
                        }
                        {
                            PyObject *old = tmp_for_loop_2__for_iterator;
                            tmp_for_loop_2__for_iterator = tmp_assign_source_18;
                            Py_XDECREF( old );
                        }

                    }
                    // Tried code:
                    loop_start_2:;
                    {
                        PyObject *tmp_next_source_2;
                        PyObject *tmp_assign_source_19;
                        CHECK_OBJECT( tmp_for_loop_2__for_iterator );
                        tmp_next_source_2 = tmp_for_loop_2__for_iterator;
                        tmp_assign_source_19 = ITERATOR_NEXT( tmp_next_source_2 );
                        if ( tmp_assign_source_19 == NULL )
                        {
                            if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                            {

                                goto loop_end_2;
                            }
                            else
                            {

                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                                type_description_1 = "ooooooooooooo";
                                exception_lineno = 1486;
                                goto try_except_handler_5;
                            }
                        }

                        {
                            PyObject *old = tmp_for_loop_2__iter_value;
                            tmp_for_loop_2__iter_value = tmp_assign_source_19;
                            Py_XDECREF( old );
                        }

                    }
                    // Tried code:
                    {
                        PyObject *tmp_assign_source_20;
                        PyObject *tmp_iter_arg_4;
                        CHECK_OBJECT( tmp_for_loop_2__iter_value );
                        tmp_iter_arg_4 = tmp_for_loop_2__iter_value;
                        tmp_assign_source_20 = MAKE_ITERATOR( tmp_iter_arg_4 );
                        if ( tmp_assign_source_20 == NULL )
                        {
                            assert( ERROR_OCCURRED() );

                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                            exception_lineno = 1486;
                            type_description_1 = "ooooooooooooo";
                            goto try_except_handler_6;
                        }
                        {
                            PyObject *old = tmp_tuple_unpack_2__source_iter;
                            tmp_tuple_unpack_2__source_iter = tmp_assign_source_20;
                            Py_XDECREF( old );
                        }

                    }
                    // Tried code:
                    {
                        PyObject *tmp_assign_source_21;
                        PyObject *tmp_unpack_3;
                        CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
                        tmp_unpack_3 = tmp_tuple_unpack_2__source_iter;
                        tmp_assign_source_21 = UNPACK_NEXT( tmp_unpack_3, 0 );
                        if ( tmp_assign_source_21 == NULL )
                        {
                            if ( !ERROR_OCCURRED() )
                            {
                                exception_type = PyExc_StopIteration;
                                Py_INCREF( exception_type );
                                exception_value = NULL;
                                exception_tb = NULL;
                            }
                            else
                            {
                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                            }


                            type_description_1 = "ooooooooooooo";
                            exception_lineno = 1486;
                            goto try_except_handler_7;
                        }
                        {
                            PyObject *old = tmp_tuple_unpack_2__element_1;
                            tmp_tuple_unpack_2__element_1 = tmp_assign_source_21;
                            Py_XDECREF( old );
                        }

                    }
                    {
                        PyObject *tmp_assign_source_22;
                        PyObject *tmp_unpack_4;
                        CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
                        tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;
                        tmp_assign_source_22 = UNPACK_NEXT( tmp_unpack_4, 1 );
                        if ( tmp_assign_source_22 == NULL )
                        {
                            if ( !ERROR_OCCURRED() )
                            {
                                exception_type = PyExc_StopIteration;
                                Py_INCREF( exception_type );
                                exception_value = NULL;
                                exception_tb = NULL;
                            }
                            else
                            {
                                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                            }


                            type_description_1 = "ooooooooooooo";
                            exception_lineno = 1486;
                            goto try_except_handler_7;
                        }
                        {
                            PyObject *old = tmp_tuple_unpack_2__element_2;
                            tmp_tuple_unpack_2__element_2 = tmp_assign_source_22;
                            Py_XDECREF( old );
                        }

                    }
                    {
                        PyObject *tmp_iterator_name_2;
                        CHECK_OBJECT( tmp_tuple_unpack_2__source_iter );
                        tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;
                        // Check if iterator has left-over elements.
                        CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

                        tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

                        if (likely( tmp_iterator_attempt == NULL ))
                        {
                            PyObject *error = GET_ERROR_OCCURRED();

                            if ( error != NULL )
                            {
                                if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
                                {
                                    CLEAR_ERROR_OCCURRED();
                                }
                                else
                                {
                                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                                    type_description_1 = "ooooooooooooo";
                                    exception_lineno = 1486;
                                    goto try_except_handler_7;
                                }
                            }
                        }
                        else
                        {
                            Py_DECREF( tmp_iterator_attempt );

                            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
                            PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
                            PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
                            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                            type_description_1 = "ooooooooooooo";
                            exception_lineno = 1486;
                            goto try_except_handler_7;
                        }
                    }
                    goto try_end_3;
                    // Exception handler code:
                    try_except_handler_7:;
                    exception_keeper_type_3 = exception_type;
                    exception_keeper_value_3 = exception_value;
                    exception_keeper_tb_3 = exception_tb;
                    exception_keeper_lineno_3 = exception_lineno;
                    exception_type = NULL;
                    exception_value = NULL;
                    exception_tb = NULL;
                    exception_lineno = 0;

                    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
                    Py_DECREF( tmp_tuple_unpack_2__source_iter );
                    tmp_tuple_unpack_2__source_iter = NULL;

                    // Re-raise.
                    exception_type = exception_keeper_type_3;
                    exception_value = exception_keeper_value_3;
                    exception_tb = exception_keeper_tb_3;
                    exception_lineno = exception_keeper_lineno_3;

                    goto try_except_handler_6;
                    // End of try:
                    try_end_3:;
                    goto try_end_4;
                    // Exception handler code:
                    try_except_handler_6:;
                    exception_keeper_type_4 = exception_type;
                    exception_keeper_value_4 = exception_value;
                    exception_keeper_tb_4 = exception_tb;
                    exception_keeper_lineno_4 = exception_lineno;
                    exception_type = NULL;
                    exception_value = NULL;
                    exception_tb = NULL;
                    exception_lineno = 0;

                    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
                    tmp_tuple_unpack_2__element_1 = NULL;

                    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
                    tmp_tuple_unpack_2__element_2 = NULL;

                    // Re-raise.
                    exception_type = exception_keeper_type_4;
                    exception_value = exception_keeper_value_4;
                    exception_tb = exception_keeper_tb_4;
                    exception_lineno = exception_keeper_lineno_4;

                    goto try_except_handler_5;
                    // End of try:
                    try_end_4:;
                    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
                    Py_DECREF( tmp_tuple_unpack_2__source_iter );
                    tmp_tuple_unpack_2__source_iter = NULL;

                    {
                        PyObject *tmp_assign_source_23;
                        CHECK_OBJECT( tmp_tuple_unpack_2__element_1 );
                        tmp_assign_source_23 = tmp_tuple_unpack_2__element_1;
                        {
                            PyObject *old = var_k;
                            var_k = tmp_assign_source_23;
                            Py_INCREF( var_k );
                            Py_XDECREF( old );
                        }

                    }
                    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
                    tmp_tuple_unpack_2__element_1 = NULL;

                    {
                        PyObject *tmp_assign_source_24;
                        CHECK_OBJECT( tmp_tuple_unpack_2__element_2 );
                        tmp_assign_source_24 = tmp_tuple_unpack_2__element_2;
                        {
                            PyObject *old = var_v;
                            var_v = tmp_assign_source_24;
                            Py_INCREF( var_v );
                            Py_XDECREF( old );
                        }

                    }
                    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
                    tmp_tuple_unpack_2__element_2 = NULL;

                    CHECK_OBJECT( var_v );
                    tmp_dictset_value = var_v;
                    CHECK_OBJECT( var_markup_attr_map );
                    tmp_dictset_dict = var_markup_attr_map;
                    CHECK_OBJECT( var_k );
                    tmp_dictset_key = var_k;
                    tmp_res = PyDict_SetItem( tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value );
                    if ( tmp_res != 0 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1487;
                        type_description_1 = "ooooooooooooo";
                        goto try_except_handler_5;
                    }
                    if ( CONSIDER_THREADING() == false )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1486;
                        type_description_1 = "ooooooooooooo";
                        goto try_except_handler_5;
                    }
                    goto loop_start_2;
                    loop_end_2:;
                    goto try_end_5;
                    // Exception handler code:
                    try_except_handler_5:;
                    exception_keeper_type_5 = exception_type;
                    exception_keeper_value_5 = exception_value;
                    exception_keeper_tb_5 = exception_tb;
                    exception_keeper_lineno_5 = exception_lineno;
                    exception_type = NULL;
                    exception_value = NULL;
                    exception_tb = NULL;
                    exception_lineno = 0;

                    Py_XDECREF( tmp_for_loop_2__iter_value );
                    tmp_for_loop_2__iter_value = NULL;

                    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
                    Py_DECREF( tmp_for_loop_2__for_iterator );
                    tmp_for_loop_2__for_iterator = NULL;

                    // Re-raise.
                    exception_type = exception_keeper_type_5;
                    exception_value = exception_keeper_value_5;
                    exception_tb = exception_keeper_tb_5;
                    exception_lineno = exception_keeper_lineno_5;

                    goto try_except_handler_2;
                    // End of try:
                    try_end_5:;
                    Py_XDECREF( tmp_for_loop_2__iter_value );
                    tmp_for_loop_2__iter_value = NULL;

                    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
                    Py_DECREF( tmp_for_loop_2__for_iterator );
                    tmp_for_loop_2__for_iterator = NULL;

                    branch_end_5:;
                }
                branch_no_4:;
            }
            {
                PyObject *tmp_assign_source_25;
                PyObject *tmp_called_instance_3;
                PyObject *tmp_args_element_name_7;
                if ( var_markup_attr_map == NULL )
                {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "markup_attr_map" );
                    exception_tb = NULL;

                    exception_lineno = 1488;
                    type_description_1 = "ooooooooooooo";
                    goto try_except_handler_2;
                }

                tmp_called_instance_3 = var_markup_attr_map;
                CHECK_OBJECT( var_attr );
                tmp_args_element_name_7 = var_attr;
                frame_9eb6ed3effa667fc4260fde143db8cce->m_frame.f_lineno = 1488;
                {
                    PyObject *call_args[] = { tmp_args_element_name_7 };
                    tmp_assign_source_25 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_get, call_args );
                }

                if ( tmp_assign_source_25 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1488;
                    type_description_1 = "ooooooooooooo";
                    goto try_except_handler_2;
                }
                {
                    PyObject *old = var_attr_value;
                    var_attr_value = tmp_assign_source_25;
                    Py_XDECREF( old );
                }

            }
            {
                nuitka_bool tmp_condition_result_6;
                PyObject *tmp_operand_name_5;
                PyObject *tmp_called_instance_4;
                PyObject *tmp_args_element_name_8;
                PyObject *tmp_args_element_name_9;
                CHECK_OBJECT( par_self );
                tmp_called_instance_4 = par_self;
                CHECK_OBJECT( var_attr_value );
                tmp_args_element_name_8 = var_attr_value;
                CHECK_OBJECT( var_match_against );
                tmp_args_element_name_9 = var_match_against;
                frame_9eb6ed3effa667fc4260fde143db8cce->m_frame.f_lineno = 1489;
                {
                    PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
                    tmp_operand_name_5 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain__matches, call_args );
                }

                if ( tmp_operand_name_5 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1489;
                    type_description_1 = "ooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_res = CHECK_IF_TRUE( tmp_operand_name_5 );
                Py_DECREF( tmp_operand_name_5 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1489;
                    type_description_1 = "ooooooooooooo";
                    goto try_except_handler_2;
                }
                tmp_condition_result_6 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_6;
                }
                else
                {
                    goto branch_no_6;
                }
                branch_yes_6:;
                {
                    PyObject *tmp_assign_source_26;
                    tmp_assign_source_26 = Py_False;
                    {
                        PyObject *old = var_match;
                        assert( old != NULL );
                        var_match = tmp_assign_source_26;
                        Py_INCREF( var_match );
                        Py_DECREF( old );
                    }

                }
                goto loop_end_1;
                branch_no_6:;
            }
            if ( CONSIDER_THREADING() == false )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1480;
                type_description_1 = "ooooooooooooo";
                goto try_except_handler_2;
            }
            goto loop_start_1;
            loop_end_1:;
            goto try_end_6;
            // Exception handler code:
            try_except_handler_2:;
            exception_keeper_type_6 = exception_type;
            exception_keeper_value_6 = exception_value;
            exception_keeper_tb_6 = exception_tb;
            exception_keeper_lineno_6 = exception_lineno;
            exception_type = NULL;
            exception_value = NULL;
            exception_tb = NULL;
            exception_lineno = 0;

            Py_XDECREF( tmp_for_loop_1__iter_value );
            tmp_for_loop_1__iter_value = NULL;

            CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
            Py_DECREF( tmp_for_loop_1__for_iterator );
            tmp_for_loop_1__for_iterator = NULL;

            // Re-raise.
            exception_type = exception_keeper_type_6;
            exception_value = exception_keeper_value_6;
            exception_tb = exception_keeper_tb_6;
            exception_lineno = exception_keeper_lineno_6;

            goto frame_exception_exit_1;
            // End of try:
            try_end_6:;
            Py_XDECREF( tmp_for_loop_1__iter_value );
            tmp_for_loop_1__iter_value = NULL;

            CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
            Py_DECREF( tmp_for_loop_1__for_iterator );
            tmp_for_loop_1__for_iterator = NULL;

            branch_end_3:;
        }
        {
            nuitka_bool tmp_condition_result_7;
            int tmp_truth_name_6;
            if ( var_match == NULL )
            {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "match" );
                exception_tb = NULL;

                exception_lineno = 1492;
                type_description_1 = "ooooooooooooo";
                goto frame_exception_exit_1;
            }

            tmp_truth_name_6 = CHECK_IF_TRUE( var_match );
            if ( tmp_truth_name_6 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1492;
                type_description_1 = "ooooooooooooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_7 = tmp_truth_name_6 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_7;
            }
            else
            {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                nuitka_bool tmp_condition_result_8;
                int tmp_truth_name_7;
                CHECK_OBJECT( var_markup );
                tmp_truth_name_7 = CHECK_IF_TRUE( var_markup );
                if ( tmp_truth_name_7 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1493;
                    type_description_1 = "ooooooooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_8 = tmp_truth_name_7 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_8;
                }
                else
                {
                    goto branch_no_8;
                }
                branch_yes_8:;
                {
                    PyObject *tmp_assign_source_27;
                    CHECK_OBJECT( var_markup );
                    tmp_assign_source_27 = var_markup;
                    {
                        PyObject *old = var_found;
                        assert( old != NULL );
                        var_found = tmp_assign_source_27;
                        Py_INCREF( var_found );
                        Py_DECREF( old );
                    }

                }
                goto branch_end_8;
                branch_no_8:;
                {
                    PyObject *tmp_assign_source_28;
                    CHECK_OBJECT( par_markup_name );
                    tmp_assign_source_28 = par_markup_name;
                    {
                        PyObject *old = var_found;
                        assert( old != NULL );
                        var_found = tmp_assign_source_28;
                        Py_INCREF( var_found );
                        Py_DECREF( old );
                    }

                }
                branch_end_8:;
            }
            branch_no_7:;
        }
        branch_no_2:;
    }
    {
        nuitka_bool tmp_condition_result_9;
        int tmp_and_left_truth_4;
        nuitka_bool tmp_and_left_value_4;
        nuitka_bool tmp_and_right_value_4;
        int tmp_truth_name_8;
        int tmp_and_left_truth_5;
        nuitka_bool tmp_and_left_value_5;
        nuitka_bool tmp_and_right_value_5;
        PyObject *tmp_source_name_9;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_9;
        PyObject *tmp_operand_name_6;
        PyObject *tmp_called_name_3;
        PyObject *tmp_source_name_10;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_source_name_11;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_source_name_12;
        if ( var_found == NULL )
        {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "found" );
            exception_tb = NULL;

            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_truth_name_8 = CHECK_IF_TRUE( var_found );
        if ( tmp_truth_name_8 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_4 = tmp_truth_name_8 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_4 == 1 )
        {
            goto and_right_4;
        }
        else
        {
            goto and_left_4;
        }
        and_right_4:;
        CHECK_OBJECT( par_self );
        tmp_source_name_9 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_text );
        if ( tmp_attribute_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_9 = CHECK_IF_TRUE( tmp_attribute_value_1 );
        if ( tmp_truth_name_9 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_1 );

            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_5 = tmp_truth_name_9 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_1 );
        tmp_and_left_truth_5 = tmp_and_left_value_5 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_5 == 1 )
        {
            goto and_right_5;
        }
        else
        {
            goto and_left_5;
        }
        and_right_5:;
        CHECK_OBJECT( par_self );
        tmp_source_name_10 = par_self;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__matches );
        if ( tmp_called_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        if ( var_found == NULL )
        {
            Py_DECREF( tmp_called_name_3 );
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "found" );
            exception_tb = NULL;

            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_11 = var_found;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_string );
        if ( tmp_args_element_name_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );

            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_self );
        tmp_source_name_12 = par_self;
        tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_text );
        if ( tmp_args_element_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_10 );

            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        frame_9eb6ed3effa667fc4260fde143db8cce->m_frame.f_lineno = 1497;
        {
            PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
            tmp_operand_name_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
        }

        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_10 );
        Py_DECREF( tmp_args_element_name_11 );
        if ( tmp_operand_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_6 );
        Py_DECREF( tmp_operand_name_6 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1497;
            type_description_1 = "ooooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_5 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_right_value_4 = tmp_and_right_value_5;
        goto and_end_5;
        and_left_5:;
        tmp_and_right_value_4 = tmp_and_left_value_5;
        and_end_5:;
        tmp_condition_result_9 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_condition_result_9 = tmp_and_left_value_4;
        and_end_4:;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_9;
        }
        else
        {
            goto branch_no_9;
        }
        branch_yes_9:;
        {
            PyObject *tmp_assign_source_29;
            tmp_assign_source_29 = Py_None;
            {
                PyObject *old = var_found;
                var_found = tmp_assign_source_29;
                Py_INCREF( var_found );
                Py_XDECREF( old );
            }

        }
        branch_no_9:;
    }
    if ( var_found == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "found" );
        exception_tb = NULL;

        exception_lineno = 1499;
        type_description_1 = "ooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_found;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9eb6ed3effa667fc4260fde143db8cce );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9eb6ed3effa667fc4260fde143db8cce );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9eb6ed3effa667fc4260fde143db8cce );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9eb6ed3effa667fc4260fde143db8cce, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9eb6ed3effa667fc4260fde143db8cce->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9eb6ed3effa667fc4260fde143db8cce, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9eb6ed3effa667fc4260fde143db8cce,
        type_description_1,
        par_self,
        par_markup_name,
        par_markup_attrs,
        var_markup,
        var_match_against,
        var_k,
        var_markup_attr_map,
        var_attr_value,
        var_v,
        var_found,
        var_call_function_with_tag_data,
        var_match,
        var_attr
    );


    // Release cached frame.
    if ( frame_9eb6ed3effa667fc4260fde143db8cce == cache_frame_9eb6ed3effa667fc4260fde143db8cce )
    {
        Py_DECREF( frame_9eb6ed3effa667fc4260fde143db8cce );
    }
    cache_frame_9eb6ed3effa667fc4260fde143db8cce = NULL;

    assertFrameObject( frame_9eb6ed3effa667fc4260fde143db8cce );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_110_search_tag );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_markup );
    Py_DECREF( var_markup );
    var_markup = NULL;

    Py_XDECREF( var_match_against );
    var_match_against = NULL;

    CHECK_OBJECT( (PyObject *)par_markup_name );
    Py_DECREF( par_markup_name );
    par_markup_name = NULL;

    Py_XDECREF( var_k );
    var_k = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_markup_attr_map );
    var_markup_attr_map = NULL;

    CHECK_OBJECT( (PyObject *)par_markup_attrs );
    Py_DECREF( par_markup_attrs );
    par_markup_attrs = NULL;

    Py_XDECREF( var_attr_value );
    var_attr_value = NULL;

    Py_XDECREF( var_v );
    var_v = NULL;

    Py_XDECREF( var_found );
    var_found = NULL;

    CHECK_OBJECT( (PyObject *)var_call_function_with_tag_data );
    Py_DECREF( var_call_function_with_tag_data );
    var_call_function_with_tag_data = NULL;

    Py_XDECREF( var_match );
    var_match = NULL;

    Py_XDECREF( var_attr );
    var_attr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_markup );
    var_markup = NULL;

    Py_XDECREF( var_match_against );
    var_match_against = NULL;

    CHECK_OBJECT( (PyObject *)par_markup_name );
    Py_DECREF( par_markup_name );
    par_markup_name = NULL;

    Py_XDECREF( var_k );
    var_k = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_markup_attr_map );
    var_markup_attr_map = NULL;

    Py_XDECREF( par_markup_attrs );
    par_markup_attrs = NULL;

    Py_XDECREF( var_attr_value );
    var_attr_value = NULL;

    Py_XDECREF( var_v );
    var_v = NULL;

    Py_XDECREF( var_found );
    var_found = NULL;

    Py_XDECREF( var_call_function_with_tag_data );
    var_call_function_with_tag_data = NULL;

    Py_XDECREF( var_match );
    var_match = NULL;

    Py_XDECREF( var_attr );
    var_attr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_110_search_tag );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_111_search( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_markup = python_pars[ 1 ];
    PyObject *var_found = NULL;
    PyObject *var_element = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_7ad6e7a72b48702f9e5b43452fda84eb;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_7ad6e7a72b48702f9e5b43452fda84eb = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert( var_found == NULL );
        Py_INCREF( tmp_assign_source_1 );
        var_found = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7ad6e7a72b48702f9e5b43452fda84eb, codeobj_7ad6e7a72b48702f9e5b43452fda84eb, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_7ad6e7a72b48702f9e5b43452fda84eb = cache_frame_7ad6e7a72b48702f9e5b43452fda84eb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7ad6e7a72b48702f9e5b43452fda84eb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7ad6e7a72b48702f9e5b43452fda84eb ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_attribute_name_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_markup );
        tmp_source_name_1 = par_markup;
        tmp_attribute_name_1 = const_str_plain___iter__;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_1, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_markup );
        tmp_isinstance_inst_1 = par_markup;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
            exception_tb = NULL;

            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_tuple_element_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
        tmp_tuple_element_1 = (PyObject *)&PyBaseString_Type;
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1507;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_markup );
            tmp_iter_arg_1 = par_markup;
            tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1508;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_2;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_3 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooo";
                    exception_lineno = 1508;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_3;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_4 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_element;
                var_element = tmp_assign_source_4;
                Py_INCREF( var_element );
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_2;
            int tmp_and_left_truth_2;
            nuitka_bool tmp_and_left_value_2;
            nuitka_bool tmp_and_right_value_2;
            PyObject *tmp_isinstance_inst_2;
            PyObject *tmp_isinstance_cls_2;
            PyObject *tmp_mvar_value_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            int tmp_truth_name_1;
            CHECK_OBJECT( var_element );
            tmp_isinstance_inst_2 = var_element;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

            if (unlikely( tmp_mvar_value_2 == NULL ))
            {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
            }

            if ( tmp_mvar_value_2 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
                exception_tb = NULL;

                exception_lineno = 1509;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }

            tmp_isinstance_cls_2 = tmp_mvar_value_2;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1509;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_and_left_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
            if ( tmp_and_left_truth_2 == 1 )
            {
                goto and_right_2;
            }
            else
            {
                goto and_left_2;
            }
            and_right_2:;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( var_element );
            tmp_args_element_name_1 = var_element;
            frame_7ad6e7a72b48702f9e5b43452fda84eb->m_frame.f_lineno = 1510;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_search, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1510;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_call_result_1 );

                exception_lineno = 1510;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            tmp_and_right_value_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_1 );
            tmp_condition_result_2 = tmp_and_right_value_2;
            goto and_end_2;
            and_left_2:;
            tmp_condition_result_2 = tmp_and_left_value_2;
            and_end_2:;
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_assign_source_5;
                CHECK_OBJECT( var_element );
                tmp_assign_source_5 = var_element;
                {
                    PyObject *old = var_found;
                    assert( old != NULL );
                    var_found = tmp_assign_source_5;
                    Py_INCREF( var_found );
                    Py_DECREF( old );
                }

            }
            goto loop_end_1;
            branch_no_2:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1508;
            type_description_1 = "oooo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_isinstance_inst_3;
            PyObject *tmp_isinstance_cls_3;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT( par_markup );
            tmp_isinstance_inst_3 = par_markup;
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

            if (unlikely( tmp_mvar_value_3 == NULL ))
            {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
            }

            if ( tmp_mvar_value_3 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
                exception_tb = NULL;

                exception_lineno = 1515;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_isinstance_cls_3 = tmp_mvar_value_3;
            tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1515;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                nuitka_bool tmp_condition_result_4;
                int tmp_or_left_truth_1;
                nuitka_bool tmp_or_left_value_1;
                nuitka_bool tmp_or_right_value_1;
                PyObject *tmp_operand_name_2;
                PyObject *tmp_source_name_2;
                int tmp_or_left_truth_2;
                nuitka_bool tmp_or_left_value_2;
                nuitka_bool tmp_or_right_value_2;
                PyObject *tmp_source_name_3;
                PyObject *tmp_attribute_value_1;
                int tmp_truth_name_2;
                PyObject *tmp_source_name_4;
                PyObject *tmp_attribute_value_2;
                int tmp_truth_name_3;
                CHECK_OBJECT( par_self );
                tmp_source_name_2 = par_self;
                tmp_operand_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_text );
                if ( tmp_operand_name_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1516;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
                Py_DECREF( tmp_operand_name_2 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1516;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_left_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_or_left_truth_1 == 1 )
                {
                    goto or_left_1;
                }
                else
                {
                    goto or_right_1;
                }
                or_right_1:;
                CHECK_OBJECT( par_self );
                tmp_source_name_3 = par_self;
                tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_name );
                if ( tmp_attribute_value_1 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1516;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_2 = CHECK_IF_TRUE( tmp_attribute_value_1 );
                if ( tmp_truth_name_2 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_attribute_value_1 );

                    exception_lineno = 1516;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_left_value_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_attribute_value_1 );
                tmp_or_left_truth_2 = tmp_or_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_or_left_truth_2 == 1 )
                {
                    goto or_left_2;
                }
                else
                {
                    goto or_right_2;
                }
                or_right_2:;
                CHECK_OBJECT( par_self );
                tmp_source_name_4 = par_self;
                tmp_attribute_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_attrs );
                if ( tmp_attribute_value_2 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1516;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_truth_name_3 = CHECK_IF_TRUE( tmp_attribute_value_2 );
                if ( tmp_truth_name_3 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_attribute_value_2 );

                    exception_lineno = 1516;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_right_value_2 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_attribute_value_2 );
                tmp_or_right_value_1 = tmp_or_right_value_2;
                goto or_end_2;
                or_left_2:;
                tmp_or_right_value_1 = tmp_or_left_value_2;
                or_end_2:;
                tmp_condition_result_4 = tmp_or_right_value_1;
                goto or_end_1;
                or_left_1:;
                tmp_condition_result_4 = tmp_or_left_value_1;
                or_end_1:;
                if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_4;
                }
                else
                {
                    goto branch_no_4;
                }
                branch_yes_4:;
                {
                    PyObject *tmp_assign_source_6;
                    PyObject *tmp_called_instance_2;
                    PyObject *tmp_args_element_name_2;
                    CHECK_OBJECT( par_self );
                    tmp_called_instance_2 = par_self;
                    CHECK_OBJECT( par_markup );
                    tmp_args_element_name_2 = par_markup;
                    frame_7ad6e7a72b48702f9e5b43452fda84eb->m_frame.f_lineno = 1517;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_2 };
                        tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_search_tag, call_args );
                    }

                    if ( tmp_assign_source_6 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1517;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    {
                        PyObject *old = var_found;
                        assert( old != NULL );
                        var_found = tmp_assign_source_6;
                        Py_DECREF( old );
                    }

                }
                branch_no_4:;
            }
            goto branch_end_3;
            branch_no_3:;
            {
                nuitka_bool tmp_condition_result_5;
                int tmp_or_left_truth_3;
                nuitka_bool tmp_or_left_value_3;
                nuitka_bool tmp_or_right_value_3;
                PyObject *tmp_isinstance_inst_4;
                PyObject *tmp_isinstance_cls_4;
                PyObject *tmp_mvar_value_4;
                PyObject *tmp_isinstance_inst_5;
                PyObject *tmp_isinstance_cls_5;
                CHECK_OBJECT( par_markup );
                tmp_isinstance_inst_4 = par_markup;
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

                if (unlikely( tmp_mvar_value_4 == NULL ))
                {
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
                }

                if ( tmp_mvar_value_4 == NULL )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "global name '%s' is not defined", "NavigableString" );
                    exception_tb = NULL;

                    exception_lineno = 1519;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_isinstance_cls_4 = tmp_mvar_value_4;
                tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_4, tmp_isinstance_cls_4 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1519;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_left_value_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_or_left_truth_3 = tmp_or_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
                if ( tmp_or_left_truth_3 == 1 )
                {
                    goto or_left_3;
                }
                else
                {
                    goto or_right_3;
                }
                or_right_3:;
                CHECK_OBJECT( par_markup );
                tmp_isinstance_inst_5 = par_markup;
                tmp_isinstance_cls_5 = (PyObject *)&PyBaseString_Type;
                tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_5, tmp_isinstance_cls_5 );
                if ( tmp_res == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1520;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                tmp_or_right_value_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                tmp_condition_result_5 = tmp_or_right_value_3;
                goto or_end_3;
                or_left_3:;
                tmp_condition_result_5 = tmp_or_left_value_3;
                or_end_3:;
                if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_5;
                }
                else
                {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    nuitka_bool tmp_condition_result_6;
                    int tmp_and_left_truth_3;
                    nuitka_bool tmp_and_left_value_3;
                    nuitka_bool tmp_and_right_value_3;
                    PyObject *tmp_operand_name_3;
                    PyObject *tmp_source_name_5;
                    int tmp_and_left_truth_4;
                    nuitka_bool tmp_and_left_value_4;
                    nuitka_bool tmp_and_right_value_4;
                    PyObject *tmp_operand_name_4;
                    PyObject *tmp_source_name_6;
                    PyObject *tmp_called_name_1;
                    PyObject *tmp_source_name_7;
                    PyObject *tmp_call_result_2;
                    PyObject *tmp_args_element_name_3;
                    PyObject *tmp_args_element_name_4;
                    PyObject *tmp_source_name_8;
                    int tmp_truth_name_4;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_5 = par_self;
                    tmp_operand_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_name );
                    if ( tmp_operand_name_3 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
                    Py_DECREF( tmp_operand_name_3 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_and_left_value_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
                    if ( tmp_and_left_truth_3 == 1 )
                    {
                        goto and_right_3;
                    }
                    else
                    {
                        goto and_left_3;
                    }
                    and_right_3:;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_6 = par_self;
                    tmp_operand_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_attrs );
                    if ( tmp_operand_name_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
                    Py_DECREF( tmp_operand_name_4 );
                    if ( tmp_res == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_and_left_value_4 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
                    if ( tmp_and_left_truth_4 == 1 )
                    {
                        goto and_right_4;
                    }
                    else
                    {
                        goto and_left_4;
                    }
                    and_right_4:;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_7 = par_self;
                    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__matches );
                    if ( tmp_called_name_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    CHECK_OBJECT( par_markup );
                    tmp_args_element_name_3 = par_markup;
                    CHECK_OBJECT( par_self );
                    tmp_source_name_8 = par_self;
                    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_text );
                    if ( tmp_args_element_name_4 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_called_name_1 );

                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    frame_7ad6e7a72b48702f9e5b43452fda84eb->m_frame.f_lineno = 1521;
                    {
                        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
                        tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
                    }

                    Py_DECREF( tmp_called_name_1 );
                    Py_DECREF( tmp_args_element_name_4 );
                    if ( tmp_call_result_2 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_truth_name_4 = CHECK_IF_TRUE( tmp_call_result_2 );
                    if ( tmp_truth_name_4 == -1 )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                        Py_DECREF( tmp_call_result_2 );

                        exception_lineno = 1521;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_and_right_value_4 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    Py_DECREF( tmp_call_result_2 );
                    tmp_and_right_value_3 = tmp_and_right_value_4;
                    goto and_end_4;
                    and_left_4:;
                    tmp_and_right_value_3 = tmp_and_left_value_4;
                    and_end_4:;
                    tmp_condition_result_6 = tmp_and_right_value_3;
                    goto and_end_3;
                    and_left_3:;
                    tmp_condition_result_6 = tmp_and_left_value_3;
                    and_end_3:;
                    if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
                    {
                        goto branch_yes_6;
                    }
                    else
                    {
                        goto branch_no_6;
                    }
                    branch_yes_6:;
                    {
                        PyObject *tmp_assign_source_7;
                        CHECK_OBJECT( par_markup );
                        tmp_assign_source_7 = par_markup;
                        {
                            PyObject *old = var_found;
                            assert( old != NULL );
                            var_found = tmp_assign_source_7;
                            Py_INCREF( var_found );
                            Py_DECREF( old );
                        }

                    }
                    branch_no_6:;
                }
                goto branch_end_5;
                branch_no_5:;
                {
                    PyObject *tmp_raise_type_1;
                    PyObject *tmp_make_exception_arg_1;
                    PyObject *tmp_left_name_1;
                    PyObject *tmp_right_name_1;
                    PyObject *tmp_source_name_9;
                    tmp_left_name_1 = const_str_digest_a635dc2cd109c09bc1bdcdd8ac24874a;
                    CHECK_OBJECT( par_markup );
                    tmp_source_name_9 = par_markup;
                    tmp_right_name_1 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_9 );
                    if ( tmp_right_name_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1525;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
                    Py_DECREF( tmp_right_name_1 );
                    if ( tmp_make_exception_arg_1 == NULL )
                    {
                        assert( ERROR_OCCURRED() );

                        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                        exception_lineno = 1525;
                        type_description_1 = "oooo";
                        goto frame_exception_exit_1;
                    }
                    frame_7ad6e7a72b48702f9e5b43452fda84eb->m_frame.f_lineno = 1524;
                    {
                        PyObject *call_args[] = { tmp_make_exception_arg_1 };
                        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_Exception, call_args );
                    }

                    Py_DECREF( tmp_make_exception_arg_1 );
                    assert( !(tmp_raise_type_1 == NULL) );
                    exception_type = tmp_raise_type_1;
                    exception_lineno = 1524;
                    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                branch_end_5:;
            }
            branch_end_3:;
        }
        branch_end_1:;
    }
    if ( var_found == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "found" );
        exception_tb = NULL;

        exception_lineno = 1526;
        type_description_1 = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_found;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ad6e7a72b48702f9e5b43452fda84eb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ad6e7a72b48702f9e5b43452fda84eb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ad6e7a72b48702f9e5b43452fda84eb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7ad6e7a72b48702f9e5b43452fda84eb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7ad6e7a72b48702f9e5b43452fda84eb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7ad6e7a72b48702f9e5b43452fda84eb, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7ad6e7a72b48702f9e5b43452fda84eb,
        type_description_1,
        par_self,
        par_markup,
        var_found,
        var_element
    );


    // Release cached frame.
    if ( frame_7ad6e7a72b48702f9e5b43452fda84eb == cache_frame_7ad6e7a72b48702f9e5b43452fda84eb )
    {
        Py_DECREF( frame_7ad6e7a72b48702f9e5b43452fda84eb );
    }
    cache_frame_7ad6e7a72b48702f9e5b43452fda84eb = NULL;

    assertFrameObject( frame_7ad6e7a72b48702f9e5b43452fda84eb );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_111_search );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( var_found );
    var_found = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_markup );
    Py_DECREF( par_markup );
    par_markup = NULL;

    Py_XDECREF( var_element );
    var_element = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var_found );
    var_found = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_markup );
    Py_DECREF( par_markup );
    par_markup = NULL;

    Py_XDECREF( var_element );
    var_element = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_111_search );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_112__matches( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_markup = python_pars[ 1 ];
    PyObject *par_match_against = python_pars[ 2 ];
    PyObject *par_already_tried = python_pars[ 3 ];
    PyObject *var_original_markup = NULL;
    PyObject *var_item = NULL;
    PyObject *var_key = NULL;
    PyObject *var_match = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    struct Nuitka_FrameObject *frame_2f876307bed7434c370747ea48135869;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    static struct Nuitka_FrameObject *cache_frame_2f876307bed7434c370747ea48135869 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f876307bed7434c370747ea48135869, codeobj_2f876307bed7434c370747ea48135869, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_2f876307bed7434c370747ea48135869 = cache_frame_2f876307bed7434c370747ea48135869;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f876307bed7434c370747ea48135869 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f876307bed7434c370747ea48135869 ) == 2 ); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT( par_markup );
        tmp_isinstance_inst_1 = par_markup;
        tmp_isinstance_cls_1 = (PyObject *)&PyList_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1531;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_or_left_truth_1 == 1 )
        {
            goto or_left_1;
        }
        else
        {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT( par_markup );
        tmp_isinstance_inst_2 = par_markup;
        tmp_isinstance_cls_2 = (PyObject *)&PyTuple_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1531;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_1 = tmp_or_left_value_1;
        or_end_1:;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_1;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT( par_markup );
            tmp_iter_arg_1 = par_markup;
            tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
            if ( tmp_assign_source_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1534;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_1__for_iterator == NULL );
            tmp_for_loop_1__for_iterator = tmp_assign_source_1;
        }
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_2;
            CHECK_OBJECT( tmp_for_loop_1__for_iterator );
            tmp_next_source_1 = tmp_for_loop_1__for_iterator;
            tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_2 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooNoo";
                    exception_lineno = 1534;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_for_loop_1__iter_value;
                tmp_for_loop_1__iter_value = tmp_assign_source_2;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_3;
            CHECK_OBJECT( tmp_for_loop_1__iter_value );
            tmp_assign_source_3 = tmp_for_loop_1__iter_value;
            {
                PyObject *old = var_item;
                var_item = tmp_assign_source_3;
                Py_INCREF( var_item );
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            int tmp_truth_name_1;
            CHECK_OBJECT( par_self );
            tmp_called_instance_1 = par_self;
            CHECK_OBJECT( var_item );
            tmp_args_element_name_1 = var_item;
            CHECK_OBJECT( par_match_against );
            tmp_args_element_name_2 = par_match_against;
            frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1535;
            {
                PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain__matches, call_args );
            }

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1535;
                type_description_1 = "ooooooNoo";
                goto try_except_handler_2;
            }
            tmp_truth_name_1 = CHECK_IF_TRUE( tmp_call_result_1 );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_call_result_1 );

                exception_lineno = 1535;
                type_description_1 = "ooooooNoo";
                goto try_except_handler_2;
            }
            tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_1 );
            if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_2;
            }
            else
            {
                goto branch_no_2;
            }
            branch_yes_2:;
            tmp_return_value = Py_True;
            Py_INCREF( tmp_return_value );
            goto try_return_handler_2;
            branch_no_2:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1534;
            type_description_1 = "ooooooNoo";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        goto try_end_1;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__iter_value );
        Py_DECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_1;
        // End of try:
        try_end_1:;
        Py_XDECREF( tmp_for_loop_1__iter_value );
        tmp_for_loop_1__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
        Py_DECREF( tmp_for_loop_1__for_iterator );
        tmp_for_loop_1__for_iterator = NULL;

        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            int tmp_truth_name_2;
            CHECK_OBJECT( par_self );
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__matches );
            if ( tmp_called_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1540;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            tmp_called_instance_2 = const_str_space;
            CHECK_OBJECT( par_markup );
            tmp_args_element_name_4 = par_markup;
            frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1540;
            {
                PyObject *call_args[] = { tmp_args_element_name_4 };
                tmp_args_element_name_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_join, call_args );
            }

            if ( tmp_args_element_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_1 );

                exception_lineno = 1540;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_match_against );
            tmp_args_element_name_5 = par_match_against;
            frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1540;
            {
                PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_5 };
                tmp_call_result_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
            }

            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_args_element_name_3 );
            if ( tmp_call_result_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1540;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            tmp_truth_name_2 = CHECK_IF_TRUE( tmp_call_result_2 );
            if ( tmp_truth_name_2 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_call_result_2 );

                exception_lineno = 1540;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_3 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_call_result_2 );
            if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            tmp_return_value = Py_True;
            Py_INCREF( tmp_return_value );
            goto frame_return_exit_1;
            branch_no_3:;
        }
        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_match_against );
        tmp_compexpr_left_1 = par_match_against;
        tmp_compexpr_right_1 = Py_True;
        tmp_condition_result_4 = ( tmp_compexpr_left_1 == tmp_compexpr_right_1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_4;
        }
        else
        {
            goto branch_no_4;
        }
        branch_yes_4:;
        {
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT( par_markup );
            tmp_compexpr_left_2 = par_markup;
            tmp_compexpr_right_2 = Py_None;
            tmp_return_value = ( tmp_compexpr_left_2 != tmp_compexpr_right_2 ) ? Py_True : Py_False;
            Py_INCREF( tmp_return_value );
            goto frame_return_exit_1;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT( par_match_against );
        tmp_isinstance_inst_3 = par_match_against;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Callable );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Callable" );
            exception_tb = NULL;

            exception_lineno = 1548;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_3 = tmp_mvar_value_1;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1548;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_5;
        }
        else
        {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_called_name_2;
            PyObject *tmp_args_element_name_6;
            CHECK_OBJECT( par_match_against );
            tmp_called_name_2 = par_match_against;
            CHECK_OBJECT( par_markup );
            tmp_args_element_name_6 = par_markup;
            frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1549;
            {
                PyObject *call_args[] = { tmp_args_element_name_6 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1549;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_5:;
    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT( par_markup );
        tmp_assign_source_4 = par_markup;
        assert( var_original_markup == NULL );
        Py_INCREF( tmp_assign_source_4 );
        var_original_markup = tmp_assign_source_4;
    }
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_isinstance_inst_4;
        PyObject *tmp_isinstance_cls_4;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT( par_markup );
        tmp_isinstance_inst_4 = par_markup;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
            exception_tb = NULL;

            exception_lineno = 1554;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_4 = tmp_mvar_value_2;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_4, tmp_isinstance_cls_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1554;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_6;
        }
        else
        {
            goto branch_no_6;
        }
        branch_yes_6:;
        {
            PyObject *tmp_assign_source_5;
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( par_markup );
            tmp_source_name_2 = par_markup;
            tmp_assign_source_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
            if ( tmp_assign_source_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1555;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = par_markup;
                assert( old != NULL );
                par_markup = tmp_assign_source_5;
                Py_DECREF( old );
            }

        }
        branch_no_6:;
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_7;
        CHECK_OBJECT( par_self );
        tmp_called_instance_3 = par_self;
        CHECK_OBJECT( par_markup );
        tmp_args_element_name_7 = par_markup;
        frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1558;
        {
            PyObject *call_args[] = { tmp_args_element_name_7 };
            tmp_assign_source_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain__normalize_search_value, call_args );
        }

        if ( tmp_assign_source_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1558;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_markup;
            assert( old != NULL );
            par_markup = tmp_assign_source_6;
            Py_DECREF( old );
        }

    }
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( par_markup );
        tmp_compexpr_left_3 = par_markup;
        tmp_compexpr_right_3 = Py_None;
        tmp_condition_result_7 = ( tmp_compexpr_left_3 == tmp_compexpr_right_3 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_7;
        }
        else
        {
            goto branch_no_7;
        }
        branch_yes_7:;
        {
            PyObject *tmp_operand_name_1;
            CHECK_OBJECT( par_match_against );
            tmp_operand_name_1 = par_match_against;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_1 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1562;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = ( tmp_res == 0 ) ? Py_True : Py_False;
            Py_INCREF( tmp_return_value );
            goto frame_return_exit_1;
        }
        branch_no_7:;
    }
    {
        nuitka_bool tmp_condition_result_8;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_attribute_name_1;
        PyObject *tmp_operand_name_2;
        PyObject *tmp_isinstance_inst_5;
        PyObject *tmp_isinstance_cls_5;
        CHECK_OBJECT( par_match_against );
        tmp_source_name_3 = par_match_against;
        tmp_attribute_name_1 = const_str_plain___iter__;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_3, tmp_attribute_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1564;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_1 == 1 )
        {
            goto and_right_1;
        }
        else
        {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT( par_match_against );
        tmp_isinstance_inst_5 = par_match_against;
        tmp_isinstance_cls_5 = (PyObject *)&PyBaseString_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_5, tmp_isinstance_cls_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1565;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_2 = ( tmp_res != 0 ) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1565;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_1 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_8 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_8 = tmp_and_left_value_1;
        and_end_1:;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_8;
        }
        else
        {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            nuitka_bool tmp_condition_result_9;
            PyObject *tmp_operand_name_3;
            CHECK_OBJECT( par_already_tried );
            tmp_operand_name_3 = par_already_tried;
            tmp_res = CHECK_IF_TRUE( tmp_operand_name_3 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1572;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            tmp_condition_result_9 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_9;
            }
            else
            {
                goto branch_no_9;
            }
            branch_yes_9:;
            {
                PyObject *tmp_assign_source_7;
                tmp_assign_source_7 = PySet_New( NULL );
                {
                    PyObject *old = par_already_tried;
                    assert( old != NULL );
                    par_already_tried = tmp_assign_source_7;
                    Py_DECREF( old );
                }

            }
            branch_no_9:;
        }
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_iter_arg_2;
            CHECK_OBJECT( par_match_against );
            tmp_iter_arg_2 = par_match_against;
            tmp_assign_source_8 = MAKE_ITERATOR( tmp_iter_arg_2 );
            if ( tmp_assign_source_8 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1574;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            assert( tmp_for_loop_2__for_iterator == NULL );
            tmp_for_loop_2__for_iterator = tmp_assign_source_8;
        }
        // Tried code:
        loop_start_2:;
        {
            PyObject *tmp_next_source_2;
            PyObject *tmp_assign_source_9;
            CHECK_OBJECT( tmp_for_loop_2__for_iterator );
            tmp_next_source_2 = tmp_for_loop_2__for_iterator;
            tmp_assign_source_9 = ITERATOR_NEXT( tmp_next_source_2 );
            if ( tmp_assign_source_9 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_2;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_1 = "ooooooNoo";
                    exception_lineno = 1574;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_for_loop_2__iter_value;
                tmp_for_loop_2__iter_value = tmp_assign_source_9;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_10;
            CHECK_OBJECT( tmp_for_loop_2__iter_value );
            tmp_assign_source_10 = tmp_for_loop_2__iter_value;
            {
                PyObject *old = var_item;
                var_item = tmp_assign_source_10;
                Py_INCREF( var_item );
                Py_XDECREF( old );
            }

        }
        {
            nuitka_bool tmp_condition_result_10;
            PyObject *tmp_source_name_4;
            PyObject *tmp_attribute_value_1;
            int tmp_truth_name_3;
            CHECK_OBJECT( var_item );
            tmp_source_name_4 = var_item;
            tmp_attribute_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___hash__ );
            if ( tmp_attribute_value_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1575;
                type_description_1 = "ooooooNoo";
                goto try_except_handler_3;
            }
            tmp_truth_name_3 = CHECK_IF_TRUE( tmp_attribute_value_1 );
            if ( tmp_truth_name_3 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_attribute_value_1 );

                exception_lineno = 1575;
                type_description_1 = "ooooooNoo";
                goto try_except_handler_3;
            }
            tmp_condition_result_10 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            Py_DECREF( tmp_attribute_value_1 );
            if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_10;
            }
            else
            {
                goto branch_no_10;
            }
            branch_yes_10:;
            {
                PyObject *tmp_assign_source_11;
                CHECK_OBJECT( var_item );
                tmp_assign_source_11 = var_item;
                {
                    PyObject *old = var_key;
                    var_key = tmp_assign_source_11;
                    Py_INCREF( var_key );
                    Py_XDECREF( old );
                }

            }
            goto branch_end_10;
            branch_no_10:;
            {
                PyObject *tmp_assign_source_12;
                PyObject *tmp_id_arg_1;
                CHECK_OBJECT( var_item );
                tmp_id_arg_1 = var_item;
                tmp_assign_source_12 = PyLong_FromVoidPtr( tmp_id_arg_1 );
                if ( tmp_assign_source_12 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1578;
                    type_description_1 = "ooooooNoo";
                    goto try_except_handler_3;
                }
                {
                    PyObject *old = var_key;
                    var_key = tmp_assign_source_12;
                    Py_XDECREF( old );
                }

            }
            branch_end_10:;
        }
        {
            nuitka_bool tmp_condition_result_11;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            CHECK_OBJECT( var_key );
            tmp_compexpr_left_4 = var_key;
            CHECK_OBJECT( par_already_tried );
            tmp_compexpr_right_4 = par_already_tried;
            tmp_res = PySequence_Contains( tmp_compexpr_right_4, tmp_compexpr_left_4 );
            if ( tmp_res == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1579;
                type_description_1 = "ooooooNoo";
                goto try_except_handler_3;
            }
            tmp_condition_result_11 = ( tmp_res == 1 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_11;
            }
            else
            {
                goto branch_no_11;
            }
            branch_yes_11:;
            goto loop_start_2;
            goto branch_end_11;
            branch_no_11:;
            {
                PyObject *tmp_called_instance_4;
                PyObject *tmp_call_result_3;
                PyObject *tmp_args_element_name_8;
                CHECK_OBJECT( par_already_tried );
                tmp_called_instance_4 = par_already_tried;
                CHECK_OBJECT( var_key );
                tmp_args_element_name_8 = var_key;
                frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1582;
                {
                    PyObject *call_args[] = { tmp_args_element_name_8 };
                    tmp_call_result_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_add, call_args );
                }

                if ( tmp_call_result_3 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1582;
                    type_description_1 = "ooooooNoo";
                    goto try_except_handler_3;
                }
                Py_DECREF( tmp_call_result_3 );
            }
            {
                nuitka_bool tmp_condition_result_12;
                PyObject *tmp_called_instance_5;
                PyObject *tmp_call_result_4;
                PyObject *tmp_args_element_name_9;
                PyObject *tmp_args_element_name_10;
                PyObject *tmp_args_element_name_11;
                int tmp_truth_name_4;
                CHECK_OBJECT( par_self );
                tmp_called_instance_5 = par_self;
                CHECK_OBJECT( var_original_markup );
                tmp_args_element_name_9 = var_original_markup;
                CHECK_OBJECT( var_item );
                tmp_args_element_name_10 = var_item;
                CHECK_OBJECT( par_already_tried );
                tmp_args_element_name_11 = par_already_tried;
                frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1583;
                {
                    PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
                    tmp_call_result_4 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_5, const_str_plain__matches, call_args );
                }

                if ( tmp_call_result_4 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1583;
                    type_description_1 = "ooooooNoo";
                    goto try_except_handler_3;
                }
                tmp_truth_name_4 = CHECK_IF_TRUE( tmp_call_result_4 );
                if ( tmp_truth_name_4 == -1 )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    Py_DECREF( tmp_call_result_4 );

                    exception_lineno = 1583;
                    type_description_1 = "ooooooNoo";
                    goto try_except_handler_3;
                }
                tmp_condition_result_12 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                Py_DECREF( tmp_call_result_4 );
                if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
                {
                    goto branch_yes_12;
                }
                else
                {
                    goto branch_no_12;
                }
                branch_yes_12:;
                tmp_return_value = Py_True;
                Py_INCREF( tmp_return_value );
                goto try_return_handler_3;
                branch_no_12:;
            }
            branch_end_11:;
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1574;
            type_description_1 = "ooooooNoo";
            goto try_except_handler_3;
        }
        goto loop_start_2;
        loop_end_2:;
        goto try_end_2;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__iter_value );
        Py_DECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto frame_exception_exit_1;
        // End of try:
        try_end_2:;
        Py_XDECREF( tmp_for_loop_2__iter_value );
        tmp_for_loop_2__iter_value = NULL;

        CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
        Py_DECREF( tmp_for_loop_2__for_iterator );
        tmp_for_loop_2__for_iterator = NULL;

        tmp_return_value = Py_False;
        Py_INCREF( tmp_return_value );
        goto frame_return_exit_1;
        branch_no_8:;
    }
    {
        PyObject *tmp_assign_source_13;
        tmp_assign_source_13 = Py_False;
        assert( var_match == NULL );
        Py_INCREF( tmp_assign_source_13 );
        var_match = tmp_assign_source_13;
    }
    {
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_isinstance_inst_6;
        PyObject *tmp_isinstance_cls_6;
        CHECK_OBJECT( par_match_against );
        tmp_isinstance_inst_6 = par_match_against;
        tmp_isinstance_cls_6 = (PyObject *)&PyUnicode_Type;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_6, tmp_isinstance_cls_6 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1592;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_13 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_13;
        }
        else
        {
            goto branch_no_13;
        }
        branch_yes_13:;
        {
            PyObject *tmp_assign_source_14;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            CHECK_OBJECT( par_markup );
            tmp_compexpr_left_5 = par_markup;
            CHECK_OBJECT( par_match_against );
            tmp_compexpr_right_5 = par_match_against;
            tmp_assign_source_14 = RICH_COMPARE_EQ_OBJECT_OBJECT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
            if ( tmp_assign_source_14 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1594;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            {
                PyObject *old = var_match;
                assert( old != NULL );
                var_match = tmp_assign_source_14;
                Py_DECREF( old );
            }

        }
        branch_no_13:;
    }
    {
        nuitka_bool tmp_condition_result_14;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_operand_name_4;
        PyObject *tmp_source_name_5;
        PyObject *tmp_attribute_name_2;
        CHECK_OBJECT( var_match );
        tmp_operand_name_4 = var_match;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_4 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1596;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_2 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_2 == 1 )
        {
            goto and_right_2;
        }
        else
        {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT( par_match_against );
        tmp_source_name_5 = par_match_against;
        tmp_attribute_name_2 = const_str_plain_search;
        tmp_res = BUILTIN_HASATTR_BOOL( tmp_source_name_5, tmp_attribute_name_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1596;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_14 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_14 = tmp_and_left_value_2;
        and_end_2:;
        if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_14;
        }
        else
        {
            goto branch_no_14;
        }
        branch_yes_14:;
        {
            PyObject *tmp_called_instance_6;
            PyObject *tmp_args_element_name_12;
            CHECK_OBJECT( par_match_against );
            tmp_called_instance_6 = par_match_against;
            CHECK_OBJECT( par_markup );
            tmp_args_element_name_12 = par_markup;
            frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1598;
            {
                PyObject *call_args[] = { tmp_args_element_name_12 };
                tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_search, call_args );
            }

            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1598;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_14:;
    }
    {
        nuitka_bool tmp_condition_result_15;
        int tmp_and_left_truth_3;
        nuitka_bool tmp_and_left_value_3;
        nuitka_bool tmp_and_right_value_3;
        PyObject *tmp_operand_name_5;
        int tmp_and_left_truth_4;
        nuitka_bool tmp_and_left_value_4;
        nuitka_bool tmp_and_right_value_4;
        PyObject *tmp_isinstance_inst_7;
        PyObject *tmp_isinstance_cls_7;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_source_name_6;
        PyObject *tmp_attribute_value_2;
        int tmp_truth_name_5;
        CHECK_OBJECT( var_match );
        tmp_operand_name_5 = var_match;
        tmp_res = CHECK_IF_TRUE( tmp_operand_name_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1600;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_3 = ( tmp_res == 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_3 = tmp_and_left_value_3 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_3 == 1 )
        {
            goto and_right_3;
        }
        else
        {
            goto and_left_3;
        }
        and_right_3:;
        CHECK_OBJECT( var_original_markup );
        tmp_isinstance_inst_7 = var_original_markup;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Tag );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "Tag" );
            exception_tb = NULL;

            exception_lineno = 1601;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }

        tmp_isinstance_cls_7 = tmp_mvar_value_3;
        tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_7, tmp_isinstance_cls_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1601;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_and_left_value_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_4 = tmp_and_left_value_4 == NUITKA_BOOL_TRUE ? 1 : 0;
        if ( tmp_and_left_truth_4 == 1 )
        {
            goto and_right_4;
        }
        else
        {
            goto and_left_4;
        }
        and_right_4:;
        CHECK_OBJECT( var_original_markup );
        tmp_source_name_6 = var_original_markup;
        tmp_attribute_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_prefix );
        if ( tmp_attribute_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1602;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_5 = CHECK_IF_TRUE( tmp_attribute_value_2 );
        if ( tmp_truth_name_5 == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_attribute_value_2 );

            exception_lineno = 1602;
            type_description_1 = "ooooooNoo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_4 = tmp_truth_name_5 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF( tmp_attribute_value_2 );
        tmp_and_right_value_3 = tmp_and_right_value_4;
        goto and_end_4;
        and_left_4:;
        tmp_and_right_value_3 = tmp_and_left_value_4;
        and_end_4:;
        tmp_condition_result_15 = tmp_and_right_value_3;
        goto and_end_3;
        and_left_3:;
        tmp_condition_result_15 = tmp_and_left_value_3;
        and_end_3:;
        if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_15;
        }
        else
        {
            goto branch_no_15;
        }
        branch_yes_15:;
        {
            PyObject *tmp_called_name_3;
            PyObject *tmp_source_name_7;
            PyObject *tmp_args_element_name_13;
            PyObject *tmp_left_name_1;
            PyObject *tmp_left_name_2;
            PyObject *tmp_source_name_8;
            PyObject *tmp_right_name_1;
            PyObject *tmp_right_name_2;
            PyObject *tmp_source_name_9;
            PyObject *tmp_args_element_name_14;
            CHECK_OBJECT( par_self );
            tmp_source_name_7 = par_self;
            tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__matches );
            if ( tmp_called_name_3 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1604;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_original_markup );
            tmp_source_name_8 = var_original_markup;
            tmp_left_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_prefix );
            if ( tmp_left_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1605;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            tmp_right_name_1 = const_str_chr_58;
            tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_STR( tmp_left_name_2, tmp_right_name_1 );
            Py_DECREF( tmp_left_name_2 );
            if ( tmp_left_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1605;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( var_original_markup );
            tmp_source_name_9 = var_original_markup;
            tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_name );
            if ( tmp_right_name_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );
                Py_DECREF( tmp_left_name_1 );

                exception_lineno = 1605;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            tmp_args_element_name_13 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
            Py_DECREF( tmp_left_name_1 );
            Py_DECREF( tmp_right_name_2 );
            if ( tmp_args_element_name_13 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_3 );

                exception_lineno = 1605;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            CHECK_OBJECT( par_match_against );
            tmp_args_element_name_14 = par_match_against;
            frame_2f876307bed7434c370747ea48135869->m_frame.f_lineno = 1604;
            {
                PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
                tmp_return_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
            }

            Py_DECREF( tmp_called_name_3 );
            Py_DECREF( tmp_args_element_name_13 );
            if ( tmp_return_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1604;
                type_description_1 = "ooooooNoo";
                goto frame_exception_exit_1;
            }
            goto frame_return_exit_1;
        }
        branch_no_15:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f876307bed7434c370747ea48135869 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f876307bed7434c370747ea48135869 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f876307bed7434c370747ea48135869 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f876307bed7434c370747ea48135869, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f876307bed7434c370747ea48135869->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f876307bed7434c370747ea48135869, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f876307bed7434c370747ea48135869,
        type_description_1,
        par_self,
        par_markup,
        par_match_against,
        par_already_tried,
        var_original_markup,
        var_item,
        NULL,
        var_key,
        var_match
    );


    // Release cached frame.
    if ( frame_2f876307bed7434c370747ea48135869 == cache_frame_2f876307bed7434c370747ea48135869 )
    {
        Py_DECREF( frame_2f876307bed7434c370747ea48135869 );
    }
    cache_frame_2f876307bed7434c370747ea48135869 = NULL;

    assertFrameObject( frame_2f876307bed7434c370747ea48135869 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_match );
    tmp_return_value = var_match;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_112__matches );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_match_against );
    Py_DECREF( par_match_against );
    par_match_against = NULL;

    Py_XDECREF( var_original_markup );
    var_original_markup = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_item );
    var_item = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( par_already_tried );
    par_already_tried = NULL;

    CHECK_OBJECT( (PyObject *)par_markup );
    Py_DECREF( par_markup );
    par_markup = NULL;

    Py_XDECREF( var_match );
    var_match = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_match_against );
    Py_DECREF( par_match_against );
    par_match_against = NULL;

    Py_XDECREF( var_original_markup );
    var_original_markup = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_item );
    var_item = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( par_already_tried );
    par_already_tried = NULL;

    Py_XDECREF( par_markup );
    par_markup = NULL;

    Py_XDECREF( var_match );
    var_match = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_112__matches );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_113___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_source = python_pars[ 1 ];
    PyObject *par_result = python_pars[ 2 ];
    struct Nuitka_FrameObject *frame_6260960175210d1d930251866ab9fdd7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_6260960175210d1d930251866ab9fdd7 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6260960175210d1d930251866ab9fdd7, codeobj_6260960175210d1d930251866ab9fdd7, module_bs4$element, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6260960175210d1d930251866ab9fdd7 = cache_frame_6260960175210d1d930251866ab9fdd7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6260960175210d1d930251866ab9fdd7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6260960175210d1d930251866ab9fdd7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_type_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_object_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ResultSet );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ResultSet );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "ResultSet" );
            exception_tb = NULL;

            exception_lineno = 1615;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_type_name_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_self );
        tmp_object_name_1 = par_self;
        tmp_called_instance_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
        if ( tmp_called_instance_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1615;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_result );
        tmp_args_element_name_1 = par_result;
        frame_6260960175210d1d930251866ab9fdd7->m_frame.f_lineno = 1615;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain___init__, call_args );
        }

        Py_DECREF( tmp_called_instance_1 );
        if ( tmp_call_result_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1615;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF( tmp_call_result_1 );
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT( par_source );
        tmp_assattr_name_1 = par_source;
        CHECK_OBJECT( par_self );
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_source, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1616;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6260960175210d1d930251866ab9fdd7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6260960175210d1d930251866ab9fdd7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6260960175210d1d930251866ab9fdd7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6260960175210d1d930251866ab9fdd7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6260960175210d1d930251866ab9fdd7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6260960175210d1d930251866ab9fdd7,
        type_description_1,
        par_self,
        par_source,
        par_result
    );


    // Release cached frame.
    if ( frame_6260960175210d1d930251866ab9fdd7 == cache_frame_6260960175210d1d930251866ab9fdd7 )
    {
        Py_DECREF( frame_6260960175210d1d930251866ab9fdd7 );
    }
    cache_frame_6260960175210d1d930251866ab9fdd7 = NULL;

    assertFrameObject( frame_6260960175210d1d930251866ab9fdd7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_113___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_source );
    Py_DECREF( par_source );
    par_source = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_source );
    Py_DECREF( par_source );
    par_source = NULL;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_result );
    Py_DECREF( par_result );
    par_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_113___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_bs4$element$$$function_114___getattr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_key = python_pars[ 1 ];
    struct Nuitka_FrameObject *frame_4e556ab3367f8156c1378d33dcbc493b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4e556ab3367f8156c1378d33dcbc493b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4e556ab3367f8156c1378d33dcbc493b, codeobj_4e556ab3367f8156c1378d33dcbc493b, module_bs4$element, sizeof(void *)+sizeof(void *) );
    frame_4e556ab3367f8156c1378d33dcbc493b = cache_frame_4e556ab3367f8156c1378d33dcbc493b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4e556ab3367f8156c1378d33dcbc493b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4e556ab3367f8156c1378d33dcbc493b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_make_exception_arg_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_str_digest_5972be3d2e0ae5cffa0313f94447abdb;
        CHECK_OBJECT( par_key );
        tmp_right_name_1 = par_key;
        tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_make_exception_arg_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1620;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_4e556ab3367f8156c1378d33dcbc493b->m_frame.f_lineno = 1619;
        {
            PyObject *call_args[] = { tmp_make_exception_arg_1 };
            tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AttributeError, call_args );
        }

        Py_DECREF( tmp_make_exception_arg_1 );
        assert( !(tmp_raise_type_1 == NULL) );
        exception_type = tmp_raise_type_1;
        exception_lineno = 1619;
        RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
        type_description_1 = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e556ab3367f8156c1378d33dcbc493b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4e556ab3367f8156c1378d33dcbc493b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4e556ab3367f8156c1378d33dcbc493b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4e556ab3367f8156c1378d33dcbc493b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4e556ab3367f8156c1378d33dcbc493b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4e556ab3367f8156c1378d33dcbc493b,
        type_description_1,
        par_self,
        par_key
    );


    // Release cached frame.
    if ( frame_4e556ab3367f8156c1378d33dcbc493b == cache_frame_4e556ab3367f8156c1378d33dcbc493b )
    {
        Py_DECREF( frame_4e556ab3367f8156c1378d33dcbc493b );
    }
    cache_frame_4e556ab3367f8156c1378d33dcbc493b = NULL;

    assertFrameObject( frame_4e556ab3367f8156c1378d33dcbc493b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_114___getattr__ );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_key );
    Py_DECREF( par_key );
    par_key = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( bs4$element$$$function_114___getattr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_100_children(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_100_children,
        const_str_plain_children,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6ffb6f921d156ce8415ba690c7511991,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_101_descendants(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_101_descendants,
        const_str_plain_descendants,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e2f97cb35361b509cf888ea2dba587ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_102_select_one( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_102_select_one,
        const_str_plain_select_one,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3d28736148c648faaf499826a4bcee28,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_a6aafb5565cda3049a1405989036800d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_103_select( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_103_select,
        const_str_plain_select,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_72b4cacabb8769a6ac882f9fe6ea574e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_44cc79d8ae47795db54dfcb36a03ec10,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_104_childGenerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_104_childGenerator,
        const_str_plain_childGenerator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a0696e67cb1c97143c8c36692ffcc165,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_105_recursiveChildGenerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_105_recursiveChildGenerator,
        const_str_plain_recursiveChildGenerator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d46550f1626ed88f6f7e24f94e3481b3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_106_has_key(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_106_has_key,
        const_str_plain_has_key,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5d5df9b0a86031ac8bf61af23f959ddb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_28fcfa6b905769882ab971e07fe72510,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_107___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_107___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0659d3a8834673b2723e32a986aab130,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_108__normalize_search_value(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_108__normalize_search_value,
        const_str_plain__normalize_search_value,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_20cb79926d5c997e0fc30883874ed8c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_109___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_109___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_285a3a357c7e6df9e65ab69b915876e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_10_substitute_entities(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_10_substitute_entities,
        const_str_plain_substitute_entities,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a083b7678dd71fa50eecfbe77aeba7fd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_1c3b497b8a4a3c183134674c43de9ce2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_110_search_tag( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_110_search_tag,
        const_str_plain_search_tag,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9eb6ed3effa667fc4260fde143db8cce,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_111_search(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_111_search,
        const_str_plain_search,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7ad6e7a72b48702f9e5b43452fda84eb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_112__matches( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_112__matches,
        const_str_plain__matches,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f876307bed7434c370747ea48135869,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_113___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_113___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6260960175210d1d930251866ab9fdd7,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_114___getattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_114___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4e556ab3367f8156c1378d33dcbc493b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_11_substitute(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_11_substitute,
        const_str_plain_substitute,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c77abc76f4a0bef790a7c7a765758c82,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_12_substitute(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_12_substitute,
        const_str_plain_substitute,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f35b594533211a40312bed4190bf81a5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_13_substitute(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_13_substitute,
        const_str_plain_substitute,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b0fc2c065017043970346a6bbad759bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_14_substitute(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_14_substitute,
        const_str_plain_substitute,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9ba465c2f63a8015bb1bc81e3ff20eff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_15_format_string( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_15_format_string,
        const_str_plain_format_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d9729a6df5eb5a5b7ae31f23e87064b3,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_4a104383ff48e621ad8c417548c98ea1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_16__is_xml(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_16__is_xml,
        const_str_plain__is_xml,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_76183d666b6fe52239c562ee299269f3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_fa9ac21a1aecbae9bb5a3c4a16e70ffe,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_17__formatter_for_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_17__formatter_for_name,
        const_str_plain__formatter_for_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2c3ff2cae6e04e9ec244d1a23dd1cba7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_dc7919f5f97ce613232f3cbd32e183ff,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_18_setup( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_18_setup,
        const_str_plain_setup,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c84480da8086d95f36164f584c21f6ab,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_d30c1fec201318981ba659c44f450ce9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_19_replace_with(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_19_replace_with,
        const_str_plain_replace_with,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_95ffa881c992b41a09b640bdd993138a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_1__alias(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_1__alias,
        const_str_plain__alias,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a5e2638464fefd2818be3fcd0d829caf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_40d1280f0aef3f3bf11313c57370733c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_1__alias$$$function_1_alias(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_1__alias$$$function_1_alias,
        const_str_plain_alias,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_55a270db2583d977babd95a54894be1a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_1__alias$$$function_2_alias(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_1__alias$$$function_2_alias,
        const_str_plain_alias,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d7959c1f6a1efaa5a744b36b9cfd8c7b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_20_unwrap(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_20_unwrap,
        const_str_plain_unwrap,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_68bc07cc376f7fe11e6f7be1682a6dbb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_21_wrap(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_21_wrap,
        const_str_plain_wrap,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_05c0c723a3dc2a65077e569ed007a15a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_22_extract(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_22_extract,
        const_str_plain_extract,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c703ca9bc738259b4324f501b5ecee93,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_5019a3250d7d4e2e305907c7346453e1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_23__last_descendant( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_23__last_descendant,
        const_str_plain__last_descendant,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0d9096af853ae8895db328ea28d3cd9a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_a5e29131f13d71b6ec2d6ad90d15151c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_24_insert(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_24_insert,
        const_str_plain_insert,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_946ab5af3c25362849801c2db8c2098f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_25_append(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_25_append,
        const_str_plain_append,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fc15a6c52943040a99d66eb74afa26d4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_e284352cda9140f58b06ed689c06ac6a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_26_extend(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_26_extend,
        const_str_plain_extend,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_783bb656bd248096fe5dff1b6735d020,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_f425bee58e499399e7174ce48229bf9d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_27_insert_before(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_27_insert_before,
        const_str_plain_insert_before,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3c97804e638eb41eb1fba6e47726f3bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_2c574a663a96a37e80240aa8a1c13e67,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_28_insert_after(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_28_insert_after,
        const_str_plain_insert_after,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_87ceeefa37b5b79d65a252ac8de9f62d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_74e818919ccc285c3d53c12c016e25d0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_29_find_next( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_29_find_next,
        const_str_plain_find_next,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9bd7632ac089adc376ecbbcb2f6dc690,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_8ca5f0d3f3d0b766a3f4cdd946dfac3b,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_2___new__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_2___new__,
        const_str_plain___new__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_840dfde127c7948681f68bac0997b15f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_30_find_all_next( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_30_find_all_next,
        const_str_plain_find_all_next,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_eda20f939454e2c4a84abc8a549d6b2c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_7db7fe37da3c09f0b3a2e370ca362f20,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_31_find_next_sibling( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_31_find_next_sibling,
        const_str_plain_find_next_sibling,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c58eed4264ebc40dcacae7730d18dcc1,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_edf143d4f0a652982e578c671c8f527f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_32_find_next_siblings( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_32_find_next_siblings,
        const_str_plain_find_next_siblings,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8498af97c4b561c649402a169426a52c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_a6d3c5dc186607b5d9991e1833ca2d3a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_33_find_previous( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_33_find_previous,
        const_str_plain_find_previous,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5989077b2bed5d70168fdd512d1c6b58,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_c42ac5a4d6fe5208c6039fd3f7e8b4d1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_34_find_all_previous( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_34_find_all_previous,
        const_str_plain_find_all_previous,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ebc3dc41d3b05d7a4f045cf17e6248c6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_687f64809c4be828c127c356e1b6ed7c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_35_find_previous_sibling( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_35_find_previous_sibling,
        const_str_plain_find_previous_sibling,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_611a6e46dc9df08fc7bf62dc91c5fc9f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_9a553da68e37fc2c9e871cef1f9a938f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_36_find_previous_siblings( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_36_find_previous_siblings,
        const_str_plain_find_previous_siblings,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_65948314dd15ad5fa1518d4867d6d673,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_5e8296b08c7275b6e9b059066a53a1cb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_37_find_parent( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_37_find_parent,
        const_str_plain_find_parent,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_493a1bcafa53978c92f68edb9700afc8,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_fd3697fca90f8714408b4dfe42e76cb5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_38_find_parents( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_38_find_parents,
        const_str_plain_find_parents,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c53dfbe39dd3a6e1884caed588a6e018,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_d39d95c610172b34eb52fa6d59d5835e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_39_next(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_39_next,
        const_str_plain_next,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_98b78ce301e50c61555c5e7b2c6faa12,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_3___new__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_3___new__,
        const_str_plain___new__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d20cd7ff19281f391bdb48bbc6615087,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_40_previous(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_40_previous,
        const_str_plain_previous,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_43344189d34fada79b0c4b1db6aa313e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_41__find_one(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_41__find_one,
        const_str_plain__find_one,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d650e4d8a3ab64c145624f43bf0229a6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_42__find_all(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_42__find_all,
        const_str_plain__find_all,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_74e0b40b40a8bd05233067bcf4acb342,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_dba4300913f590ab70dd3a55a3c580d8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_43_next_elements(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_43_next_elements,
        const_str_plain_next_elements,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2ce30ad51f869b601f01107834b055c1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_44_next_siblings(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_44_next_siblings,
        const_str_plain_next_siblings,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_96d5c0615e56d061f1a75be0898d3893,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_45_previous_elements(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_45_previous_elements,
        const_str_plain_previous_elements,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_30fec37bac69a968b531d72f50d1eab0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_46_previous_siblings(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_46_previous_siblings,
        const_str_plain_previous_siblings,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_101279b401d05ad5c4ab4058c37f2e3a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_47_parents(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_47_parents,
        const_str_plain_parents,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2389c2d402cbef9638c4531890382b4c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_48_nextGenerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_48_nextGenerator,
        const_str_plain_nextGenerator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5d84c23d22e2c284d1e911e1df415815,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_49_nextSiblingGenerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_49_nextSiblingGenerator,
        const_str_plain_nextSiblingGenerator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0104bb1a834c0db99dc949612ee9e530,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_4_encode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_4_encode,
        const_str_plain_encode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c0b19e80631658ec74bb3e25429fd67f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_50_previousGenerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_50_previousGenerator,
        const_str_plain_previousGenerator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6b8832c71060328b0d13cb2fbbebfc80,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_51_previousSiblingGenerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_51_previousSiblingGenerator,
        const_str_plain_previousSiblingGenerator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_793293dba737101c30c17c8b35d070dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_52_parentGenerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_52_parentGenerator,
        const_str_plain_parentGenerator,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6bbdfb85b0c1bb816d1a814b3fcd7b62,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_53___new__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_53___new__,
        const_str_plain___new__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b85adaa470e25a69858dfde85e7c078a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_fb2a771a9c1c9339fad2ef3c863c3219,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_54___copy__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_54___copy__,
        const_str_plain___copy__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_36b2c8d556861624aae77de0a07304d0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_c9d2da40f15d12241238636e3ea4b960,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_55___getnewargs__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_55___getnewargs__,
        const_str_plain___getnewargs__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c07331a2a0ef212bddc2df31da1b3830,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_56___getattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_56___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fc41c2ad8dbe85f71981b8bba617eec6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_5806791943ce856d9cfa3df6f3256880,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_57_output_ready( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_57_output_ready,
        const_str_plain_output_ready,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_be712631c87fcbe3bc2bb6dcb0fd15ab,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_58_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_58_name,
        const_str_plain_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d56f0c18f6036936cda6e2235379c39a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_59_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_59_name,
        const_str_plain_name,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_363b9dadd23cca41333766adec78f9ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_5___new__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_5___new__,
        const_str_plain___new__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_50849ac5284d4f3ccb4a11f07fe777db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_60_output_ready( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_60_output_ready,
        const_str_plain_output_ready,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f4cab256fd83a2e1d0fcdc2f34349723,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_0335416823e683d1ebbe424bdd45a2ca,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_61_for_name_and_ids(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_61_for_name_and_ids,
        const_str_plain_for_name_and_ids,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c01b4cc490155bdf7d76523f4d2063da,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_62___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_62___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5258e8cca0a1d712e5493a4091af0ee6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_d8274aeb344d2374500ebe6784747ede,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_63___copy__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_63___copy__,
        const_str_plain___copy__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_28dae34448982e5cb647814084cb47ed,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_150a3ddd6f980f74b974d699bb653243,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_64_is_empty_element(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_64_is_empty_element,
        const_str_plain_is_empty_element,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_aa9ed37f4d2da439684924b28158708d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_7b88dc5ab83916f8d7010fa0bb999fa3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_65_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_65_string,
        const_str_plain_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b70a4906c97184e98518c95aaa529398,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_2c354f1221e3e09909d06a3dc3c259cb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_66_string(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_66_string,
        const_str_plain_string,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5548f114506669f9d9e933fd7df4510b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_67__all_strings( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_67__all_strings,
        const_str_plain__all_strings,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_30b570e03eb3cc558516ab120ff84408,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_5dde75ea46d316ab5ab5d75080f755c4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_68_stripped_strings(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_68_stripped_strings,
        const_str_plain_stripped_strings,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3d5f44d2cf135a3c60072595cf5a7ac9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_69_get_text( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_69_get_text,
        const_str_plain_get_text,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_10e6028ad198a440f60e91ee9df066ba,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_f217e48ed4c26f47ac3e1db2e35e3868,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_6_encode(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_6_encode,
        const_str_plain_encode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4cbc0d50c319b71db955e0ed001178e7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_6_encode$$$function_1_rewrite(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_6_encode$$$function_1_rewrite,
        const_str_plain_rewrite,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d3162c8595b383cfcf9beeb61084282b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_70_decompose(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_70_decompose,
        const_str_plain_decompose,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_43f0e352fcabe0b721afedeac0d47b0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_c5639168a5cbc5c4d0956b93b3eb2792,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_71_clear( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_71_clear,
        const_str_plain_clear,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7707ae06690f1d6d8642fa5203e1fb8c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_979b3c48ae5244d26d6c51e2422468ee,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_72_index(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_72_index,
        const_str_plain_index,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f0e649407f94da0d732748f63e73614d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_9a607885277141d349d6d92be27c1d04,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_73_get( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_73_get,
        const_str_plain_get,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_fcd1cb2a719ec8e30788d0fa79a3b2c6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_530dbdb9b402b3f07d411a938927f2b3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_74_get_attribute_list( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_74_get_attribute_list,
        const_str_plain_get_attribute_list,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_46e9c6ffef111ec7276e47293446caf3,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_12efe66a592585182310e41465bc3228,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_75_has_attr(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_75_has_attr,
        const_str_plain_has_attr,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c11ea474ffae6c6476256a2a70014948,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_76___hash__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_76___hash__,
        const_str_plain___hash__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1d647466fb145e14671911abb2f457d6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_77___getitem__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_77___getitem__,
        const_str_plain___getitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d67dc5583d9735364a2e7eb7aa2f4f9f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_d72d114df8db0ba64be9f314fb3d10ea,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_78___iter__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_78___iter__,
        const_str_plain___iter__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f8ede56649c9acbcf3e4d1611cbd7bf1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_a1252b58837909ad9dc1fcca1e9295d3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_79___len__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_79___len__,
        const_str_plain___len__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_df689961d1889b2bc63517aeff723192,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_3efbf8635fb02c14f734f6fa1f903d94,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_7__substitute_if_appropriate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_7__substitute_if_appropriate,
        const_str_plain__substitute_if_appropriate,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7a87a787dc98c0e8040744cc9c67fa9c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_80___contains__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_80___contains__,
        const_str_plain___contains__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d06555feeb0f99a8946ae79358eebe14,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_81___nonzero__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_81___nonzero__,
        const_str_plain___nonzero__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_876387fdd220214a20731241696fa347,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_2301ed3ad80a75315314e7e55d580eb4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_82___setitem__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_82___setitem__,
        const_str_plain___setitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e799db36c7ac958aeacbc8d3fbdfd7c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_996dd8adec957dee57886c3b180eb10e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_83___delitem__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_83___delitem__,
        const_str_plain___delitem__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_18dce61cea9fc7c55052b8072b93f4ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_73e3f65a5e6a0e231abfd780063ee2b0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_84___call__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_84___call__,
        const_str_plain___call__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_14c9ca35b08857b494d3b34d6a24c792,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_b42292186816115aadac41c6428c2b70,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_85___getattr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_85___getattr__,
        const_str_plain___getattr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b69ca57a2878fd3ed8c2fa69b9943835,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_86___eq__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_86___eq__,
        const_str_plain___eq__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_0f121366c6314e05c4e94b4ba4f281db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_a8642630e4859aa7595db413203bd4d1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_87___ne__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_87___ne__,
        const_str_plain___ne__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_47e271e4323d4ffe193e3efd217220e8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_51f97402dd7101c57c82d9e47530321c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_88___repr__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_88___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7ae4d0ab18c86a7b052b0c944ba8bd65,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_29649a9de50f1b949dd54bb0ed0bf2bf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_89___unicode__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_89___unicode__,
        const_str_plain___unicode__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9c1c3b549a0cf791cb178533927bbf79,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_8_substitute_html(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_8_substitute_html,
        const_str_plain_substitute_html,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9cbfa9cd9bf3ad290e3f71543c5dfd6a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_90___str__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_90___str__,
        const_str_plain___str__,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_099aaa80f69d337732d9b444d82bacd1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_91_encode( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_91_encode,
        const_str_plain_encode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8135d7ca17005947bac227662c113913,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_92__should_pretty_print(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_92__should_pretty_print,
        const_str_plain__should_pretty_print,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2cb78b1700e9c5a78e9a9931b71ffd39,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_cb7f043884ff2a2610043d53506bac64,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_93_decode( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_93_decode,
        const_str_plain_decode,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7e5ea0a96abd38fc63210a5d0436fdc4,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_6e295b76c4b27f5a846f1bb005613354,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_94_prettify( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_94_prettify,
        const_str_plain_prettify,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7e3e5722d1e42f7d6ddb1bbecd61c01f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_95_decode_contents( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_95_decode_contents,
        const_str_plain_decode_contents,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_f80e94e61a5498e34db5e8bf04849743,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_43f42e221dbc99e7846a13559b986b53,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_96_encode_contents( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_96_encode_contents,
        const_str_plain_encode_contents,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_ef22ab60bd4c83e9125fddfcee10b1a1,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_74feb09b4e7b5c98ea28f927cc7ad7ec,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_97_renderContents( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_97_renderContents,
        const_str_plain_renderContents,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6aa072799d86fee962e5df98aa577a0b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_98_find( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_98_find,
        const_str_plain_find,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6df50eb59cc2c378df6c21e1c696f6a0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_a0f6e9f5acfe56723fdae36afe1e77fb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_99_find_all( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_99_find_all,
        const_str_plain_find_all,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_984ee2fe2ba0922e4dd2853b23c0064e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        const_str_digest_345cf92f17033766f082736e15d759aa,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_bs4$element$$$function_9_substitute_xml(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_bs4$element$$$function_9_substitute_xml,
        const_str_plain_substitute_xml,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f58cf123329779cc61cb72a584cda0b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_bs4$element,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_bs4$element =
{
    PyModuleDef_HEAD_INIT,
    "bs4.element",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;

extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( bs4$element )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_bs4$element );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("bs4.element: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("bs4.element: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("bs4.element: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initbs4$element" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_bs4$element = Py_InitModule4(
        "bs4.element",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_bs4$element = PyModule_Create( &mdef_bs4$element );
#endif

    moduledict_bs4$element = MODULE_DICT( module_bs4$element );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_bs4$element,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_bs4$element,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_bs4$element,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_bs4$element );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_digest_a694a1497725bd5d49805e1c282892b9, module_bs4$element );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *tmp_Tag$assign_unpack_1__assign_source = NULL;
    PyObject *tmp_class_creation_10__bases = NULL;
    PyObject *tmp_class_creation_10__class = NULL;
    PyObject *tmp_class_creation_10__class_dict = NULL;
    PyObject *tmp_class_creation_10__metaclass = NULL;
    PyObject *tmp_class_creation_11__bases = NULL;
    PyObject *tmp_class_creation_11__class = NULL;
    PyObject *tmp_class_creation_11__class_dict = NULL;
    PyObject *tmp_class_creation_11__metaclass = NULL;
    PyObject *tmp_class_creation_12__class = NULL;
    PyObject *tmp_class_creation_12__class_dict = NULL;
    PyObject *tmp_class_creation_12__metaclass = NULL;
    PyObject *tmp_class_creation_13__bases = NULL;
    PyObject *tmp_class_creation_13__class = NULL;
    PyObject *tmp_class_creation_13__class_dict = NULL;
    PyObject *tmp_class_creation_13__metaclass = NULL;
    PyObject *tmp_class_creation_14__bases = NULL;
    PyObject *tmp_class_creation_14__class = NULL;
    PyObject *tmp_class_creation_14__class_dict = NULL;
    PyObject *tmp_class_creation_14__metaclass = NULL;
    PyObject *tmp_class_creation_15__bases = NULL;
    PyObject *tmp_class_creation_15__class = NULL;
    PyObject *tmp_class_creation_15__class_dict = NULL;
    PyObject *tmp_class_creation_15__metaclass = NULL;
    PyObject *tmp_class_creation_16__bases = NULL;
    PyObject *tmp_class_creation_16__class = NULL;
    PyObject *tmp_class_creation_16__class_dict = NULL;
    PyObject *tmp_class_creation_16__metaclass = NULL;
    PyObject *tmp_class_creation_17__bases = NULL;
    PyObject *tmp_class_creation_17__class = NULL;
    PyObject *tmp_class_creation_17__class_dict = NULL;
    PyObject *tmp_class_creation_17__metaclass = NULL;
    PyObject *tmp_class_creation_18__bases = NULL;
    PyObject *tmp_class_creation_18__class = NULL;
    PyObject *tmp_class_creation_18__class_dict = NULL;
    PyObject *tmp_class_creation_18__metaclass = NULL;
    PyObject *tmp_class_creation_19__bases = NULL;
    PyObject *tmp_class_creation_19__class = NULL;
    PyObject *tmp_class_creation_19__class_dict = NULL;
    PyObject *tmp_class_creation_19__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_20__bases = NULL;
    PyObject *tmp_class_creation_20__class = NULL;
    PyObject *tmp_class_creation_20__class_dict = NULL;
    PyObject *tmp_class_creation_20__metaclass = NULL;
    PyObject *tmp_class_creation_21__bases = NULL;
    PyObject *tmp_class_creation_21__class = NULL;
    PyObject *tmp_class_creation_21__class_dict = NULL;
    PyObject *tmp_class_creation_21__metaclass = NULL;
    PyObject *tmp_class_creation_22__class = NULL;
    PyObject *tmp_class_creation_22__class_dict = NULL;
    PyObject *tmp_class_creation_22__metaclass = NULL;
    PyObject *tmp_class_creation_23__class = NULL;
    PyObject *tmp_class_creation_23__class_dict = NULL;
    PyObject *tmp_class_creation_23__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_3__bases = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_5__bases = NULL;
    PyObject *tmp_class_creation_5__class = NULL;
    PyObject *tmp_class_creation_5__class_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_6__class = NULL;
    PyObject *tmp_class_creation_6__class_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_7__bases = NULL;
    PyObject *tmp_class_creation_7__class = NULL;
    PyObject *tmp_class_creation_7__class_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_8__bases = NULL;
    PyObject *tmp_class_creation_8__class = NULL;
    PyObject *tmp_class_creation_8__class_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_9__bases = NULL;
    PyObject *tmp_class_creation_9__class = NULL;
    PyObject *tmp_class_creation_9__class_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_locals_bs4$element_139_key_substitute_entities = NULL;
    PyObject *tmp_locals_bs4$element_1611_key___getattr__ = NULL;
    PyObject *tmp_locals_bs4$element_1611_key___init__ = NULL;
    PyObject *tmp_select_metaclass_10__base = NULL;
    PyObject *tmp_select_metaclass_11__base = NULL;
    PyObject *tmp_select_metaclass_13__base = NULL;
    PyObject *tmp_select_metaclass_14__base = NULL;
    PyObject *tmp_select_metaclass_15__base = NULL;
    PyObject *tmp_select_metaclass_16__base = NULL;
    PyObject *tmp_select_metaclass_17__base = NULL;
    PyObject *tmp_select_metaclass_18__base = NULL;
    PyObject *tmp_select_metaclass_19__base = NULL;
    PyObject *tmp_select_metaclass_20__base = NULL;
    PyObject *tmp_select_metaclass_21__base = NULL;
    PyObject *tmp_select_metaclass_3__base = NULL;
    PyObject *tmp_select_metaclass_4__base = NULL;
    PyObject *tmp_select_metaclass_5__base = NULL;
    PyObject *tmp_select_metaclass_7__base = NULL;
    PyObject *tmp_select_metaclass_8__base = NULL;
    PyObject *tmp_select_metaclass_9__base = NULL;
    struct Nuitka_FrameObject *frame_e5c9f68c83b74cb2baea83eeeaa3cdfd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *locals_bs4$element_42 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_dfd0b236e1e38e11663e9e5414aa850a_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_dfd0b236e1e38e11663e9e5414aa850a_2 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *locals_bs4$element_60 = NULL;
    struct Nuitka_FrameObject *frame_f1bdb48699f20645f690a022d5e2c172_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_f1bdb48699f20645f690a022d5e2c172_3 = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *locals_bs4$element_76 = NULL;
    struct Nuitka_FrameObject *frame_203f19c7266c2e913c49a142834bbcfc_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_203f19c7266c2e913c49a142834bbcfc_4 = NULL;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *locals_bs4$element_102 = NULL;
    struct Nuitka_FrameObject *frame_88c1f00bd461942e207810ba94d1fa55_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_88c1f00bd461942e207810ba94d1fa55_5 = NULL;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *locals_bs4$element_149 = NULL;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *locals_bs4$element_154 = NULL;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *locals_bs4$element_159 = NULL;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *locals_bs4$element_163 = NULL;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *locals_bs4$element_168 = NULL;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *locals_bs4$element_174 = NULL;
    struct Nuitka_FrameObject *frame_9d17cb8081dcccefd359db453c9db698_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_9d17cb8081dcccefd359db453c9db698_6 = NULL;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;
    PyObject *locals_bs4$element_699 = NULL;
    struct Nuitka_FrameObject *frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 = NULL;
    PyObject *exception_keeper_type_28;
    PyObject *exception_keeper_value_28;
    PyTracebackObject *exception_keeper_tb_28;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_28;
    PyObject *exception_keeper_type_29;
    PyObject *exception_keeper_value_29;
    PyTracebackObject *exception_keeper_tb_29;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_29;
    PyObject *exception_keeper_type_30;
    PyObject *exception_keeper_value_30;
    PyTracebackObject *exception_keeper_tb_30;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_30;
    PyObject *locals_bs4$element_756 = NULL;
    PyObject *exception_keeper_type_31;
    PyObject *exception_keeper_value_31;
    PyTracebackObject *exception_keeper_tb_31;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_31;
    PyObject *exception_keeper_type_32;
    PyObject *exception_keeper_value_32;
    PyTracebackObject *exception_keeper_tb_32;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_32;
    PyObject *locals_bs4$element_769 = NULL;
    PyObject *exception_keeper_type_33;
    PyObject *exception_keeper_value_33;
    PyTracebackObject *exception_keeper_tb_33;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_33;
    PyObject *exception_keeper_type_34;
    PyObject *exception_keeper_value_34;
    PyTracebackObject *exception_keeper_tb_34;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_34;
    PyObject *locals_bs4$element_774 = NULL;
    PyObject *exception_keeper_type_35;
    PyObject *exception_keeper_value_35;
    PyTracebackObject *exception_keeper_tb_35;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_35;
    PyObject *exception_keeper_type_36;
    PyObject *exception_keeper_value_36;
    PyTracebackObject *exception_keeper_tb_36;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_36;
    PyObject *locals_bs4$element_780 = NULL;
    PyObject *exception_keeper_type_37;
    PyObject *exception_keeper_value_37;
    PyTracebackObject *exception_keeper_tb_37;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_37;
    PyObject *exception_keeper_type_38;
    PyObject *exception_keeper_value_38;
    PyTracebackObject *exception_keeper_tb_38;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_38;
    PyObject *locals_bs4$element_785 = NULL;
    PyObject *exception_keeper_type_39;
    PyObject *exception_keeper_value_39;
    PyTracebackObject *exception_keeper_tb_39;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_39;
    PyObject *exception_keeper_type_40;
    PyObject *exception_keeper_value_40;
    PyTracebackObject *exception_keeper_tb_40;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_40;
    PyObject *locals_bs4$element_791 = NULL;
    PyObject *exception_keeper_type_41;
    PyObject *exception_keeper_value_41;
    PyTracebackObject *exception_keeper_tb_41;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_41;
    PyObject *exception_keeper_type_42;
    PyObject *exception_keeper_value_42;
    PyTracebackObject *exception_keeper_tb_42;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_42;
    PyObject *locals_bs4$element_796 = NULL;
    struct Nuitka_FrameObject *frame_873a41d8549c3eae2ceb236f16fe8da3_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_873a41d8549c3eae2ceb236f16fe8da3_8 = NULL;
    PyObject *exception_keeper_type_43;
    PyObject *exception_keeper_value_43;
    PyTracebackObject *exception_keeper_tb_43;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_43;
    PyObject *exception_keeper_type_44;
    PyObject *exception_keeper_value_44;
    PyTracebackObject *exception_keeper_tb_44;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_44;
    PyObject *exception_keeper_type_45;
    PyObject *exception_keeper_value_45;
    PyTracebackObject *exception_keeper_tb_45;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_45;
    PyObject *locals_bs4$element_814 = NULL;
    struct Nuitka_FrameObject *frame_9d2b28a2d5efc66db477b9157d5d71f4_9;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    static struct Nuitka_FrameObject *cache_frame_9d2b28a2d5efc66db477b9157d5d71f4_9 = NULL;
    PyObject *exception_keeper_type_46;
    PyObject *exception_keeper_value_46;
    PyTracebackObject *exception_keeper_tb_46;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_46;
    PyObject *exception_keeper_type_47;
    PyObject *exception_keeper_value_47;
    PyTracebackObject *exception_keeper_tb_47;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_47;
    PyObject *exception_keeper_type_48;
    PyObject *exception_keeper_value_48;
    PyTracebackObject *exception_keeper_tb_48;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_48;
    PyObject *locals_bs4$element_1394 = NULL;
    PyObject *exception_keeper_type_49;
    PyObject *exception_keeper_value_49;
    PyTracebackObject *exception_keeper_tb_49;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_49;
    PyObject *exception_keeper_type_50;
    PyObject *exception_keeper_value_50;
    PyTracebackObject *exception_keeper_tb_50;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_50;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_str_digest_74605c90f126dd9a5280fd0d6380988e;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = const_str_plain_MIT;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___license__, tmp_assign_source_3 );
    }
    // Frame without reuse.
    frame_e5c9f68c83b74cb2baea83eeeaa3cdfd = MAKE_MODULE_FRAME( codeobj_e5c9f68c83b74cb2baea83eeeaa3cdfd, module_bs4$element );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd );
    assert( Py_REFCNT( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd ) == 2 );

    // Framed code:
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        tmp_name_name_1 = const_str_digest_dc6974bae1533a27ce9599cdf14ca60e;
        tmp_globals_name_1 = (PyObject *)moduledict_bs4$element;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_Callable_tuple;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 5;
        tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 5;

            goto try_except_handler_1;
        }
        tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_Callable );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 5;

            goto try_except_handler_1;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable, tmp_assign_source_4 );
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != 0 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_e5c9f68c83b74cb2baea83eeeaa3cdfd, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_ImportError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 6;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_1 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_1;
        }
        else
        {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_assign_source_5;
            tmp_assign_source_5 = EXC_VALUE(PyThreadState_GET());
            UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_e, tmp_assign_source_5 );
        }
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_import_name_from_2;
            PyObject *tmp_name_name_2;
            PyObject *tmp_globals_name_2;
            PyObject *tmp_locals_name_2;
            PyObject *tmp_fromlist_name_2;
            tmp_name_name_2 = const_str_plain_collections;
            tmp_globals_name_2 = (PyObject *)moduledict_bs4$element;
            tmp_locals_name_2 = Py_None;
            tmp_fromlist_name_2 = const_tuple_str_plain_Callable_tuple;
            frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 7;
            tmp_import_name_from_2 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
            if ( tmp_import_name_from_2 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 7;

                goto frame_exception_exit_1;
            }
            tmp_assign_source_6 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_Callable );
            Py_DECREF( tmp_import_name_from_2 );
            if ( tmp_assign_source_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 7;

                goto frame_exception_exit_1;
            }
            UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Callable, tmp_assign_source_6 );
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 4;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame) frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = exception_tb->tb_lineno;

        goto frame_exception_exit_1;
        branch_end_1:;
    }
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element );
    return MOD_RETURN_VALUE( NULL );
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        tmp_name_name_3 = const_str_plain_re;
        tmp_globals_name_3 = (PyObject *)moduledict_bs4$element;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = Py_None;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 8;
        tmp_assign_source_7 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
        if ( tmp_assign_source_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 8;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_re, tmp_assign_source_7 );
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        tmp_name_name_4 = const_str_plain_sys;
        tmp_globals_name_4 = (PyObject *)moduledict_bs4$element;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = Py_None;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 9;
        tmp_assign_source_8 = IMPORT_MODULE4( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4 );
        assert( !(tmp_assign_source_8 == NULL) );
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_sys, tmp_assign_source_8 );
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        tmp_name_name_5 = const_str_plain_warnings;
        tmp_globals_name_5 = (PyObject *)moduledict_bs4$element;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = Py_None;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 10;
        tmp_assign_source_9 = IMPORT_MODULE4( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5 );
        if ( tmp_assign_source_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 10;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_warnings, tmp_assign_source_9 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        tmp_name_name_6 = const_str_plain_soupsieve;
        tmp_globals_name_6 = (PyObject *)moduledict_bs4$element;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = Py_None;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 12;
        tmp_assign_source_10 = IMPORT_MODULE4( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6 );
        if ( tmp_assign_source_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 12;

            goto try_except_handler_2;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_soupsieve, tmp_assign_source_10 );
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != 0 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_e5c9f68c83b74cb2baea83eeeaa3cdfd, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_2 = PyExc_ImportError;
        tmp_res = EXCEPTION_MATCH_BOOL( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 13;

            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_2 == NUITKA_BOOL_TRUE )
        {
            goto branch_yes_2;
        }
        else
        {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_11;
            tmp_assign_source_11 = EXC_VALUE(PyThreadState_GET());
            UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_e, tmp_assign_source_11 );
        }
        {
            PyObject *tmp_assign_source_12;
            tmp_assign_source_12 = Py_None;
            UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_soupsieve, tmp_assign_source_12 );
        }
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_mvar_value_1;
            PyObject *tmp_call_result_1;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_warnings );

            if (unlikely( tmp_mvar_value_1 == NULL ))
            {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
            }

            if ( tmp_mvar_value_1 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "warnings" );
                exception_tb = NULL;

                exception_lineno = 15;

                goto frame_exception_exit_1;
            }

            tmp_called_instance_1 = tmp_mvar_value_1;
            frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 15;
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_warn, &PyTuple_GET_ITEM( const_tuple_str_digest_8896f8bf9a99a51797228d5d40f8f021_tuple, 0 ) );

            if ( tmp_call_result_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 15;

                goto frame_exception_exit_1;
            }
            Py_DECREF( tmp_call_result_1 );
        }
        goto branch_end_2;
        branch_no_2:;
        tmp_result = RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        if (unlikely( tmp_result == false ))
        {
            exception_lineno = 11;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame) frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = exception_tb->tb_lineno;

        goto frame_exception_exit_1;
        branch_end_2:;
    }
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( bs4$element );
    return MOD_RETURN_VALUE( NULL );
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_import_name_from_3;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        tmp_name_name_7 = const_str_digest_e2405d39d6d616d1c5a0beb6aaa8ef8f;
        tmp_globals_name_7 = (PyObject *)moduledict_bs4$element;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = const_tuple_str_plain_EntitySubstitution_tuple;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 19;
        tmp_import_name_from_3 = IMPORT_MODULE4( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7 );
        if ( tmp_import_name_from_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 19;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_EntitySubstitution );
        Py_DECREF( tmp_import_name_from_3 );
        if ( tmp_assign_source_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 19;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_EntitySubstitution, tmp_assign_source_13 );
    }
    {
        PyObject *tmp_assign_source_14;
        tmp_assign_source_14 = const_str_digest_c075052d723d6707083e869a0e3659bb;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING, tmp_assign_source_14 );
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_subscript_name_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "sys" );
            exception_tb = NULL;

            exception_lineno = 22;

            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_2;
        tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_version_info );
        if ( tmp_subscribed_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 22;

            goto frame_exception_exit_1;
        }
        tmp_subscript_name_1 = const_int_0;
        tmp_compexpr_left_3 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_1, tmp_subscript_name_1, 0 );
        Py_DECREF( tmp_subscribed_name_1 );
        if ( tmp_compexpr_left_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 22;

            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_int_pos_2;
        tmp_assign_source_15 = RICH_COMPARE_GT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        Py_DECREF( tmp_compexpr_left_3 );
        if ( tmp_assign_source_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 22;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PY3K, tmp_assign_source_15 );
    }
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_re );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
        }

        if ( tmp_mvar_value_3 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "re" );
            exception_tb = NULL;

            exception_lineno = 24;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 24;
        tmp_assign_source_16 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_compile, &PyTuple_GET_ITEM( const_tuple_str_digest_7f7e4cda8c2433356d7798b9dc3aa32c_tuple, 0 ) );

        if ( tmp_assign_source_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 24;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_nonwhitespace_re, tmp_assign_source_16 );
    }
    {
        PyObject *tmp_assign_source_17;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_re );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
        }

        if ( tmp_mvar_value_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "re" );
            exception_tb = NULL;

            exception_lineno = 28;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_4;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 28;
        tmp_assign_source_17 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_compile, &PyTuple_GET_ITEM( const_tuple_str_digest_2717a74e8094c62311bf53472f4de0ca_tuple, 0 ) );

        if ( tmp_assign_source_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 28;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_whitespace_re, tmp_assign_source_17 );
    }
    {
        PyObject *tmp_assign_source_18;
        tmp_assign_source_18 = MAKE_FUNCTION_bs4$element$$$function_1__alias(  );



        UPDATE_STRING_DICT1( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain__alias, tmp_assign_source_18 );
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_19;
        {
            PyObject *tmp_set_locals_1;
            tmp_set_locals_1 = PyDict_New();
            locals_bs4$element_42 = tmp_set_locals_1;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_42, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_dfd0b236e1e38e11663e9e5414aa850a_2, codeobj_dfd0b236e1e38e11663e9e5414aa850a, module_bs4$element, 0 );
        frame_dfd0b236e1e38e11663e9e5414aa850a_2 = cache_frame_dfd0b236e1e38e11663e9e5414aa850a_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_dfd0b236e1e38e11663e9e5414aa850a_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_dfd0b236e1e38e11663e9e5414aa850a_2 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_staticmethod_arg_1;
            PyObject *tmp_defaults_1;
            tmp_defaults_1 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_1 );
            tmp_staticmethod_arg_1 = MAKE_FUNCTION_bs4$element$$$function_2___new__( tmp_defaults_1 );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_1 );
            Py_DECREF( tmp_staticmethod_arg_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 44;

                goto frame_exception_exit_2;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_42, const_str_plain___new__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 44;

                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_dfd0b236e1e38e11663e9e5414aa850a_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_dfd0b236e1e38e11663e9e5414aa850a_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_dfd0b236e1e38e11663e9e5414aa850a_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_dfd0b236e1e38e11663e9e5414aa850a_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_dfd0b236e1e38e11663e9e5414aa850a_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_dfd0b236e1e38e11663e9e5414aa850a_2,
            type_description_2
        );


        // Release cached frame.
        if ( frame_dfd0b236e1e38e11663e9e5414aa850a_2 == cache_frame_dfd0b236e1e38e11663e9e5414aa850a_2 )
        {
            Py_DECREF( frame_dfd0b236e1e38e11663e9e5414aa850a_2 );
        }
        cache_frame_dfd0b236e1e38e11663e9e5414aa850a_2 = NULL;

        assertFrameObject( frame_dfd0b236e1e38e11663e9e5414aa850a_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_4;
        skip_nested_handling_1:;
        tmp_assign_source_19 = locals_bs4$element_42;
        Py_INCREF( tmp_assign_source_19 );
        goto try_return_handler_4;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_4:;
        Py_DECREF( locals_bs4$element_42 );
        locals_bs4$element_42 = NULL;
        goto outline_result_1;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_42 );
        locals_bs4$element_42 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_1:;
        exception_lineno = 42;
        goto try_except_handler_3;
        outline_result_1:;
        assert( tmp_class_creation_1__class_dict == NULL );
        tmp_class_creation_1__class_dict = tmp_assign_source_19;
    }
    {
        PyObject *tmp_assign_source_20;
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        tmp_key_name_1 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_dict_name_1 = tmp_class_creation_1__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_1, tmp_key_name_1 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 42;

            goto try_except_handler_3;
        }
        tmp_condition_result_3 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_3 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_1;
        }
        else
        {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_dict_name_2 = tmp_class_creation_1__class_dict;
        tmp_key_name_2 = const_str_plain___metaclass__;
        tmp_assign_source_20 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
        if ( tmp_assign_source_20 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 42;

            goto try_except_handler_3;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_assign_source_20 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_20 );
        condexpr_end_1:;
        assert( tmp_class_creation_1__metaclass == NULL );
        tmp_class_creation_1__metaclass = tmp_assign_source_20;
    }
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT( tmp_class_creation_1__metaclass );
        tmp_called_name_1 = tmp_class_creation_1__metaclass;
        tmp_args_element_name_1 = const_str_plain_NamespacedAttribute;
        tmp_args_element_name_2 = const_tuple_type_unicode_tuple;
        CHECK_OBJECT( tmp_class_creation_1__class_dict );
        tmp_args_element_name_3 = tmp_class_creation_1__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 42;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
            tmp_assign_source_21 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
        }

        if ( tmp_assign_source_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 42;

            goto try_except_handler_3;
        }
        assert( tmp_class_creation_1__class == NULL );
        tmp_class_creation_1__class = tmp_assign_source_21;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    {
        PyObject *tmp_assign_source_22;
        CHECK_OBJECT( tmp_class_creation_1__class );
        tmp_assign_source_22 = tmp_class_creation_1__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NamespacedAttribute, tmp_assign_source_22 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    {
        PyObject *tmp_assign_source_23;
        tmp_assign_source_23 = PyDict_Copy( const_dict_ac1eba801ee59541af7075d340bfcec6 );
        assert( tmp_class_creation_2__class_dict == NULL );
        tmp_class_creation_2__class_dict = tmp_assign_source_23;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_24;
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_key_name_4;
        tmp_key_name_3 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_3 = tmp_class_creation_2__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_3, tmp_key_name_3 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 57;

            goto try_except_handler_5;
        }
        tmp_condition_result_4 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_4 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_2;
        }
        else
        {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_dict_name_4 = tmp_class_creation_2__class_dict;
        tmp_key_name_4 = const_str_plain___metaclass__;
        tmp_assign_source_24 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
        if ( tmp_assign_source_24 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 57;

            goto try_except_handler_5;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_assign_source_24 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_24 );
        condexpr_end_2:;
        assert( tmp_class_creation_2__metaclass == NULL );
        tmp_class_creation_2__metaclass = tmp_assign_source_24;
    }
    {
        PyObject *tmp_assign_source_25;
        PyObject *tmp_called_name_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        CHECK_OBJECT( tmp_class_creation_2__metaclass );
        tmp_called_name_2 = tmp_class_creation_2__metaclass;
        tmp_args_element_name_4 = const_str_plain_AttributeValueWithCharsetSubstitution;
        tmp_args_element_name_5 = const_tuple_type_unicode_tuple;
        CHECK_OBJECT( tmp_class_creation_2__class_dict );
        tmp_args_element_name_6 = tmp_class_creation_2__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 57;
        {
            PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
            tmp_assign_source_25 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
        }

        if ( tmp_assign_source_25 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 57;

            goto try_except_handler_5;
        }
        assert( tmp_class_creation_2__class == NULL );
        tmp_class_creation_2__class = tmp_assign_source_25;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    {
        PyObject *tmp_assign_source_26;
        CHECK_OBJECT( tmp_class_creation_2__class );
        tmp_assign_source_26 = tmp_class_creation_2__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_AttributeValueWithCharsetSubstitution, tmp_assign_source_26 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_27;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_AttributeValueWithCharsetSubstitution );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AttributeValueWithCharsetSubstitution );
        }

        if ( tmp_mvar_value_5 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "AttributeValueWithCharsetSubstitution" );
            exception_tb = NULL;

            exception_lineno = 60;

            goto try_except_handler_6;
        }

        tmp_tuple_element_1 = tmp_mvar_value_5;
        tmp_assign_source_27 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_1 );
        PyTuple_SET_ITEM( tmp_assign_source_27, 0, tmp_tuple_element_1 );
        assert( tmp_class_creation_3__bases == NULL );
        tmp_class_creation_3__bases = tmp_assign_source_27;
    }
    {
        PyObject *tmp_assign_source_28;
        {
            PyObject *tmp_set_locals_2;
            tmp_set_locals_2 = PyDict_New();
            locals_bs4$element_60 = tmp_set_locals_2;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_60, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_e457b16160571c2a0063096a0b61fed9;
        tmp_res = PyDict_SetItem( locals_bs4$element_60, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_f1bdb48699f20645f690a022d5e2c172_3, codeobj_f1bdb48699f20645f690a022d5e2c172, module_bs4$element, 0 );
        frame_f1bdb48699f20645f690a022d5e2c172_3 = cache_frame_f1bdb48699f20645f690a022d5e2c172_3;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_f1bdb48699f20645f690a022d5e2c172_3 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_f1bdb48699f20645f690a022d5e2c172_3 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_staticmethod_arg_2;
            tmp_staticmethod_arg_2 = MAKE_FUNCTION_bs4$element$$$function_3___new__(  );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_2 );
            Py_DECREF( tmp_staticmethod_arg_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 67;

                goto frame_exception_exit_3;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_60, const_str_plain___new__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 67;

                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_f1bdb48699f20645f690a022d5e2c172_3 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_f1bdb48699f20645f690a022d5e2c172_3 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_f1bdb48699f20645f690a022d5e2c172_3, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_f1bdb48699f20645f690a022d5e2c172_3->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_f1bdb48699f20645f690a022d5e2c172_3, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_f1bdb48699f20645f690a022d5e2c172_3,
            type_description_2
        );


        // Release cached frame.
        if ( frame_f1bdb48699f20645f690a022d5e2c172_3 == cache_frame_f1bdb48699f20645f690a022d5e2c172_3 )
        {
            Py_DECREF( frame_f1bdb48699f20645f690a022d5e2c172_3 );
        }
        cache_frame_f1bdb48699f20645f690a022d5e2c172_3 = NULL;

        assertFrameObject( frame_f1bdb48699f20645f690a022d5e2c172_3 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_7;
        skip_nested_handling_2:;
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_4_encode(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_60, const_str_plain_encode, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_28 = locals_bs4$element_60;
        Py_INCREF( tmp_assign_source_28 );
        goto try_return_handler_7;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_7:;
        Py_DECREF( locals_bs4$element_60 );
        locals_bs4$element_60 = NULL;
        goto outline_result_2;
        // Exception handler code:
        try_except_handler_7:;
        exception_keeper_type_6 = exception_type;
        exception_keeper_value_6 = exception_value;
        exception_keeper_tb_6 = exception_tb;
        exception_keeper_lineno_6 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_60 );
        locals_bs4$element_60 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_6;
        exception_value = exception_keeper_value_6;
        exception_tb = exception_keeper_tb_6;
        exception_lineno = exception_keeper_lineno_6;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_2:;
        exception_lineno = 60;
        goto try_except_handler_6;
        outline_result_2:;
        assert( tmp_class_creation_3__class_dict == NULL );
        tmp_class_creation_3__class_dict = tmp_assign_source_28;
    }
    {
        PyObject *tmp_assign_source_29;
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_key_name_5;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_dict_name_6;
        PyObject *tmp_key_name_6;
        tmp_key_name_5 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_5 = tmp_class_creation_3__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_5, tmp_key_name_5 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 60;

            goto try_except_handler_6;
        }
        tmp_condition_result_5 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_5 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_3;
        }
        else
        {
            goto condexpr_false_3;
        }
        condexpr_true_3:;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_dict_name_6 = tmp_class_creation_3__class_dict;
        tmp_key_name_6 = const_str_plain___metaclass__;
        tmp_assign_source_29 = DICT_GET_ITEM( tmp_dict_name_6, tmp_key_name_6 );
        if ( tmp_assign_source_29 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 60;

            goto try_except_handler_6;
        }
        goto condexpr_end_3;
        condexpr_false_3:;
        {
            PyObject *tmp_assign_source_30;
            PyObject *tmp_subscribed_name_2;
            PyObject *tmp_subscript_name_2;
            CHECK_OBJECT( tmp_class_creation_3__bases );
            tmp_subscribed_name_2 = tmp_class_creation_3__bases;
            tmp_subscript_name_2 = const_int_0;
            tmp_assign_source_30 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 0 );
            if ( tmp_assign_source_30 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 60;

                goto try_except_handler_6;
            }
            assert( tmp_select_metaclass_3__base == NULL );
            tmp_select_metaclass_3__base = tmp_assign_source_30;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_2;
            CHECK_OBJECT( tmp_select_metaclass_3__base );
            tmp_source_name_2 = tmp_select_metaclass_3__base;
            tmp_assign_source_29 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_2 );
            if ( tmp_assign_source_29 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 60;

                goto try_except_handler_9;
            }
            goto try_return_handler_8;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_7 = exception_type;
        exception_keeper_value_7 = exception_value;
        exception_keeper_tb_7 = exception_tb;
        exception_keeper_lineno_7 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_1;
            Py_DECREF( exception_keeper_type_7 );
            Py_XDECREF( exception_keeper_value_7 );
            Py_XDECREF( exception_keeper_tb_7 );
            CHECK_OBJECT( tmp_select_metaclass_3__base );
            tmp_type_arg_1 = tmp_select_metaclass_3__base;
            tmp_assign_source_29 = BUILTIN_TYPE1( tmp_type_arg_1 );
            assert( !(tmp_assign_source_29 == NULL) );
            goto try_return_handler_8;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_8:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_3__base );
        Py_DECREF( tmp_select_metaclass_3__base );
        tmp_select_metaclass_3__base = NULL;

        goto outline_result_3;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_3__base );
        Py_DECREF( tmp_select_metaclass_3__base );
        tmp_select_metaclass_3__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_3:;
        condexpr_end_3:;
        assert( tmp_class_creation_3__metaclass == NULL );
        tmp_class_creation_3__metaclass = tmp_assign_source_29;
    }
    {
        PyObject *tmp_assign_source_31;
        PyObject *tmp_called_name_3;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        CHECK_OBJECT( tmp_class_creation_3__metaclass );
        tmp_called_name_3 = tmp_class_creation_3__metaclass;
        tmp_args_element_name_7 = const_str_plain_CharsetMetaAttributeValue;
        CHECK_OBJECT( tmp_class_creation_3__bases );
        tmp_args_element_name_8 = tmp_class_creation_3__bases;
        CHECK_OBJECT( tmp_class_creation_3__class_dict );
        tmp_args_element_name_9 = tmp_class_creation_3__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 60;
        {
            PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
            tmp_assign_source_31 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
        }

        if ( tmp_assign_source_31 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 60;

            goto try_except_handler_6;
        }
        assert( tmp_class_creation_3__class == NULL );
        tmp_class_creation_3__class = tmp_assign_source_31;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    Py_XDECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    {
        PyObject *tmp_assign_source_32;
        CHECK_OBJECT( tmp_class_creation_3__class );
        tmp_assign_source_32 = tmp_class_creation_3__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_CharsetMetaAttributeValue, tmp_assign_source_32 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases );
    Py_DECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_AttributeValueWithCharsetSubstitution );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AttributeValueWithCharsetSubstitution );
        }

        if ( tmp_mvar_value_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "AttributeValueWithCharsetSubstitution" );
            exception_tb = NULL;

            exception_lineno = 76;

            goto try_except_handler_10;
        }

        tmp_tuple_element_2 = tmp_mvar_value_6;
        tmp_assign_source_33 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_2 );
        PyTuple_SET_ITEM( tmp_assign_source_33, 0, tmp_tuple_element_2 );
        assert( tmp_class_creation_4__bases == NULL );
        tmp_class_creation_4__bases = tmp_assign_source_33;
    }
    {
        PyObject *tmp_assign_source_34;
        {
            PyObject *tmp_set_locals_3;
            tmp_set_locals_3 = PyDict_New();
            locals_bs4$element_76 = tmp_set_locals_3;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_76, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_3001d417e4f50c846776bdf1db22299b;
        tmp_res = PyDict_SetItem( locals_bs4$element_76, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_203f19c7266c2e913c49a142834bbcfc_4, codeobj_203f19c7266c2e913c49a142834bbcfc, module_bs4$element, 0 );
        frame_203f19c7266c2e913c49a142834bbcfc_4 = cache_frame_203f19c7266c2e913c49a142834bbcfc_4;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_203f19c7266c2e913c49a142834bbcfc_4 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_203f19c7266c2e913c49a142834bbcfc_4 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_4;
            PyObject *tmp_source_name_3;
            PyObject *tmp_mvar_value_7;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_source_name_4;
            PyObject *tmp_mvar_value_8;
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_re );

            if (unlikely( tmp_mvar_value_7 == NULL ))
            {
                tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
            }

            if ( tmp_mvar_value_7 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "re" );
                exception_tb = NULL;

                exception_lineno = 85;

                goto frame_exception_exit_4;
            }

            tmp_source_name_3 = tmp_mvar_value_7;
            tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_compile );
            if ( tmp_called_name_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 85;

                goto frame_exception_exit_4;
            }
            tmp_args_element_name_10 = const_str_digest_b246a21da0bf0d1ecd21a222430c1e19;
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_re );

            if (unlikely( tmp_mvar_value_8 == NULL ))
            {
                tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
            }

            if ( tmp_mvar_value_8 == NULL )
            {
                Py_DECREF( tmp_called_name_4 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "re" );
                exception_tb = NULL;

                exception_lineno = 85;

                goto frame_exception_exit_4;
            }

            tmp_source_name_4 = tmp_mvar_value_8;
            tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_M );
            if ( tmp_args_element_name_11 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_called_name_4 );

                exception_lineno = 85;

                goto frame_exception_exit_4;
            }
            frame_203f19c7266c2e913c49a142834bbcfc_4->m_frame.f_lineno = 85;
            {
                PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
            }

            Py_DECREF( tmp_called_name_4 );
            Py_DECREF( tmp_args_element_name_11 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 85;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_76, const_str_plain_CHARSET_RE, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 85;

                goto frame_exception_exit_4;
            }
        }
        {
            PyObject *tmp_staticmethod_arg_3;
            tmp_staticmethod_arg_3 = MAKE_FUNCTION_bs4$element$$$function_5___new__(  );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_3 );
            Py_DECREF( tmp_staticmethod_arg_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 87;

                goto frame_exception_exit_4;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_76, const_str_plain___new__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 87;

                goto frame_exception_exit_4;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_203f19c7266c2e913c49a142834bbcfc_4 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_203f19c7266c2e913c49a142834bbcfc_4 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_203f19c7266c2e913c49a142834bbcfc_4, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_203f19c7266c2e913c49a142834bbcfc_4->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_203f19c7266c2e913c49a142834bbcfc_4, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_203f19c7266c2e913c49a142834bbcfc_4,
            type_description_2
        );


        // Release cached frame.
        if ( frame_203f19c7266c2e913c49a142834bbcfc_4 == cache_frame_203f19c7266c2e913c49a142834bbcfc_4 )
        {
            Py_DECREF( frame_203f19c7266c2e913c49a142834bbcfc_4 );
        }
        cache_frame_203f19c7266c2e913c49a142834bbcfc_4 = NULL;

        assertFrameObject( frame_203f19c7266c2e913c49a142834bbcfc_4 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_11;
        skip_nested_handling_3:;
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_6_encode(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_76, const_str_plain_encode, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_34 = locals_bs4$element_76;
        Py_INCREF( tmp_assign_source_34 );
        goto try_return_handler_11;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_11:;
        Py_DECREF( locals_bs4$element_76 );
        locals_bs4$element_76 = NULL;
        goto outline_result_4;
        // Exception handler code:
        try_except_handler_11:;
        exception_keeper_type_9 = exception_type;
        exception_keeper_value_9 = exception_value;
        exception_keeper_tb_9 = exception_tb;
        exception_keeper_lineno_9 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_76 );
        locals_bs4$element_76 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_9;
        exception_value = exception_keeper_value_9;
        exception_tb = exception_keeper_tb_9;
        exception_lineno = exception_keeper_lineno_9;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_3:;
        exception_lineno = 76;
        goto try_except_handler_10;
        outline_result_4:;
        assert( tmp_class_creation_4__class_dict == NULL );
        tmp_class_creation_4__class_dict = tmp_assign_source_34;
    }
    {
        PyObject *tmp_assign_source_35;
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        tmp_key_name_7 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_7 = tmp_class_creation_4__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_7, tmp_key_name_7 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 76;

            goto try_except_handler_10;
        }
        tmp_condition_result_6 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_6 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_4;
        }
        else
        {
            goto condexpr_false_4;
        }
        condexpr_true_4:;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_dict_name_8 = tmp_class_creation_4__class_dict;
        tmp_key_name_8 = const_str_plain___metaclass__;
        tmp_assign_source_35 = DICT_GET_ITEM( tmp_dict_name_8, tmp_key_name_8 );
        if ( tmp_assign_source_35 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 76;

            goto try_except_handler_10;
        }
        goto condexpr_end_4;
        condexpr_false_4:;
        {
            PyObject *tmp_assign_source_36;
            PyObject *tmp_subscribed_name_3;
            PyObject *tmp_subscript_name_3;
            CHECK_OBJECT( tmp_class_creation_4__bases );
            tmp_subscribed_name_3 = tmp_class_creation_4__bases;
            tmp_subscript_name_3 = const_int_0;
            tmp_assign_source_36 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 0 );
            if ( tmp_assign_source_36 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 76;

                goto try_except_handler_10;
            }
            assert( tmp_select_metaclass_4__base == NULL );
            tmp_select_metaclass_4__base = tmp_assign_source_36;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_5;
            CHECK_OBJECT( tmp_select_metaclass_4__base );
            tmp_source_name_5 = tmp_select_metaclass_4__base;
            tmp_assign_source_35 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_5 );
            if ( tmp_assign_source_35 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 76;

                goto try_except_handler_13;
            }
            goto try_return_handler_12;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_13:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_2;
            Py_DECREF( exception_keeper_type_10 );
            Py_XDECREF( exception_keeper_value_10 );
            Py_XDECREF( exception_keeper_tb_10 );
            CHECK_OBJECT( tmp_select_metaclass_4__base );
            tmp_type_arg_2 = tmp_select_metaclass_4__base;
            tmp_assign_source_35 = BUILTIN_TYPE1( tmp_type_arg_2 );
            assert( !(tmp_assign_source_35 == NULL) );
            goto try_return_handler_12;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_12:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
        Py_DECREF( tmp_select_metaclass_4__base );
        tmp_select_metaclass_4__base = NULL;

        goto outline_result_5;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_4__base );
        Py_DECREF( tmp_select_metaclass_4__base );
        tmp_select_metaclass_4__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_5:;
        condexpr_end_4:;
        assert( tmp_class_creation_4__metaclass == NULL );
        tmp_class_creation_4__metaclass = tmp_assign_source_35;
    }
    {
        PyObject *tmp_assign_source_37;
        PyObject *tmp_called_name_5;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_args_element_name_14;
        CHECK_OBJECT( tmp_class_creation_4__metaclass );
        tmp_called_name_5 = tmp_class_creation_4__metaclass;
        tmp_args_element_name_12 = const_str_plain_ContentMetaAttributeValue;
        CHECK_OBJECT( tmp_class_creation_4__bases );
        tmp_args_element_name_13 = tmp_class_creation_4__bases;
        CHECK_OBJECT( tmp_class_creation_4__class_dict );
        tmp_args_element_name_14 = tmp_class_creation_4__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 76;
        {
            PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13, tmp_args_element_name_14 };
            tmp_assign_source_37 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
        }

        if ( tmp_assign_source_37 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 76;

            goto try_except_handler_10;
        }
        assert( tmp_class_creation_4__class == NULL );
        tmp_class_creation_4__class = tmp_assign_source_37;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_11 = exception_type;
    exception_keeper_value_11 = exception_value;
    exception_keeper_tb_11 = exception_tb;
    exception_keeper_lineno_11 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_11;
    exception_value = exception_keeper_value_11;
    exception_tb = exception_keeper_tb_11;
    exception_lineno = exception_keeper_lineno_11;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    {
        PyObject *tmp_assign_source_38;
        CHECK_OBJECT( tmp_class_creation_4__class );
        tmp_assign_source_38 = tmp_class_creation_4__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ContentMetaAttributeValue, tmp_assign_source_38 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases );
    Py_DECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_39;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_EntitySubstitution );
        }

        if ( tmp_mvar_value_9 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "EntitySubstitution" );
            exception_tb = NULL;

            exception_lineno = 102;

            goto try_except_handler_14;
        }

        tmp_tuple_element_3 = tmp_mvar_value_9;
        tmp_assign_source_39 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_3 );
        PyTuple_SET_ITEM( tmp_assign_source_39, 0, tmp_tuple_element_3 );
        assert( tmp_class_creation_5__bases == NULL );
        tmp_class_creation_5__bases = tmp_assign_source_39;
    }
    {
        PyObject *tmp_assign_source_40;
        {
            PyObject *tmp_set_locals_4;
            tmp_set_locals_4 = PyDict_New();
            locals_bs4$element_102 = tmp_set_locals_4;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_1017197213f46afeb9536ec49b2f35a5;
        tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PySet_New( const_set_13fb6c8ad2f041fc4071c1ba6487ab4e );
        tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain_cdata_containing_tags, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PySet_New( const_set_c4437c08c2c2846750c8f9786cb91cc1 );
        tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain_preformatted_tags, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PySet_New( const_set_6e20dab302bdf7555943e6e98a3c0a93 );
        tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain_preserve_whitespace_tags, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_88c1f00bd461942e207810ba94d1fa55_5, codeobj_88c1f00bd461942e207810ba94d1fa55, module_bs4$element, 0 );
        frame_88c1f00bd461942e207810ba94d1fa55_5 = cache_frame_88c1f00bd461942e207810ba94d1fa55_5;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_88c1f00bd461942e207810ba94d1fa55_5 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_88c1f00bd461942e207810ba94d1fa55_5 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_1;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_bs4$element$$$function_7__substitute_if_appropriate(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_1 );
            Py_DECREF( tmp_classmethod_arg_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 119;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain__substitute_if_appropriate, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 119;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_classmethod_arg_2;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_bs4$element$$$function_8_substitute_html(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_2 );
            Py_DECREF( tmp_classmethod_arg_2 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 129;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain_substitute_html, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 129;

                goto frame_exception_exit_5;
            }
        }
        {
            PyObject *tmp_classmethod_arg_3;
            tmp_classmethod_arg_3 = MAKE_FUNCTION_bs4$element$$$function_9_substitute_xml(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_3 );
            Py_DECREF( tmp_classmethod_arg_3 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 134;

                goto frame_exception_exit_5;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_102, const_str_plain_substitute_xml, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 134;

                goto frame_exception_exit_5;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_88c1f00bd461942e207810ba94d1fa55_5 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_88c1f00bd461942e207810ba94d1fa55_5 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_88c1f00bd461942e207810ba94d1fa55_5, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_88c1f00bd461942e207810ba94d1fa55_5->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_88c1f00bd461942e207810ba94d1fa55_5, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_88c1f00bd461942e207810ba94d1fa55_5,
            type_description_2
        );


        // Release cached frame.
        if ( frame_88c1f00bd461942e207810ba94d1fa55_5 == cache_frame_88c1f00bd461942e207810ba94d1fa55_5 )
        {
            Py_DECREF( frame_88c1f00bd461942e207810ba94d1fa55_5 );
        }
        cache_frame_88c1f00bd461942e207810ba94d1fa55_5 = NULL;

        assertFrameObject( frame_88c1f00bd461942e207810ba94d1fa55_5 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_15;
        skip_nested_handling_4:;
        tmp_assign_source_40 = locals_bs4$element_102;
        Py_INCREF( tmp_assign_source_40 );
        goto try_return_handler_15;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_15:;
        Py_DECREF( locals_bs4$element_102 );
        locals_bs4$element_102 = NULL;
        goto outline_result_6;
        // Exception handler code:
        try_except_handler_15:;
        exception_keeper_type_12 = exception_type;
        exception_keeper_value_12 = exception_value;
        exception_keeper_tb_12 = exception_tb;
        exception_keeper_lineno_12 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_102 );
        locals_bs4$element_102 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_12;
        exception_value = exception_keeper_value_12;
        exception_tb = exception_keeper_tb_12;
        exception_lineno = exception_keeper_lineno_12;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_4:;
        exception_lineno = 102;
        goto try_except_handler_14;
        outline_result_6:;
        assert( tmp_class_creation_5__class_dict == NULL );
        tmp_class_creation_5__class_dict = tmp_assign_source_40;
    }
    {
        PyObject *tmp_assign_source_41;
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_key_name_10;
        tmp_key_name_9 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_9 = tmp_class_creation_5__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_9, tmp_key_name_9 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_14;
        }
        tmp_condition_result_7 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_7 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_5;
        }
        else
        {
            goto condexpr_false_5;
        }
        condexpr_true_5:;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_dict_name_10 = tmp_class_creation_5__class_dict;
        tmp_key_name_10 = const_str_plain___metaclass__;
        tmp_assign_source_41 = DICT_GET_ITEM( tmp_dict_name_10, tmp_key_name_10 );
        if ( tmp_assign_source_41 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_14;
        }
        goto condexpr_end_5;
        condexpr_false_5:;
        {
            PyObject *tmp_assign_source_42;
            PyObject *tmp_subscribed_name_4;
            PyObject *tmp_subscript_name_4;
            CHECK_OBJECT( tmp_class_creation_5__bases );
            tmp_subscribed_name_4 = tmp_class_creation_5__bases;
            tmp_subscript_name_4 = const_int_0;
            tmp_assign_source_42 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 0 );
            if ( tmp_assign_source_42 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 102;

                goto try_except_handler_14;
            }
            assert( tmp_select_metaclass_5__base == NULL );
            tmp_select_metaclass_5__base = tmp_assign_source_42;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_6;
            CHECK_OBJECT( tmp_select_metaclass_5__base );
            tmp_source_name_6 = tmp_select_metaclass_5__base;
            tmp_assign_source_41 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_6 );
            if ( tmp_assign_source_41 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 102;

                goto try_except_handler_17;
            }
            goto try_return_handler_16;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_17:;
        exception_keeper_type_13 = exception_type;
        exception_keeper_value_13 = exception_value;
        exception_keeper_tb_13 = exception_tb;
        exception_keeper_lineno_13 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_3;
            Py_DECREF( exception_keeper_type_13 );
            Py_XDECREF( exception_keeper_value_13 );
            Py_XDECREF( exception_keeper_tb_13 );
            CHECK_OBJECT( tmp_select_metaclass_5__base );
            tmp_type_arg_3 = tmp_select_metaclass_5__base;
            tmp_assign_source_41 = BUILTIN_TYPE1( tmp_type_arg_3 );
            assert( !(tmp_assign_source_41 == NULL) );
            goto try_return_handler_16;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_16:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
        Py_DECREF( tmp_select_metaclass_5__base );
        tmp_select_metaclass_5__base = NULL;

        goto outline_result_7;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_5__base );
        Py_DECREF( tmp_select_metaclass_5__base );
        tmp_select_metaclass_5__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_7:;
        condexpr_end_5:;
        assert( tmp_class_creation_5__metaclass == NULL );
        tmp_class_creation_5__metaclass = tmp_assign_source_41;
    }
    {
        PyObject *tmp_assign_source_43;
        PyObject *tmp_called_name_6;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        CHECK_OBJECT( tmp_class_creation_5__metaclass );
        tmp_called_name_6 = tmp_class_creation_5__metaclass;
        tmp_args_element_name_15 = const_str_plain_HTMLAwareEntitySubstitution;
        CHECK_OBJECT( tmp_class_creation_5__bases );
        tmp_args_element_name_16 = tmp_class_creation_5__bases;
        CHECK_OBJECT( tmp_class_creation_5__class_dict );
        tmp_args_element_name_17 = tmp_class_creation_5__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 102;
        {
            PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16, tmp_args_element_name_17 };
            tmp_assign_source_43 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, call_args );
        }

        if ( tmp_assign_source_43 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 102;

            goto try_except_handler_14;
        }
        assert( tmp_class_creation_5__class == NULL );
        tmp_class_creation_5__class = tmp_assign_source_43;
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_14:;
    exception_keeper_type_14 = exception_type;
    exception_keeper_value_14 = exception_value;
    exception_keeper_tb_14 = exception_tb;
    exception_keeper_lineno_14 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    Py_XDECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_14;
    exception_value = exception_keeper_value_14;
    exception_tb = exception_keeper_tb_14;
    exception_lineno = exception_keeper_lineno_14;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    {
        PyObject *tmp_assign_source_44;
        CHECK_OBJECT( tmp_class_creation_5__class );
        tmp_assign_source_44 = tmp_class_creation_5__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLAwareEntitySubstitution, tmp_assign_source_44 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class );
    Py_DECREF( tmp_class_creation_5__class );
    tmp_class_creation_5__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__bases );
    Py_DECREF( tmp_class_creation_5__bases );
    tmp_class_creation_5__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__class_dict );
    Py_DECREF( tmp_class_creation_5__class_dict );
    tmp_class_creation_5__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_5__metaclass );
    Py_DECREF( tmp_class_creation_5__metaclass );
    tmp_class_creation_5__metaclass = NULL;

    {
        PyObject *tmp_assign_source_45;
        {
            PyObject *tmp_assign_source_46;
            tmp_assign_source_46 = MAKE_FUNCTION_bs4$element$$$function_10_substitute_entities(  );



            assert( tmp_locals_bs4$element_139_key_substitute_entities == NULL );
            tmp_locals_bs4$element_139_key_substitute_entities = tmp_assign_source_46;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            PyObject *tmp_dict_key_3;
            PyObject *tmp_dict_value_3;
            PyObject *tmp_dict_key_4;
            PyObject *tmp_dict_value_4;
            tmp_dict_value_1 = const_str_digest_a694a1497725bd5d49805e1c282892b9;
            tmp_dict_key_1 = const_str_plain___module__;
            tmp_assign_source_45 = _PyDict_NewPresized( 4 );
            tmp_res = PyDict_SetItem( tmp_assign_source_45, tmp_dict_key_1, tmp_dict_value_1 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_2 = const_str_digest_16edbedf290760e205b7c3d404645ec6;
            tmp_dict_key_2 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_45, tmp_dict_key_2, tmp_dict_value_2 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_3 = const_str_chr_47;
            tmp_dict_key_3 = const_str_plain_void_element_close_prefix;
            tmp_res = PyDict_SetItem( tmp_assign_source_45, tmp_dict_key_3, tmp_dict_value_3 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_bs4$element_139_key_substitute_entities );
            tmp_dict_value_4 = tmp_locals_bs4$element_139_key_substitute_entities;
            tmp_dict_key_4 = const_str_plain_substitute_entities;
            tmp_res = PyDict_SetItem( tmp_assign_source_45, tmp_dict_key_4, tmp_dict_value_4 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_18;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_18:;
        CHECK_OBJECT( (PyObject *)tmp_locals_bs4$element_139_key_substitute_entities );
        Py_DECREF( tmp_locals_bs4$element_139_key_substitute_entities );
        tmp_locals_bs4$element_139_key_substitute_entities = NULL;

        goto outline_result_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_8:;
        assert( tmp_class_creation_6__class_dict == NULL );
        tmp_class_creation_6__class_dict = tmp_assign_source_45;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_47;
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_key_name_11;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_dict_name_12;
        PyObject *tmp_key_name_12;
        tmp_key_name_11 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_11 = tmp_class_creation_6__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_11, tmp_key_name_11 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;

            goto try_except_handler_19;
        }
        tmp_condition_result_8 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_8 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_6;
        }
        else
        {
            goto condexpr_false_6;
        }
        condexpr_true_6:;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_dict_name_12 = tmp_class_creation_6__class_dict;
        tmp_key_name_12 = const_str_plain___metaclass__;
        tmp_assign_source_47 = DICT_GET_ITEM( tmp_dict_name_12, tmp_key_name_12 );
        if ( tmp_assign_source_47 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;

            goto try_except_handler_19;
        }
        goto condexpr_end_6;
        condexpr_false_6:;
        tmp_assign_source_47 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_47 );
        condexpr_end_6:;
        assert( tmp_class_creation_6__metaclass == NULL );
        tmp_class_creation_6__metaclass = tmp_assign_source_47;
    }
    {
        PyObject *tmp_assign_source_48;
        PyObject *tmp_called_name_7;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        CHECK_OBJECT( tmp_class_creation_6__metaclass );
        tmp_called_name_7 = tmp_class_creation_6__metaclass;
        tmp_args_element_name_18 = const_str_plain_Formatter;
        tmp_args_element_name_19 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_6__class_dict );
        tmp_args_element_name_20 = tmp_class_creation_6__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 139;
        {
            PyObject *call_args[] = { tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20 };
            tmp_assign_source_48 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, call_args );
        }

        if ( tmp_assign_source_48 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;

            goto try_except_handler_19;
        }
        assert( tmp_class_creation_6__class == NULL );
        tmp_class_creation_6__class = tmp_assign_source_48;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    {
        PyObject *tmp_assign_source_49;
        CHECK_OBJECT( tmp_class_creation_6__class );
        tmp_assign_source_49 = tmp_class_creation_6__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter, tmp_assign_source_49 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class );
    Py_DECREF( tmp_class_creation_6__class );
    tmp_class_creation_6__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__class_dict );
    Py_DECREF( tmp_class_creation_6__class_dict );
    tmp_class_creation_6__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_6__metaclass );
    Py_DECREF( tmp_class_creation_6__metaclass );
    tmp_class_creation_6__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_50;
        PyObject *tmp_tuple_element_4;
        PyObject *tmp_mvar_value_10;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Formatter );
        }

        if ( tmp_mvar_value_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Formatter" );
            exception_tb = NULL;

            exception_lineno = 149;

            goto try_except_handler_20;
        }

        tmp_tuple_element_4 = tmp_mvar_value_10;
        tmp_assign_source_50 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_4 );
        PyTuple_SET_ITEM( tmp_assign_source_50, 0, tmp_tuple_element_4 );
        assert( tmp_class_creation_7__bases == NULL );
        tmp_class_creation_7__bases = tmp_assign_source_50;
    }
    {
        PyObject *tmp_assign_source_51;
        {
            PyObject *tmp_set_locals_5;
            tmp_set_locals_5 = PyDict_New();
            locals_bs4$element_149 = tmp_set_locals_5;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_149, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_683058e4e72e5e683458d44dcd762604;
        tmp_res = PyDict_SetItem( locals_bs4$element_149, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_11_substitute(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_149, const_str_plain_substitute, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_51 = locals_bs4$element_149;
        Py_INCREF( tmp_assign_source_51 );
        goto try_return_handler_21;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_21:;
        Py_DECREF( locals_bs4$element_149 );
        locals_bs4$element_149 = NULL;
        goto outline_result_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_9:;
        assert( tmp_class_creation_7__class_dict == NULL );
        tmp_class_creation_7__class_dict = tmp_assign_source_51;
    }
    {
        PyObject *tmp_assign_source_52;
        nuitka_bool tmp_condition_result_9;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        tmp_key_name_13 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_13 = tmp_class_creation_7__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_13, tmp_key_name_13 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;

            goto try_except_handler_20;
        }
        tmp_condition_result_9 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_9 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_7;
        }
        else
        {
            goto condexpr_false_7;
        }
        condexpr_true_7:;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_dict_name_14 = tmp_class_creation_7__class_dict;
        tmp_key_name_14 = const_str_plain___metaclass__;
        tmp_assign_source_52 = DICT_GET_ITEM( tmp_dict_name_14, tmp_key_name_14 );
        if ( tmp_assign_source_52 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;

            goto try_except_handler_20;
        }
        goto condexpr_end_7;
        condexpr_false_7:;
        {
            PyObject *tmp_assign_source_53;
            PyObject *tmp_subscribed_name_5;
            PyObject *tmp_subscript_name_5;
            CHECK_OBJECT( tmp_class_creation_7__bases );
            tmp_subscribed_name_5 = tmp_class_creation_7__bases;
            tmp_subscript_name_5 = const_int_0;
            tmp_assign_source_53 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 0 );
            if ( tmp_assign_source_53 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 149;

                goto try_except_handler_20;
            }
            assert( tmp_select_metaclass_7__base == NULL );
            tmp_select_metaclass_7__base = tmp_assign_source_53;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_7;
            CHECK_OBJECT( tmp_select_metaclass_7__base );
            tmp_source_name_7 = tmp_select_metaclass_7__base;
            tmp_assign_source_52 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_7 );
            if ( tmp_assign_source_52 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 149;

                goto try_except_handler_23;
            }
            goto try_return_handler_22;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_23:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_4;
            Py_DECREF( exception_keeper_type_16 );
            Py_XDECREF( exception_keeper_value_16 );
            Py_XDECREF( exception_keeper_tb_16 );
            CHECK_OBJECT( tmp_select_metaclass_7__base );
            tmp_type_arg_4 = tmp_select_metaclass_7__base;
            tmp_assign_source_52 = BUILTIN_TYPE1( tmp_type_arg_4 );
            assert( !(tmp_assign_source_52 == NULL) );
            goto try_return_handler_22;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_22:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_7__base );
        Py_DECREF( tmp_select_metaclass_7__base );
        tmp_select_metaclass_7__base = NULL;

        goto outline_result_10;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_7__base );
        Py_DECREF( tmp_select_metaclass_7__base );
        tmp_select_metaclass_7__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_10:;
        condexpr_end_7:;
        assert( tmp_class_creation_7__metaclass == NULL );
        tmp_class_creation_7__metaclass = tmp_assign_source_52;
    }
    {
        PyObject *tmp_assign_source_54;
        PyObject *tmp_called_name_8;
        PyObject *tmp_args_element_name_21;
        PyObject *tmp_args_element_name_22;
        PyObject *tmp_args_element_name_23;
        CHECK_OBJECT( tmp_class_creation_7__metaclass );
        tmp_called_name_8 = tmp_class_creation_7__metaclass;
        tmp_args_element_name_21 = const_str_plain_HTMLFormatter;
        CHECK_OBJECT( tmp_class_creation_7__bases );
        tmp_args_element_name_22 = tmp_class_creation_7__bases;
        CHECK_OBJECT( tmp_class_creation_7__class_dict );
        tmp_args_element_name_23 = tmp_class_creation_7__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 149;
        {
            PyObject *call_args[] = { tmp_args_element_name_21, tmp_args_element_name_22, tmp_args_element_name_23 };
            tmp_assign_source_54 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_8, call_args );
        }

        if ( tmp_assign_source_54 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;

            goto try_except_handler_20;
        }
        assert( tmp_class_creation_7__class == NULL );
        tmp_class_creation_7__class = tmp_assign_source_54;
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_20:;
    exception_keeper_type_17 = exception_type;
    exception_keeper_value_17 = exception_value;
    exception_keeper_tb_17 = exception_tb;
    exception_keeper_lineno_17 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    Py_XDECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_17;
    exception_value = exception_keeper_value_17;
    exception_tb = exception_keeper_tb_17;
    exception_lineno = exception_keeper_lineno_17;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    {
        PyObject *tmp_assign_source_55;
        CHECK_OBJECT( tmp_class_creation_7__class );
        tmp_assign_source_55 = tmp_class_creation_7__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLFormatter, tmp_assign_source_55 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class );
    Py_DECREF( tmp_class_creation_7__class );
    tmp_class_creation_7__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__bases );
    Py_DECREF( tmp_class_creation_7__bases );
    tmp_class_creation_7__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__class_dict );
    Py_DECREF( tmp_class_creation_7__class_dict );
    tmp_class_creation_7__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_7__metaclass );
    Py_DECREF( tmp_class_creation_7__metaclass );
    tmp_class_creation_7__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_56;
        PyObject *tmp_tuple_element_5;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Formatter );
        }

        if ( tmp_mvar_value_11 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Formatter" );
            exception_tb = NULL;

            exception_lineno = 154;

            goto try_except_handler_24;
        }

        tmp_tuple_element_5 = tmp_mvar_value_11;
        tmp_assign_source_56 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_5 );
        PyTuple_SET_ITEM( tmp_assign_source_56, 0, tmp_tuple_element_5 );
        assert( tmp_class_creation_8__bases == NULL );
        tmp_class_creation_8__bases = tmp_assign_source_56;
    }
    {
        PyObject *tmp_assign_source_57;
        {
            PyObject *tmp_set_locals_6;
            tmp_set_locals_6 = PyDict_New();
            locals_bs4$element_154 = tmp_set_locals_6;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_154, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_66fede51f6d2599d31cae6b2824d49fe;
        tmp_res = PyDict_SetItem( locals_bs4$element_154, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_12_substitute(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_154, const_str_plain_substitute, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_57 = locals_bs4$element_154;
        Py_INCREF( tmp_assign_source_57 );
        goto try_return_handler_25;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_25:;
        Py_DECREF( locals_bs4$element_154 );
        locals_bs4$element_154 = NULL;
        goto outline_result_11;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_11:;
        assert( tmp_class_creation_8__class_dict == NULL );
        tmp_class_creation_8__class_dict = tmp_assign_source_57;
    }
    {
        PyObject *tmp_assign_source_58;
        nuitka_bool tmp_condition_result_10;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_key_name_16;
        tmp_key_name_15 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_15 = tmp_class_creation_8__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_15, tmp_key_name_15 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 154;

            goto try_except_handler_24;
        }
        tmp_condition_result_10 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_10 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_8;
        }
        else
        {
            goto condexpr_false_8;
        }
        condexpr_true_8:;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_dict_name_16 = tmp_class_creation_8__class_dict;
        tmp_key_name_16 = const_str_plain___metaclass__;
        tmp_assign_source_58 = DICT_GET_ITEM( tmp_dict_name_16, tmp_key_name_16 );
        if ( tmp_assign_source_58 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 154;

            goto try_except_handler_24;
        }
        goto condexpr_end_8;
        condexpr_false_8:;
        {
            PyObject *tmp_assign_source_59;
            PyObject *tmp_subscribed_name_6;
            PyObject *tmp_subscript_name_6;
            CHECK_OBJECT( tmp_class_creation_8__bases );
            tmp_subscribed_name_6 = tmp_class_creation_8__bases;
            tmp_subscript_name_6 = const_int_0;
            tmp_assign_source_59 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 0 );
            if ( tmp_assign_source_59 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 154;

                goto try_except_handler_24;
            }
            assert( tmp_select_metaclass_8__base == NULL );
            tmp_select_metaclass_8__base = tmp_assign_source_59;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_8;
            CHECK_OBJECT( tmp_select_metaclass_8__base );
            tmp_source_name_8 = tmp_select_metaclass_8__base;
            tmp_assign_source_58 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_8 );
            if ( tmp_assign_source_58 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 154;

                goto try_except_handler_27;
            }
            goto try_return_handler_26;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_27:;
        exception_keeper_type_18 = exception_type;
        exception_keeper_value_18 = exception_value;
        exception_keeper_tb_18 = exception_tb;
        exception_keeper_lineno_18 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_5;
            Py_DECREF( exception_keeper_type_18 );
            Py_XDECREF( exception_keeper_value_18 );
            Py_XDECREF( exception_keeper_tb_18 );
            CHECK_OBJECT( tmp_select_metaclass_8__base );
            tmp_type_arg_5 = tmp_select_metaclass_8__base;
            tmp_assign_source_58 = BUILTIN_TYPE1( tmp_type_arg_5 );
            assert( !(tmp_assign_source_58 == NULL) );
            goto try_return_handler_26;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_26:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_8__base );
        Py_DECREF( tmp_select_metaclass_8__base );
        tmp_select_metaclass_8__base = NULL;

        goto outline_result_12;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_8__base );
        Py_DECREF( tmp_select_metaclass_8__base );
        tmp_select_metaclass_8__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_12:;
        condexpr_end_8:;
        assert( tmp_class_creation_8__metaclass == NULL );
        tmp_class_creation_8__metaclass = tmp_assign_source_58;
    }
    {
        PyObject *tmp_assign_source_60;
        PyObject *tmp_called_name_9;
        PyObject *tmp_args_element_name_24;
        PyObject *tmp_args_element_name_25;
        PyObject *tmp_args_element_name_26;
        CHECK_OBJECT( tmp_class_creation_8__metaclass );
        tmp_called_name_9 = tmp_class_creation_8__metaclass;
        tmp_args_element_name_24 = const_str_plain_MinimalHTMLFormatter;
        CHECK_OBJECT( tmp_class_creation_8__bases );
        tmp_args_element_name_25 = tmp_class_creation_8__bases;
        CHECK_OBJECT( tmp_class_creation_8__class_dict );
        tmp_args_element_name_26 = tmp_class_creation_8__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 154;
        {
            PyObject *call_args[] = { tmp_args_element_name_24, tmp_args_element_name_25, tmp_args_element_name_26 };
            tmp_assign_source_60 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
        }

        if ( tmp_assign_source_60 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 154;

            goto try_except_handler_24;
        }
        assert( tmp_class_creation_8__class == NULL );
        tmp_class_creation_8__class = tmp_assign_source_60;
    }
    goto try_end_10;
    // Exception handler code:
    try_except_handler_24:;
    exception_keeper_type_19 = exception_type;
    exception_keeper_value_19 = exception_value;
    exception_keeper_tb_19 = exception_tb;
    exception_keeper_lineno_19 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_8__bases );
    tmp_class_creation_8__bases = NULL;

    Py_XDECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_19;
    exception_value = exception_keeper_value_19;
    exception_tb = exception_keeper_tb_19;
    exception_lineno = exception_keeper_lineno_19;

    goto frame_exception_exit_1;
    // End of try:
    try_end_10:;
    {
        PyObject *tmp_assign_source_61;
        CHECK_OBJECT( tmp_class_creation_8__class );
        tmp_assign_source_61 = tmp_class_creation_8__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_MinimalHTMLFormatter, tmp_assign_source_61 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class );
    Py_DECREF( tmp_class_creation_8__class );
    tmp_class_creation_8__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__bases );
    Py_DECREF( tmp_class_creation_8__bases );
    tmp_class_creation_8__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__class_dict );
    Py_DECREF( tmp_class_creation_8__class_dict );
    tmp_class_creation_8__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_8__metaclass );
    Py_DECREF( tmp_class_creation_8__metaclass );
    tmp_class_creation_8__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_62;
        PyObject *tmp_tuple_element_6;
        PyObject *tmp_mvar_value_12;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLFormatter );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLFormatter );
        }

        if ( tmp_mvar_value_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "HTMLFormatter" );
            exception_tb = NULL;

            exception_lineno = 159;

            goto try_except_handler_28;
        }

        tmp_tuple_element_6 = tmp_mvar_value_12;
        tmp_assign_source_62 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_6 );
        PyTuple_SET_ITEM( tmp_assign_source_62, 0, tmp_tuple_element_6 );
        assert( tmp_class_creation_9__bases == NULL );
        tmp_class_creation_9__bases = tmp_assign_source_62;
    }
    {
        PyObject *tmp_assign_source_63;
        {
            PyObject *tmp_set_locals_7;
            tmp_set_locals_7 = PyDict_New();
            locals_bs4$element_159 = tmp_set_locals_7;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_159, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_f6bcba6ba3fa9e79445ecc6dd89d522b;
        tmp_res = PyDict_SetItem( locals_bs4$element_159, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = Py_None;
        tmp_res = PyDict_SetItem( locals_bs4$element_159, const_str_plain_void_element_close_prefix, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_63 = locals_bs4$element_159;
        Py_INCREF( tmp_assign_source_63 );
        goto try_return_handler_29;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_29:;
        Py_DECREF( locals_bs4$element_159 );
        locals_bs4$element_159 = NULL;
        goto outline_result_13;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_13:;
        assert( tmp_class_creation_9__class_dict == NULL );
        tmp_class_creation_9__class_dict = tmp_assign_source_63;
    }
    {
        PyObject *tmp_assign_source_64;
        nuitka_bool tmp_condition_result_11;
        PyObject *tmp_key_name_17;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_dict_name_18;
        PyObject *tmp_key_name_18;
        tmp_key_name_17 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_17 = tmp_class_creation_9__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_17, tmp_key_name_17 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 159;

            goto try_except_handler_28;
        }
        tmp_condition_result_11 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_11 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_9;
        }
        else
        {
            goto condexpr_false_9;
        }
        condexpr_true_9:;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_dict_name_18 = tmp_class_creation_9__class_dict;
        tmp_key_name_18 = const_str_plain___metaclass__;
        tmp_assign_source_64 = DICT_GET_ITEM( tmp_dict_name_18, tmp_key_name_18 );
        if ( tmp_assign_source_64 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 159;

            goto try_except_handler_28;
        }
        goto condexpr_end_9;
        condexpr_false_9:;
        {
            PyObject *tmp_assign_source_65;
            PyObject *tmp_subscribed_name_7;
            PyObject *tmp_subscript_name_7;
            CHECK_OBJECT( tmp_class_creation_9__bases );
            tmp_subscribed_name_7 = tmp_class_creation_9__bases;
            tmp_subscript_name_7 = const_int_0;
            tmp_assign_source_65 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 0 );
            if ( tmp_assign_source_65 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 159;

                goto try_except_handler_28;
            }
            assert( tmp_select_metaclass_9__base == NULL );
            tmp_select_metaclass_9__base = tmp_assign_source_65;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_9;
            CHECK_OBJECT( tmp_select_metaclass_9__base );
            tmp_source_name_9 = tmp_select_metaclass_9__base;
            tmp_assign_source_64 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_9 );
            if ( tmp_assign_source_64 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 159;

                goto try_except_handler_31;
            }
            goto try_return_handler_30;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_31:;
        exception_keeper_type_20 = exception_type;
        exception_keeper_value_20 = exception_value;
        exception_keeper_tb_20 = exception_tb;
        exception_keeper_lineno_20 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_6;
            Py_DECREF( exception_keeper_type_20 );
            Py_XDECREF( exception_keeper_value_20 );
            Py_XDECREF( exception_keeper_tb_20 );
            CHECK_OBJECT( tmp_select_metaclass_9__base );
            tmp_type_arg_6 = tmp_select_metaclass_9__base;
            tmp_assign_source_64 = BUILTIN_TYPE1( tmp_type_arg_6 );
            assert( !(tmp_assign_source_64 == NULL) );
            goto try_return_handler_30;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_30:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
        Py_DECREF( tmp_select_metaclass_9__base );
        tmp_select_metaclass_9__base = NULL;

        goto outline_result_14;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_9__base );
        Py_DECREF( tmp_select_metaclass_9__base );
        tmp_select_metaclass_9__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_14:;
        condexpr_end_9:;
        assert( tmp_class_creation_9__metaclass == NULL );
        tmp_class_creation_9__metaclass = tmp_assign_source_64;
    }
    {
        PyObject *tmp_assign_source_66;
        PyObject *tmp_called_name_10;
        PyObject *tmp_args_element_name_27;
        PyObject *tmp_args_element_name_28;
        PyObject *tmp_args_element_name_29;
        CHECK_OBJECT( tmp_class_creation_9__metaclass );
        tmp_called_name_10 = tmp_class_creation_9__metaclass;
        tmp_args_element_name_27 = const_str_plain_HTML5Formatter;
        CHECK_OBJECT( tmp_class_creation_9__bases );
        tmp_args_element_name_28 = tmp_class_creation_9__bases;
        CHECK_OBJECT( tmp_class_creation_9__class_dict );
        tmp_args_element_name_29 = tmp_class_creation_9__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 159;
        {
            PyObject *call_args[] = { tmp_args_element_name_27, tmp_args_element_name_28, tmp_args_element_name_29 };
            tmp_assign_source_66 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, call_args );
        }

        if ( tmp_assign_source_66 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 159;

            goto try_except_handler_28;
        }
        assert( tmp_class_creation_9__class == NULL );
        tmp_class_creation_9__class = tmp_assign_source_66;
    }
    goto try_end_11;
    // Exception handler code:
    try_except_handler_28:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    Py_XDECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_11:;
    {
        PyObject *tmp_assign_source_67;
        CHECK_OBJECT( tmp_class_creation_9__class );
        tmp_assign_source_67 = tmp_class_creation_9__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTML5Formatter, tmp_assign_source_67 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class );
    Py_DECREF( tmp_class_creation_9__class );
    tmp_class_creation_9__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__bases );
    Py_DECREF( tmp_class_creation_9__bases );
    tmp_class_creation_9__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__class_dict );
    Py_DECREF( tmp_class_creation_9__class_dict );
    tmp_class_creation_9__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_9__metaclass );
    Py_DECREF( tmp_class_creation_9__metaclass );
    tmp_class_creation_9__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_68;
        PyObject *tmp_tuple_element_7;
        PyObject *tmp_mvar_value_13;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Formatter );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Formatter" );
            exception_tb = NULL;

            exception_lineno = 163;

            goto try_except_handler_32;
        }

        tmp_tuple_element_7 = tmp_mvar_value_13;
        tmp_assign_source_68 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_7 );
        PyTuple_SET_ITEM( tmp_assign_source_68, 0, tmp_tuple_element_7 );
        assert( tmp_class_creation_10__bases == NULL );
        tmp_class_creation_10__bases = tmp_assign_source_68;
    }
    {
        PyObject *tmp_assign_source_69;
        {
            PyObject *tmp_set_locals_8;
            tmp_set_locals_8 = PyDict_New();
            locals_bs4$element_163 = tmp_set_locals_8;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_163, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_6fafb2efdc26996459dc0ccdbcddbdf7;
        tmp_res = PyDict_SetItem( locals_bs4$element_163, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_13_substitute(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_163, const_str_plain_substitute, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_69 = locals_bs4$element_163;
        Py_INCREF( tmp_assign_source_69 );
        goto try_return_handler_33;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_33:;
        Py_DECREF( locals_bs4$element_163 );
        locals_bs4$element_163 = NULL;
        goto outline_result_15;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_15:;
        assert( tmp_class_creation_10__class_dict == NULL );
        tmp_class_creation_10__class_dict = tmp_assign_source_69;
    }
    {
        PyObject *tmp_assign_source_70;
        nuitka_bool tmp_condition_result_12;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        tmp_key_name_19 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_19 = tmp_class_creation_10__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_19, tmp_key_name_19 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 163;

            goto try_except_handler_32;
        }
        tmp_condition_result_12 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_12 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_10;
        }
        else
        {
            goto condexpr_false_10;
        }
        condexpr_true_10:;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_dict_name_20 = tmp_class_creation_10__class_dict;
        tmp_key_name_20 = const_str_plain___metaclass__;
        tmp_assign_source_70 = DICT_GET_ITEM( tmp_dict_name_20, tmp_key_name_20 );
        if ( tmp_assign_source_70 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 163;

            goto try_except_handler_32;
        }
        goto condexpr_end_10;
        condexpr_false_10:;
        {
            PyObject *tmp_assign_source_71;
            PyObject *tmp_subscribed_name_8;
            PyObject *tmp_subscript_name_8;
            CHECK_OBJECT( tmp_class_creation_10__bases );
            tmp_subscribed_name_8 = tmp_class_creation_10__bases;
            tmp_subscript_name_8 = const_int_0;
            tmp_assign_source_71 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_8, tmp_subscript_name_8, 0 );
            if ( tmp_assign_source_71 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 163;

                goto try_except_handler_32;
            }
            assert( tmp_select_metaclass_10__base == NULL );
            tmp_select_metaclass_10__base = tmp_assign_source_71;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_10;
            CHECK_OBJECT( tmp_select_metaclass_10__base );
            tmp_source_name_10 = tmp_select_metaclass_10__base;
            tmp_assign_source_70 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_10 );
            if ( tmp_assign_source_70 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 163;

                goto try_except_handler_35;
            }
            goto try_return_handler_34;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_35:;
        exception_keeper_type_22 = exception_type;
        exception_keeper_value_22 = exception_value;
        exception_keeper_tb_22 = exception_tb;
        exception_keeper_lineno_22 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_7;
            Py_DECREF( exception_keeper_type_22 );
            Py_XDECREF( exception_keeper_value_22 );
            Py_XDECREF( exception_keeper_tb_22 );
            CHECK_OBJECT( tmp_select_metaclass_10__base );
            tmp_type_arg_7 = tmp_select_metaclass_10__base;
            tmp_assign_source_70 = BUILTIN_TYPE1( tmp_type_arg_7 );
            assert( !(tmp_assign_source_70 == NULL) );
            goto try_return_handler_34;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_34:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
        Py_DECREF( tmp_select_metaclass_10__base );
        tmp_select_metaclass_10__base = NULL;

        goto outline_result_16;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_10__base );
        Py_DECREF( tmp_select_metaclass_10__base );
        tmp_select_metaclass_10__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_16:;
        condexpr_end_10:;
        assert( tmp_class_creation_10__metaclass == NULL );
        tmp_class_creation_10__metaclass = tmp_assign_source_70;
    }
    {
        PyObject *tmp_assign_source_72;
        PyObject *tmp_called_name_11;
        PyObject *tmp_args_element_name_30;
        PyObject *tmp_args_element_name_31;
        PyObject *tmp_args_element_name_32;
        CHECK_OBJECT( tmp_class_creation_10__metaclass );
        tmp_called_name_11 = tmp_class_creation_10__metaclass;
        tmp_args_element_name_30 = const_str_plain_XMLFormatter;
        CHECK_OBJECT( tmp_class_creation_10__bases );
        tmp_args_element_name_31 = tmp_class_creation_10__bases;
        CHECK_OBJECT( tmp_class_creation_10__class_dict );
        tmp_args_element_name_32 = tmp_class_creation_10__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 163;
        {
            PyObject *call_args[] = { tmp_args_element_name_30, tmp_args_element_name_31, tmp_args_element_name_32 };
            tmp_assign_source_72 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_11, call_args );
        }

        if ( tmp_assign_source_72 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 163;

            goto try_except_handler_32;
        }
        assert( tmp_class_creation_10__class == NULL );
        tmp_class_creation_10__class = tmp_assign_source_72;
    }
    goto try_end_12;
    // Exception handler code:
    try_except_handler_32:;
    exception_keeper_type_23 = exception_type;
    exception_keeper_value_23 = exception_value;
    exception_keeper_tb_23 = exception_tb;
    exception_keeper_lineno_23 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    Py_XDECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_23;
    exception_value = exception_keeper_value_23;
    exception_tb = exception_keeper_tb_23;
    exception_lineno = exception_keeper_lineno_23;

    goto frame_exception_exit_1;
    // End of try:
    try_end_12:;
    {
        PyObject *tmp_assign_source_73;
        CHECK_OBJECT( tmp_class_creation_10__class );
        tmp_assign_source_73 = tmp_class_creation_10__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_XMLFormatter, tmp_assign_source_73 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class );
    Py_DECREF( tmp_class_creation_10__class );
    tmp_class_creation_10__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__bases );
    Py_DECREF( tmp_class_creation_10__bases );
    tmp_class_creation_10__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__class_dict );
    Py_DECREF( tmp_class_creation_10__class_dict );
    tmp_class_creation_10__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_10__metaclass );
    Py_DECREF( tmp_class_creation_10__metaclass );
    tmp_class_creation_10__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_74;
        PyObject *tmp_tuple_element_8;
        PyObject *tmp_mvar_value_14;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Formatter );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Formatter );
        }

        if ( tmp_mvar_value_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "Formatter" );
            exception_tb = NULL;

            exception_lineno = 168;

            goto try_except_handler_36;
        }

        tmp_tuple_element_8 = tmp_mvar_value_14;
        tmp_assign_source_74 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_8 );
        PyTuple_SET_ITEM( tmp_assign_source_74, 0, tmp_tuple_element_8 );
        assert( tmp_class_creation_11__bases == NULL );
        tmp_class_creation_11__bases = tmp_assign_source_74;
    }
    {
        PyObject *tmp_assign_source_75;
        {
            PyObject *tmp_set_locals_9;
            tmp_set_locals_9 = PyDict_New();
            locals_bs4$element_168 = tmp_set_locals_9;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_168, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_c658d19634e753d4f72ac98fd801f3f1;
        tmp_res = PyDict_SetItem( locals_bs4$element_168, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_14_substitute(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_168, const_str_plain_substitute, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_75 = locals_bs4$element_168;
        Py_INCREF( tmp_assign_source_75 );
        goto try_return_handler_37;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_37:;
        Py_DECREF( locals_bs4$element_168 );
        locals_bs4$element_168 = NULL;
        goto outline_result_17;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_17:;
        assert( tmp_class_creation_11__class_dict == NULL );
        tmp_class_creation_11__class_dict = tmp_assign_source_75;
    }
    {
        PyObject *tmp_assign_source_76;
        nuitka_bool tmp_condition_result_13;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_key_name_22;
        tmp_key_name_21 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_21 = tmp_class_creation_11__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_21, tmp_key_name_21 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 168;

            goto try_except_handler_36;
        }
        tmp_condition_result_13 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_13 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_11;
        }
        else
        {
            goto condexpr_false_11;
        }
        condexpr_true_11:;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_dict_name_22 = tmp_class_creation_11__class_dict;
        tmp_key_name_22 = const_str_plain___metaclass__;
        tmp_assign_source_76 = DICT_GET_ITEM( tmp_dict_name_22, tmp_key_name_22 );
        if ( tmp_assign_source_76 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 168;

            goto try_except_handler_36;
        }
        goto condexpr_end_11;
        condexpr_false_11:;
        {
            PyObject *tmp_assign_source_77;
            PyObject *tmp_subscribed_name_9;
            PyObject *tmp_subscript_name_9;
            CHECK_OBJECT( tmp_class_creation_11__bases );
            tmp_subscribed_name_9 = tmp_class_creation_11__bases;
            tmp_subscript_name_9 = const_int_0;
            tmp_assign_source_77 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_9, tmp_subscript_name_9, 0 );
            if ( tmp_assign_source_77 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 168;

                goto try_except_handler_36;
            }
            assert( tmp_select_metaclass_11__base == NULL );
            tmp_select_metaclass_11__base = tmp_assign_source_77;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_11;
            CHECK_OBJECT( tmp_select_metaclass_11__base );
            tmp_source_name_11 = tmp_select_metaclass_11__base;
            tmp_assign_source_76 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_11 );
            if ( tmp_assign_source_76 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 168;

                goto try_except_handler_39;
            }
            goto try_return_handler_38;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_39:;
        exception_keeper_type_24 = exception_type;
        exception_keeper_value_24 = exception_value;
        exception_keeper_tb_24 = exception_tb;
        exception_keeper_lineno_24 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_8;
            Py_DECREF( exception_keeper_type_24 );
            Py_XDECREF( exception_keeper_value_24 );
            Py_XDECREF( exception_keeper_tb_24 );
            CHECK_OBJECT( tmp_select_metaclass_11__base );
            tmp_type_arg_8 = tmp_select_metaclass_11__base;
            tmp_assign_source_76 = BUILTIN_TYPE1( tmp_type_arg_8 );
            assert( !(tmp_assign_source_76 == NULL) );
            goto try_return_handler_38;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_38:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
        Py_DECREF( tmp_select_metaclass_11__base );
        tmp_select_metaclass_11__base = NULL;

        goto outline_result_18;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_11__base );
        Py_DECREF( tmp_select_metaclass_11__base );
        tmp_select_metaclass_11__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_18:;
        condexpr_end_11:;
        assert( tmp_class_creation_11__metaclass == NULL );
        tmp_class_creation_11__metaclass = tmp_assign_source_76;
    }
    {
        PyObject *tmp_assign_source_78;
        PyObject *tmp_called_name_12;
        PyObject *tmp_args_element_name_33;
        PyObject *tmp_args_element_name_34;
        PyObject *tmp_args_element_name_35;
        CHECK_OBJECT( tmp_class_creation_11__metaclass );
        tmp_called_name_12 = tmp_class_creation_11__metaclass;
        tmp_args_element_name_33 = const_str_plain_HTMLXMLFormatter;
        CHECK_OBJECT( tmp_class_creation_11__bases );
        tmp_args_element_name_34 = tmp_class_creation_11__bases;
        CHECK_OBJECT( tmp_class_creation_11__class_dict );
        tmp_args_element_name_35 = tmp_class_creation_11__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 168;
        {
            PyObject *call_args[] = { tmp_args_element_name_33, tmp_args_element_name_34, tmp_args_element_name_35 };
            tmp_assign_source_78 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_12, call_args );
        }

        if ( tmp_assign_source_78 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 168;

            goto try_except_handler_36;
        }
        assert( tmp_class_creation_11__class == NULL );
        tmp_class_creation_11__class = tmp_assign_source_78;
    }
    goto try_end_13;
    // Exception handler code:
    try_except_handler_36:;
    exception_keeper_type_25 = exception_type;
    exception_keeper_value_25 = exception_value;
    exception_keeper_tb_25 = exception_tb;
    exception_keeper_lineno_25 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    Py_XDECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_25;
    exception_value = exception_keeper_value_25;
    exception_tb = exception_keeper_tb_25;
    exception_lineno = exception_keeper_lineno_25;

    goto frame_exception_exit_1;
    // End of try:
    try_end_13:;
    {
        PyObject *tmp_assign_source_79;
        CHECK_OBJECT( tmp_class_creation_11__class );
        tmp_assign_source_79 = tmp_class_creation_11__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLXMLFormatter, tmp_assign_source_79 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class );
    Py_DECREF( tmp_class_creation_11__class );
    tmp_class_creation_11__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__bases );
    Py_DECREF( tmp_class_creation_11__bases );
    tmp_class_creation_11__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__class_dict );
    Py_DECREF( tmp_class_creation_11__class_dict );
    tmp_class_creation_11__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_11__metaclass );
    Py_DECREF( tmp_class_creation_11__metaclass );
    tmp_class_creation_11__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_80;
        {
            PyObject *tmp_set_locals_10;
            tmp_set_locals_10 = PyDict_New();
            locals_bs4$element_174 = tmp_set_locals_10;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_d73614277c6d61645b151d81f183d780;
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_9d17cb8081dcccefd359db453c9db698_6, codeobj_9d17cb8081dcccefd359db453c9db698, module_bs4$element, 0 );
        frame_9d17cb8081dcccefd359db453c9db698_6 = cache_frame_9d17cb8081dcccefd359db453c9db698_6;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_9d17cb8081dcccefd359db453c9db698_6 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_9d17cb8081dcccefd359db453c9db698_6 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_dict_key_5;
            PyObject *tmp_dict_value_5;
            PyObject *tmp_called_name_13;
            PyObject *tmp_mvar_value_15;
            PyObject *tmp_dict_key_6;
            PyObject *tmp_dict_value_6;
            PyObject *tmp_called_name_14;
            PyObject *tmp_mvar_value_16;
            PyObject *tmp_dict_key_7;
            PyObject *tmp_dict_value_7;
            PyObject *tmp_called_name_15;
            PyObject *tmp_mvar_value_17;
            PyObject *tmp_dict_key_8;
            PyObject *tmp_dict_value_8;
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLFormatter );

            if (unlikely( tmp_mvar_value_15 == NULL ))
            {
                tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLFormatter );
            }

            if ( tmp_mvar_value_15 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "HTMLFormatter" );
                exception_tb = NULL;

                exception_lineno = 201;

                goto frame_exception_exit_6;
            }

            tmp_called_name_13 = tmp_mvar_value_15;
            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 201;
            tmp_dict_value_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_13 );
            if ( tmp_dict_value_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 201;

                goto frame_exception_exit_6;
            }
            tmp_dict_key_5 = const_str_plain_html;
            tmp_dictset_value = _PyDict_NewPresized( 4 );
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_5, tmp_dict_value_5 );
            Py_DECREF( tmp_dict_value_5 );
            assert( !(tmp_res != 0) );
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTML5Formatter );

            if (unlikely( tmp_mvar_value_16 == NULL ))
            {
                tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTML5Formatter );
            }

            if ( tmp_mvar_value_16 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "HTML5Formatter" );
                exception_tb = NULL;

                exception_lineno = 202;

                goto frame_exception_exit_6;
            }

            tmp_called_name_14 = tmp_mvar_value_16;
            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 202;
            tmp_dict_value_6 = CALL_FUNCTION_NO_ARGS( tmp_called_name_14 );
            if ( tmp_dict_value_6 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 202;

                goto frame_exception_exit_6;
            }
            tmp_dict_key_6 = const_str_plain_html5;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_6, tmp_dict_value_6 );
            Py_DECREF( tmp_dict_value_6 );
            assert( !(tmp_res != 0) );
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_MinimalHTMLFormatter );

            if (unlikely( tmp_mvar_value_17 == NULL ))
            {
                tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_MinimalHTMLFormatter );
            }

            if ( tmp_mvar_value_17 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "MinimalHTMLFormatter" );
                exception_tb = NULL;

                exception_lineno = 203;

                goto frame_exception_exit_6;
            }

            tmp_called_name_15 = tmp_mvar_value_17;
            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 203;
            tmp_dict_value_7 = CALL_FUNCTION_NO_ARGS( tmp_called_name_15 );
            if ( tmp_dict_value_7 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 203;

                goto frame_exception_exit_6;
            }
            tmp_dict_key_7 = const_str_plain_minimal;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_7, tmp_dict_value_7 );
            Py_DECREF( tmp_dict_value_7 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_8 = Py_None;
            tmp_dict_key_8 = Py_None;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_8, tmp_dict_value_8 );
            assert( !(tmp_res != 0) );
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_HTML_FORMATTERS, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 200;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_dict_key_9;
            PyObject *tmp_dict_value_9;
            PyObject *tmp_called_name_16;
            PyObject *tmp_mvar_value_18;
            PyObject *tmp_dict_key_10;
            PyObject *tmp_dict_value_10;
            PyObject *tmp_called_name_17;
            PyObject *tmp_mvar_value_19;
            PyObject *tmp_dict_key_11;
            PyObject *tmp_dict_value_11;
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_HTMLXMLFormatter );

            if (unlikely( tmp_mvar_value_18 == NULL ))
            {
                tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_HTMLXMLFormatter );
            }

            if ( tmp_mvar_value_18 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "HTMLXMLFormatter" );
                exception_tb = NULL;

                exception_lineno = 208;

                goto frame_exception_exit_6;
            }

            tmp_called_name_16 = tmp_mvar_value_18;
            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 208;
            tmp_dict_value_9 = CALL_FUNCTION_NO_ARGS( tmp_called_name_16 );
            if ( tmp_dict_value_9 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 208;

                goto frame_exception_exit_6;
            }
            tmp_dict_key_9 = const_str_plain_html;
            tmp_dictset_value = _PyDict_NewPresized( 3 );
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_9, tmp_dict_value_9 );
            Py_DECREF( tmp_dict_value_9 );
            assert( !(tmp_res != 0) );
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_XMLFormatter );

            if (unlikely( tmp_mvar_value_19 == NULL ))
            {
                tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_XMLFormatter );
            }

            if ( tmp_mvar_value_19 == NULL )
            {
                Py_DECREF( tmp_dictset_value );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "XMLFormatter" );
                exception_tb = NULL;

                exception_lineno = 209;

                goto frame_exception_exit_6;
            }

            tmp_called_name_17 = tmp_mvar_value_19;
            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 209;
            tmp_dict_value_10 = CALL_FUNCTION_NO_ARGS( tmp_called_name_17 );
            if ( tmp_dict_value_10 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                Py_DECREF( tmp_dictset_value );

                exception_lineno = 209;

                goto frame_exception_exit_6;
            }
            tmp_dict_key_10 = const_str_plain_minimal;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_10, tmp_dict_value_10 );
            Py_DECREF( tmp_dict_value_10 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_11 = Py_None;
            tmp_dict_key_11 = Py_None;
            tmp_res = PyDict_SetItem( tmp_dictset_value, tmp_dict_key_11, tmp_dict_value_11 );
            assert( !(tmp_res != 0) );
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_XML_FORMATTERS, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 207;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_str_plain_minimal_tuple;
            Py_INCREF( tmp_defaults_2 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_15_format_string( tmp_defaults_2 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_format_string, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_called_name_18;
            PyObject *tmp_args_element_name_36;
            tmp_called_name_18 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_36 = MAKE_FUNCTION_bs4$element$$$function_16__is_xml(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 227;
            {
                PyObject *call_args[] = { tmp_args_element_name_36 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
            }

            Py_DECREF( tmp_args_element_name_36 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 227;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain__is_xml, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 227;

                goto frame_exception_exit_6;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_17__formatter_for_name(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain__formatter_for_name, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_3;
            tmp_defaults_3 = const_tuple_none_none_none_none_none_tuple;
            Py_INCREF( tmp_defaults_3 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_18_setup( tmp_defaults_3 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_setup, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_called_name_19;
            PyObject *tmp_mvar_value_20;
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain__alias );

            if (unlikely( tmp_mvar_value_20 == NULL ))
            {
                tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__alias );
            }

            if ( tmp_mvar_value_20 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_alias" );
                exception_tb = NULL;

                exception_lineno = 284;

                goto frame_exception_exit_6;
            }

            tmp_called_name_19 = tmp_mvar_value_20;
            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 284;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, &PyTuple_GET_ITEM( const_tuple_str_plain_next_sibling_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 284;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_nextSibling, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 284;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_20;
            PyObject *tmp_mvar_value_21;
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain__alias );

            if (unlikely( tmp_mvar_value_21 == NULL ))
            {
                tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__alias );
            }

            if ( tmp_mvar_value_21 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_alias" );
                exception_tb = NULL;

                exception_lineno = 285;

                goto frame_exception_exit_6;
            }

            tmp_called_name_20 = tmp_mvar_value_21;
            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 285;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, &PyTuple_GET_ITEM( const_tuple_str_plain_previous_sibling_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 285;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_previousSibling, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 285;

                goto frame_exception_exit_6;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_19_replace_with(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_replace_with, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_replace_with );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "replace_with" );
            exception_tb = NULL;

            exception_lineno = 301;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 301;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_replaceWith, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_20_unwrap(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_unwrap, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_unwrap );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "unwrap" );
            exception_tb = NULL;

            exception_lineno = 314;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 314;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_replace_with_children, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_unwrap );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "unwrap" );
            exception_tb = NULL;

            exception_lineno = 315;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 315;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_replaceWithChildren, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_21_wrap(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_wrap, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_22_extract(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_extract, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_4;
            tmp_defaults_4 = const_tuple_true_true_tuple;
            Py_INCREF( tmp_defaults_4 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_23__last_descendant( tmp_defaults_4 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain__last_descendant, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain__last_descendant );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "_last_descendant" );
            exception_tb = NULL;

            exception_lineno = 363;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 363;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain__lastRecursiveChild, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_24_insert(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_insert, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_25_append(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_append, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_26_extend(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_extend, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_27_insert_before(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_insert_before, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_28_insert_after(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_insert_after, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_5;
            PyObject *tmp_tuple_element_9;
            tmp_tuple_element_9 = Py_None;
            tmp_defaults_5 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_9 );
            PyTuple_SET_ITEM( tmp_defaults_5, 0, tmp_tuple_element_9 );
            tmp_tuple_element_9 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_5, 1, tmp_tuple_element_9 );
            tmp_tuple_element_9 = Py_None;
            Py_INCREF( tmp_tuple_element_9 );
            PyTuple_SET_ITEM( tmp_defaults_5, 2, tmp_tuple_element_9 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_29_find_next( tmp_defaults_5 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_next, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_next );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_next" );
            exception_tb = NULL;

            exception_lineno = 496;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 496;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findNext, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_6;
            PyObject *tmp_tuple_element_10;
            tmp_tuple_element_10 = Py_None;
            tmp_defaults_6 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_10 );
            PyTuple_SET_ITEM( tmp_defaults_6, 0, tmp_tuple_element_10 );
            tmp_tuple_element_10 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_6, 1, tmp_tuple_element_10 );
            tmp_tuple_element_10 = Py_None;
            Py_INCREF( tmp_tuple_element_10 );
            PyTuple_SET_ITEM( tmp_defaults_6, 2, tmp_tuple_element_10 );
            tmp_tuple_element_10 = Py_None;
            Py_INCREF( tmp_tuple_element_10 );
            PyTuple_SET_ITEM( tmp_defaults_6, 3, tmp_tuple_element_10 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_30_find_all_next( tmp_defaults_6 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_all_next, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_all_next );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_all_next" );
            exception_tb = NULL;

            exception_lineno = 504;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 504;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findAllNext, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_7;
            PyObject *tmp_tuple_element_11;
            tmp_tuple_element_11 = Py_None;
            tmp_defaults_7 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_11 );
            PyTuple_SET_ITEM( tmp_defaults_7, 0, tmp_tuple_element_11 );
            tmp_tuple_element_11 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_7, 1, tmp_tuple_element_11 );
            tmp_tuple_element_11 = Py_None;
            Py_INCREF( tmp_tuple_element_11 );
            PyTuple_SET_ITEM( tmp_defaults_7, 2, tmp_tuple_element_11 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_31_find_next_sibling( tmp_defaults_7 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_next_sibling, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_next_sibling );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_next_sibling" );
            exception_tb = NULL;

            exception_lineno = 511;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 511;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findNextSibling, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_8;
            PyObject *tmp_tuple_element_12;
            tmp_tuple_element_12 = Py_None;
            tmp_defaults_8 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_12 );
            PyTuple_SET_ITEM( tmp_defaults_8, 0, tmp_tuple_element_12 );
            tmp_tuple_element_12 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_8, 1, tmp_tuple_element_12 );
            tmp_tuple_element_12 = Py_None;
            Py_INCREF( tmp_tuple_element_12 );
            PyTuple_SET_ITEM( tmp_defaults_8, 2, tmp_tuple_element_12 );
            tmp_tuple_element_12 = Py_None;
            Py_INCREF( tmp_tuple_element_12 );
            PyTuple_SET_ITEM( tmp_defaults_8, 3, tmp_tuple_element_12 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_32_find_next_siblings( tmp_defaults_8 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_next_siblings, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_next_siblings );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_next_siblings" );
            exception_tb = NULL;

            exception_lineno = 519;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 519;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findNextSiblings, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_next_siblings );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_next_siblings" );
            exception_tb = NULL;

            exception_lineno = 520;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 520;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_fetchNextSiblings, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_9;
            PyObject *tmp_tuple_element_13;
            tmp_tuple_element_13 = Py_None;
            tmp_defaults_9 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_13 );
            PyTuple_SET_ITEM( tmp_defaults_9, 0, tmp_tuple_element_13 );
            tmp_tuple_element_13 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_9, 1, tmp_tuple_element_13 );
            tmp_tuple_element_13 = Py_None;
            Py_INCREF( tmp_tuple_element_13 );
            PyTuple_SET_ITEM( tmp_defaults_9, 2, tmp_tuple_element_13 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_33_find_previous( tmp_defaults_9 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_previous, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_previous );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_previous" );
            exception_tb = NULL;

            exception_lineno = 527;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 527;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findPrevious, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_10;
            PyObject *tmp_tuple_element_14;
            tmp_tuple_element_14 = Py_None;
            tmp_defaults_10 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_14 );
            PyTuple_SET_ITEM( tmp_defaults_10, 0, tmp_tuple_element_14 );
            tmp_tuple_element_14 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_10, 1, tmp_tuple_element_14 );
            tmp_tuple_element_14 = Py_None;
            Py_INCREF( tmp_tuple_element_14 );
            PyTuple_SET_ITEM( tmp_defaults_10, 2, tmp_tuple_element_14 );
            tmp_tuple_element_14 = Py_None;
            Py_INCREF( tmp_tuple_element_14 );
            PyTuple_SET_ITEM( tmp_defaults_10, 3, tmp_tuple_element_14 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_34_find_all_previous( tmp_defaults_10 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_all_previous, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_all_previous );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_all_previous" );
            exception_tb = NULL;

            exception_lineno = 535;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 535;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findAllPrevious, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_all_previous );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_all_previous" );
            exception_tb = NULL;

            exception_lineno = 536;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 536;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_fetchPrevious, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_11;
            PyObject *tmp_tuple_element_15;
            tmp_tuple_element_15 = Py_None;
            tmp_defaults_11 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_15 );
            PyTuple_SET_ITEM( tmp_defaults_11, 0, tmp_tuple_element_15 );
            tmp_tuple_element_15 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_11, 1, tmp_tuple_element_15 );
            tmp_tuple_element_15 = Py_None;
            Py_INCREF( tmp_tuple_element_15 );
            PyTuple_SET_ITEM( tmp_defaults_11, 2, tmp_tuple_element_15 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_35_find_previous_sibling( tmp_defaults_11 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_previous_sibling, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_previous_sibling );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_previous_sibling" );
            exception_tb = NULL;

            exception_lineno = 543;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 543;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findPreviousSibling, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_12;
            PyObject *tmp_tuple_element_16;
            tmp_tuple_element_16 = Py_None;
            tmp_defaults_12 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_16 );
            PyTuple_SET_ITEM( tmp_defaults_12, 0, tmp_tuple_element_16 );
            tmp_tuple_element_16 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_12, 1, tmp_tuple_element_16 );
            tmp_tuple_element_16 = Py_None;
            Py_INCREF( tmp_tuple_element_16 );
            PyTuple_SET_ITEM( tmp_defaults_12, 2, tmp_tuple_element_16 );
            tmp_tuple_element_16 = Py_None;
            Py_INCREF( tmp_tuple_element_16 );
            PyTuple_SET_ITEM( tmp_defaults_12, 3, tmp_tuple_element_16 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_36_find_previous_siblings( tmp_defaults_12 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_previous_siblings, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_previous_siblings );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_previous_siblings" );
            exception_tb = NULL;

            exception_lineno = 551;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 551;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findPreviousSiblings, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_previous_siblings );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_previous_siblings" );
            exception_tb = NULL;

            exception_lineno = 552;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 552;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_fetchPreviousSiblings, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_13;
            PyObject *tmp_tuple_element_17;
            tmp_tuple_element_17 = Py_None;
            tmp_defaults_13 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_17 );
            PyTuple_SET_ITEM( tmp_defaults_13, 0, tmp_tuple_element_17 );
            tmp_tuple_element_17 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_13, 1, tmp_tuple_element_17 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_37_find_parent( tmp_defaults_13 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_parent, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_parent );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_parent" );
            exception_tb = NULL;

            exception_lineno = 564;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 564;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findParent, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_14;
            PyObject *tmp_tuple_element_18;
            tmp_tuple_element_18 = Py_None;
            tmp_defaults_14 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_18 );
            PyTuple_SET_ITEM( tmp_defaults_14, 0, tmp_tuple_element_18 );
            tmp_tuple_element_18 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_14, 1, tmp_tuple_element_18 );
            tmp_tuple_element_18 = Py_None;
            Py_INCREF( tmp_tuple_element_18 );
            PyTuple_SET_ITEM( tmp_defaults_14, 2, tmp_tuple_element_18 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_38_find_parents( tmp_defaults_14 );



            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_find_parents, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_parents );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_parents" );
            exception_tb = NULL;

            exception_lineno = 572;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 572;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_findParents, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_174, const_str_plain_find_parents );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_parents" );
            exception_tb = NULL;

            exception_lineno = 573;

            goto frame_exception_exit_6;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 573;

            goto frame_exception_exit_6;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_fetchParents, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_21;
            PyObject *tmp_args_element_name_37;
            tmp_called_name_21 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_37 = MAKE_FUNCTION_bs4$element$$$function_39_next(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 575;
            {
                PyObject *call_args[] = { tmp_args_element_name_37 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_21, call_args );
            }

            Py_DECREF( tmp_args_element_name_37 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 575;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_next, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 575;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_22;
            PyObject *tmp_args_element_name_38;
            tmp_called_name_22 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_38 = MAKE_FUNCTION_bs4$element$$$function_40_previous(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 579;
            {
                PyObject *call_args[] = { tmp_args_element_name_38 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
            }

            Py_DECREF( tmp_args_element_name_38 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 579;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_previous, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 579;

                goto frame_exception_exit_6;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_41__find_one(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain__find_one, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_42__find_all(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain__find_all, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_23;
            PyObject *tmp_args_element_name_39;
            tmp_called_name_23 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_39 = MAKE_FUNCTION_bs4$element$$$function_43_next_elements(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 646;
            {
                PyObject *call_args[] = { tmp_args_element_name_39 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
            }

            Py_DECREF( tmp_args_element_name_39 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 646;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_next_elements, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 646;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_24;
            PyObject *tmp_args_element_name_40;
            tmp_called_name_24 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_40 = MAKE_FUNCTION_bs4$element$$$function_44_next_siblings(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 653;
            {
                PyObject *call_args[] = { tmp_args_element_name_40 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
            }

            Py_DECREF( tmp_args_element_name_40 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 653;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_next_siblings, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 653;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_25;
            PyObject *tmp_args_element_name_41;
            tmp_called_name_25 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_41 = MAKE_FUNCTION_bs4$element$$$function_45_previous_elements(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 660;
            {
                PyObject *call_args[] = { tmp_args_element_name_41 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_25, call_args );
            }

            Py_DECREF( tmp_args_element_name_41 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 660;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_previous_elements, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 660;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_26;
            PyObject *tmp_args_element_name_42;
            tmp_called_name_26 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_42 = MAKE_FUNCTION_bs4$element$$$function_46_previous_siblings(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 667;
            {
                PyObject *call_args[] = { tmp_args_element_name_42 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_26, call_args );
            }

            Py_DECREF( tmp_args_element_name_42 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 667;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_previous_siblings, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 667;

                goto frame_exception_exit_6;
            }
        }
        {
            PyObject *tmp_called_name_27;
            PyObject *tmp_args_element_name_43;
            tmp_called_name_27 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_43 = MAKE_FUNCTION_bs4$element$$$function_47_parents(  );



            frame_9d17cb8081dcccefd359db453c9db698_6->m_frame.f_lineno = 674;
            {
                PyObject *call_args[] = { tmp_args_element_name_43 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
            }

            Py_DECREF( tmp_args_element_name_43 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 674;

                goto frame_exception_exit_6;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_parents, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 674;

                goto frame_exception_exit_6;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_9d17cb8081dcccefd359db453c9db698_6 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_9d17cb8081dcccefd359db453c9db698_6 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_9d17cb8081dcccefd359db453c9db698_6, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_9d17cb8081dcccefd359db453c9db698_6->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_9d17cb8081dcccefd359db453c9db698_6, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_9d17cb8081dcccefd359db453c9db698_6,
            type_description_2
        );


        // Release cached frame.
        if ( frame_9d17cb8081dcccefd359db453c9db698_6 == cache_frame_9d17cb8081dcccefd359db453c9db698_6 )
        {
            Py_DECREF( frame_9d17cb8081dcccefd359db453c9db698_6 );
        }
        cache_frame_9d17cb8081dcccefd359db453c9db698_6 = NULL;

        assertFrameObject( frame_9d17cb8081dcccefd359db453c9db698_6 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_41;
        skip_nested_handling_5:;
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_48_nextGenerator(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_nextGenerator, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_49_nextSiblingGenerator(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_nextSiblingGenerator, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_50_previousGenerator(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_previousGenerator, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_51_previousSiblingGenerator(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_previousSiblingGenerator, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_52_parentGenerator(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_174, const_str_plain_parentGenerator, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_80 = locals_bs4$element_174;
        Py_INCREF( tmp_assign_source_80 );
        goto try_return_handler_41;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_41:;
        Py_DECREF( locals_bs4$element_174 );
        locals_bs4$element_174 = NULL;
        goto outline_result_19;
        // Exception handler code:
        try_except_handler_41:;
        exception_keeper_type_26 = exception_type;
        exception_keeper_value_26 = exception_value;
        exception_keeper_tb_26 = exception_tb;
        exception_keeper_lineno_26 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_174 );
        locals_bs4$element_174 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_26;
        exception_value = exception_keeper_value_26;
        exception_tb = exception_keeper_tb_26;
        exception_lineno = exception_keeper_lineno_26;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_5:;
        exception_lineno = 174;
        goto try_except_handler_40;
        outline_result_19:;
        assert( tmp_class_creation_12__class_dict == NULL );
        tmp_class_creation_12__class_dict = tmp_assign_source_80;
    }
    {
        PyObject *tmp_assign_source_81;
        nuitka_bool tmp_condition_result_14;
        PyObject *tmp_key_name_23;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_dict_name_24;
        PyObject *tmp_key_name_24;
        tmp_key_name_23 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_23 = tmp_class_creation_12__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_23, tmp_key_name_23 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 174;

            goto try_except_handler_40;
        }
        tmp_condition_result_14 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_14 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_12;
        }
        else
        {
            goto condexpr_false_12;
        }
        condexpr_true_12:;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_dict_name_24 = tmp_class_creation_12__class_dict;
        tmp_key_name_24 = const_str_plain___metaclass__;
        tmp_assign_source_81 = DICT_GET_ITEM( tmp_dict_name_24, tmp_key_name_24 );
        if ( tmp_assign_source_81 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 174;

            goto try_except_handler_40;
        }
        goto condexpr_end_12;
        condexpr_false_12:;
        tmp_assign_source_81 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_81 );
        condexpr_end_12:;
        assert( tmp_class_creation_12__metaclass == NULL );
        tmp_class_creation_12__metaclass = tmp_assign_source_81;
    }
    {
        PyObject *tmp_assign_source_82;
        PyObject *tmp_called_name_28;
        PyObject *tmp_args_element_name_44;
        PyObject *tmp_args_element_name_45;
        PyObject *tmp_args_element_name_46;
        CHECK_OBJECT( tmp_class_creation_12__metaclass );
        tmp_called_name_28 = tmp_class_creation_12__metaclass;
        tmp_args_element_name_44 = const_str_plain_PageElement;
        tmp_args_element_name_45 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_12__class_dict );
        tmp_args_element_name_46 = tmp_class_creation_12__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 174;
        {
            PyObject *call_args[] = { tmp_args_element_name_44, tmp_args_element_name_45, tmp_args_element_name_46 };
            tmp_assign_source_82 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_28, call_args );
        }

        if ( tmp_assign_source_82 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 174;

            goto try_except_handler_40;
        }
        assert( tmp_class_creation_12__class == NULL );
        tmp_class_creation_12__class = tmp_assign_source_82;
    }
    goto try_end_14;
    // Exception handler code:
    try_except_handler_40:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_14:;
    {
        PyObject *tmp_assign_source_83;
        CHECK_OBJECT( tmp_class_creation_12__class );
        tmp_assign_source_83 = tmp_class_creation_12__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PageElement, tmp_assign_source_83 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class );
    Py_DECREF( tmp_class_creation_12__class );
    tmp_class_creation_12__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__class_dict );
    Py_DECREF( tmp_class_creation_12__class_dict );
    tmp_class_creation_12__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_12__metaclass );
    Py_DECREF( tmp_class_creation_12__metaclass );
    tmp_class_creation_12__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_84;
        PyObject *tmp_tuple_element_19;
        PyObject *tmp_mvar_value_22;
        tmp_tuple_element_19 = (PyObject *)&PyUnicode_Type;
        tmp_assign_source_84 = PyTuple_New( 2 );
        Py_INCREF( tmp_tuple_element_19 );
        PyTuple_SET_ITEM( tmp_assign_source_84, 0, tmp_tuple_element_19 );
        tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PageElement );

        if (unlikely( tmp_mvar_value_22 == NULL ))
        {
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PageElement );
        }

        if ( tmp_mvar_value_22 == NULL )
        {
            Py_DECREF( tmp_assign_source_84 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PageElement" );
            exception_tb = NULL;

            exception_lineno = 699;

            goto try_except_handler_42;
        }

        tmp_tuple_element_19 = tmp_mvar_value_22;
        Py_INCREF( tmp_tuple_element_19 );
        PyTuple_SET_ITEM( tmp_assign_source_84, 1, tmp_tuple_element_19 );
        assert( tmp_class_creation_13__bases == NULL );
        tmp_class_creation_13__bases = tmp_assign_source_84;
    }
    {
        PyObject *tmp_assign_source_85;
        {
            PyObject *tmp_set_locals_11;
            tmp_set_locals_11 = PyDict_New();
            locals_bs4$element_699 = tmp_set_locals_11;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_empty;
        tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain_PREFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_empty;
        tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain_SUFFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = Py_None;
        tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain_known_xml, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7, codeobj_3877e7ba57fb85f72eb8eaa734d3dbe4, module_bs4$element, 0 );
        frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 = cache_frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_staticmethod_arg_4;
            tmp_staticmethod_arg_4 = MAKE_FUNCTION_bs4$element$$$function_53___new__(  );



            tmp_dictset_value = BUILTIN_STATICMETHOD( tmp_staticmethod_arg_4 );
            Py_DECREF( tmp_staticmethod_arg_4 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 709;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain___new__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 709;

                goto frame_exception_exit_7;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_54___copy__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain___copy__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_55___getnewargs__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain___getnewargs__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_56___getattr__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain___getattr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_15;
            tmp_defaults_15 = const_tuple_str_plain_minimal_tuple;
            Py_INCREF( tmp_defaults_15 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_57_output_ready( tmp_defaults_15 );



            tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain_output_ready, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_called_name_29;
            PyObject *tmp_args_element_name_47;
            tmp_called_name_29 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_47 = MAKE_FUNCTION_bs4$element$$$function_58_name(  );



            frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7->m_frame.f_lineno = 748;
            {
                PyObject *call_args[] = { tmp_args_element_name_47 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_29, call_args );
            }

            Py_DECREF( tmp_args_element_name_47 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 748;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain_name, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 748;

                goto frame_exception_exit_7;
            }
        }
        {
            PyObject *tmp_called_instance_4;
            PyObject *tmp_args_element_name_48;
            tmp_called_instance_4 = PyDict_GetItem( locals_bs4$element_699, const_str_plain_name );

            if ( tmp_called_instance_4 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "name" );
                exception_tb = NULL;

                exception_lineno = 752;

                goto frame_exception_exit_7;
            }

            if ( tmp_called_instance_4 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 752;

                goto frame_exception_exit_7;
            }
            tmp_args_element_name_48 = MAKE_FUNCTION_bs4$element$$$function_59_name(  );



            frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7->m_frame.f_lineno = 752;
            {
                PyObject *call_args[] = { tmp_args_element_name_48 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_args_element_name_48 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 752;

                goto frame_exception_exit_7;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_699, const_str_plain_name, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 752;

                goto frame_exception_exit_7;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7,
            type_description_2
        );


        // Release cached frame.
        if ( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 == cache_frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 )
        {
            Py_DECREF( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 );
        }
        cache_frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 = NULL;

        assertFrameObject( frame_3877e7ba57fb85f72eb8eaa734d3dbe4_7 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_43;
        skip_nested_handling_6:;
        tmp_assign_source_85 = locals_bs4$element_699;
        Py_INCREF( tmp_assign_source_85 );
        goto try_return_handler_43;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_43:;
        Py_DECREF( locals_bs4$element_699 );
        locals_bs4$element_699 = NULL;
        goto outline_result_20;
        // Exception handler code:
        try_except_handler_43:;
        exception_keeper_type_28 = exception_type;
        exception_keeper_value_28 = exception_value;
        exception_keeper_tb_28 = exception_tb;
        exception_keeper_lineno_28 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_699 );
        locals_bs4$element_699 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_28;
        exception_value = exception_keeper_value_28;
        exception_tb = exception_keeper_tb_28;
        exception_lineno = exception_keeper_lineno_28;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_6:;
        exception_lineno = 699;
        goto try_except_handler_42;
        outline_result_20:;
        assert( tmp_class_creation_13__class_dict == NULL );
        tmp_class_creation_13__class_dict = tmp_assign_source_85;
    }
    {
        PyObject *tmp_assign_source_86;
        nuitka_bool tmp_condition_result_15;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        tmp_key_name_25 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_25 = tmp_class_creation_13__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_25, tmp_key_name_25 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 699;

            goto try_except_handler_42;
        }
        tmp_condition_result_15 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_15 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_13;
        }
        else
        {
            goto condexpr_false_13;
        }
        condexpr_true_13:;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_dict_name_26 = tmp_class_creation_13__class_dict;
        tmp_key_name_26 = const_str_plain___metaclass__;
        tmp_assign_source_86 = DICT_GET_ITEM( tmp_dict_name_26, tmp_key_name_26 );
        if ( tmp_assign_source_86 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 699;

            goto try_except_handler_42;
        }
        goto condexpr_end_13;
        condexpr_false_13:;
        {
            PyObject *tmp_assign_source_87;
            PyObject *tmp_subscribed_name_10;
            PyObject *tmp_subscript_name_10;
            CHECK_OBJECT( tmp_class_creation_13__bases );
            tmp_subscribed_name_10 = tmp_class_creation_13__bases;
            tmp_subscript_name_10 = const_int_0;
            tmp_assign_source_87 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_10, tmp_subscript_name_10, 0 );
            if ( tmp_assign_source_87 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 699;

                goto try_except_handler_42;
            }
            assert( tmp_select_metaclass_13__base == NULL );
            tmp_select_metaclass_13__base = tmp_assign_source_87;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_12;
            CHECK_OBJECT( tmp_select_metaclass_13__base );
            tmp_source_name_12 = tmp_select_metaclass_13__base;
            tmp_assign_source_86 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_12 );
            if ( tmp_assign_source_86 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 699;

                goto try_except_handler_45;
            }
            goto try_return_handler_44;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_45:;
        exception_keeper_type_29 = exception_type;
        exception_keeper_value_29 = exception_value;
        exception_keeper_tb_29 = exception_tb;
        exception_keeper_lineno_29 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_9;
            Py_DECREF( exception_keeper_type_29 );
            Py_XDECREF( exception_keeper_value_29 );
            Py_XDECREF( exception_keeper_tb_29 );
            CHECK_OBJECT( tmp_select_metaclass_13__base );
            tmp_type_arg_9 = tmp_select_metaclass_13__base;
            tmp_assign_source_86 = BUILTIN_TYPE1( tmp_type_arg_9 );
            assert( !(tmp_assign_source_86 == NULL) );
            goto try_return_handler_44;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_44:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_13__base );
        Py_DECREF( tmp_select_metaclass_13__base );
        tmp_select_metaclass_13__base = NULL;

        goto outline_result_21;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_13__base );
        Py_DECREF( tmp_select_metaclass_13__base );
        tmp_select_metaclass_13__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_21:;
        condexpr_end_13:;
        assert( tmp_class_creation_13__metaclass == NULL );
        tmp_class_creation_13__metaclass = tmp_assign_source_86;
    }
    {
        PyObject *tmp_assign_source_88;
        PyObject *tmp_called_name_30;
        PyObject *tmp_args_element_name_49;
        PyObject *tmp_args_element_name_50;
        PyObject *tmp_args_element_name_51;
        CHECK_OBJECT( tmp_class_creation_13__metaclass );
        tmp_called_name_30 = tmp_class_creation_13__metaclass;
        tmp_args_element_name_49 = const_str_plain_NavigableString;
        CHECK_OBJECT( tmp_class_creation_13__bases );
        tmp_args_element_name_50 = tmp_class_creation_13__bases;
        CHECK_OBJECT( tmp_class_creation_13__class_dict );
        tmp_args_element_name_51 = tmp_class_creation_13__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 699;
        {
            PyObject *call_args[] = { tmp_args_element_name_49, tmp_args_element_name_50, tmp_args_element_name_51 };
            tmp_assign_source_88 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_30, call_args );
        }

        if ( tmp_assign_source_88 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 699;

            goto try_except_handler_42;
        }
        assert( tmp_class_creation_13__class == NULL );
        tmp_class_creation_13__class = tmp_assign_source_88;
    }
    goto try_end_15;
    // Exception handler code:
    try_except_handler_42:;
    exception_keeper_type_30 = exception_type;
    exception_keeper_value_30 = exception_value;
    exception_keeper_tb_30 = exception_tb;
    exception_keeper_lineno_30 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    Py_XDECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_30;
    exception_value = exception_keeper_value_30;
    exception_tb = exception_keeper_tb_30;
    exception_lineno = exception_keeper_lineno_30;

    goto frame_exception_exit_1;
    // End of try:
    try_end_15:;
    {
        PyObject *tmp_assign_source_89;
        CHECK_OBJECT( tmp_class_creation_13__class );
        tmp_assign_source_89 = tmp_class_creation_13__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString, tmp_assign_source_89 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class );
    Py_DECREF( tmp_class_creation_13__class );
    tmp_class_creation_13__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__bases );
    Py_DECREF( tmp_class_creation_13__bases );
    tmp_class_creation_13__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__class_dict );
    Py_DECREF( tmp_class_creation_13__class_dict );
    tmp_class_creation_13__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_13__metaclass );
    Py_DECREF( tmp_class_creation_13__metaclass );
    tmp_class_creation_13__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_90;
        PyObject *tmp_tuple_element_20;
        PyObject *tmp_mvar_value_23;
        tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

        if (unlikely( tmp_mvar_value_23 == NULL ))
        {
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
        }

        if ( tmp_mvar_value_23 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "NavigableString" );
            exception_tb = NULL;

            exception_lineno = 756;

            goto try_except_handler_46;
        }

        tmp_tuple_element_20 = tmp_mvar_value_23;
        tmp_assign_source_90 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_20 );
        PyTuple_SET_ITEM( tmp_assign_source_90, 0, tmp_tuple_element_20 );
        assert( tmp_class_creation_14__bases == NULL );
        tmp_class_creation_14__bases = tmp_assign_source_90;
    }
    {
        PyObject *tmp_assign_source_91;
        {
            PyObject *tmp_set_locals_12;
            tmp_set_locals_12 = PyDict_New();
            locals_bs4$element_756 = tmp_set_locals_12;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_756, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_789a2a1ab5c730365a2961867d62159f;
        tmp_res = PyDict_SetItem( locals_bs4$element_756, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_16;
            tmp_defaults_16 = const_tuple_str_plain_minimal_tuple;
            Py_INCREF( tmp_defaults_16 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_60_output_ready( tmp_defaults_16 );



            tmp_res = PyDict_SetItem( locals_bs4$element_756, const_str_plain_output_ready, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        // Tried code:
        tmp_assign_source_91 = locals_bs4$element_756;
        Py_INCREF( tmp_assign_source_91 );
        goto try_return_handler_47;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_47:;
        Py_DECREF( locals_bs4$element_756 );
        locals_bs4$element_756 = NULL;
        goto outline_result_22;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_22:;
        assert( tmp_class_creation_14__class_dict == NULL );
        tmp_class_creation_14__class_dict = tmp_assign_source_91;
    }
    {
        PyObject *tmp_assign_source_92;
        nuitka_bool tmp_condition_result_16;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        PyObject *tmp_dict_name_28;
        PyObject *tmp_key_name_28;
        tmp_key_name_27 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_27 = tmp_class_creation_14__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_27, tmp_key_name_27 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 756;

            goto try_except_handler_46;
        }
        tmp_condition_result_16 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_16 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_14;
        }
        else
        {
            goto condexpr_false_14;
        }
        condexpr_true_14:;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_dict_name_28 = tmp_class_creation_14__class_dict;
        tmp_key_name_28 = const_str_plain___metaclass__;
        tmp_assign_source_92 = DICT_GET_ITEM( tmp_dict_name_28, tmp_key_name_28 );
        if ( tmp_assign_source_92 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 756;

            goto try_except_handler_46;
        }
        goto condexpr_end_14;
        condexpr_false_14:;
        {
            PyObject *tmp_assign_source_93;
            PyObject *tmp_subscribed_name_11;
            PyObject *tmp_subscript_name_11;
            CHECK_OBJECT( tmp_class_creation_14__bases );
            tmp_subscribed_name_11 = tmp_class_creation_14__bases;
            tmp_subscript_name_11 = const_int_0;
            tmp_assign_source_93 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_11, tmp_subscript_name_11, 0 );
            if ( tmp_assign_source_93 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 756;

                goto try_except_handler_46;
            }
            assert( tmp_select_metaclass_14__base == NULL );
            tmp_select_metaclass_14__base = tmp_assign_source_93;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_13;
            CHECK_OBJECT( tmp_select_metaclass_14__base );
            tmp_source_name_13 = tmp_select_metaclass_14__base;
            tmp_assign_source_92 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_13 );
            if ( tmp_assign_source_92 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 756;

                goto try_except_handler_49;
            }
            goto try_return_handler_48;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_49:;
        exception_keeper_type_31 = exception_type;
        exception_keeper_value_31 = exception_value;
        exception_keeper_tb_31 = exception_tb;
        exception_keeper_lineno_31 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_10;
            Py_DECREF( exception_keeper_type_31 );
            Py_XDECREF( exception_keeper_value_31 );
            Py_XDECREF( exception_keeper_tb_31 );
            CHECK_OBJECT( tmp_select_metaclass_14__base );
            tmp_type_arg_10 = tmp_select_metaclass_14__base;
            tmp_assign_source_92 = BUILTIN_TYPE1( tmp_type_arg_10 );
            assert( !(tmp_assign_source_92 == NULL) );
            goto try_return_handler_48;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_48:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_14__base );
        Py_DECREF( tmp_select_metaclass_14__base );
        tmp_select_metaclass_14__base = NULL;

        goto outline_result_23;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_14__base );
        Py_DECREF( tmp_select_metaclass_14__base );
        tmp_select_metaclass_14__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_23:;
        condexpr_end_14:;
        assert( tmp_class_creation_14__metaclass == NULL );
        tmp_class_creation_14__metaclass = tmp_assign_source_92;
    }
    {
        PyObject *tmp_assign_source_94;
        PyObject *tmp_called_name_31;
        PyObject *tmp_args_element_name_52;
        PyObject *tmp_args_element_name_53;
        PyObject *tmp_args_element_name_54;
        CHECK_OBJECT( tmp_class_creation_14__metaclass );
        tmp_called_name_31 = tmp_class_creation_14__metaclass;
        tmp_args_element_name_52 = const_str_plain_PreformattedString;
        CHECK_OBJECT( tmp_class_creation_14__bases );
        tmp_args_element_name_53 = tmp_class_creation_14__bases;
        CHECK_OBJECT( tmp_class_creation_14__class_dict );
        tmp_args_element_name_54 = tmp_class_creation_14__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 756;
        {
            PyObject *call_args[] = { tmp_args_element_name_52, tmp_args_element_name_53, tmp_args_element_name_54 };
            tmp_assign_source_94 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_31, call_args );
        }

        if ( tmp_assign_source_94 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 756;

            goto try_except_handler_46;
        }
        assert( tmp_class_creation_14__class == NULL );
        tmp_class_creation_14__class = tmp_assign_source_94;
    }
    goto try_end_16;
    // Exception handler code:
    try_except_handler_46:;
    exception_keeper_type_32 = exception_type;
    exception_keeper_value_32 = exception_value;
    exception_keeper_tb_32 = exception_tb;
    exception_keeper_lineno_32 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    Py_XDECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_32;
    exception_value = exception_keeper_value_32;
    exception_tb = exception_keeper_tb_32;
    exception_lineno = exception_keeper_lineno_32;

    goto frame_exception_exit_1;
    // End of try:
    try_end_16:;
    {
        PyObject *tmp_assign_source_95;
        CHECK_OBJECT( tmp_class_creation_14__class );
        tmp_assign_source_95 = tmp_class_creation_14__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PreformattedString, tmp_assign_source_95 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class );
    Py_DECREF( tmp_class_creation_14__class );
    tmp_class_creation_14__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__bases );
    Py_DECREF( tmp_class_creation_14__bases );
    tmp_class_creation_14__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__class_dict );
    Py_DECREF( tmp_class_creation_14__class_dict );
    tmp_class_creation_14__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_14__metaclass );
    Py_DECREF( tmp_class_creation_14__metaclass );
    tmp_class_creation_14__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_96;
        PyObject *tmp_tuple_element_21;
        PyObject *tmp_mvar_value_24;
        tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PreformattedString );

        if (unlikely( tmp_mvar_value_24 == NULL ))
        {
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PreformattedString );
        }

        if ( tmp_mvar_value_24 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PreformattedString" );
            exception_tb = NULL;

            exception_lineno = 769;

            goto try_except_handler_50;
        }

        tmp_tuple_element_21 = tmp_mvar_value_24;
        tmp_assign_source_96 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_21 );
        PyTuple_SET_ITEM( tmp_assign_source_96, 0, tmp_tuple_element_21 );
        assert( tmp_class_creation_15__bases == NULL );
        tmp_class_creation_15__bases = tmp_assign_source_96;
    }
    {
        PyObject *tmp_assign_source_97;
        {
            PyObject *tmp_set_locals_13;
            tmp_set_locals_13 = PyDict_New();
            locals_bs4$element_769 = tmp_set_locals_13;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_769, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_6fd0b05522159f98d6181ab8bfabc7f6;
        tmp_res = PyDict_SetItem( locals_bs4$element_769, const_str_plain_PREFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_bdc18e346a4949f889a922a59c59687c;
        tmp_res = PyDict_SetItem( locals_bs4$element_769, const_str_plain_SUFFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_97 = locals_bs4$element_769;
        Py_INCREF( tmp_assign_source_97 );
        goto try_return_handler_51;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_51:;
        Py_DECREF( locals_bs4$element_769 );
        locals_bs4$element_769 = NULL;
        goto outline_result_24;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_24:;
        assert( tmp_class_creation_15__class_dict == NULL );
        tmp_class_creation_15__class_dict = tmp_assign_source_97;
    }
    {
        PyObject *tmp_assign_source_98;
        nuitka_bool tmp_condition_result_17;
        PyObject *tmp_key_name_29;
        PyObject *tmp_dict_name_29;
        PyObject *tmp_dict_name_30;
        PyObject *tmp_key_name_30;
        tmp_key_name_29 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_29 = tmp_class_creation_15__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_29, tmp_key_name_29 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 769;

            goto try_except_handler_50;
        }
        tmp_condition_result_17 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_17 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_15;
        }
        else
        {
            goto condexpr_false_15;
        }
        condexpr_true_15:;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_dict_name_30 = tmp_class_creation_15__class_dict;
        tmp_key_name_30 = const_str_plain___metaclass__;
        tmp_assign_source_98 = DICT_GET_ITEM( tmp_dict_name_30, tmp_key_name_30 );
        if ( tmp_assign_source_98 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 769;

            goto try_except_handler_50;
        }
        goto condexpr_end_15;
        condexpr_false_15:;
        {
            PyObject *tmp_assign_source_99;
            PyObject *tmp_subscribed_name_12;
            PyObject *tmp_subscript_name_12;
            CHECK_OBJECT( tmp_class_creation_15__bases );
            tmp_subscribed_name_12 = tmp_class_creation_15__bases;
            tmp_subscript_name_12 = const_int_0;
            tmp_assign_source_99 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_12, tmp_subscript_name_12, 0 );
            if ( tmp_assign_source_99 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 769;

                goto try_except_handler_50;
            }
            assert( tmp_select_metaclass_15__base == NULL );
            tmp_select_metaclass_15__base = tmp_assign_source_99;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_14;
            CHECK_OBJECT( tmp_select_metaclass_15__base );
            tmp_source_name_14 = tmp_select_metaclass_15__base;
            tmp_assign_source_98 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_14 );
            if ( tmp_assign_source_98 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 769;

                goto try_except_handler_53;
            }
            goto try_return_handler_52;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_53:;
        exception_keeper_type_33 = exception_type;
        exception_keeper_value_33 = exception_value;
        exception_keeper_tb_33 = exception_tb;
        exception_keeper_lineno_33 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_11;
            Py_DECREF( exception_keeper_type_33 );
            Py_XDECREF( exception_keeper_value_33 );
            Py_XDECREF( exception_keeper_tb_33 );
            CHECK_OBJECT( tmp_select_metaclass_15__base );
            tmp_type_arg_11 = tmp_select_metaclass_15__base;
            tmp_assign_source_98 = BUILTIN_TYPE1( tmp_type_arg_11 );
            assert( !(tmp_assign_source_98 == NULL) );
            goto try_return_handler_52;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_52:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_15__base );
        Py_DECREF( tmp_select_metaclass_15__base );
        tmp_select_metaclass_15__base = NULL;

        goto outline_result_25;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_15__base );
        Py_DECREF( tmp_select_metaclass_15__base );
        tmp_select_metaclass_15__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_25:;
        condexpr_end_15:;
        assert( tmp_class_creation_15__metaclass == NULL );
        tmp_class_creation_15__metaclass = tmp_assign_source_98;
    }
    {
        PyObject *tmp_assign_source_100;
        PyObject *tmp_called_name_32;
        PyObject *tmp_args_element_name_55;
        PyObject *tmp_args_element_name_56;
        PyObject *tmp_args_element_name_57;
        CHECK_OBJECT( tmp_class_creation_15__metaclass );
        tmp_called_name_32 = tmp_class_creation_15__metaclass;
        tmp_args_element_name_55 = const_str_plain_CData;
        CHECK_OBJECT( tmp_class_creation_15__bases );
        tmp_args_element_name_56 = tmp_class_creation_15__bases;
        CHECK_OBJECT( tmp_class_creation_15__class_dict );
        tmp_args_element_name_57 = tmp_class_creation_15__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 769;
        {
            PyObject *call_args[] = { tmp_args_element_name_55, tmp_args_element_name_56, tmp_args_element_name_57 };
            tmp_assign_source_100 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_32, call_args );
        }

        if ( tmp_assign_source_100 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 769;

            goto try_except_handler_50;
        }
        assert( tmp_class_creation_15__class == NULL );
        tmp_class_creation_15__class = tmp_assign_source_100;
    }
    goto try_end_17;
    // Exception handler code:
    try_except_handler_50:;
    exception_keeper_type_34 = exception_type;
    exception_keeper_value_34 = exception_value;
    exception_keeper_tb_34 = exception_tb;
    exception_keeper_lineno_34 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    Py_XDECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_34;
    exception_value = exception_keeper_value_34;
    exception_tb = exception_keeper_tb_34;
    exception_lineno = exception_keeper_lineno_34;

    goto frame_exception_exit_1;
    // End of try:
    try_end_17:;
    {
        PyObject *tmp_assign_source_101;
        CHECK_OBJECT( tmp_class_creation_15__class );
        tmp_assign_source_101 = tmp_class_creation_15__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_CData, tmp_assign_source_101 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class );
    Py_DECREF( tmp_class_creation_15__class );
    tmp_class_creation_15__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__bases );
    Py_DECREF( tmp_class_creation_15__bases );
    tmp_class_creation_15__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__class_dict );
    Py_DECREF( tmp_class_creation_15__class_dict );
    tmp_class_creation_15__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_15__metaclass );
    Py_DECREF( tmp_class_creation_15__metaclass );
    tmp_class_creation_15__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_102;
        PyObject *tmp_tuple_element_22;
        PyObject *tmp_mvar_value_25;
        tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PreformattedString );

        if (unlikely( tmp_mvar_value_25 == NULL ))
        {
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PreformattedString );
        }

        if ( tmp_mvar_value_25 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PreformattedString" );
            exception_tb = NULL;

            exception_lineno = 774;

            goto try_except_handler_54;
        }

        tmp_tuple_element_22 = tmp_mvar_value_25;
        tmp_assign_source_102 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_22 );
        PyTuple_SET_ITEM( tmp_assign_source_102, 0, tmp_tuple_element_22 );
        assert( tmp_class_creation_16__bases == NULL );
        tmp_class_creation_16__bases = tmp_assign_source_102;
    }
    {
        PyObject *tmp_assign_source_103;
        {
            PyObject *tmp_set_locals_14;
            tmp_set_locals_14 = PyDict_New();
            locals_bs4$element_774 = tmp_set_locals_14;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_774, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_0ffd0fc42335dceae8efe9c6f5089d15;
        tmp_res = PyDict_SetItem( locals_bs4$element_774, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_ce081481423abca80d01dc6b2ce9e9ea;
        tmp_res = PyDict_SetItem( locals_bs4$element_774, const_str_plain_PREFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_chr_62;
        tmp_res = PyDict_SetItem( locals_bs4$element_774, const_str_plain_SUFFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_103 = locals_bs4$element_774;
        Py_INCREF( tmp_assign_source_103 );
        goto try_return_handler_55;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_55:;
        Py_DECREF( locals_bs4$element_774 );
        locals_bs4$element_774 = NULL;
        goto outline_result_26;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_26:;
        assert( tmp_class_creation_16__class_dict == NULL );
        tmp_class_creation_16__class_dict = tmp_assign_source_103;
    }
    {
        PyObject *tmp_assign_source_104;
        nuitka_bool tmp_condition_result_18;
        PyObject *tmp_key_name_31;
        PyObject *tmp_dict_name_31;
        PyObject *tmp_dict_name_32;
        PyObject *tmp_key_name_32;
        tmp_key_name_31 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_31 = tmp_class_creation_16__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_31, tmp_key_name_31 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 774;

            goto try_except_handler_54;
        }
        tmp_condition_result_18 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_18 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_16;
        }
        else
        {
            goto condexpr_false_16;
        }
        condexpr_true_16:;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_dict_name_32 = tmp_class_creation_16__class_dict;
        tmp_key_name_32 = const_str_plain___metaclass__;
        tmp_assign_source_104 = DICT_GET_ITEM( tmp_dict_name_32, tmp_key_name_32 );
        if ( tmp_assign_source_104 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 774;

            goto try_except_handler_54;
        }
        goto condexpr_end_16;
        condexpr_false_16:;
        {
            PyObject *tmp_assign_source_105;
            PyObject *tmp_subscribed_name_13;
            PyObject *tmp_subscript_name_13;
            CHECK_OBJECT( tmp_class_creation_16__bases );
            tmp_subscribed_name_13 = tmp_class_creation_16__bases;
            tmp_subscript_name_13 = const_int_0;
            tmp_assign_source_105 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_13, tmp_subscript_name_13, 0 );
            if ( tmp_assign_source_105 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 774;

                goto try_except_handler_54;
            }
            assert( tmp_select_metaclass_16__base == NULL );
            tmp_select_metaclass_16__base = tmp_assign_source_105;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_15;
            CHECK_OBJECT( tmp_select_metaclass_16__base );
            tmp_source_name_15 = tmp_select_metaclass_16__base;
            tmp_assign_source_104 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_15 );
            if ( tmp_assign_source_104 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 774;

                goto try_except_handler_57;
            }
            goto try_return_handler_56;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_57:;
        exception_keeper_type_35 = exception_type;
        exception_keeper_value_35 = exception_value;
        exception_keeper_tb_35 = exception_tb;
        exception_keeper_lineno_35 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_12;
            Py_DECREF( exception_keeper_type_35 );
            Py_XDECREF( exception_keeper_value_35 );
            Py_XDECREF( exception_keeper_tb_35 );
            CHECK_OBJECT( tmp_select_metaclass_16__base );
            tmp_type_arg_12 = tmp_select_metaclass_16__base;
            tmp_assign_source_104 = BUILTIN_TYPE1( tmp_type_arg_12 );
            assert( !(tmp_assign_source_104 == NULL) );
            goto try_return_handler_56;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_56:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_16__base );
        Py_DECREF( tmp_select_metaclass_16__base );
        tmp_select_metaclass_16__base = NULL;

        goto outline_result_27;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_16__base );
        Py_DECREF( tmp_select_metaclass_16__base );
        tmp_select_metaclass_16__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_27:;
        condexpr_end_16:;
        assert( tmp_class_creation_16__metaclass == NULL );
        tmp_class_creation_16__metaclass = tmp_assign_source_104;
    }
    {
        PyObject *tmp_assign_source_106;
        PyObject *tmp_called_name_33;
        PyObject *tmp_args_element_name_58;
        PyObject *tmp_args_element_name_59;
        PyObject *tmp_args_element_name_60;
        CHECK_OBJECT( tmp_class_creation_16__metaclass );
        tmp_called_name_33 = tmp_class_creation_16__metaclass;
        tmp_args_element_name_58 = const_str_plain_ProcessingInstruction;
        CHECK_OBJECT( tmp_class_creation_16__bases );
        tmp_args_element_name_59 = tmp_class_creation_16__bases;
        CHECK_OBJECT( tmp_class_creation_16__class_dict );
        tmp_args_element_name_60 = tmp_class_creation_16__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 774;
        {
            PyObject *call_args[] = { tmp_args_element_name_58, tmp_args_element_name_59, tmp_args_element_name_60 };
            tmp_assign_source_106 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_33, call_args );
        }

        if ( tmp_assign_source_106 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 774;

            goto try_except_handler_54;
        }
        assert( tmp_class_creation_16__class == NULL );
        tmp_class_creation_16__class = tmp_assign_source_106;
    }
    goto try_end_18;
    // Exception handler code:
    try_except_handler_54:;
    exception_keeper_type_36 = exception_type;
    exception_keeper_value_36 = exception_value;
    exception_keeper_tb_36 = exception_tb;
    exception_keeper_lineno_36 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_16__bases );
    tmp_class_creation_16__bases = NULL;

    Py_XDECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_36;
    exception_value = exception_keeper_value_36;
    exception_tb = exception_keeper_tb_36;
    exception_lineno = exception_keeper_lineno_36;

    goto frame_exception_exit_1;
    // End of try:
    try_end_18:;
    {
        PyObject *tmp_assign_source_107;
        CHECK_OBJECT( tmp_class_creation_16__class );
        tmp_assign_source_107 = tmp_class_creation_16__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ProcessingInstruction, tmp_assign_source_107 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class );
    Py_DECREF( tmp_class_creation_16__class );
    tmp_class_creation_16__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__bases );
    Py_DECREF( tmp_class_creation_16__bases );
    tmp_class_creation_16__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__class_dict );
    Py_DECREF( tmp_class_creation_16__class_dict );
    tmp_class_creation_16__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_16__metaclass );
    Py_DECREF( tmp_class_creation_16__metaclass );
    tmp_class_creation_16__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_108;
        PyObject *tmp_tuple_element_23;
        PyObject *tmp_mvar_value_26;
        tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ProcessingInstruction );

        if (unlikely( tmp_mvar_value_26 == NULL ))
        {
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ProcessingInstruction );
        }

        if ( tmp_mvar_value_26 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "ProcessingInstruction" );
            exception_tb = NULL;

            exception_lineno = 780;

            goto try_except_handler_58;
        }

        tmp_tuple_element_23 = tmp_mvar_value_26;
        tmp_assign_source_108 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_23 );
        PyTuple_SET_ITEM( tmp_assign_source_108, 0, tmp_tuple_element_23 );
        assert( tmp_class_creation_17__bases == NULL );
        tmp_class_creation_17__bases = tmp_assign_source_108;
    }
    {
        PyObject *tmp_assign_source_109;
        {
            PyObject *tmp_set_locals_15;
            tmp_set_locals_15 = PyDict_New();
            locals_bs4$element_780 = tmp_set_locals_15;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_780, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_e1e9a7d7419bad7afb9206c02e4c795d;
        tmp_res = PyDict_SetItem( locals_bs4$element_780, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_ce081481423abca80d01dc6b2ce9e9ea;
        tmp_res = PyDict_SetItem( locals_bs4$element_780, const_str_plain_PREFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_28f2d46bf240bc75f671359bf185105d;
        tmp_res = PyDict_SetItem( locals_bs4$element_780, const_str_plain_SUFFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_109 = locals_bs4$element_780;
        Py_INCREF( tmp_assign_source_109 );
        goto try_return_handler_59;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_59:;
        Py_DECREF( locals_bs4$element_780 );
        locals_bs4$element_780 = NULL;
        goto outline_result_28;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_28:;
        assert( tmp_class_creation_17__class_dict == NULL );
        tmp_class_creation_17__class_dict = tmp_assign_source_109;
    }
    {
        PyObject *tmp_assign_source_110;
        nuitka_bool tmp_condition_result_19;
        PyObject *tmp_key_name_33;
        PyObject *tmp_dict_name_33;
        PyObject *tmp_dict_name_34;
        PyObject *tmp_key_name_34;
        tmp_key_name_33 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_dict_name_33 = tmp_class_creation_17__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_33, tmp_key_name_33 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 780;

            goto try_except_handler_58;
        }
        tmp_condition_result_19 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_19 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_17;
        }
        else
        {
            goto condexpr_false_17;
        }
        condexpr_true_17:;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_dict_name_34 = tmp_class_creation_17__class_dict;
        tmp_key_name_34 = const_str_plain___metaclass__;
        tmp_assign_source_110 = DICT_GET_ITEM( tmp_dict_name_34, tmp_key_name_34 );
        if ( tmp_assign_source_110 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 780;

            goto try_except_handler_58;
        }
        goto condexpr_end_17;
        condexpr_false_17:;
        {
            PyObject *tmp_assign_source_111;
            PyObject *tmp_subscribed_name_14;
            PyObject *tmp_subscript_name_14;
            CHECK_OBJECT( tmp_class_creation_17__bases );
            tmp_subscribed_name_14 = tmp_class_creation_17__bases;
            tmp_subscript_name_14 = const_int_0;
            tmp_assign_source_111 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_14, tmp_subscript_name_14, 0 );
            if ( tmp_assign_source_111 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 780;

                goto try_except_handler_58;
            }
            assert( tmp_select_metaclass_17__base == NULL );
            tmp_select_metaclass_17__base = tmp_assign_source_111;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_16;
            CHECK_OBJECT( tmp_select_metaclass_17__base );
            tmp_source_name_16 = tmp_select_metaclass_17__base;
            tmp_assign_source_110 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_16 );
            if ( tmp_assign_source_110 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 780;

                goto try_except_handler_61;
            }
            goto try_return_handler_60;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_61:;
        exception_keeper_type_37 = exception_type;
        exception_keeper_value_37 = exception_value;
        exception_keeper_tb_37 = exception_tb;
        exception_keeper_lineno_37 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_13;
            Py_DECREF( exception_keeper_type_37 );
            Py_XDECREF( exception_keeper_value_37 );
            Py_XDECREF( exception_keeper_tb_37 );
            CHECK_OBJECT( tmp_select_metaclass_17__base );
            tmp_type_arg_13 = tmp_select_metaclass_17__base;
            tmp_assign_source_110 = BUILTIN_TYPE1( tmp_type_arg_13 );
            assert( !(tmp_assign_source_110 == NULL) );
            goto try_return_handler_60;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_60:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_17__base );
        Py_DECREF( tmp_select_metaclass_17__base );
        tmp_select_metaclass_17__base = NULL;

        goto outline_result_29;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_17__base );
        Py_DECREF( tmp_select_metaclass_17__base );
        tmp_select_metaclass_17__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_29:;
        condexpr_end_17:;
        assert( tmp_class_creation_17__metaclass == NULL );
        tmp_class_creation_17__metaclass = tmp_assign_source_110;
    }
    {
        PyObject *tmp_assign_source_112;
        PyObject *tmp_called_name_34;
        PyObject *tmp_args_element_name_61;
        PyObject *tmp_args_element_name_62;
        PyObject *tmp_args_element_name_63;
        CHECK_OBJECT( tmp_class_creation_17__metaclass );
        tmp_called_name_34 = tmp_class_creation_17__metaclass;
        tmp_args_element_name_61 = const_str_plain_XMLProcessingInstruction;
        CHECK_OBJECT( tmp_class_creation_17__bases );
        tmp_args_element_name_62 = tmp_class_creation_17__bases;
        CHECK_OBJECT( tmp_class_creation_17__class_dict );
        tmp_args_element_name_63 = tmp_class_creation_17__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 780;
        {
            PyObject *call_args[] = { tmp_args_element_name_61, tmp_args_element_name_62, tmp_args_element_name_63 };
            tmp_assign_source_112 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_34, call_args );
        }

        if ( tmp_assign_source_112 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 780;

            goto try_except_handler_58;
        }
        assert( tmp_class_creation_17__class == NULL );
        tmp_class_creation_17__class = tmp_assign_source_112;
    }
    goto try_end_19;
    // Exception handler code:
    try_except_handler_58:;
    exception_keeper_type_38 = exception_type;
    exception_keeper_value_38 = exception_value;
    exception_keeper_tb_38 = exception_tb;
    exception_keeper_lineno_38 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_17__bases );
    tmp_class_creation_17__bases = NULL;

    Py_XDECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_38;
    exception_value = exception_keeper_value_38;
    exception_tb = exception_keeper_tb_38;
    exception_lineno = exception_keeper_lineno_38;

    goto frame_exception_exit_1;
    // End of try:
    try_end_19:;
    {
        PyObject *tmp_assign_source_113;
        CHECK_OBJECT( tmp_class_creation_17__class );
        tmp_assign_source_113 = tmp_class_creation_17__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_XMLProcessingInstruction, tmp_assign_source_113 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class );
    Py_DECREF( tmp_class_creation_17__class );
    tmp_class_creation_17__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__bases );
    Py_DECREF( tmp_class_creation_17__bases );
    tmp_class_creation_17__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__class_dict );
    Py_DECREF( tmp_class_creation_17__class_dict );
    tmp_class_creation_17__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_17__metaclass );
    Py_DECREF( tmp_class_creation_17__metaclass );
    tmp_class_creation_17__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_114;
        PyObject *tmp_tuple_element_24;
        PyObject *tmp_mvar_value_27;
        tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PreformattedString );

        if (unlikely( tmp_mvar_value_27 == NULL ))
        {
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PreformattedString );
        }

        if ( tmp_mvar_value_27 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PreformattedString" );
            exception_tb = NULL;

            exception_lineno = 785;

            goto try_except_handler_62;
        }

        tmp_tuple_element_24 = tmp_mvar_value_27;
        tmp_assign_source_114 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_24 );
        PyTuple_SET_ITEM( tmp_assign_source_114, 0, tmp_tuple_element_24 );
        assert( tmp_class_creation_18__bases == NULL );
        tmp_class_creation_18__bases = tmp_assign_source_114;
    }
    {
        PyObject *tmp_assign_source_115;
        {
            PyObject *tmp_set_locals_16;
            tmp_set_locals_16 = PyDict_New();
            locals_bs4$element_785 = tmp_set_locals_16;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_785, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_10b0cc8d52dbda6d37909d215669cae2;
        tmp_res = PyDict_SetItem( locals_bs4$element_785, const_str_plain_PREFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_08c55f7436746dfbed837b418ea65a70;
        tmp_res = PyDict_SetItem( locals_bs4$element_785, const_str_plain_SUFFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_115 = locals_bs4$element_785;
        Py_INCREF( tmp_assign_source_115 );
        goto try_return_handler_63;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_63:;
        Py_DECREF( locals_bs4$element_785 );
        locals_bs4$element_785 = NULL;
        goto outline_result_30;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_30:;
        assert( tmp_class_creation_18__class_dict == NULL );
        tmp_class_creation_18__class_dict = tmp_assign_source_115;
    }
    {
        PyObject *tmp_assign_source_116;
        nuitka_bool tmp_condition_result_20;
        PyObject *tmp_key_name_35;
        PyObject *tmp_dict_name_35;
        PyObject *tmp_dict_name_36;
        PyObject *tmp_key_name_36;
        tmp_key_name_35 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_18__class_dict );
        tmp_dict_name_35 = tmp_class_creation_18__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_35, tmp_key_name_35 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 785;

            goto try_except_handler_62;
        }
        tmp_condition_result_20 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_20 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_18;
        }
        else
        {
            goto condexpr_false_18;
        }
        condexpr_true_18:;
        CHECK_OBJECT( tmp_class_creation_18__class_dict );
        tmp_dict_name_36 = tmp_class_creation_18__class_dict;
        tmp_key_name_36 = const_str_plain___metaclass__;
        tmp_assign_source_116 = DICT_GET_ITEM( tmp_dict_name_36, tmp_key_name_36 );
        if ( tmp_assign_source_116 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 785;

            goto try_except_handler_62;
        }
        goto condexpr_end_18;
        condexpr_false_18:;
        {
            PyObject *tmp_assign_source_117;
            PyObject *tmp_subscribed_name_15;
            PyObject *tmp_subscript_name_15;
            CHECK_OBJECT( tmp_class_creation_18__bases );
            tmp_subscribed_name_15 = tmp_class_creation_18__bases;
            tmp_subscript_name_15 = const_int_0;
            tmp_assign_source_117 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_15, tmp_subscript_name_15, 0 );
            if ( tmp_assign_source_117 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 785;

                goto try_except_handler_62;
            }
            assert( tmp_select_metaclass_18__base == NULL );
            tmp_select_metaclass_18__base = tmp_assign_source_117;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_17;
            CHECK_OBJECT( tmp_select_metaclass_18__base );
            tmp_source_name_17 = tmp_select_metaclass_18__base;
            tmp_assign_source_116 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_17 );
            if ( tmp_assign_source_116 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 785;

                goto try_except_handler_65;
            }
            goto try_return_handler_64;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_65:;
        exception_keeper_type_39 = exception_type;
        exception_keeper_value_39 = exception_value;
        exception_keeper_tb_39 = exception_tb;
        exception_keeper_lineno_39 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_14;
            Py_DECREF( exception_keeper_type_39 );
            Py_XDECREF( exception_keeper_value_39 );
            Py_XDECREF( exception_keeper_tb_39 );
            CHECK_OBJECT( tmp_select_metaclass_18__base );
            tmp_type_arg_14 = tmp_select_metaclass_18__base;
            tmp_assign_source_116 = BUILTIN_TYPE1( tmp_type_arg_14 );
            assert( !(tmp_assign_source_116 == NULL) );
            goto try_return_handler_64;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_64:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_18__base );
        Py_DECREF( tmp_select_metaclass_18__base );
        tmp_select_metaclass_18__base = NULL;

        goto outline_result_31;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_18__base );
        Py_DECREF( tmp_select_metaclass_18__base );
        tmp_select_metaclass_18__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_31:;
        condexpr_end_18:;
        assert( tmp_class_creation_18__metaclass == NULL );
        tmp_class_creation_18__metaclass = tmp_assign_source_116;
    }
    {
        PyObject *tmp_assign_source_118;
        PyObject *tmp_called_name_35;
        PyObject *tmp_args_element_name_64;
        PyObject *tmp_args_element_name_65;
        PyObject *tmp_args_element_name_66;
        CHECK_OBJECT( tmp_class_creation_18__metaclass );
        tmp_called_name_35 = tmp_class_creation_18__metaclass;
        tmp_args_element_name_64 = const_str_plain_Comment;
        CHECK_OBJECT( tmp_class_creation_18__bases );
        tmp_args_element_name_65 = tmp_class_creation_18__bases;
        CHECK_OBJECT( tmp_class_creation_18__class_dict );
        tmp_args_element_name_66 = tmp_class_creation_18__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 785;
        {
            PyObject *call_args[] = { tmp_args_element_name_64, tmp_args_element_name_65, tmp_args_element_name_66 };
            tmp_assign_source_118 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_35, call_args );
        }

        if ( tmp_assign_source_118 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 785;

            goto try_except_handler_62;
        }
        assert( tmp_class_creation_18__class == NULL );
        tmp_class_creation_18__class = tmp_assign_source_118;
    }
    goto try_end_20;
    // Exception handler code:
    try_except_handler_62:;
    exception_keeper_type_40 = exception_type;
    exception_keeper_value_40 = exception_value;
    exception_keeper_tb_40 = exception_tb;
    exception_keeper_lineno_40 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_18__bases );
    tmp_class_creation_18__bases = NULL;

    Py_XDECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_40;
    exception_value = exception_keeper_value_40;
    exception_tb = exception_keeper_tb_40;
    exception_lineno = exception_keeper_lineno_40;

    goto frame_exception_exit_1;
    // End of try:
    try_end_20:;
    {
        PyObject *tmp_assign_source_119;
        CHECK_OBJECT( tmp_class_creation_18__class );
        tmp_assign_source_119 = tmp_class_creation_18__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Comment, tmp_assign_source_119 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class );
    Py_DECREF( tmp_class_creation_18__class );
    tmp_class_creation_18__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__bases );
    Py_DECREF( tmp_class_creation_18__bases );
    tmp_class_creation_18__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__class_dict );
    Py_DECREF( tmp_class_creation_18__class_dict );
    tmp_class_creation_18__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_18__metaclass );
    Py_DECREF( tmp_class_creation_18__metaclass );
    tmp_class_creation_18__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_120;
        PyObject *tmp_tuple_element_25;
        PyObject *tmp_mvar_value_28;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PreformattedString );

        if (unlikely( tmp_mvar_value_28 == NULL ))
        {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PreformattedString );
        }

        if ( tmp_mvar_value_28 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PreformattedString" );
            exception_tb = NULL;

            exception_lineno = 791;

            goto try_except_handler_66;
        }

        tmp_tuple_element_25 = tmp_mvar_value_28;
        tmp_assign_source_120 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_25 );
        PyTuple_SET_ITEM( tmp_assign_source_120, 0, tmp_tuple_element_25 );
        assert( tmp_class_creation_19__bases == NULL );
        tmp_class_creation_19__bases = tmp_assign_source_120;
    }
    {
        PyObject *tmp_assign_source_121;
        {
            PyObject *tmp_set_locals_17;
            tmp_set_locals_17 = PyDict_New();
            locals_bs4$element_791 = tmp_set_locals_17;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_791, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_ce081481423abca80d01dc6b2ce9e9ea;
        tmp_res = PyDict_SetItem( locals_bs4$element_791, const_str_plain_PREFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_28f2d46bf240bc75f671359bf185105d;
        tmp_res = PyDict_SetItem( locals_bs4$element_791, const_str_plain_SUFFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        tmp_assign_source_121 = locals_bs4$element_791;
        Py_INCREF( tmp_assign_source_121 );
        goto try_return_handler_67;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_67:;
        Py_DECREF( locals_bs4$element_791 );
        locals_bs4$element_791 = NULL;
        goto outline_result_32;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_32:;
        assert( tmp_class_creation_19__class_dict == NULL );
        tmp_class_creation_19__class_dict = tmp_assign_source_121;
    }
    {
        PyObject *tmp_assign_source_122;
        nuitka_bool tmp_condition_result_21;
        PyObject *tmp_key_name_37;
        PyObject *tmp_dict_name_37;
        PyObject *tmp_dict_name_38;
        PyObject *tmp_key_name_38;
        tmp_key_name_37 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_19__class_dict );
        tmp_dict_name_37 = tmp_class_creation_19__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_37, tmp_key_name_37 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 791;

            goto try_except_handler_66;
        }
        tmp_condition_result_21 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_21 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_19;
        }
        else
        {
            goto condexpr_false_19;
        }
        condexpr_true_19:;
        CHECK_OBJECT( tmp_class_creation_19__class_dict );
        tmp_dict_name_38 = tmp_class_creation_19__class_dict;
        tmp_key_name_38 = const_str_plain___metaclass__;
        tmp_assign_source_122 = DICT_GET_ITEM( tmp_dict_name_38, tmp_key_name_38 );
        if ( tmp_assign_source_122 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 791;

            goto try_except_handler_66;
        }
        goto condexpr_end_19;
        condexpr_false_19:;
        {
            PyObject *tmp_assign_source_123;
            PyObject *tmp_subscribed_name_16;
            PyObject *tmp_subscript_name_16;
            CHECK_OBJECT( tmp_class_creation_19__bases );
            tmp_subscribed_name_16 = tmp_class_creation_19__bases;
            tmp_subscript_name_16 = const_int_0;
            tmp_assign_source_123 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_16, tmp_subscript_name_16, 0 );
            if ( tmp_assign_source_123 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 791;

                goto try_except_handler_66;
            }
            assert( tmp_select_metaclass_19__base == NULL );
            tmp_select_metaclass_19__base = tmp_assign_source_123;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_18;
            CHECK_OBJECT( tmp_select_metaclass_19__base );
            tmp_source_name_18 = tmp_select_metaclass_19__base;
            tmp_assign_source_122 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_18 );
            if ( tmp_assign_source_122 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 791;

                goto try_except_handler_69;
            }
            goto try_return_handler_68;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_69:;
        exception_keeper_type_41 = exception_type;
        exception_keeper_value_41 = exception_value;
        exception_keeper_tb_41 = exception_tb;
        exception_keeper_lineno_41 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_15;
            Py_DECREF( exception_keeper_type_41 );
            Py_XDECREF( exception_keeper_value_41 );
            Py_XDECREF( exception_keeper_tb_41 );
            CHECK_OBJECT( tmp_select_metaclass_19__base );
            tmp_type_arg_15 = tmp_select_metaclass_19__base;
            tmp_assign_source_122 = BUILTIN_TYPE1( tmp_type_arg_15 );
            assert( !(tmp_assign_source_122 == NULL) );
            goto try_return_handler_68;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_68:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_19__base );
        Py_DECREF( tmp_select_metaclass_19__base );
        tmp_select_metaclass_19__base = NULL;

        goto outline_result_33;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_19__base );
        Py_DECREF( tmp_select_metaclass_19__base );
        tmp_select_metaclass_19__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_33:;
        condexpr_end_19:;
        assert( tmp_class_creation_19__metaclass == NULL );
        tmp_class_creation_19__metaclass = tmp_assign_source_122;
    }
    {
        PyObject *tmp_assign_source_124;
        PyObject *tmp_called_name_36;
        PyObject *tmp_args_element_name_67;
        PyObject *tmp_args_element_name_68;
        PyObject *tmp_args_element_name_69;
        CHECK_OBJECT( tmp_class_creation_19__metaclass );
        tmp_called_name_36 = tmp_class_creation_19__metaclass;
        tmp_args_element_name_67 = const_str_plain_Declaration;
        CHECK_OBJECT( tmp_class_creation_19__bases );
        tmp_args_element_name_68 = tmp_class_creation_19__bases;
        CHECK_OBJECT( tmp_class_creation_19__class_dict );
        tmp_args_element_name_69 = tmp_class_creation_19__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 791;
        {
            PyObject *call_args[] = { tmp_args_element_name_67, tmp_args_element_name_68, tmp_args_element_name_69 };
            tmp_assign_source_124 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_36, call_args );
        }

        if ( tmp_assign_source_124 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 791;

            goto try_except_handler_66;
        }
        assert( tmp_class_creation_19__class == NULL );
        tmp_class_creation_19__class = tmp_assign_source_124;
    }
    goto try_end_21;
    // Exception handler code:
    try_except_handler_66:;
    exception_keeper_type_42 = exception_type;
    exception_keeper_value_42 = exception_value;
    exception_keeper_tb_42 = exception_tb;
    exception_keeper_lineno_42 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_19__bases );
    tmp_class_creation_19__bases = NULL;

    Py_XDECREF( tmp_class_creation_19__class_dict );
    tmp_class_creation_19__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_19__metaclass );
    tmp_class_creation_19__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_42;
    exception_value = exception_keeper_value_42;
    exception_tb = exception_keeper_tb_42;
    exception_lineno = exception_keeper_lineno_42;

    goto frame_exception_exit_1;
    // End of try:
    try_end_21:;
    {
        PyObject *tmp_assign_source_125;
        CHECK_OBJECT( tmp_class_creation_19__class );
        tmp_assign_source_125 = tmp_class_creation_19__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Declaration, tmp_assign_source_125 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_19__class );
    Py_DECREF( tmp_class_creation_19__class );
    tmp_class_creation_19__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_19__bases );
    Py_DECREF( tmp_class_creation_19__bases );
    tmp_class_creation_19__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_19__class_dict );
    Py_DECREF( tmp_class_creation_19__class_dict );
    tmp_class_creation_19__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_19__metaclass );
    Py_DECREF( tmp_class_creation_19__metaclass );
    tmp_class_creation_19__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_126;
        PyObject *tmp_tuple_element_26;
        PyObject *tmp_mvar_value_29;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PreformattedString );

        if (unlikely( tmp_mvar_value_29 == NULL ))
        {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PreformattedString );
        }

        if ( tmp_mvar_value_29 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PreformattedString" );
            exception_tb = NULL;

            exception_lineno = 796;

            goto try_except_handler_70;
        }

        tmp_tuple_element_26 = tmp_mvar_value_29;
        tmp_assign_source_126 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_26 );
        PyTuple_SET_ITEM( tmp_assign_source_126, 0, tmp_tuple_element_26 );
        assert( tmp_class_creation_20__bases == NULL );
        tmp_class_creation_20__bases = tmp_assign_source_126;
    }
    {
        PyObject *tmp_assign_source_127;
        {
            PyObject *tmp_set_locals_18;
            tmp_set_locals_18 = PyDict_New();
            locals_bs4$element_796 = tmp_set_locals_18;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_796, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_873a41d8549c3eae2ceb236f16fe8da3_8, codeobj_873a41d8549c3eae2ceb236f16fe8da3, module_bs4$element, 0 );
        frame_873a41d8549c3eae2ceb236f16fe8da3_8 = cache_frame_873a41d8549c3eae2ceb236f16fe8da3_8;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_873a41d8549c3eae2ceb236f16fe8da3_8 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_873a41d8549c3eae2ceb236f16fe8da3_8 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_classmethod_arg_4;
            tmp_classmethod_arg_4 = MAKE_FUNCTION_bs4$element$$$function_61_for_name_and_ids(  );



            tmp_dictset_value = BUILTIN_CLASSMETHOD( tmp_classmethod_arg_4 );
            Py_DECREF( tmp_classmethod_arg_4 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 798;

                goto frame_exception_exit_8;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_796, const_str_plain_for_name_and_ids, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 798;

                goto frame_exception_exit_8;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_873a41d8549c3eae2ceb236f16fe8da3_8 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_873a41d8549c3eae2ceb236f16fe8da3_8 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_873a41d8549c3eae2ceb236f16fe8da3_8, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_873a41d8549c3eae2ceb236f16fe8da3_8->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_873a41d8549c3eae2ceb236f16fe8da3_8, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_873a41d8549c3eae2ceb236f16fe8da3_8,
            type_description_2
        );


        // Release cached frame.
        if ( frame_873a41d8549c3eae2ceb236f16fe8da3_8 == cache_frame_873a41d8549c3eae2ceb236f16fe8da3_8 )
        {
            Py_DECREF( frame_873a41d8549c3eae2ceb236f16fe8da3_8 );
        }
        cache_frame_873a41d8549c3eae2ceb236f16fe8da3_8 = NULL;

        assertFrameObject( frame_873a41d8549c3eae2ceb236f16fe8da3_8 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_71;
        skip_nested_handling_7:;
        tmp_dictset_value = const_unicode_digest_c58e033f1c5c7944b6670af092f11d09;
        tmp_res = PyDict_SetItem( locals_bs4$element_796, const_str_plain_PREFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_unicode_digest_42aaa86f3155a0ac9064d3ba1116a0c9;
        tmp_res = PyDict_SetItem( locals_bs4$element_796, const_str_plain_SUFFIX, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_127 = locals_bs4$element_796;
        Py_INCREF( tmp_assign_source_127 );
        goto try_return_handler_71;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_71:;
        Py_DECREF( locals_bs4$element_796 );
        locals_bs4$element_796 = NULL;
        goto outline_result_34;
        // Exception handler code:
        try_except_handler_71:;
        exception_keeper_type_43 = exception_type;
        exception_keeper_value_43 = exception_value;
        exception_keeper_tb_43 = exception_tb;
        exception_keeper_lineno_43 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_796 );
        locals_bs4$element_796 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_43;
        exception_value = exception_keeper_value_43;
        exception_tb = exception_keeper_tb_43;
        exception_lineno = exception_keeper_lineno_43;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_7:;
        exception_lineno = 796;
        goto try_except_handler_70;
        outline_result_34:;
        assert( tmp_class_creation_20__class_dict == NULL );
        tmp_class_creation_20__class_dict = tmp_assign_source_127;
    }
    {
        PyObject *tmp_assign_source_128;
        nuitka_bool tmp_condition_result_22;
        PyObject *tmp_key_name_39;
        PyObject *tmp_dict_name_39;
        PyObject *tmp_dict_name_40;
        PyObject *tmp_key_name_40;
        tmp_key_name_39 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_20__class_dict );
        tmp_dict_name_39 = tmp_class_creation_20__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_39, tmp_key_name_39 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 796;

            goto try_except_handler_70;
        }
        tmp_condition_result_22 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_22 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_20;
        }
        else
        {
            goto condexpr_false_20;
        }
        condexpr_true_20:;
        CHECK_OBJECT( tmp_class_creation_20__class_dict );
        tmp_dict_name_40 = tmp_class_creation_20__class_dict;
        tmp_key_name_40 = const_str_plain___metaclass__;
        tmp_assign_source_128 = DICT_GET_ITEM( tmp_dict_name_40, tmp_key_name_40 );
        if ( tmp_assign_source_128 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 796;

            goto try_except_handler_70;
        }
        goto condexpr_end_20;
        condexpr_false_20:;
        {
            PyObject *tmp_assign_source_129;
            PyObject *tmp_subscribed_name_17;
            PyObject *tmp_subscript_name_17;
            CHECK_OBJECT( tmp_class_creation_20__bases );
            tmp_subscribed_name_17 = tmp_class_creation_20__bases;
            tmp_subscript_name_17 = const_int_0;
            tmp_assign_source_129 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_17, tmp_subscript_name_17, 0 );
            if ( tmp_assign_source_129 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 796;

                goto try_except_handler_70;
            }
            assert( tmp_select_metaclass_20__base == NULL );
            tmp_select_metaclass_20__base = tmp_assign_source_129;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_19;
            CHECK_OBJECT( tmp_select_metaclass_20__base );
            tmp_source_name_19 = tmp_select_metaclass_20__base;
            tmp_assign_source_128 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_19 );
            if ( tmp_assign_source_128 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 796;

                goto try_except_handler_73;
            }
            goto try_return_handler_72;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_73:;
        exception_keeper_type_44 = exception_type;
        exception_keeper_value_44 = exception_value;
        exception_keeper_tb_44 = exception_tb;
        exception_keeper_lineno_44 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_16;
            Py_DECREF( exception_keeper_type_44 );
            Py_XDECREF( exception_keeper_value_44 );
            Py_XDECREF( exception_keeper_tb_44 );
            CHECK_OBJECT( tmp_select_metaclass_20__base );
            tmp_type_arg_16 = tmp_select_metaclass_20__base;
            tmp_assign_source_128 = BUILTIN_TYPE1( tmp_type_arg_16 );
            assert( !(tmp_assign_source_128 == NULL) );
            goto try_return_handler_72;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_72:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_20__base );
        Py_DECREF( tmp_select_metaclass_20__base );
        tmp_select_metaclass_20__base = NULL;

        goto outline_result_35;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_20__base );
        Py_DECREF( tmp_select_metaclass_20__base );
        tmp_select_metaclass_20__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_35:;
        condexpr_end_20:;
        assert( tmp_class_creation_20__metaclass == NULL );
        tmp_class_creation_20__metaclass = tmp_assign_source_128;
    }
    {
        PyObject *tmp_assign_source_130;
        PyObject *tmp_called_name_37;
        PyObject *tmp_args_element_name_70;
        PyObject *tmp_args_element_name_71;
        PyObject *tmp_args_element_name_72;
        CHECK_OBJECT( tmp_class_creation_20__metaclass );
        tmp_called_name_37 = tmp_class_creation_20__metaclass;
        tmp_args_element_name_70 = const_str_plain_Doctype;
        CHECK_OBJECT( tmp_class_creation_20__bases );
        tmp_args_element_name_71 = tmp_class_creation_20__bases;
        CHECK_OBJECT( tmp_class_creation_20__class_dict );
        tmp_args_element_name_72 = tmp_class_creation_20__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 796;
        {
            PyObject *call_args[] = { tmp_args_element_name_70, tmp_args_element_name_71, tmp_args_element_name_72 };
            tmp_assign_source_130 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_37, call_args );
        }

        if ( tmp_assign_source_130 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 796;

            goto try_except_handler_70;
        }
        assert( tmp_class_creation_20__class == NULL );
        tmp_class_creation_20__class = tmp_assign_source_130;
    }
    goto try_end_22;
    // Exception handler code:
    try_except_handler_70:;
    exception_keeper_type_45 = exception_type;
    exception_keeper_value_45 = exception_value;
    exception_keeper_tb_45 = exception_tb;
    exception_keeper_lineno_45 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_20__bases );
    tmp_class_creation_20__bases = NULL;

    Py_XDECREF( tmp_class_creation_20__class_dict );
    tmp_class_creation_20__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_20__metaclass );
    tmp_class_creation_20__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_45;
    exception_value = exception_keeper_value_45;
    exception_tb = exception_keeper_tb_45;
    exception_lineno = exception_keeper_lineno_45;

    goto frame_exception_exit_1;
    // End of try:
    try_end_22:;
    {
        PyObject *tmp_assign_source_131;
        CHECK_OBJECT( tmp_class_creation_20__class );
        tmp_assign_source_131 = tmp_class_creation_20__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Doctype, tmp_assign_source_131 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_20__class );
    Py_DECREF( tmp_class_creation_20__class );
    tmp_class_creation_20__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_20__bases );
    Py_DECREF( tmp_class_creation_20__bases );
    tmp_class_creation_20__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_20__class_dict );
    Py_DECREF( tmp_class_creation_20__class_dict );
    tmp_class_creation_20__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_20__metaclass );
    Py_DECREF( tmp_class_creation_20__metaclass );
    tmp_class_creation_20__metaclass = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_132;
        PyObject *tmp_tuple_element_27;
        PyObject *tmp_mvar_value_30;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PageElement );

        if (unlikely( tmp_mvar_value_30 == NULL ))
        {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PageElement );
        }

        if ( tmp_mvar_value_30 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "PageElement" );
            exception_tb = NULL;

            exception_lineno = 814;

            goto try_except_handler_74;
        }

        tmp_tuple_element_27 = tmp_mvar_value_30;
        tmp_assign_source_132 = PyTuple_New( 1 );
        Py_INCREF( tmp_tuple_element_27 );
        PyTuple_SET_ITEM( tmp_assign_source_132, 0, tmp_tuple_element_27 );
        assert( tmp_class_creation_21__bases == NULL );
        tmp_class_creation_21__bases = tmp_assign_source_132;
    }
    {
        PyObject *tmp_assign_source_133;
        {
            PyObject *tmp_set_locals_19;
            tmp_set_locals_19 = PyDict_New();
            locals_bs4$element_814 = tmp_set_locals_19;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_7367bb348cc3e8e5398ecf366526fd9f;
        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_17;
            tmp_defaults_17 = const_tuple_none_none_none_none_none_none_none_none_none_tuple;
            Py_INCREF( tmp_defaults_17 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_62___init__( tmp_defaults_17 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_9d2b28a2d5efc66db477b9157d5d71f4_9, codeobj_9d2b28a2d5efc66db477b9157d5d71f4, module_bs4$element, 0 );
        frame_9d2b28a2d5efc66db477b9157d5d71f4_9 = cache_frame_9d2b28a2d5efc66db477b9157d5d71f4_9;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_9d2b28a2d5efc66db477b9157d5d71f4_9 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_9d2b28a2d5efc66db477b9157d5d71f4_9 ) == 2 ); // Frame stack

        // Framed code:
        {
            PyObject *tmp_called_name_38;
            PyObject *tmp_mvar_value_31;
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain__alias );

            if (unlikely( tmp_mvar_value_31 == NULL ))
            {
                tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__alias );
            }

            if ( tmp_mvar_value_31 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_alias" );
                exception_tb = NULL;

                exception_lineno = 871;

                goto frame_exception_exit_9;
            }

            tmp_called_name_38 = tmp_mvar_value_31;
            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 871;
            tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_38, &PyTuple_GET_ITEM( const_tuple_str_plain_parser_class_tuple, 0 ) );

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 871;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_parserClass, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 871;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_63___copy__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___copy__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_39;
            PyObject *tmp_args_element_name_73;
            tmp_called_name_39 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_73 = MAKE_FUNCTION_bs4$element$$$function_64_is_empty_element(  );



            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 885;
            {
                PyObject *call_args[] = { tmp_args_element_name_73 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_39, call_args );
            }

            Py_DECREF( tmp_args_element_name_73 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 885;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_is_empty_element, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 885;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_814, const_str_plain_is_empty_element );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "is_empty_element" );
            exception_tb = NULL;

            exception_lineno = 901;

            goto frame_exception_exit_9;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 901;

            goto frame_exception_exit_9;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_isSelfClosing, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_40;
            PyObject *tmp_args_element_name_74;
            tmp_called_name_40 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_74 = MAKE_FUNCTION_bs4$element$$$function_65_string(  );



            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 903;
            {
                PyObject *call_args[] = { tmp_args_element_name_74 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_40, call_args );
            }

            Py_DECREF( tmp_args_element_name_74 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 903;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_string, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 903;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_called_instance_5;
            PyObject *tmp_args_element_name_75;
            tmp_called_instance_5 = PyDict_GetItem( locals_bs4$element_814, const_str_plain_string );

            if ( tmp_called_instance_5 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "string" );
                exception_tb = NULL;

                exception_lineno = 920;

                goto frame_exception_exit_9;
            }

            if ( tmp_called_instance_5 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 920;

                goto frame_exception_exit_9;
            }
            tmp_args_element_name_75 = MAKE_FUNCTION_bs4$element$$$function_66_string(  );



            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 920;
            {
                PyObject *call_args[] = { tmp_args_element_name_75 };
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_setter, call_args );
            }

            Py_DECREF( tmp_args_element_name_75 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 920;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_string, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 920;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_defaults_18;
            PyObject *tmp_tuple_element_28;
            PyObject *tmp_tuple_element_29;
            PyObject *tmp_mvar_value_32;
            PyObject *tmp_mvar_value_33;
            tmp_tuple_element_28 = Py_False;
            tmp_defaults_18 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_28 );
            PyTuple_SET_ITEM( tmp_defaults_18, 0, tmp_tuple_element_28 );
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

            if (unlikely( tmp_mvar_value_32 == NULL ))
            {
                tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
            }

            if ( tmp_mvar_value_32 == NULL )
            {
                Py_DECREF( tmp_defaults_18 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "NavigableString" );
                exception_tb = NULL;

                exception_lineno = 925;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_29 = tmp_mvar_value_32;
            tmp_tuple_element_28 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_29 );
            PyTuple_SET_ITEM( tmp_tuple_element_28, 0, tmp_tuple_element_29 );
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_CData );

            if (unlikely( tmp_mvar_value_33 == NULL ))
            {
                tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CData );
            }

            if ( tmp_mvar_value_33 == NULL )
            {
                Py_DECREF( tmp_defaults_18 );
                Py_DECREF( tmp_tuple_element_28 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "CData" );
                exception_tb = NULL;

                exception_lineno = 925;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_29 = tmp_mvar_value_33;
            Py_INCREF( tmp_tuple_element_29 );
            PyTuple_SET_ITEM( tmp_tuple_element_28, 1, tmp_tuple_element_29 );
            PyTuple_SET_ITEM( tmp_defaults_18, 1, tmp_tuple_element_28 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_67__all_strings( tmp_defaults_18 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain__all_strings, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 925;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_called_name_41;
            PyObject *tmp_args_element_name_76;
            tmp_called_name_41 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_76 = PyDict_GetItem( locals_bs4$element_814, const_str_plain__all_strings );

            if ( tmp_args_element_name_76 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "_all_strings" );
                exception_tb = NULL;

                exception_lineno = 943;

                goto frame_exception_exit_9;
            }

            if ( tmp_args_element_name_76 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 943;

                goto frame_exception_exit_9;
            }
            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 943;
            {
                PyObject *call_args[] = { tmp_args_element_name_76 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_41, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 943;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_strings, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 943;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_called_name_42;
            PyObject *tmp_args_element_name_77;
            tmp_called_name_42 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_77 = MAKE_FUNCTION_bs4$element$$$function_68_stripped_strings(  );



            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 945;
            {
                PyObject *call_args[] = { tmp_args_element_name_77 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_42, call_args );
            }

            Py_DECREF( tmp_args_element_name_77 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 945;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_stripped_strings, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 945;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_defaults_19;
            PyObject *tmp_tuple_element_30;
            PyObject *tmp_tuple_element_31;
            PyObject *tmp_mvar_value_34;
            PyObject *tmp_mvar_value_35;
            tmp_tuple_element_30 = const_unicode_empty;
            tmp_defaults_19 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_30 );
            PyTuple_SET_ITEM( tmp_defaults_19, 0, tmp_tuple_element_30 );
            tmp_tuple_element_30 = Py_False;
            Py_INCREF( tmp_tuple_element_30 );
            PyTuple_SET_ITEM( tmp_defaults_19, 1, tmp_tuple_element_30 );
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_NavigableString );

            if (unlikely( tmp_mvar_value_34 == NULL ))
            {
                tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NavigableString );
            }

            if ( tmp_mvar_value_34 == NULL )
            {
                Py_DECREF( tmp_defaults_19 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "NavigableString" );
                exception_tb = NULL;

                exception_lineno = 951;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_31 = tmp_mvar_value_34;
            tmp_tuple_element_30 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_31 );
            PyTuple_SET_ITEM( tmp_tuple_element_30, 0, tmp_tuple_element_31 );
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_CData );

            if (unlikely( tmp_mvar_value_35 == NULL ))
            {
                tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CData );
            }

            if ( tmp_mvar_value_35 == NULL )
            {
                Py_DECREF( tmp_defaults_19 );
                Py_DECREF( tmp_tuple_element_30 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "CData" );
                exception_tb = NULL;

                exception_lineno = 951;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_31 = tmp_mvar_value_35;
            Py_INCREF( tmp_tuple_element_31 );
            PyTuple_SET_ITEM( tmp_tuple_element_30, 1, tmp_tuple_element_31 );
            PyTuple_SET_ITEM( tmp_defaults_19, 2, tmp_tuple_element_30 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_69_get_text( tmp_defaults_19 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_get_text, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 950;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_814, const_str_plain_get_text );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "get_text" );
            exception_tb = NULL;

            exception_lineno = 957;

            goto frame_exception_exit_9;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 957;

            goto frame_exception_exit_9;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_getText, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_43;
            PyObject *tmp_args_element_name_78;
            tmp_called_name_43 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_78 = PyDict_GetItem( locals_bs4$element_814, const_str_plain_get_text );

            if ( tmp_args_element_name_78 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "get_text" );
                exception_tb = NULL;

                exception_lineno = 958;

                goto frame_exception_exit_9;
            }

            if ( tmp_args_element_name_78 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 958;

                goto frame_exception_exit_9;
            }
            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 958;
            {
                PyObject *call_args[] = { tmp_args_element_name_78 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_43, call_args );
            }

            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 958;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_text, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 958;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_70_decompose(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_decompose, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_20;
            tmp_defaults_20 = const_tuple_false_tuple;
            Py_INCREF( tmp_defaults_20 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_71_clear( tmp_defaults_20 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_clear, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_72_index(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_index, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_21;
            tmp_defaults_21 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_21 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_73_get( tmp_defaults_21 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_get, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_defaults_22;
            tmp_defaults_22 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_22 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_74_get_attribute_list( tmp_defaults_22 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_get_attribute_list, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_75_has_attr(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_has_attr, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_76___hash__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___hash__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_77___getitem__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___getitem__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_78___iter__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___iter__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_79___len__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___len__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_80___contains__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___contains__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_81___nonzero__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___nonzero__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_82___setitem__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___setitem__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_83___delitem__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___delitem__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_84___call__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___call__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_85___getattr__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___getattr__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_86___eq__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___eq__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_87___ne__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___ne__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_23;
            tmp_defaults_23 = const_tuple_str_digest_688f06597223eaae9df5adffcac1b5da_tuple;
            Py_INCREF( tmp_defaults_23 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_88___repr__( tmp_defaults_23 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___repr__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_89___unicode__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___unicode__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_90___str__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___str__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            nuitka_bool tmp_condition_result_23;
            PyObject *tmp_mvar_value_36;
            int tmp_truth_name_1;
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_PY3K );

            if (unlikely( tmp_mvar_value_36 == NULL ))
            {
                tmp_mvar_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PY3K );
            }

            if ( tmp_mvar_value_36 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "PY3K" );
                exception_tb = NULL;

                exception_lineno = 1107;

                goto frame_exception_exit_9;
            }

            tmp_truth_name_1 = CHECK_IF_TRUE( tmp_mvar_value_36 );
            if ( tmp_truth_name_1 == -1 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1107;

                goto frame_exception_exit_9;
            }
            tmp_condition_result_23 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if ( tmp_condition_result_23 == NUITKA_BOOL_TRUE )
            {
                goto branch_yes_3;
            }
            else
            {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_134;
                tmp_assign_source_134 = PyDict_GetItem( locals_bs4$element_814, const_str_plain___unicode__ );

                if ( tmp_assign_source_134 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
                {

                    exception_type = PyExc_NameError;
                    Py_INCREF( exception_type );
                    exception_value = PyString_FromFormat( "name '%s' is not defined", "__unicode__" );
                    exception_tb = NULL;

                    exception_lineno = 1108;

                    goto frame_exception_exit_9;
                }

                if ( tmp_assign_source_134 == NULL )
                {
                    assert( ERROR_OCCURRED() );

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                    exception_lineno = 1108;

                    goto frame_exception_exit_9;
                }
                assert( tmp_Tag$assign_unpack_1__assign_source == NULL );
                Py_INCREF( tmp_assign_source_134 );
                tmp_Tag$assign_unpack_1__assign_source = tmp_assign_source_134;
            }
            CHECK_OBJECT( tmp_Tag$assign_unpack_1__assign_source );
            tmp_dictset_value = tmp_Tag$assign_unpack_1__assign_source;
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___str__, tmp_dictset_value );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_Tag$assign_unpack_1__assign_source );
            tmp_dictset_value = tmp_Tag$assign_unpack_1__assign_source;
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain___repr__, tmp_dictset_value );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( (PyObject *)tmp_Tag$assign_unpack_1__assign_source );
            Py_DECREF( tmp_Tag$assign_unpack_1__assign_source );
            tmp_Tag$assign_unpack_1__assign_source = NULL;

            branch_no_3:;
        }
        {
            PyObject *tmp_defaults_24;
            PyObject *tmp_tuple_element_32;
            PyObject *tmp_mvar_value_37;
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );

            if (unlikely( tmp_mvar_value_37 == NULL ))
            {
                tmp_mvar_value_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );
            }

            if ( tmp_mvar_value_37 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "DEFAULT_OUTPUT_ENCODING" );
                exception_tb = NULL;

                exception_lineno = 1110;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_32 = tmp_mvar_value_37;
            tmp_defaults_24 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_32 );
            PyTuple_SET_ITEM( tmp_defaults_24, 0, tmp_tuple_element_32 );
            tmp_tuple_element_32 = Py_None;
            Py_INCREF( tmp_tuple_element_32 );
            PyTuple_SET_ITEM( tmp_defaults_24, 1, tmp_tuple_element_32 );
            tmp_tuple_element_32 = const_str_plain_minimal;
            Py_INCREF( tmp_tuple_element_32 );
            PyTuple_SET_ITEM( tmp_defaults_24, 2, tmp_tuple_element_32 );
            tmp_tuple_element_32 = const_str_plain_xmlcharrefreplace;
            Py_INCREF( tmp_tuple_element_32 );
            PyTuple_SET_ITEM( tmp_defaults_24, 3, tmp_tuple_element_32 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_91_encode( tmp_defaults_24 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_encode, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1110;

                goto frame_exception_exit_9;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_92__should_pretty_print(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain__should_pretty_print, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_25;
            PyObject *tmp_tuple_element_33;
            PyObject *tmp_mvar_value_38;
            tmp_tuple_element_33 = Py_None;
            tmp_defaults_25 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_33 );
            PyTuple_SET_ITEM( tmp_defaults_25, 0, tmp_tuple_element_33 );
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );

            if (unlikely( tmp_mvar_value_38 == NULL ))
            {
                tmp_mvar_value_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );
            }

            if ( tmp_mvar_value_38 == NULL )
            {
                Py_DECREF( tmp_defaults_25 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "DEFAULT_OUTPUT_ENCODING" );
                exception_tb = NULL;

                exception_lineno = 1127;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_33 = tmp_mvar_value_38;
            Py_INCREF( tmp_tuple_element_33 );
            PyTuple_SET_ITEM( tmp_defaults_25, 1, tmp_tuple_element_33 );
            tmp_tuple_element_33 = const_str_plain_minimal;
            Py_INCREF( tmp_tuple_element_33 );
            PyTuple_SET_ITEM( tmp_defaults_25, 2, tmp_tuple_element_33 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_93_decode( tmp_defaults_25 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_decode, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1126;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_defaults_26;
            tmp_defaults_26 = const_tuple_none_str_plain_minimal_tuple;
            Py_INCREF( tmp_defaults_26 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_94_prettify( tmp_defaults_26 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_prettify, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_defaults_27;
            PyObject *tmp_tuple_element_34;
            PyObject *tmp_mvar_value_39;
            tmp_tuple_element_34 = Py_None;
            tmp_defaults_27 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_34 );
            PyTuple_SET_ITEM( tmp_defaults_27, 0, tmp_tuple_element_34 );
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );

            if (unlikely( tmp_mvar_value_39 == NULL ))
            {
                tmp_mvar_value_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );
            }

            if ( tmp_mvar_value_39 == NULL )
            {
                Py_DECREF( tmp_defaults_27 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "DEFAULT_OUTPUT_ENCODING" );
                exception_tb = NULL;

                exception_lineno = 1227;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_34 = tmp_mvar_value_39;
            Py_INCREF( tmp_tuple_element_34 );
            PyTuple_SET_ITEM( tmp_defaults_27, 1, tmp_tuple_element_34 );
            tmp_tuple_element_34 = const_str_plain_minimal;
            Py_INCREF( tmp_tuple_element_34 );
            PyTuple_SET_ITEM( tmp_defaults_27, 2, tmp_tuple_element_34 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_95_decode_contents( tmp_defaults_27 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_decode_contents, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1226;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_defaults_28;
            PyObject *tmp_tuple_element_35;
            PyObject *tmp_mvar_value_40;
            tmp_tuple_element_35 = Py_None;
            tmp_defaults_28 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_35 );
            PyTuple_SET_ITEM( tmp_defaults_28, 0, tmp_tuple_element_35 );
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );

            if (unlikely( tmp_mvar_value_40 == NULL ))
            {
                tmp_mvar_value_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );
            }

            if ( tmp_mvar_value_40 == NULL )
            {
                Py_DECREF( tmp_defaults_28 );
                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "DEFAULT_OUTPUT_ENCODING" );
                exception_tb = NULL;

                exception_lineno = 1269;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_35 = tmp_mvar_value_40;
            Py_INCREF( tmp_tuple_element_35 );
            PyTuple_SET_ITEM( tmp_defaults_28, 1, tmp_tuple_element_35 );
            tmp_tuple_element_35 = const_str_plain_minimal;
            Py_INCREF( tmp_tuple_element_35 );
            PyTuple_SET_ITEM( tmp_defaults_28, 2, tmp_tuple_element_35 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_96_encode_contents( tmp_defaults_28 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_encode_contents, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1268;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_defaults_29;
            PyObject *tmp_tuple_element_36;
            PyObject *tmp_mvar_value_41;
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );

            if (unlikely( tmp_mvar_value_41 == NULL ))
            {
                tmp_mvar_value_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DEFAULT_OUTPUT_ENCODING );
            }

            if ( tmp_mvar_value_41 == NULL )
            {

                exception_type = PyExc_NameError;
                Py_INCREF( exception_type );
                exception_value = PyString_FromFormat( "name '%s' is not defined", "DEFAULT_OUTPUT_ENCODING" );
                exception_tb = NULL;

                exception_lineno = 1286;

                goto frame_exception_exit_9;
            }

            tmp_tuple_element_36 = tmp_mvar_value_41;
            tmp_defaults_29 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_36 );
            PyTuple_SET_ITEM( tmp_defaults_29, 0, tmp_tuple_element_36 );
            tmp_tuple_element_36 = Py_False;
            Py_INCREF( tmp_tuple_element_36 );
            PyTuple_SET_ITEM( tmp_defaults_29, 1, tmp_tuple_element_36 );
            tmp_tuple_element_36 = const_int_0;
            Py_INCREF( tmp_tuple_element_36 );
            PyTuple_SET_ITEM( tmp_defaults_29, 2, tmp_tuple_element_36 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_97_renderContents( tmp_defaults_29 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_renderContents, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1286;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_defaults_30;
            PyObject *tmp_tuple_element_37;
            tmp_tuple_element_37 = Py_None;
            tmp_defaults_30 = PyTuple_New( 4 );
            Py_INCREF( tmp_tuple_element_37 );
            PyTuple_SET_ITEM( tmp_defaults_30, 0, tmp_tuple_element_37 );
            tmp_tuple_element_37 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_30, 1, tmp_tuple_element_37 );
            tmp_tuple_element_37 = Py_True;
            Py_INCREF( tmp_tuple_element_37 );
            PyTuple_SET_ITEM( tmp_defaults_30, 2, tmp_tuple_element_37 );
            tmp_tuple_element_37 = Py_None;
            Py_INCREF( tmp_tuple_element_37 );
            PyTuple_SET_ITEM( tmp_defaults_30, 3, tmp_tuple_element_37 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_98_find( tmp_defaults_30 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_find, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_814, const_str_plain_find );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find" );
            exception_tb = NULL;

            exception_lineno = 1304;

            goto frame_exception_exit_9;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1304;

            goto frame_exception_exit_9;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_findChild, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_31;
            PyObject *tmp_tuple_element_38;
            tmp_tuple_element_38 = Py_None;
            tmp_defaults_31 = PyTuple_New( 5 );
            Py_INCREF( tmp_tuple_element_38 );
            PyTuple_SET_ITEM( tmp_defaults_31, 0, tmp_tuple_element_38 );
            tmp_tuple_element_38 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_31, 1, tmp_tuple_element_38 );
            tmp_tuple_element_38 = Py_True;
            Py_INCREF( tmp_tuple_element_38 );
            PyTuple_SET_ITEM( tmp_defaults_31, 2, tmp_tuple_element_38 );
            tmp_tuple_element_38 = Py_None;
            Py_INCREF( tmp_tuple_element_38 );
            PyTuple_SET_ITEM( tmp_defaults_31, 3, tmp_tuple_element_38 );
            tmp_tuple_element_38 = Py_None;
            Py_INCREF( tmp_tuple_element_38 );
            PyTuple_SET_ITEM( tmp_defaults_31, 4, tmp_tuple_element_38 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_99_find_all( tmp_defaults_31 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_find_all, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_814, const_str_plain_find_all );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_all" );
            exception_tb = NULL;

            exception_lineno = 1322;

            goto frame_exception_exit_9;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1322;

            goto frame_exception_exit_9;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_findAll, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_814, const_str_plain_find_all );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "find_all" );
            exception_tb = NULL;

            exception_lineno = 1323;

            goto frame_exception_exit_9;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1323;

            goto frame_exception_exit_9;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_findChildren, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_called_name_44;
            PyObject *tmp_args_element_name_79;
            tmp_called_name_44 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_79 = MAKE_FUNCTION_bs4$element$$$function_100_children(  );



            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 1326;
            {
                PyObject *call_args[] = { tmp_args_element_name_79 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_44, call_args );
            }

            Py_DECREF( tmp_args_element_name_79 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1326;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_children, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1326;

                goto frame_exception_exit_9;
            }
        }
        {
            PyObject *tmp_called_name_45;
            PyObject *tmp_args_element_name_80;
            tmp_called_name_45 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_80 = MAKE_FUNCTION_bs4$element$$$function_101_descendants(  );



            frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame.f_lineno = 1331;
            {
                PyObject *call_args[] = { tmp_args_element_name_80 };
                tmp_dictset_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_45, call_args );
            }

            Py_DECREF( tmp_args_element_name_80 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1331;

                goto frame_exception_exit_9;
            }
            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_descendants, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 1331;

                goto frame_exception_exit_9;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION( frame_9d2b28a2d5efc66db477b9157d5d71f4_9 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_8;

        frame_exception_exit_9:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_9d2b28a2d5efc66db477b9157d5d71f4_9 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_9d2b28a2d5efc66db477b9157d5d71f4_9, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_9d2b28a2d5efc66db477b9157d5d71f4_9->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_9d2b28a2d5efc66db477b9157d5d71f4_9, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_9d2b28a2d5efc66db477b9157d5d71f4_9,
            type_description_2
        );


        // Release cached frame.
        if ( frame_9d2b28a2d5efc66db477b9157d5d71f4_9 == cache_frame_9d2b28a2d5efc66db477b9157d5d71f4_9 )
        {
            Py_DECREF( frame_9d2b28a2d5efc66db477b9157d5d71f4_9 );
        }
        cache_frame_9d2b28a2d5efc66db477b9157d5d71f4_9 = NULL;

        assertFrameObject( frame_9d2b28a2d5efc66db477b9157d5d71f4_9 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_8;

        frame_no_exception_8:;
        goto skip_nested_handling_8;
        nested_frame_exit_8:;

        goto try_except_handler_75;
        skip_nested_handling_8:;
        {
            PyObject *tmp_defaults_32;
            tmp_defaults_32 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_32 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_102_select_one( tmp_defaults_32 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_select_one, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        {
            PyObject *tmp_defaults_33;
            tmp_defaults_33 = const_tuple_none_none_tuple;
            Py_INCREF( tmp_defaults_33 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_103_select( tmp_defaults_33 );



            tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_select, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_104_childGenerator(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_childGenerator, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_105_recursiveChildGenerator(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_recursiveChildGenerator, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_106_has_key(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_814, const_str_plain_has_key, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_assign_source_133 = locals_bs4$element_814;
        Py_INCREF( tmp_assign_source_133 );
        goto try_return_handler_75;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_75:;
        Py_DECREF( locals_bs4$element_814 );
        locals_bs4$element_814 = NULL;
        goto outline_result_36;
        // Exception handler code:
        try_except_handler_75:;
        exception_keeper_type_46 = exception_type;
        exception_keeper_value_46 = exception_value;
        exception_keeper_tb_46 = exception_tb;
        exception_keeper_lineno_46 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF( locals_bs4$element_814 );
        locals_bs4$element_814 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_46;
        exception_value = exception_keeper_value_46;
        exception_tb = exception_keeper_tb_46;
        exception_lineno = exception_keeper_lineno_46;

        goto outline_exception_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_8:;
        exception_lineno = 814;
        goto try_except_handler_74;
        outline_result_36:;
        assert( tmp_class_creation_21__class_dict == NULL );
        tmp_class_creation_21__class_dict = tmp_assign_source_133;
    }
    {
        PyObject *tmp_assign_source_135;
        nuitka_bool tmp_condition_result_24;
        PyObject *tmp_key_name_41;
        PyObject *tmp_dict_name_41;
        PyObject *tmp_dict_name_42;
        PyObject *tmp_key_name_42;
        tmp_key_name_41 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_21__class_dict );
        tmp_dict_name_41 = tmp_class_creation_21__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_41, tmp_key_name_41 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 814;

            goto try_except_handler_74;
        }
        tmp_condition_result_24 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_24 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_21;
        }
        else
        {
            goto condexpr_false_21;
        }
        condexpr_true_21:;
        CHECK_OBJECT( tmp_class_creation_21__class_dict );
        tmp_dict_name_42 = tmp_class_creation_21__class_dict;
        tmp_key_name_42 = const_str_plain___metaclass__;
        tmp_assign_source_135 = DICT_GET_ITEM( tmp_dict_name_42, tmp_key_name_42 );
        if ( tmp_assign_source_135 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 814;

            goto try_except_handler_74;
        }
        goto condexpr_end_21;
        condexpr_false_21:;
        {
            PyObject *tmp_assign_source_136;
            PyObject *tmp_subscribed_name_18;
            PyObject *tmp_subscript_name_18;
            CHECK_OBJECT( tmp_class_creation_21__bases );
            tmp_subscribed_name_18 = tmp_class_creation_21__bases;
            tmp_subscript_name_18 = const_int_0;
            tmp_assign_source_136 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_18, tmp_subscript_name_18, 0 );
            if ( tmp_assign_source_136 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 814;

                goto try_except_handler_74;
            }
            assert( tmp_select_metaclass_21__base == NULL );
            tmp_select_metaclass_21__base = tmp_assign_source_136;
        }
        // Tried code:
        // Tried code:
        {
            PyObject *tmp_source_name_20;
            CHECK_OBJECT( tmp_select_metaclass_21__base );
            tmp_source_name_20 = tmp_select_metaclass_21__base;
            tmp_assign_source_135 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_20 );
            if ( tmp_assign_source_135 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 814;

                goto try_except_handler_77;
            }
            goto try_return_handler_76;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Exception handler code:
        try_except_handler_77:;
        exception_keeper_type_47 = exception_type;
        exception_keeper_value_47 = exception_value;
        exception_keeper_tb_47 = exception_tb;
        exception_keeper_lineno_47 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        {
            PyObject *tmp_type_arg_17;
            Py_DECREF( exception_keeper_type_47 );
            Py_XDECREF( exception_keeper_value_47 );
            Py_XDECREF( exception_keeper_tb_47 );
            CHECK_OBJECT( tmp_select_metaclass_21__base );
            tmp_type_arg_17 = tmp_select_metaclass_21__base;
            tmp_assign_source_135 = BUILTIN_TYPE1( tmp_type_arg_17 );
            assert( !(tmp_assign_source_135 == NULL) );
            goto try_return_handler_76;
        }
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_76:;
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_21__base );
        Py_DECREF( tmp_select_metaclass_21__base );
        tmp_select_metaclass_21__base = NULL;

        goto outline_result_37;
        // End of try:
        CHECK_OBJECT( (PyObject *)tmp_select_metaclass_21__base );
        Py_DECREF( tmp_select_metaclass_21__base );
        tmp_select_metaclass_21__base = NULL;

        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_37:;
        condexpr_end_21:;
        assert( tmp_class_creation_21__metaclass == NULL );
        tmp_class_creation_21__metaclass = tmp_assign_source_135;
    }
    {
        PyObject *tmp_assign_source_137;
        PyObject *tmp_called_name_46;
        PyObject *tmp_args_element_name_81;
        PyObject *tmp_args_element_name_82;
        PyObject *tmp_args_element_name_83;
        CHECK_OBJECT( tmp_class_creation_21__metaclass );
        tmp_called_name_46 = tmp_class_creation_21__metaclass;
        tmp_args_element_name_81 = const_str_plain_Tag;
        CHECK_OBJECT( tmp_class_creation_21__bases );
        tmp_args_element_name_82 = tmp_class_creation_21__bases;
        CHECK_OBJECT( tmp_class_creation_21__class_dict );
        tmp_args_element_name_83 = tmp_class_creation_21__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 814;
        {
            PyObject *call_args[] = { tmp_args_element_name_81, tmp_args_element_name_82, tmp_args_element_name_83 };
            tmp_assign_source_137 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_46, call_args );
        }

        if ( tmp_assign_source_137 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 814;

            goto try_except_handler_74;
        }
        assert( tmp_class_creation_21__class == NULL );
        tmp_class_creation_21__class = tmp_assign_source_137;
    }
    goto try_end_23;
    // Exception handler code:
    try_except_handler_74:;
    exception_keeper_type_48 = exception_type;
    exception_keeper_value_48 = exception_value;
    exception_keeper_tb_48 = exception_tb;
    exception_keeper_lineno_48 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_class_creation_21__bases );
    tmp_class_creation_21__bases = NULL;

    Py_XDECREF( tmp_class_creation_21__class_dict );
    tmp_class_creation_21__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_21__metaclass );
    tmp_class_creation_21__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_48;
    exception_value = exception_keeper_value_48;
    exception_tb = exception_keeper_tb_48;
    exception_lineno = exception_keeper_lineno_48;

    goto frame_exception_exit_1;
    // End of try:
    try_end_23:;
    {
        PyObject *tmp_assign_source_138;
        CHECK_OBJECT( tmp_class_creation_21__class );
        tmp_assign_source_138 = tmp_class_creation_21__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_Tag, tmp_assign_source_138 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_21__class );
    Py_DECREF( tmp_class_creation_21__class );
    tmp_class_creation_21__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_21__bases );
    Py_DECREF( tmp_class_creation_21__bases );
    tmp_class_creation_21__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_21__class_dict );
    Py_DECREF( tmp_class_creation_21__class_dict );
    tmp_class_creation_21__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_21__metaclass );
    Py_DECREF( tmp_class_creation_21__metaclass );
    tmp_class_creation_21__metaclass = NULL;

    {
        PyObject *tmp_assign_source_139;
        {
            PyObject *tmp_set_locals_20;
            tmp_set_locals_20 = PyDict_New();
            locals_bs4$element_1394 = tmp_set_locals_20;
        }
        tmp_dictset_value = const_str_digest_a694a1497725bd5d49805e1c282892b9;
        tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain___module__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = const_str_digest_7f21154356114069eea0623d81bf7f58;
        tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain___doc__, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_34;
            PyObject *tmp_tuple_element_39;
            tmp_tuple_element_39 = Py_None;
            tmp_defaults_34 = PyTuple_New( 3 );
            Py_INCREF( tmp_tuple_element_39 );
            PyTuple_SET_ITEM( tmp_defaults_34, 0, tmp_tuple_element_39 );
            tmp_tuple_element_39 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_34, 1, tmp_tuple_element_39 );
            tmp_tuple_element_39 = Py_None;
            Py_INCREF( tmp_tuple_element_39 );
            PyTuple_SET_ITEM( tmp_defaults_34, 2, tmp_tuple_element_39 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_107___init__( tmp_defaults_34 );



            tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain___init__, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_108__normalize_search_value(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain__normalize_search_value, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_109___str__(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain___str__, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_35;
            PyObject *tmp_tuple_element_40;
            tmp_tuple_element_40 = Py_None;
            tmp_defaults_35 = PyTuple_New( 2 );
            Py_INCREF( tmp_tuple_element_40 );
            PyTuple_SET_ITEM( tmp_defaults_35, 0, tmp_tuple_element_40 );
            tmp_tuple_element_40 = PyDict_New();
            PyTuple_SET_ITEM( tmp_defaults_35, 1, tmp_tuple_element_40 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_110_search_tag( tmp_defaults_35 );



            tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain_search_tag, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        tmp_dictset_value = PyDict_GetItem( locals_bs4$element_1394, const_str_plain_search_tag );

        if ( tmp_dictset_value == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED() )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "name '%s' is not defined", "search_tag" );
            exception_tb = NULL;

            exception_lineno = 1500;

            goto frame_exception_exit_1;
        }

        if ( tmp_dictset_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1500;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain_searchTag, tmp_dictset_value );
        assert( !(tmp_res != 0) );
        tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_111_search(  );



        tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain_search, tmp_dictset_value );
        Py_DECREF( tmp_dictset_value );
        assert( !(tmp_res != 0) );
        {
            PyObject *tmp_defaults_36;
            tmp_defaults_36 = const_tuple_none_tuple;
            Py_INCREF( tmp_defaults_36 );
            tmp_dictset_value = MAKE_FUNCTION_bs4$element$$$function_112__matches( tmp_defaults_36 );



            tmp_res = PyDict_SetItem( locals_bs4$element_1394, const_str_plain__matches, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            assert( !(tmp_res != 0) );
        }
        // Tried code:
        tmp_assign_source_139 = locals_bs4$element_1394;
        Py_INCREF( tmp_assign_source_139 );
        goto try_return_handler_78;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_78:;
        Py_DECREF( locals_bs4$element_1394 );
        locals_bs4$element_1394 = NULL;
        goto outline_result_38;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_38:;
        assert( tmp_class_creation_22__class_dict == NULL );
        tmp_class_creation_22__class_dict = tmp_assign_source_139;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_140;
        nuitka_bool tmp_condition_result_25;
        PyObject *tmp_key_name_43;
        PyObject *tmp_dict_name_43;
        PyObject *tmp_dict_name_44;
        PyObject *tmp_key_name_44;
        tmp_key_name_43 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_22__class_dict );
        tmp_dict_name_43 = tmp_class_creation_22__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_43, tmp_key_name_43 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;

            goto try_except_handler_79;
        }
        tmp_condition_result_25 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_25 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_22;
        }
        else
        {
            goto condexpr_false_22;
        }
        condexpr_true_22:;
        CHECK_OBJECT( tmp_class_creation_22__class_dict );
        tmp_dict_name_44 = tmp_class_creation_22__class_dict;
        tmp_key_name_44 = const_str_plain___metaclass__;
        tmp_assign_source_140 = DICT_GET_ITEM( tmp_dict_name_44, tmp_key_name_44 );
        if ( tmp_assign_source_140 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;

            goto try_except_handler_79;
        }
        goto condexpr_end_22;
        condexpr_false_22:;
        tmp_assign_source_140 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_140 );
        condexpr_end_22:;
        assert( tmp_class_creation_22__metaclass == NULL );
        tmp_class_creation_22__metaclass = tmp_assign_source_140;
    }
    {
        PyObject *tmp_assign_source_141;
        PyObject *tmp_called_name_47;
        PyObject *tmp_args_element_name_84;
        PyObject *tmp_args_element_name_85;
        PyObject *tmp_args_element_name_86;
        CHECK_OBJECT( tmp_class_creation_22__metaclass );
        tmp_called_name_47 = tmp_class_creation_22__metaclass;
        tmp_args_element_name_84 = const_str_plain_SoupStrainer;
        tmp_args_element_name_85 = const_tuple_type_object_tuple;
        CHECK_OBJECT( tmp_class_creation_22__class_dict );
        tmp_args_element_name_86 = tmp_class_creation_22__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 1394;
        {
            PyObject *call_args[] = { tmp_args_element_name_84, tmp_args_element_name_85, tmp_args_element_name_86 };
            tmp_assign_source_141 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_47, call_args );
        }

        if ( tmp_assign_source_141 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1394;

            goto try_except_handler_79;
        }
        assert( tmp_class_creation_22__class == NULL );
        tmp_class_creation_22__class = tmp_assign_source_141;
    }
    goto try_end_24;
    // Exception handler code:
    try_except_handler_79:;
    exception_keeper_type_49 = exception_type;
    exception_keeper_value_49 = exception_value;
    exception_keeper_tb_49 = exception_tb;
    exception_keeper_lineno_49 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_22__class_dict );
    Py_DECREF( tmp_class_creation_22__class_dict );
    tmp_class_creation_22__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_22__metaclass );
    tmp_class_creation_22__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_49;
    exception_value = exception_keeper_value_49;
    exception_tb = exception_keeper_tb_49;
    exception_lineno = exception_keeper_lineno_49;

    goto frame_exception_exit_1;
    // End of try:
    try_end_24:;
    {
        PyObject *tmp_assign_source_142;
        CHECK_OBJECT( tmp_class_creation_22__class );
        tmp_assign_source_142 = tmp_class_creation_22__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_SoupStrainer, tmp_assign_source_142 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_22__class );
    Py_DECREF( tmp_class_creation_22__class );
    tmp_class_creation_22__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_22__class_dict );
    Py_DECREF( tmp_class_creation_22__class_dict );
    tmp_class_creation_22__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_22__metaclass );
    Py_DECREF( tmp_class_creation_22__metaclass );
    tmp_class_creation_22__metaclass = NULL;

    {
        PyObject *tmp_assign_source_143;
        {
            PyObject *tmp_assign_source_144;
            PyObject *tmp_defaults_37;
            tmp_defaults_37 = const_tuple_tuple_empty_tuple;
            Py_INCREF( tmp_defaults_37 );
            tmp_assign_source_144 = MAKE_FUNCTION_bs4$element$$$function_113___init__( tmp_defaults_37 );



            assert( tmp_locals_bs4$element_1611_key___init__ == NULL );
            tmp_locals_bs4$element_1611_key___init__ = tmp_assign_source_144;
        }
        {
            PyObject *tmp_assign_source_145;
            tmp_assign_source_145 = MAKE_FUNCTION_bs4$element$$$function_114___getattr__(  );



            assert( tmp_locals_bs4$element_1611_key___getattr__ == NULL );
            tmp_locals_bs4$element_1611_key___getattr__ = tmp_assign_source_145;
        }
        // Tried code:
        {
            PyObject *tmp_dict_key_12;
            PyObject *tmp_dict_value_12;
            PyObject *tmp_dict_key_13;
            PyObject *tmp_dict_value_13;
            PyObject *tmp_dict_key_14;
            PyObject *tmp_dict_value_14;
            PyObject *tmp_dict_key_15;
            PyObject *tmp_dict_value_15;
            tmp_dict_value_12 = const_str_digest_a694a1497725bd5d49805e1c282892b9;
            tmp_dict_key_12 = const_str_plain___module__;
            tmp_assign_source_143 = _PyDict_NewPresized( 4 );
            tmp_res = PyDict_SetItem( tmp_assign_source_143, tmp_dict_key_12, tmp_dict_value_12 );
            assert( !(tmp_res != 0) );
            tmp_dict_value_13 = const_str_digest_a3d9d833894395d6536a0b717d3a6231;
            tmp_dict_key_13 = const_str_plain___doc__;
            tmp_res = PyDict_SetItem( tmp_assign_source_143, tmp_dict_key_13, tmp_dict_value_13 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_bs4$element_1611_key___init__ );
            tmp_dict_value_14 = tmp_locals_bs4$element_1611_key___init__;
            tmp_dict_key_14 = const_str_plain___init__;
            tmp_res = PyDict_SetItem( tmp_assign_source_143, tmp_dict_key_14, tmp_dict_value_14 );
            assert( !(tmp_res != 0) );
            CHECK_OBJECT( tmp_locals_bs4$element_1611_key___getattr__ );
            tmp_dict_value_15 = tmp_locals_bs4$element_1611_key___getattr__;
            tmp_dict_key_15 = const_str_plain___getattr__;
            tmp_res = PyDict_SetItem( tmp_assign_source_143, tmp_dict_key_15, tmp_dict_value_15 );
            assert( !(tmp_res != 0) );
            goto try_return_handler_80;
        }
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_80:;
        CHECK_OBJECT( (PyObject *)tmp_locals_bs4$element_1611_key___init__ );
        Py_DECREF( tmp_locals_bs4$element_1611_key___init__ );
        tmp_locals_bs4$element_1611_key___init__ = NULL;

        CHECK_OBJECT( (PyObject *)tmp_locals_bs4$element_1611_key___getattr__ );
        Py_DECREF( tmp_locals_bs4$element_1611_key___getattr__ );
        tmp_locals_bs4$element_1611_key___getattr__ = NULL;

        goto outline_result_39;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( bs4$element );
        return MOD_RETURN_VALUE( NULL );
        outline_result_39:;
        assert( tmp_class_creation_23__class_dict == NULL );
        tmp_class_creation_23__class_dict = tmp_assign_source_143;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_146;
        nuitka_bool tmp_condition_result_26;
        PyObject *tmp_key_name_45;
        PyObject *tmp_dict_name_45;
        PyObject *tmp_dict_name_46;
        PyObject *tmp_key_name_46;
        tmp_key_name_45 = const_str_plain___metaclass__;
        CHECK_OBJECT( tmp_class_creation_23__class_dict );
        tmp_dict_name_45 = tmp_class_creation_23__class_dict;
        tmp_res = PyDict_Contains( tmp_dict_name_45, tmp_key_name_45 );
        if ( tmp_res == -1 )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1611;

            goto try_except_handler_81;
        }
        tmp_condition_result_26 = ( tmp_res != 0 ) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if ( tmp_condition_result_26 == NUITKA_BOOL_TRUE )
        {
            goto condexpr_true_23;
        }
        else
        {
            goto condexpr_false_23;
        }
        condexpr_true_23:;
        CHECK_OBJECT( tmp_class_creation_23__class_dict );
        tmp_dict_name_46 = tmp_class_creation_23__class_dict;
        tmp_key_name_46 = const_str_plain___metaclass__;
        tmp_assign_source_146 = DICT_GET_ITEM( tmp_dict_name_46, tmp_key_name_46 );
        if ( tmp_assign_source_146 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1611;

            goto try_except_handler_81;
        }
        goto condexpr_end_23;
        condexpr_false_23:;
        tmp_assign_source_146 = (PyObject *)&PyType_Type;
        Py_INCREF( tmp_assign_source_146 );
        condexpr_end_23:;
        assert( tmp_class_creation_23__metaclass == NULL );
        tmp_class_creation_23__metaclass = tmp_assign_source_146;
    }
    {
        PyObject *tmp_assign_source_147;
        PyObject *tmp_called_name_48;
        PyObject *tmp_args_element_name_87;
        PyObject *tmp_args_element_name_88;
        PyObject *tmp_args_element_name_89;
        CHECK_OBJECT( tmp_class_creation_23__metaclass );
        tmp_called_name_48 = tmp_class_creation_23__metaclass;
        tmp_args_element_name_87 = const_str_plain_ResultSet;
        tmp_args_element_name_88 = const_tuple_type_list_tuple;
        CHECK_OBJECT( tmp_class_creation_23__class_dict );
        tmp_args_element_name_89 = tmp_class_creation_23__class_dict;
        frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame.f_lineno = 1611;
        {
            PyObject *call_args[] = { tmp_args_element_name_87, tmp_args_element_name_88, tmp_args_element_name_89 };
            tmp_assign_source_147 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_48, call_args );
        }

        if ( tmp_assign_source_147 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1611;

            goto try_except_handler_81;
        }
        assert( tmp_class_creation_23__class == NULL );
        tmp_class_creation_23__class = tmp_assign_source_147;
    }
    goto try_end_25;
    // Exception handler code:
    try_except_handler_81:;
    exception_keeper_type_50 = exception_type;
    exception_keeper_value_50 = exception_value;
    exception_keeper_tb_50 = exception_tb;
    exception_keeper_lineno_50 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_23__class_dict );
    Py_DECREF( tmp_class_creation_23__class_dict );
    tmp_class_creation_23__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_23__metaclass );
    tmp_class_creation_23__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_50;
    exception_value = exception_keeper_value_50;
    exception_tb = exception_keeper_tb_50;
    exception_lineno = exception_keeper_lineno_50;

    goto frame_exception_exit_1;
    // End of try:
    try_end_25:;

    // Restore frame exception if necessary.
#if 1
    RESTORE_FRAME_EXCEPTION( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd );
#endif
    popFrameStack();

    assertFrameObject( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd );

    goto frame_no_exception_9;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e5c9f68c83b74cb2baea83eeeaa3cdfd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e5c9f68c83b74cb2baea83eeeaa3cdfd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e5c9f68c83b74cb2baea83eeeaa3cdfd, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_9:;
    {
        PyObject *tmp_assign_source_148;
        CHECK_OBJECT( tmp_class_creation_23__class );
        tmp_assign_source_148 = tmp_class_creation_23__class;
        UPDATE_STRING_DICT0( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain_ResultSet, tmp_assign_source_148 );
    }
    CHECK_OBJECT( (PyObject *)tmp_class_creation_23__class );
    Py_DECREF( tmp_class_creation_23__class );
    tmp_class_creation_23__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_23__class_dict );
    Py_DECREF( tmp_class_creation_23__class_dict );
    tmp_class_creation_23__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_23__metaclass );
    Py_DECREF( tmp_class_creation_23__metaclass );
    tmp_class_creation_23__metaclass = NULL;


#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_bs4$element, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_bs4$element );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
